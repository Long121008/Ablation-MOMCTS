[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5130185048048914,
            0.8003642082214355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5130185048048914,
            0.8003642082214355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5130185048048914,
            0.8003642082214355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8117252264357466,
            1.557085633277893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8117252264357466,
            1.557085633277893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swaps with multi-objective path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform edge swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective path relinking: Selectively improve edges in different objective spaces\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Identify worst edges in this objective space\n        worst_edge = None\n        max_dist = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (k, (k+1)%n)\n\n        if worst_edge:\n            # Try to improve the worst edge by relinking\n            k, l = worst_edge\n            u, v = new_solution[k], new_solution[l]\n            # Find a better edge (u, w) in this objective space\n            for w in range(n):\n                if w != u and w != v and distance_matrix[u, w] < max_dist:\n                    # Perform the relink\n                    if np.random.rand() < 0.7:  # 70% chance to accept improvement\n                        # Find positions of u and w\n                        pos_u = np.where(new_solution == u)[0][0]\n                        pos_w = np.where(new_solution == w)[0][0]\n                        if pos_u > pos_w:\n                            pos_u, pos_w = pos_w, pos_u\n                        # Perform the 2-opt move\n                        new_solution[pos_u:pos_w+1] = new_solution[pos_u:pos_w+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7165329992220232,
            0.7870859026908874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swaps with multi-objective path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform edge swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective path relinking: Selectively improve edges in different objective spaces\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Identify worst edges in this objective space\n        worst_edge = None\n        max_dist = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (k, (k+1)%n)\n\n        if worst_edge:\n            # Try to improve the worst edge by relinking\n            k, l = worst_edge\n            u, v = new_solution[k], new_solution[l]\n            # Find a better edge (u, w) in this objective space\n            for w in range(n):\n                if w != u and w != v and distance_matrix[u, w] < max_dist:\n                    # Perform the relink\n                    if np.random.rand() < 0.7:  # 70% chance to accept improvement\n                        # Find positions of u and w\n                        pos_u = np.where(new_solution == u)[0][0]\n                        pos_w = np.where(new_solution == w)[0][0]\n                        if pos_u > pos_w:\n                            pos_u, pos_w = pos_w, pos_u\n                        # Perform the 2-opt move\n                        new_solution[pos_u:pos_w+1] = new_solution[pos_u:pos_w+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swaps with multi-objective path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform edge swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective path relinking: Selectively improve edges in different objective spaces\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Identify worst edges in this objective space\n        worst_edge = None\n        max_dist = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (k, (k+1)%n)\n\n        if worst_edge:\n            # Try to improve the worst edge by relinking\n            k, l = worst_edge\n            u, v = new_solution[k], new_solution[l]\n            # Find a better edge (u, w) in this objective space\n            for w in range(n):\n                if w != u and w != v and distance_matrix[u, w] < max_dist:\n                    # Perform the relink\n                    if np.random.rand() < 0.7:  # 70% chance to accept improvement\n                        # Find positions of u and w\n                        pos_u = np.where(new_solution == u)[0][0]\n                        pos_w = np.where(new_solution == w)[0][0]\n                        if pos_u > pos_w:\n                            pos_u, pos_w = pos_w, pos_u\n                        # Perform the 2-opt move\n                        new_solution[pos_u:pos_w+1] = new_solution[pos_u:pos_w+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7165329992220232,
            0.7870859026908874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swaps with multi-objective path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform edge swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective path relinking: Selectively improve edges in different objective spaces\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Identify worst edges in this objective space\n        worst_edge = None\n        max_dist = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (k, (k+1)%n)\n\n        if worst_edge:\n            # Try to improve the worst edge by relinking\n            k, l = worst_edge\n            u, v = new_solution[k], new_solution[l]\n            # Find a better edge (u, w) in this objective space\n            for w in range(n):\n                if w != u and w != v and distance_matrix[u, w] < max_dist:\n                    # Perform the relink\n                    if np.random.rand() < 0.7:  # 70% chance to accept improvement\n                        # Find positions of u and w\n                        pos_u = np.where(new_solution == u)[0][0]\n                        pos_w = np.where(new_solution == w)[0][0]\n                        if pos_u > pos_w:\n                            pos_u, pos_w = pos_w, pos_u\n                        # Perform the 2-opt move\n                        new_solution[pos_u:pos_w+1] = new_solution[pos_u:pos_w+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    for _ in range(10):  # Limit the number of attempts to find an improving move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if the move improves at least one objective\n        original_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[i]] +\n            distance_matrix_1[base_solution[j-1], base_solution[j]],\n            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n            distance_matrix_2[base_solution[j-1], base_solution[j]],\n            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n            distance_matrix_3[base_solution[j-1], base_solution[j]]\n        ]\n        new_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[j]] +\n            distance_matrix_1[base_solution[j-1], base_solution[i]],\n            distance_matrix_2[base_solution[i-1], base_solution[j]] +\n            distance_matrix_2[base_solution[j-1], base_solution[i]],\n            distance_matrix_3[base_solution[i-1], base_solution[j]] +\n            distance_matrix_3[base_solution[j-1], base_solution[i]]\n        ]\n        if any(new_costs[k] < original_costs[k] for k in range(3)):\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7670263075939927,
            1.2906283140182495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    for _ in range(10):  # Limit the number of attempts to find an improving move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if the move improves at least one objective\n        original_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[i]] +\n            distance_matrix_1[base_solution[j-1], base_solution[j]],\n            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n            distance_matrix_2[base_solution[j-1], base_solution[j]],\n            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n            distance_matrix_3[base_solution[j-1], base_solution[j]]\n        ]\n        new_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[j]] +\n            distance_matrix_1[base_solution[j-1], base_solution[i]],\n            distance_matrix_2[base_solution[i-1], base_solution[j]] +\n            distance_matrix_2[base_solution[j-1], base_solution[i]],\n            distance_matrix_3[base_solution[i-1], base_solution[j]] +\n            distance_matrix_3[base_solution[j-1], base_solution[i]]\n        ]\n        if any(new_costs[k] < original_costs[k] for k in range(3)):\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best trade-off across all three objectives using a weighted sum\n    def calculate_score(objective):\n        return sum(objective)  # Simple sum as a proxy for trade-off\n\n    archive_sorted = sorted(archive, key=lambda x: calculate_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt for each objective space with probabilistic selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt in one of the spaces\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    space = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt in the selected space\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Reverse the segment if it improves the total distance in the selected space\n    current_dist = (dist_matrix[new_solution[i-1], new_solution[i]] +\n                    dist_matrix[new_solution[j-1], new_solution[j]])\n    new_dist = (dist_matrix[new_solution[i-1], new_solution[j-1]] +\n                dist_matrix[new_solution[i], new_solution[j]])\n\n    if new_dist < current_dist:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.5817959696284661,
            3.780918002128601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best trade-off across all three objectives using a weighted sum\n    def calculate_score(objective):\n        return sum(objective)  # Simple sum as a proxy for trade-off\n\n    archive_sorted = sorted(archive, key=lambda x: calculate_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt for each objective space with probabilistic selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt in one of the spaces\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    space = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt in the selected space\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Reverse the segment if it improves the total distance in the selected space\n    current_dist = (dist_matrix[new_solution[i-1], new_solution[i]] +\n                    dist_matrix[new_solution[j-1], new_solution[j]])\n    new_dist = (dist_matrix[new_solution[i-1], new_solution[j-1]] +\n                dist_matrix[new_solution[i], new_solution[j]])\n\n    if new_dist < current_dist:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel local search operator combining segment reversal and objective-aware edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Identify the worst objective and perform an insertion based on that objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best insertion point for a randomly selected node\n    node = np.random.choice(new_solution)\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n):\n        if pos == 0:\n            cost = dist_matrix[new_solution[-1], node] + dist_matrix[node, new_solution[pos]]\n        elif pos == n - 1:\n            cost = dist_matrix[new_solution[pos-1], node] + dist_matrix[node, new_solution[0]]\n        else:\n            cost = dist_matrix[new_solution[pos-1], node] + dist_matrix[node, new_solution[pos]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.5769610052264319,
            1.367909038066864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel local search operator combining segment reversal and objective-aware edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Identify the worst objective and perform an insertion based on that objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best insertion point for a randomly selected node\n    node = np.random.choice(new_solution)\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n):\n        if pos == 0:\n            cost = dist_matrix[new_solution[-1], node] + dist_matrix[node, new_solution[pos]]\n        elif pos == n - 1:\n            cost = dist_matrix[new_solution[pos-1], node] + dist_matrix[node, new_solution[0]]\n        else:\n            cost = dist_matrix[new_solution[pos-1], node] + dist_matrix[node, new_solution[pos]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance rank and applies a novel segment inversion and edge recombination operator to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes through a greedy replacement strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance rank (simplified as the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segment inversion and edge recombination\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges and recombine them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Repair duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7036973211603235,
            1.245957124233246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance rank (simplified as the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segment inversion and edge recombination\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges and recombine them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Repair duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm selects a solution from the archive based on the worst objective value, then applies a novel multi-objective local search strategy combining segment reversal with objective-aware edge swaps to improve all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform segment reversal based on the worst objective\n    worst_obj = objectives.index(max(objectives))\n    if worst_obj == 0:\n        # For the worst objective, reverse a segment to potentially reduce the longest edge\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For other objectives, perform a more targeted edge swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Swap edges in a way that reduces the worst objective\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Perform an additional edge swap based on multi-objective improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate the potential improvement across all objectives\n            current_cost = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                           distance_matrix_1[new_solution[c], new_solution[d]] +\n                           distance_matrix_2[new_solution[a], new_solution[b]] +\n                           distance_matrix_2[new_solution[c], new_solution[d]] +\n                           distance_matrix_3[new_solution[a], new_solution[b]] +\n                           distance_matrix_3[new_solution[c], new_solution[d]])\n            new_cost = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                        distance_matrix_1[new_solution[b], new_solution[d]] +\n                        distance_matrix_2[new_solution[a], new_solution[c]] +\n                        distance_matrix_2[new_solution[b], new_solution[d]] +\n                        distance_matrix_3[new_solution[a], new_solution[c]] +\n                        distance_matrix_3[new_solution[b], new_solution[d]])\n            if new_cost < current_cost:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7282336811815562,
            1.5136300086975099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform segment reversal based on the worst objective\n    worst_obj = objectives.index(max(objectives))\n    if worst_obj == 0:\n        # For the worst objective, reverse a segment to potentially reduce the longest edge\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For other objectives, perform a more targeted edge swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Swap edges in a way that reduces the worst objective\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Perform an additional edge swap based on multi-objective improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate the potential improvement across all objectives\n            current_cost = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                           distance_matrix_1[new_solution[c], new_solution[d]] +\n                           distance_matrix_2[new_solution[a], new_solution[b]] +\n                           distance_matrix_2[new_solution[c], new_solution[d]] +\n                           distance_matrix_3[new_solution[a], new_solution[b]] +\n                           distance_matrix_3[new_solution[c], new_solution[d]])\n            new_cost = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                        distance_matrix_1[new_solution[b], new_solution[d]] +\n                        distance_matrix_2[new_solution[a], new_solution[c]] +\n                        distance_matrix_2[new_solution[b], new_solution[d]] +\n                        distance_matrix_3[new_solution[a], new_solution[c]] +\n                        distance_matrix_3[new_solution[b], new_solution[d]])\n            if new_cost < current_cost:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines a novel node-swapping strategy with a segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Node-swapping with segment-based crossover\n    # First, perform node-swapping for diversification\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.691681516255656,
            2.85974805355072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Node-swapping with segment-based crossover\n    # First, perform node-swapping for diversification\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of objectives, then applies a hybrid local search combining 2-opt and edge exchange, with additional checks to ensure feasibility and diversification in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.7, otherwise apply edge exchange\n    if np.random.rand() < 0.7:\n        # 2-opt: randomly select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: randomly select two edges and swap their nodes\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicates or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.6937830821397,
            1.0591074347496032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.7, otherwise apply edge exchange\n    if np.random.rand() < 0.7:\n        # 2-opt: randomly select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: randomly select two edges and swap their nodes\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicates or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, applies a 3-opt local search with a novel segment inversion strategy to improve the tour, and ensures feasibility by repairing any duplicate nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (to focus on improvement)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with segment inversion\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Invert segments and rearrange\n    segment1 = new_solution[i:j+1][::-1]\n    segment2 = new_solution[j+1:k+1][::-1]\n    new_solution[i:j+1] = segment1\n    new_solution[j+1:k+1] = segment2\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4032299708962044,
            0.9341681241989136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (to focus on improvement)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with segment inversion\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Invert segments and rearrange\n    segment1 = new_solution[i:j+1][::-1]\n    segment2 = new_solution[j+1:k+1][::-1]\n    new_solution[i:j+1] = segment1\n    new_solution[j+1:k+1] = segment2\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This heuristic function selects a solution from the archive based on the least crowded hypervolume contribution, applies a novel three-segment crossover operator that combines segments from three different solutions to exploit complementary objectives, and then refines the solution using a multi-objective 3-opt move to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with least crowded hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(np.abs(objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Three-segment crossover with three random solutions\n    if len(archive) >= 3:\n        sol_indices = np.random.choice(len(archive), 3, replace=False)\n        solutions = [archive[i][0].copy() for i in sol_indices]\n\n        # Divide into three segments and combine from different solutions\n        seg1, seg2, seg3 = np.split(solutions[0], [n//3, 2*n//3])\n        seg4, seg5, seg6 = np.split(solutions[1], [n//3, 2*n//3])\n        seg7, seg8, seg9 = np.split(solutions[2], [n//3, 2*n//3])\n\n        new_solution = np.concatenate([seg1, seg5, seg9])\n\n    # Multi-objective 3-opt move\n    if n >= 3:\n        a, b, c = np.random.choice(n, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Evaluate all possible 3-opt moves across objectives\n        options = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]])\n        ]\n\n        # Select the move with the best average improvement across objectives\n        best_option = options[0]\n        best_improvement = 0\n        for option in options:\n            total_improvement = 0\n            for i in range(3):\n                if i == 0:\n                    dm = distance_matrix_1\n                elif i == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                current_cost = sum(dm[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                new_cost = sum(dm[option[k], option[(k+1)%n]] for k in range(n))\n                total_improvement += current_cost - new_cost\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_option = option\n\n        new_solution = best_option\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6947270414766885,
            1.9523501873016358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with least crowded hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(np.abs(objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Three-segment crossover with three random solutions\n    if len(archive) >= 3:\n        sol_indices = np.random.choice(len(archive), 3, replace=False)\n        solutions = [archive[i][0].copy() for i in sol_indices]\n\n        # Divide into three segments and combine from different solutions\n        seg1, seg2, seg3 = np.split(solutions[0], [n//3, 2*n//3])\n        seg4, seg5, seg6 = np.split(solutions[1], [n//3, 2*n//3])\n        seg7, seg8, seg9 = np.split(solutions[2], [n//3, 2*n//3])\n\n        new_solution = np.concatenate([seg1, seg5, seg9])\n\n    # Multi-objective 3-opt move\n    if n >= 3:\n        a, b, c = np.random.choice(n, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Evaluate all possible 3-opt moves across objectives\n        options = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]])\n        ]\n\n        # Select the move with the best average improvement across objectives\n        best_option = options[0]\n        best_improvement = 0\n        for option in options:\n            total_improvement = 0\n            for i in range(3):\n                if i == 0:\n                    dm = distance_matrix_1\n                elif i == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                current_cost = sum(dm[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                new_cost = sum(dm[option[k], option[(k+1)%n]] for k in range(n))\n                total_improvement += current_cost - new_cost\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_option = option\n\n        new_solution = best_option\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) / 3)\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel hybrid local search combining segment reversal, edge exchange, and objective-aware node swaps\n    # Segment reversal with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    # Reverse the segment if it improves at least one objective\n    reversed_segment = segment[::-1]\n    original_costs = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    reversed_costs = sum(distance_matrix_1[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n    if reversed_costs < original_costs:\n        new_solution[i:j] = reversed_segment\n\n    # Objective-aware edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate the change in all three objectives\n        old_edges = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b] +\n                     distance_matrix_1[c, d] + distance_matrix_2[c, d] + distance_matrix_3[c, d])\n        new_edges = (distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_3[a, c] +\n                     distance_matrix_1[b, d] + distance_matrix_2[b, d] + distance_matrix_3[b, d])\n        if new_edges < old_edges:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Objective-aware node swap\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    # Calculate the change in all three objectives\n    old_cost = (distance_matrix_1[k, new_solution[(k-1)%n]] + distance_matrix_1[k, new_solution[(k+1)%n]] +\n                distance_matrix_1[l, new_solution[(l-1)%n]] + distance_matrix_1[l, new_solution[(l+1)%n]] +\n                distance_matrix_2[k, new_solution[(k-1)%n]] + distance_matrix_2[k, new_solution[(k+1)%n]] +\n                distance_matrix_2[l, new_solution[(l-1)%n]] + distance_matrix_2[l, new_solution[(l+1)%n]] +\n                distance_matrix_3[k, new_solution[(k-1)%n]] + distance_matrix_3[k, new_solution[(k+1)%n]] +\n                distance_matrix_3[l, new_solution[(l-1)%n]] + distance_matrix_3[l, new_solution[(l+1)%n]])\n    new_cost = (distance_matrix_1[k, new_solution[(l-1)%n]] + distance_matrix_1[k, new_solution[(l+1)%n]] +\n                distance_matrix_1[l, new_solution[(k-1)%n]] + distance_matrix_1[l, new_solution[(k+1)%n]] +\n                distance_matrix_2[k, new_solution[(l-1)%n]] + distance_matrix_2[k, new_solution[(l+1)%n]] +\n                distance_matrix_2[l, new_solution[(k-1)%n]] + distance_matrix_2[l, new_solution[(k+1)%n]] +\n                distance_matrix_3[k, new_solution[(l-1)%n]] + distance_matrix_3[k, new_solution[(l+1)%n]] +\n                distance_matrix_3[l, new_solution[(k-1)%n]] + distance_matrix_3[l, new_solution[(k+1)%n]])\n    if new_cost < old_cost:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5256523093115254,
            1.1077860832214355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) / 3)\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel hybrid local search combining segment reversal, edge exchange, and objective-aware node swaps\n    # Segment reversal with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    # Reverse the segment if it improves at least one objective\n    reversed_segment = segment[::-1]\n    original_costs = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    reversed_costs = sum(distance_matrix_1[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n    if reversed_costs < original_costs:\n        new_solution[i:j] = reversed_segment\n\n    # Objective-aware edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate the change in all three objectives\n        old_edges = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b] +\n                     distance_matrix_1[c, d] + distance_matrix_2[c, d] + distance_matrix_3[c, d])\n        new_edges = (distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_3[a, c] +\n                     distance_matrix_1[b, d] + distance_matrix_2[b, d] + distance_matrix_3[b, d])\n        if new_edges < old_edges:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Objective-aware node swap\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    # Calculate the change in all three objectives\n    old_cost = (distance_matrix_1[k, new_solution[(k-1)%n]] + distance_matrix_1[k, new_solution[(k+1)%n]] +\n                distance_matrix_1[l, new_solution[(l-1)%n]] + distance_matrix_1[l, new_solution[(l+1)%n]] +\n                distance_matrix_2[k, new_solution[(k-1)%n]] + distance_matrix_2[k, new_solution[(k+1)%n]] +\n                distance_matrix_2[l, new_solution[(l-1)%n]] + distance_matrix_2[l, new_solution[(l+1)%n]] +\n                distance_matrix_3[k, new_solution[(k-1)%n]] + distance_matrix_3[k, new_solution[(k+1)%n]] +\n                distance_matrix_3[l, new_solution[(l-1)%n]] + distance_matrix_3[l, new_solution[(l+1)%n]])\n    new_cost = (distance_matrix_1[k, new_solution[(l-1)%n]] + distance_matrix_1[k, new_solution[(l+1)%n]] +\n                distance_matrix_1[l, new_solution[(k-1)%n]] + distance_matrix_1[l, new_solution[(k+1)%n]] +\n                distance_matrix_2[k, new_solution[(l-1)%n]] + distance_matrix_2[k, new_solution[(l+1)%n]] +\n                distance_matrix_2[l, new_solution[(k-1)%n]] + distance_matrix_2[l, new_solution[(k+1)%n]] +\n                distance_matrix_3[k, new_solution[(l-1)%n]] + distance_matrix_3[k, new_solution[(l+1)%n]] +\n                distance_matrix_3[l, new_solution[(k-1)%n]] + distance_matrix_3[l, new_solution[(k+1)%n]])\n    if new_cost < old_cost:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, applies a multi-objective-aware local search combining 3-opt moves and a novel edge-swapping strategy to improve the tour across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move to improve the tour\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Multi-objective edge swapping: select edges with high potential for improvement\n    for _ in range(2):  # Perform 2 edge swaps\n        # Find edges with high distance in any objective\n        edge_scores = []\n        for idx in range(n):\n            next_idx = (idx + 1) % n\n            d1 = distance_matrix_1[new_solution[idx], new_solution[next_idx]]\n            d2 = distance_matrix_2[new_solution[idx], new_solution[next_idx]]\n            d3 = distance_matrix_3[new_solution[idx], new_solution[next_idx]]\n            score = max(d1, d2, d3)  # Prioritize worst objective\n            edge_scores.append((score, idx))\n\n        # Select the worst edge to improve\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n        worst_edge = edge_scores[0][1]\n\n        # Find a better edge to swap with\n        candidate_edges = []\n        for idx in range(n):\n            if idx != worst_edge and idx != (worst_edge + 1) % n:\n                candidate_edges.append(idx)\n\n        if candidate_edges:\n            swap_with = np.random.choice(candidate_edges)\n            new_solution[worst_edge], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.5834279416076871,
            1.2516796469688416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move to improve the tour\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Multi-objective edge swapping: select edges with high potential for improvement\n    for _ in range(2):  # Perform 2 edge swaps\n        # Find edges with high distance in any objective\n        edge_scores = []\n        for idx in range(n):\n            next_idx = (idx + 1) % n\n            d1 = distance_matrix_1[new_solution[idx], new_solution[next_idx]]\n            d2 = distance_matrix_2[new_solution[idx], new_solution[next_idx]]\n            d3 = distance_matrix_3[new_solution[idx], new_solution[next_idx]]\n            score = max(d1, d2, d3)  # Prioritize worst objective\n            edge_scores.append((score, idx))\n\n        # Select the worst edge to improve\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n        worst_edge = edge_scores[0][1]\n\n        # Find a better edge to swap with\n        candidate_edges = []\n        for idx in range(n):\n            if idx != worst_edge and idx != (worst_edge + 1) % n:\n                candidate_edges.append(idx)\n\n        if candidate_edges:\n            swap_with = np.random.choice(candidate_edges)\n            new_solution[worst_edge], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    selected_index = np.argmax(np.sum(normalized_objectives, axis=1))\n    selected_solution = archive[selected_index][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective aware 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Evaluate the three possible 3-opt moves and select the one that improves the most in the combined objectives\n    def evaluate_move(move):\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = move[0]\n        temp_solution[b:c] = move[1]\n        temp_solution[c:] = move[2]\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        cost3 = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        return cost1 + cost2 + cost3\n\n    # Generate all possible 3-opt moves and evaluate them\n    moves = [\n        (new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]),\n        (new_solution[a:b], new_solution[b:c][::-1], new_solution[c:]),\n        (new_solution[a:b], new_solution[b:c], new_solution[c:][::-1])\n    ]\n\n    costs = [evaluate_move(move) for move in moves]\n    best_move_index = np.argmin(costs)\n\n    # Apply the best move\n    new_solution[a:b] = moves[best_move_index][0]\n    new_solution[b:c] = moves[best_move_index][1]\n    new_solution[c:] = moves[best_move_index][2]\n\n    return new_solution\n\n",
        "score": [
            -0.661458727081676,
            1.5135102272033691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    selected_index = np.argmax(np.sum(normalized_objectives, axis=1))\n    selected_solution = archive[selected_index][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective aware 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Evaluate the three possible 3-opt moves and select the one that improves the most in the combined objectives\n    def evaluate_move(move):\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = move[0]\n        temp_solution[b:c] = move[1]\n        temp_solution[c:] = move[2]\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        cost3 = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        return cost1 + cost2 + cost3\n\n    # Generate all possible 3-opt moves and evaluate them\n    moves = [\n        (new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]),\n        (new_solution[a:b], new_solution[b:c][::-1], new_solution[c:]),\n        (new_solution[a:b], new_solution[b:c], new_solution[c:][::-1])\n    ]\n\n    costs = [evaluate_move(move) for move in moves]\n    best_move_index = np.argmin(costs)\n\n    # Apply the best move\n    new_solution[a:b] = moves[best_move_index][0]\n    new_solution[b:c] = moves[best_move_index][1]\n    new_solution[c:] = moves[best_move_index][2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on crowding distance to ensure diversity, then applies a novel multi-objective local search operator that combines 3-opt moves with objective-aware edge exchanges to improve solutions across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        objectives = [obj for _, obj in solutions]\n        distances = [0] * len(objectives)\n        for m in range(3):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective 3-opt with edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments and perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Objective-aware edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate improvement potential across all objectives\n        current_cost = (distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n                        distance_matrix_1[selected_solution[b-1], selected_solution[b]] +\n                        distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n                        distance_matrix_2[selected_solution[b-1], selected_solution[b]] +\n                        distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n                        distance_matrix_3[selected_solution[b-1], selected_solution[b]])\n\n        new_cost = (distance_matrix_1[selected_solution[a-1], selected_solution[c]] +\n                    distance_matrix_1[selected_solution[b-1], selected_solution[d]] +\n                    distance_matrix_2[selected_solution[a-1], selected_solution[c]] +\n                    distance_matrix_2[selected_solution[b-1], selected_solution[d]] +\n                    distance_matrix_3[selected_solution[a-1], selected_solution[c]] +\n                    distance_matrix_3[selected_solution[b-1], selected_solution[d]])\n\n        if new_cost < current_cost and a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7429776263121124,
            1.9692327380180359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        objectives = [obj for _, obj in solutions]\n        distances = [0] * len(objectives)\n        for m in range(3):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective 3-opt with edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments and perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Objective-aware edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate improvement potential across all objectives\n        current_cost = (distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n                        distance_matrix_1[selected_solution[b-1], selected_solution[b]] +\n                        distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n                        distance_matrix_2[selected_solution[b-1], selected_solution[b]] +\n                        distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n                        distance_matrix_3[selected_solution[b-1], selected_solution[b]])\n\n        new_cost = (distance_matrix_1[selected_solution[a-1], selected_solution[c]] +\n                    distance_matrix_1[selected_solution[b-1], selected_solution[d]] +\n                    distance_matrix_2[selected_solution[a-1], selected_solution[c]] +\n                    distance_matrix_2[selected_solution[b-1], selected_solution[d]] +\n                    distance_matrix_3[selected_solution[a-1], selected_solution[c]] +\n                    distance_matrix_3[selected_solution[b-1], selected_solution[d]])\n\n        if new_cost < current_cost and a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, then applies a novel 3-opt local search combined with a multi-objective segment insertion to generate a neighbor solution, ensuring feasibility by validating and repairing the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (most room for improvement)\n    objectives = [obj for _, obj in archive]\n    max_objectives = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(max_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # 3-opt local search: randomly select three segments and rearrange them\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Rearrange segments to create a new tour\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Combine segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Multi-objective segment insertion: insert a segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n)\n        segment = other_solution[i:j]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7117781396984884,
            0.28346977233886717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (most room for improvement)\n    objectives = [obj for _, obj in archive]\n    max_objectives = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(max_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # 3-opt local search: randomly select three segments and rearrange them\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Rearrange segments to create a new tour\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Combine segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Multi-objective segment insertion: insert a segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n)\n        segment = other_solution[i:j]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, then applies a novel 3-opt local search combined with a multi-objective segment insertion to generate a neighbor solution, ensuring feasibility by validating and repairing the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (most room for improvement)\n    objectives = [obj for _, obj in archive]\n    max_objectives = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(max_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # 3-opt local search: randomly select three segments and rearrange them\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Rearrange segments to create a new tour\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Combine segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Multi-objective segment insertion: insert a segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n)\n        segment = other_solution[i:j]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7117781396984884,
            0.28346977233886717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (most room for improvement)\n    objectives = [obj for _, obj in archive]\n    max_objectives = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(max_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # 3-opt local search: randomly select three segments and rearrange them\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Rearrange segments to create a new tour\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Combine segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Multi-objective segment insertion: insert a segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n)\n        segment = other_solution[i:j]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware segment selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    obj1_impact = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj2_impact = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj3_impact = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n    if (0.4 * obj1_impact + 0.3 * obj2_impact + 0.3 * obj3_impact) > 0.5 * (sum(x[1][0] for x in archive) / len(archive)):\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with multi-objective consideration\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate objective impact of exchange\n        old_edges = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                    distance_matrix_1[new_solution[c], new_solution[d]] +\n                    distance_matrix_2[new_solution[a], new_solution[b]] +\n                    distance_matrix_2[new_solution[c], new_solution[d]] +\n                    distance_matrix_3[new_solution[a], new_solution[b]] +\n                    distance_matrix_3[new_solution[c], new_solution[d]])\n\n        new_edges = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                    distance_matrix_1[new_solution[b], new_solution[d]] +\n                    distance_matrix_2[new_solution[a], new_solution[c]] +\n                    distance_matrix_2[new_solution[b], new_solution[d]] +\n                    distance_matrix_3[new_solution[a], new_solution[c]] +\n                    distance_matrix_3[new_solution[b], new_solution[d]])\n\n        if new_edges < old_edges:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply novel multi-objective edge insertion\n    if np.random.random() < 0.3:\n        k = np.random.randint(1, n)\n        # Find edge with best combined improvement\n        best_improvement = 0\n        best_edge = None\n        for i in range(n):\n            if i == k or i == (k-1)%n:\n                continue\n            # Calculate improvement for all three objectives\n            imp1 = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[i], new_solution[k]] -\n                   distance_matrix_1[new_solution[k-1], new_solution[k]])\n            imp2 = (distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i], new_solution[k]] -\n                   distance_matrix_2[new_solution[k-1], new_solution[k]])\n            imp3 = (distance_matrix_3[new_solution[k-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[i], new_solution[k]] -\n                   distance_matrix_3[new_solution[k-1], new_solution[k]])\n            total_imp = 0.4*imp1 + 0.3*imp2 + 0.3*imp3\n            if total_imp < best_improvement:\n                best_improvement = total_imp\n                best_edge = i\n        if best_edge is not None:\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:k], [new_solution[best_edge]], new_solution[k:]])\n            new_solution = np.delete(new_solution, best_edge + (1 if best_edge > k else 0))\n\n    return new_solution\n\n",
        "score": [
            -0.6954929338777571,
            1.2141797065734863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware segment selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    obj1_impact = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj2_impact = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj3_impact = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n    if (0.4 * obj1_impact + 0.3 * obj2_impact + 0.3 * obj3_impact) > 0.5 * (sum(x[1][0] for x in archive) / len(archive)):\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with multi-objective consideration\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate objective impact of exchange\n        old_edges = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                    distance_matrix_1[new_solution[c], new_solution[d]] +\n                    distance_matrix_2[new_solution[a], new_solution[b]] +\n                    distance_matrix_2[new_solution[c], new_solution[d]] +\n                    distance_matrix_3[new_solution[a], new_solution[b]] +\n                    distance_matrix_3[new_solution[c], new_solution[d]])\n\n        new_edges = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                    distance_matrix_1[new_solution[b], new_solution[d]] +\n                    distance_matrix_2[new_solution[a], new_solution[c]] +\n                    distance_matrix_2[new_solution[b], new_solution[d]] +\n                    distance_matrix_3[new_solution[a], new_solution[c]] +\n                    distance_matrix_3[new_solution[b], new_solution[d]])\n\n        if new_edges < old_edges:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply novel multi-objective edge insertion\n    if np.random.random() < 0.3:\n        k = np.random.randint(1, n)\n        # Find edge with best combined improvement\n        best_improvement = 0\n        best_edge = None\n        for i in range(n):\n            if i == k or i == (k-1)%n:\n                continue\n            # Calculate improvement for all three objectives\n            imp1 = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[i], new_solution[k]] -\n                   distance_matrix_1[new_solution[k-1], new_solution[k]])\n            imp2 = (distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i], new_solution[k]] -\n                   distance_matrix_2[new_solution[k-1], new_solution[k]])\n            imp3 = (distance_matrix_3[new_solution[k-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[i], new_solution[k]] -\n                   distance_matrix_3[new_solution[k-1], new_solution[k]])\n            total_imp = 0.4*imp1 + 0.3*imp2 + 0.3*imp3\n            if total_imp < best_improvement:\n                best_improvement = total_imp\n                best_edge = i\n        if best_edge is not None:\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:k], [new_solution[best_edge]], new_solution[k:]])\n            new_solution = np.delete(new_solution, best_edge + (1 if best_edge > k else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search operator combining segment reversal, edge insertion, and node permutation to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal with a probability of 0.5\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion with a probability of 0.5\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:b+1], new_solution[a:b], new_solution[b+1:]])\n\n    # Apply node permutation with a probability of 0.3\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, n // 2)\n        indices = np.random.choice(n, k, replace=False)\n        np.random.shuffle(new_solution[indices])\n\n    return new_solution\n\n",
        "score": [
            -0.5210752983984286,
            1.5379212737083434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal with a probability of 0.5\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion with a probability of 0.5\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:b+1], new_solution[a:b], new_solution[b+1:]])\n\n    # Apply node permutation with a probability of 0.3\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, n // 2)\n        indices = np.random.choice(n, k, replace=False)\n        np.random.shuffle(new_solution[indices])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 3-opt and edge insertion\n    if n >= 4:\n        # 3-opt move: randomly select three edges and reverse a segment\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Edge insertion: move a random node to another position\n    a, b = np.random.choice(n, 2, replace=False)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5396255119944361,
            1.1994273662567139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 3-opt and edge insertion\n    if n >= 4:\n        # 3-opt move: randomly select three edges and reverse a segment\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Edge insertion: move a random node to another position\n    a, b = np.random.choice(n, 2, replace=False)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel local search operator: Multi-Objective Segment Reversal with Objective-Aware Swapping\n    # Randomly select three segments and reverse them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Swap nodes based on the objective with the worst performance\n    objectives = [sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]),\n                 sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]),\n                 sum(distance_matrix_3[new_solution[:-1], new_solution[1:]])]\n\n    worst_obj = np.argmax(objectives)\n    if worst_obj == 0:\n        # If first objective is worst, swap nodes that improve it\n        for _ in range(5):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] < \\\n               distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # If second objective is worst, swap nodes that improve it\n        for _ in range(5):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] < \\\n               distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # If third objective is worst, swap nodes that improve it\n        for _ in range(5):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]] < \\\n               distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6142794085893942,
            1.2881725311279297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel local search operator: Multi-Objective Segment Reversal with Objective-Aware Swapping\n    # Randomly select three segments and reverse them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Swap nodes based on the objective with the worst performance\n    objectives = [sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]),\n                 sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]),\n                 sum(distance_matrix_3[new_solution[:-1], new_solution[1:]])]\n\n    worst_obj = np.argmax(objectives)\n    if worst_obj == 0:\n        # If first objective is worst, swap nodes that improve it\n        for _ in range(5):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] < \\\n               distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # If second objective is worst, swap nodes that improve it\n        for _ in range(5):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] < \\\n               distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # If third objective is worst, swap nodes that improve it\n        for _ in range(5):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]] < \\\n               distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of its objectives, then applies a hybrid local search combining 2-opt and edge exchange, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    # 2-opt move: reverse a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange: swap two edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5967196147985501,
            1.1765230298042297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    # 2-opt move: reverse a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange: swap two edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining objective values and diversity, then applies a multi-objective-aware 2-opt move followed by a node relinking step to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        obj_score = sum(obj)  # Sum of all three objectives\n        diversity = sum(np.abs(sol - archive[0][0]))  # Diversity from first solution\n        scores.append(obj_score + 0.5 * diversity)\n    selected_idx = np.argmax(scores)\n    selected_solution, _ = archive[selected_idx]\n\n    # Apply multi-objective 2-opt move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Choose objective space for 2-opt based on relative improvement\n    obj1_before = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n    obj1_after = distance_matrix_1[selected_solution[i-1], selected_solution[j-1]] + distance_matrix_1[selected_solution[i], selected_solution[j]]\n    improvement1 = obj1_before - obj1_after\n\n    obj2_before = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n    obj2_after = distance_matrix_2[selected_solution[i-1], selected_solution[j-1]] + distance_matrix_2[selected_solution[i], selected_solution[j]]\n    improvement2 = obj2_before - obj2_after\n\n    obj3_before = distance_matrix_3[selected_solution[i-1], selected_solution[i]] + distance_matrix_3[selected_solution[j-1], selected_solution[j]]\n    obj3_after = distance_matrix_3[selected_solution[i-1], selected_solution[j-1]] + distance_matrix_3[selected_solution[i], selected_solution[j]]\n    improvement3 = obj3_before - obj3_after\n\n    # Perform 2-opt if at least one objective improves\n    if improvement1 > 0 or improvement2 > 0 or improvement3 > 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node relinking step\n    k = np.random.randint(1, n-1)\n    new_solution[k:] = np.roll(new_solution[k:], shift=1)\n\n    return new_solution\n\n",
        "score": [
            -0.574655157209866,
            2.0120483160018923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        obj_score = sum(obj)  # Sum of all three objectives\n        diversity = sum(np.abs(sol - archive[0][0]))  # Diversity from first solution\n        scores.append(obj_score + 0.5 * diversity)\n    selected_idx = np.argmax(scores)\n    selected_solution, _ = archive[selected_idx]\n\n    # Apply multi-objective 2-opt move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Choose objective space for 2-opt based on relative improvement\n    obj1_before = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n    obj1_after = distance_matrix_1[selected_solution[i-1], selected_solution[j-1]] + distance_matrix_1[selected_solution[i], selected_solution[j]]\n    improvement1 = obj1_before - obj1_after\n\n    obj2_before = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n    obj2_after = distance_matrix_2[selected_solution[i-1], selected_solution[j-1]] + distance_matrix_2[selected_solution[i], selected_solution[j]]\n    improvement2 = obj2_before - obj2_after\n\n    obj3_before = distance_matrix_3[selected_solution[i-1], selected_solution[i]] + distance_matrix_3[selected_solution[j-1], selected_solution[j]]\n    obj3_after = distance_matrix_3[selected_solution[i-1], selected_solution[j-1]] + distance_matrix_3[selected_solution[i], selected_solution[j]]\n    improvement3 = obj3_before - obj3_after\n\n    # Perform 2-opt if at least one objective improves\n    if improvement1 > 0 or improvement2 > 0 or improvement3 > 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node relinking step\n    k = np.random.randint(1, n-1)\n    new_solution[k:] = np.roll(new_solution[k:], shift=1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The new algorithm will select a solution from the archive based on its dominance in the Pareto front, then apply a novel local search operator that combines a multi-segment reversal with a weighted edge insertion to explore diverse regions of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (minimizing max objective)\n    max_objectives = [max(obj) for _, obj in archive]\n    selected_idx = np.argmin(max_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[segments[0]:segments[1]] = new_solution[segments[0]:segments[1]][::-1]\n    new_solution[segments[1]:segments[2]] = new_solution[segments[1]:segments[2]][::-1]\n\n    # Weighted edge insertion\n    weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    avg_weights = np.mean(weights, axis=0)\n    i, j = np.random.choice(n, 2, replace=False)\n    if avg_weights[new_solution[i-1], new_solution[j]] + avg_weights[new_solution[j], new_solution[i]] < avg_weights[new_solution[i-1], new_solution[i]] + avg_weights[new_solution[j-1], new_solution[j]]:\n        new_solution[i:j] = np.roll(new_solution[i:j], 1)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6816850422340333,
            1.1916717052459718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (minimizing max objective)\n    max_objectives = [max(obj) for _, obj in archive]\n    selected_idx = np.argmin(max_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[segments[0]:segments[1]] = new_solution[segments[0]:segments[1]][::-1]\n    new_solution[segments[1]:segments[2]] = new_solution[segments[1]:segments[2]][::-1]\n\n    # Weighted edge insertion\n    weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    avg_weights = np.mean(weights, axis=0)\n    i, j = np.random.choice(n, 2, replace=False)\n    if avg_weights[new_solution[i-1], new_solution[j]] + avg_weights[new_solution[j], new_solution[i]] < avg_weights[new_solution[i-1], new_solution[i]] + avg_weights[new_solution[j-1], new_solution[j]]:\n        new_solution[i:j] = np.roll(new_solution[i:j], 1)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 3-opt and a segment-based mutation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using weighted sum of objectives\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create all possible permutations of the selected segment\n    segment = new_solution[a:c+1]\n    permutations = [segment, segment[::-1], np.roll(segment, 1), np.roll(segment, -1)]\n\n    # Evaluate each permutation based on the weighted sum of objectives\n    best_perm = segment\n    best_score = float('inf')\n\n    for perm in permutations:\n        temp_solution = new_solution.copy()\n        temp_solution[a:c+1] = perm\n\n        # Calculate the weighted sum of objectives for the temp solution\n        obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        obj3 = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        score = weights[0] * obj1 + weights[1] * obj2 + weights[2] * obj3\n\n        if score < best_score:\n            best_score = score\n            best_perm = perm\n\n    new_solution[a:c+1] = best_perm\n\n    # Apply segment-based mutation with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7403913264561932,
            3.9589595079421995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using weighted sum of objectives\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create all possible permutations of the selected segment\n    segment = new_solution[a:c+1]\n    permutations = [segment, segment[::-1], np.roll(segment, 1), np.roll(segment, -1)]\n\n    # Evaluate each permutation based on the weighted sum of objectives\n    best_perm = segment\n    best_score = float('inf')\n\n    for perm in permutations:\n        temp_solution = new_solution.copy()\n        temp_solution[a:c+1] = perm\n\n        # Calculate the weighted sum of objectives for the temp solution\n        obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        obj3 = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        score = weights[0] * obj1 + weights[1] * obj2 + weights[2] * obj3\n\n        if score < best_score:\n            best_score = score\n            best_perm = perm\n\n    new_solution[a:c+1] = best_perm\n\n    # Apply segment-based mutation with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance metrics, then applies a hybrid local search combining multi-objective edge exchange and 3-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i-1], new_solution[j]] < \\\n       distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i-1], new_solution[i]]:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 3-opt move for multi-objective optimization\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    temp = new_solution.copy()\n    temp[a:b] = temp[a:b][::-1]\n    temp[b:c] = temp[b:c][::-1]\n    temp[a:c] = temp[a:c][::-1]\n\n    # Accept if at least one objective improves\n    if (sum([distance_matrix_1[temp[i-1], temp[i]] for i in range(n)]) < sum([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)]) or\n        sum([distance_matrix_2[temp[i-1], temp[i]] for i in range(n)]) < sum([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)]) or\n        sum([distance_matrix_3[temp[i-1], temp[i]] for i in range(n)]) < sum([distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)])):\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7347813422566238,
            3.3381206512451174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i-1], new_solution[j]] < \\\n       distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i-1], new_solution[i]]:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 3-opt move for multi-objective optimization\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    temp = new_solution.copy()\n    temp[a:b] = temp[a:b][::-1]\n    temp[b:c] = temp[b:c][::-1]\n    temp[a:c] = temp[a:c][::-1]\n\n    # Accept if at least one objective improves\n    if (sum([distance_matrix_1[temp[i-1], temp[i]] for i in range(n)]) < sum([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)]) or\n        sum([distance_matrix_2[temp[i-1], temp[i]] for i in range(n)]) < sum([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)]) or\n        sum([distance_matrix_3[temp[i-1], temp[i]] for i in range(n)]) < sum([distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)])):\n        new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in the objective space, then applies a novel multi-objective segment inversion operator that simultaneously optimizes all three objectives by selectively inverting segments of the tour while ensuring feasibility and maintaining non-dominated characteristics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all objectives using a weighted sum approach\n    objectives = [obj for _, obj in archive]\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply a secondary inversion based on objective improvement\n    best_improvement = 0\n    best_inversion = None\n\n    for _ in range(3):  # Try a few random secondary inversions\n        temp_solution = new_solution.copy()\n        seg_len = np.random.randint(2, min(5, n//2))\n        seg_start = np.random.randint(0, n - seg_len)\n        seg_end = seg_start + seg_len\n        temp_solution[seg_start:seg_end] = temp_solution[seg_start:seg_end][::-1]\n\n        # Calculate improvement across all objectives\n        original_cost = (sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(n)))\n\n        new_cost = (sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n                   sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n                   sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n)))\n\n        improvement = sum(1 if new < orig else 0 for new, orig in zip(new_cost, original_cost))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_inversion = temp_solution.copy()\n\n    if best_inversion is not None:\n        new_solution = best_inversion\n\n    return new_solution\n\n",
        "score": [
            -0.7029433154748747,
            2.905672323703766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all objectives using a weighted sum approach\n    objectives = [obj for _, obj in archive]\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply a secondary inversion based on objective improvement\n    best_improvement = 0\n    best_inversion = None\n\n    for _ in range(3):  # Try a few random secondary inversions\n        temp_solution = new_solution.copy()\n        seg_len = np.random.randint(2, min(5, n//2))\n        seg_start = np.random.randint(0, n - seg_len)\n        seg_end = seg_start + seg_len\n        temp_solution[seg_start:seg_end] = temp_solution[seg_start:seg_end][::-1]\n\n        # Calculate improvement across all objectives\n        original_cost = (sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(n)))\n\n        new_cost = (sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n                   sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n                   sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n)))\n\n        improvement = sum(1 if new < orig else 0 for new, orig in zip(new_cost, original_cost))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_inversion = temp_solution.copy()\n\n    if best_inversion is not None:\n        new_solution = best_inversion\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel tri-objective local search algorithm that selects solutions with high potential for improvement by considering dominance and diversity, then applies a hybrid operator combining 3-opt and multi-objective edge exchange to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(obj):\n        return (obj[0] + obj[1] + obj[2]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2) + np.sum(distance_matrix_3))\n\n    selected_solution, selected_obj = max(archive, key=lambda x: score(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Check if the exchange improves at least one objective\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]],\n            distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]],\n            distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]]\n        ]\n        if any(n < c for n, c in zip(new_costs, current_costs)):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.4839737688933017,
            4.24535082578659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(obj):\n        return (obj[0] + obj[1] + obj[2]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2) + np.sum(distance_matrix_3))\n\n    selected_solution, selected_obj = max(archive, key=lambda x: score(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Check if the exchange improves at least one objective\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]],\n            distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]],\n            distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]]\n        ]\n        if any(n < c for n, c in zip(new_costs, current_costs)):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a solution from the archive that shows high potential for improvement by evaluating the diversity and quality of solutions, then applies a novel multi-objective local search combining segment inversion, edge relocation, and objective-aware edge swapping to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives and select the middle one (diverse but not worst)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        selected_solution = sorted_solutions[len(sorted_solutions)//2][0]\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective local search\n    if n > 3:\n        # Segment inversion with objective awareness\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        obj1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        obj2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        obj3 = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Decide whether to invert based on objective balance\n        if (obj1 + obj2 + obj3) > (np.random.rand() * 2 * sum([obj1, obj2, obj3])):\n            new_solution[i:j] = segment[::-1]\n\n        # Edge relocation with objective awareness\n        a = np.random.randint(1, n-1)\n        b = np.random.randint(1, n-1)\n        if a != b:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[a+1]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[a+1]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[a], new_solution[a+1]])\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[a+1]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[a+1]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b], new_solution[a+1]])\n\n            if new_cost < old_cost:\n                # Perform relocation if it improves all objectives\n                node = new_solution[a]\n                new_solution = np.concatenate([new_solution[:a], new_solution[a+1:]])\n                insert_pos = np.random.randint(1, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge swap\n        c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if c != d:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                        distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                        distance_matrix_1[new_solution[d-1], new_solution[d]] +\n                        distance_matrix_1[new_solution[d], new_solution[d+1]] +\n                        distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                        distance_matrix_2[new_solution[d-1], new_solution[d]] +\n                        distance_matrix_2[new_solution[d], new_solution[d+1]] +\n                        distance_matrix_3[new_solution[c-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[c], new_solution[c+1]] +\n                        distance_matrix_3[new_solution[d-1], new_solution[d]] +\n                        distance_matrix_3[new_solution[d], new_solution[d+1]])\n            new_cost = (distance_matrix_1[new_solution[c-1], new_solution[d]] +\n                        distance_matrix_1[new_solution[d], new_solution[c+1]] +\n                        distance_matrix_1[new_solution[d-1], new_solution[c]] +\n                        distance_matrix_1[new_solution[c], new_solution[d+1]] +\n                        distance_matrix_2[new_solution[c-1], new_solution[d]] +\n                        distance_matrix_2[new_solution[d], new_solution[c+1]] +\n                        distance_matrix_2[new_solution[d-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[c], new_solution[d+1]] +\n                        distance_matrix_3[new_solution[c-1], new_solution[d]] +\n                        distance_matrix_3[new_solution[d], new_solution[c+1]] +\n                        distance_matrix_3[new_solution[d-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[c], new_solution[d+1]])\n\n            if new_cost < old_cost:\n                # Perform swap if it improves all objectives\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.7099035218991687,
            1.3889545440673827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives and select the middle one (diverse but not worst)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        selected_solution = sorted_solutions[len(sorted_solutions)//2][0]\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective local search\n    if n > 3:\n        # Segment inversion with objective awareness\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        obj1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        obj2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        obj3 = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Decide whether to invert based on objective balance\n        if (obj1 + obj2 + obj3) > (np.random.rand() * 2 * sum([obj1, obj2, obj3])):\n            new_solution[i:j] = segment[::-1]\n\n        # Edge relocation with objective awareness\n        a = np.random.randint(1, n-1)\n        b = np.random.randint(1, n-1)\n        if a != b:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[a+1]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[a+1]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[a], new_solution[a+1]])\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[a+1]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[a+1]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b], new_solution[a+1]])\n\n            if new_cost < old_cost:\n                # Perform relocation if it improves all objectives\n                node = new_solution[a]\n                new_solution = np.concatenate([new_solution[:a], new_solution[a+1:]])\n                insert_pos = np.random.randint(1, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge swap\n        c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if c != d:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                        distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                        distance_matrix_1[new_solution[d-1], new_solution[d]] +\n                        distance_matrix_1[new_solution[d], new_solution[d+1]] +\n                        distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                        distance_matrix_2[new_solution[d-1], new_solution[d]] +\n                        distance_matrix_2[new_solution[d], new_solution[d+1]] +\n                        distance_matrix_3[new_solution[c-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[c], new_solution[c+1]] +\n                        distance_matrix_3[new_solution[d-1], new_solution[d]] +\n                        distance_matrix_3[new_solution[d], new_solution[d+1]])\n            new_cost = (distance_matrix_1[new_solution[c-1], new_solution[d]] +\n                        distance_matrix_1[new_solution[d], new_solution[c+1]] +\n                        distance_matrix_1[new_solution[d-1], new_solution[c]] +\n                        distance_matrix_1[new_solution[c], new_solution[d+1]] +\n                        distance_matrix_2[new_solution[c-1], new_solution[d]] +\n                        distance_matrix_2[new_solution[d], new_solution[c+1]] +\n                        distance_matrix_2[new_solution[d-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[c], new_solution[d+1]] +\n                        distance_matrix_3[new_solution[c-1], new_solution[d]] +\n                        distance_matrix_3[new_solution[d], new_solution[c+1]] +\n                        distance_matrix_3[new_solution[d-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[c], new_solution[d+1]])\n\n            if new_cost < old_cost:\n                # Perform swap if it improves all objectives\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This heuristic selects a solution from the archive based on the worst objective value, applies a segment inversion and a segment exchange with another solution, and repairs any feasibility issues to ensure a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the worst solution based on the maximum objective value\n    objectives = [max(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Exchange segments with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Repair duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5971154973056823,
            1.613287615776062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the worst solution based on the maximum objective value\n    objectives = [max(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Exchange segments with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Repair duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The new algorithm combines a multi-objective-aware selection strategy with a novel 3-opt-inspired local search operator that simultaneously optimizes across all three objectives by considering edge improvements in each objective space and performing a coordinated inversion of segments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on relative importance of objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt-inspired move with multi-objective consideration\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate potential improvements in all three objectives\n    def calculate_improvement(sol):\n        total_improvement = 0\n        for i in range(n):\n            u, v = sol[i], sol[(i+1)%n]\n            original_cost = distance_matrix_1[u,v] + distance_matrix_2[u,v] + distance_matrix_3[u,v]\n            new_cost = distance_matrix_1[v,u] + distance_matrix_2[v,u] + distance_matrix_3[v,u]\n            total_improvement += original_cost - new_cost\n        return total_improvement\n\n    # Try different segment inversions\n    candidates = [\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy()\n    ]\n\n    # Candidate 1: Reverse segment a to b\n    candidates[0][a:b] = candidates[0][a:b][::-1]\n\n    # Candidate 2: Reverse segment b to c\n    candidates[1][b:c] = candidates[1][b:c][::-1]\n\n    # Candidate 3: Reverse segment a to c\n    candidates[2][a:c] = candidates[2][a:c][::-1]\n\n    # Select the candidate with the best total improvement\n    improvements = [calculate_improvement(c) for c in candidates]\n    best_idx = np.argmax(improvements)\n    new_solution = candidates[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6469062261282004,
            1.61383113861084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on relative importance of objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt-inspired move with multi-objective consideration\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate potential improvements in all three objectives\n    def calculate_improvement(sol):\n        total_improvement = 0\n        for i in range(n):\n            u, v = sol[i], sol[(i+1)%n]\n            original_cost = distance_matrix_1[u,v] + distance_matrix_2[u,v] + distance_matrix_3[u,v]\n            new_cost = distance_matrix_1[v,u] + distance_matrix_2[v,u] + distance_matrix_3[v,u]\n            total_improvement += original_cost - new_cost\n        return total_improvement\n\n    # Try different segment inversions\n    candidates = [\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy()\n    ]\n\n    # Candidate 1: Reverse segment a to b\n    candidates[0][a:b] = candidates[0][a:b][::-1]\n\n    # Candidate 2: Reverse segment b to c\n    candidates[1][b:c] = candidates[1][b:c][::-1]\n\n    # Candidate 3: Reverse segment a to c\n    candidates[2][a:c] = candidates[2][a:c][::-1]\n\n    # Select the candidate with the best total improvement\n    improvements = [calculate_improvement(c) for c in candidates]\n    best_idx = np.argmax(improvements)\n    new_solution = candidates[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: np.mean([x[1][0], x[1][1], x[1][2]]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 3-opt and node insertion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[[j, k]] = new_solution[[k, j]]\n\n    # Randomly select a node and insert it at a different position\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5742910389405054,
            2.5390639543533324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: np.mean([x[1][0], x[1][1], x[1][2]]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 3-opt and node insertion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[[j, k]] = new_solution[[k, j]]\n\n    # Randomly select a node and insert it at a different position\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This heuristic function selects a solution from the archive based on the best trade-off between objectives, identifies critical segments using a multi-objective segment analysis, and applies a hybrid local search combining 3-opt with a novel segment-based mutation to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives / np.max(objectives, axis=0), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves\n    options = [\n        new_solution.copy(),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    # Evaluate all options based on total distance in all three objectives\n    def evaluate(sol):\n        total = 0\n        for d in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            total += sum(d[sol[i], sol[(i+1)%n]] for i in range(n))\n        return total\n\n    best_option = min(options, key=evaluate)\n    new_solution = best_option.copy()\n\n    # Apply segment-based mutation\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        start, end = np.random.choice(n, 2, replace=False)\n        start, end = min(start, end), max(start, end)\n        new_solution[start:end+1] = other_solution[start:end+1]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n                if len(missing) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6766526729817207,
            3.854857528209686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives / np.max(objectives, axis=0), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves\n    options = [\n        new_solution.copy(),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    # Evaluate all options based on total distance in all three objectives\n    def evaluate(sol):\n        total = 0\n        for d in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            total += sum(d[sol[i], sol[(i+1)%n]] for i in range(n))\n        return total\n\n    best_option = min(options, key=evaluate)\n    new_solution = best_option.copy()\n\n    # Apply segment-based mutation\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        start, end = np.random.choice(n, 2, replace=False)\n        start, end = min(start, end), max(start, end)\n        new_solution[start:end+1] = other_solution[start:end+1]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n                if len(missing) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A novel heuristic function that intelligently selects a non-dominated solution from the archive and applies a hybrid local search combining segment reversal and multi-objective edge swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet([1, 1, 1])\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal for diversification\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply multi-objective edge swapping\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the improvement across all three objectives\n    def calculate_improvement(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    original_costs = calculate_improvement(new_solution)\n\n    # Try the swap and check if it improves any objective\n    temp_solution = new_solution.copy()\n    temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n    new_costs = calculate_improvement(temp_solution)\n\n    # Accept the swap if it improves at least one objective\n    if any(new < orig for new, orig in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7007991292488595,
            1.9632571816444397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet([1, 1, 1])\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal for diversification\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply multi-objective edge swapping\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the improvement across all three objectives\n    def calculate_improvement(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    original_costs = calculate_improvement(new_solution)\n\n    # Try the swap and check if it improves any objective\n    temp_solution = new_solution.copy()\n    temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n    new_costs = calculate_improvement(temp_solution)\n\n    # Accept the swap if it improves at least one objective\n    if any(new < orig for new, orig in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects solutions with high potential for improvement by combining crowding distance-based selection with a hybrid of 2-opt and edge exchange operations, while ensuring feasibility through careful edge swapping and segment reversal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[max(0, i-1)]\n            right = solutions[min(len(solutions)-1, i+1)]\n            dist = sum(abs(a - b) for a, b in zip(left[1], right[1]))\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_solution = archive[np.argmax(distances)][0].copy()\n\n    # Apply hybrid local search: 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6918233223342182,
            1.1412354111671448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[max(0, i-1)]\n            right = solutions[min(len(solutions)-1, i+1)]\n            dist = sum(abs(a - b) for a, b in zip(left[1], right[1]))\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_solution = archive[np.argmax(distances)][0].copy()\n\n    # Apply hybrid local search: 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst-performing objective, performs a novel segment inversion and insertion operation, and combines it with a random segment from another solution to create a diverse neighbor while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (diversification)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1][::-1]\n\n    # Insert the inverted segment at a random position\n    k = np.random.randint(0, n - (j - i))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Remove duplicate nodes (if any) by replacing them with missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n                if len(missing_nodes) == 0:\n                    break\n\n    # Ensure the solution is a valid tour (no duplicates and all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If still duplicates, repair by replacing with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in np.unique(new_solution[:idx]):\n                continue\n            new_solution[idx] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n            if len(missing_nodes) == 0:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7158105558518699,
            0.3725907802581787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (diversification)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1][::-1]\n\n    # Insert the inverted segment at a random position\n    k = np.random.randint(0, n - (j - i))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Remove duplicate nodes (if any) by replacing them with missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n                if len(missing_nodes) == 0:\n                    break\n\n    # Ensure the solution is a valid tour (no duplicates and all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If still duplicates, repair by replacing with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in np.unique(new_solution[:idx]):\n                continue\n            new_solution[idx] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n            if len(missing_nodes) == 0:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions with high potential for improvement by combining multi-objective crowding distance analysis with a probabilistic 3-opt move and a novel edge-swap operator tailored for tri-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            objectives_sorted = objectives[sorted_indices, m]\n\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                if objectives_sorted[-1] - objectives_sorted[0] == 0:\n                    crowding_distances[sorted_indices[i]] += 0\n                else:\n                    crowding_distances[sorted_indices[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0])\n\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt move with probability based on objective improvements\n    if np.random.random() < 0.7:\n        n = len(new_solution)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate original and new costs\n        orig_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                    distance_matrix_3[new_solution[c-1], new_solution[a]])\n\n        if new_cost < orig_cost:\n            # Perform the 3-opt move\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Apply novel edge-swap operator for tri-objective optimization\n        n = len(new_solution)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate potential improvements for all three objectives\n        improvements = [\n            (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n             distance_matrix_1[new_solution[b-1], new_solution[c]] +\n             distance_matrix_1[new_solution[c-1], new_solution[a]]) -\n            (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n             distance_matrix_1[new_solution[c-1], new_solution[c]]),\n\n            (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n             distance_matrix_2[new_solution[b-1], new_solution[c]] +\n             distance_matrix_2[new_solution[c-1], new_solution[a]]) -\n            (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n             distance_matrix_2[new_solution[c-1], new_solution[c]]),\n\n            (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n             distance_matrix_3[new_solution[b-1], new_solution[c]] +\n             distance_matrix_3[new_solution[c-1], new_solution[a]]) -\n            (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n             distance_matrix_3[new_solution[b-1], new_solution[b]] +\n             distance_matrix_3[new_solution[c-1], new_solution[c]])\n        ]\n\n        # Accept if at least two objectives improve\n        if sum(1 for imp in improvements if imp < 0) >= 2:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5912372050740899,
            4.0395458221435545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            objectives_sorted = objectives[sorted_indices, m]\n\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                if objectives_sorted[-1] - objectives_sorted[0] == 0:\n                    crowding_distances[sorted_indices[i]] += 0\n                else:\n                    crowding_distances[sorted_indices[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0])\n\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt move with probability based on objective improvements\n    if np.random.random() < 0.7:\n        n = len(new_solution)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate original and new costs\n        orig_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                    distance_matrix_3[new_solution[c-1], new_solution[a]])\n\n        if new_cost < orig_cost:\n            # Perform the 3-opt move\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Apply novel edge-swap operator for tri-objective optimization\n        n = len(new_solution)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate potential improvements for all three objectives\n        improvements = [\n            (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n             distance_matrix_1[new_solution[b-1], new_solution[c]] +\n             distance_matrix_1[new_solution[c-1], new_solution[a]]) -\n            (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n             distance_matrix_1[new_solution[c-1], new_solution[c]]),\n\n            (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n             distance_matrix_2[new_solution[b-1], new_solution[c]] +\n             distance_matrix_2[new_solution[c-1], new_solution[a]]) -\n            (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n             distance_matrix_2[new_solution[c-1], new_solution[c]]),\n\n            (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n             distance_matrix_3[new_solution[b-1], new_solution[c]] +\n             distance_matrix_3[new_solution[c-1], new_solution[a]]) -\n            (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n             distance_matrix_3[new_solution[b-1], new_solution[b]] +\n             distance_matrix_3[new_solution[c-1], new_solution[c]])\n        ]\n\n        # Accept if at least two objectives improve\n        if sum(1 for imp in improvements if imp < 0) >= 2:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance in the objective space, then applies a novel multi-segment inversion and edge rotation operator to generate a neighbor solution, ensuring feasibility through careful node reassignment and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    scores = [obj[0] * obj[1] * obj[2] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments and invert them in a circular fashion\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = segments\n\n    # Invert segments in a circular pattern\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Rotate edges between segments to improve multi-objective connectivity\n    if a != b and b != c:\n        new_solution[[a, b, c]] = new_solution[[a, c, b]]\n\n    # Ensure the solution is a valid tour by checking for duplicates and repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6115831717176374,
            1.1637562394142151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    scores = [obj[0] * obj[1] * obj[2] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments and invert them in a circular fashion\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = segments\n\n    # Invert segments in a circular pattern\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Rotate edges between segments to improve multi-objective connectivity\n    if a != b and b != c:\n        new_solution[[a, b, c]] = new_solution[[a, c, b]]\n\n    # Ensure the solution is a valid tour by checking for duplicates and repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining 2-opt with a multi-objective edge exchange to generate a neighbor solution, ensuring feasibility and exploring trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighting for objectives 1, 2, and 3\n    selected_solution, _ = max(archive, key=lambda x: sum(w * val for w, val in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective consideration\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    reversed_segment = new_solution[i:j][::-1]\n\n    # Evaluate both options for the 2-opt move\n    orig_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                 sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                 sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)))\n    new_solution[i:j] = reversed_segment\n    new_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)))\n\n    # Revert if worse in any objective\n    if new_cost > orig_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        temp = new_solution.copy()\n        temp[[a, b, c, d]] = temp[[a, c, b, d]]\n\n        # Accept if improvement in at least one objective\n        temp_cost1 = sum(distance_matrix_1[temp[k-1], temp[k]] for k in range(1, n))\n        temp_cost2 = sum(distance_matrix_2[temp[k-1], temp[k]] for k in range(1, n))\n        temp_cost3 = sum(distance_matrix_3[temp[k-1], temp[k]] for k in range(1, n))\n\n        if (temp_cost1 <= sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) or\n            temp_cost2 <= sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) or\n            temp_cost3 <= sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n))):\n            new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5932420993278432,
            1.4876583337783813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighting for objectives 1, 2, and 3\n    selected_solution, _ = max(archive, key=lambda x: sum(w * val for w, val in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective consideration\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    reversed_segment = new_solution[i:j][::-1]\n\n    # Evaluate both options for the 2-opt move\n    orig_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                 sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                 sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)))\n    new_solution[i:j] = reversed_segment\n    new_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n                sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)))\n\n    # Revert if worse in any objective\n    if new_cost > orig_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        temp = new_solution.copy()\n        temp[[a, b, c, d]] = temp[[a, c, b, d]]\n\n        # Accept if improvement in at least one objective\n        temp_cost1 = sum(distance_matrix_1[temp[k-1], temp[k]] for k in range(1, n))\n        temp_cost2 = sum(distance_matrix_2[temp[k-1], temp[k]] for k in range(1, n))\n        temp_cost3 = sum(distance_matrix_3[temp[k-1], temp[k]] for k in range(1, n))\n\n        if (temp_cost1 <= sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) or\n            temp_cost2 <= sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) or\n            temp_cost3 <= sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n))):\n            new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{Select a solution from the archive that shows the most potential for improvement across all three objectives, then apply a novel multi-objective-aware segment inversion and edge reversal operator to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj_sum = -float('inf')\n    selected_solution = None\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        current_sum = sum(normalized_obj)\n        if current_sum > max_obj_sum:\n            max_obj_sum = current_sum\n            selected_solution = sol\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment inversion\n    obj_weights = np.random.rand(3)\n    obj_weights /= obj_weights.sum()\n\n    # Select a segment to invert based on objective weights\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate the impact of inversion on each objective\n    impact = np.zeros(3)\n    for k in range(len(segment)-1):\n        u, v = segment[k], segment[k+1]\n        impact[0] += distance_matrix_1[u, v] - distance_matrix_1[v, u]\n        impact[1] += distance_matrix_2[u, v] - distance_matrix_2[v, u]\n        impact[2] += distance_matrix_3[u, v] - distance_matrix_3[v, u]\n\n    # Apply inversion if it improves the weighted sum of objectives\n    weighted_impact = sum(impact * obj_weights)\n    if weighted_impact > 0:\n        new_solution[i:j] = segment[::-1]\n\n    # Edge reversal based on objective improvement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        u, v = new_solution[a], new_solution[b]\n        x, y = new_solution[c], new_solution[d]\n\n        # Calculate the change in each objective\n        delta_obj = np.zeros(3)\n        delta_obj[0] = (distance_matrix_1[u, x] + distance_matrix_1[v, y] - distance_matrix_1[u, v] - distance_matrix_1[x, y])\n        delta_obj[1] = (distance_matrix_2[u, x] + distance_matrix_2[v, y] - distance_matrix_2[u, v] - distance_matrix_2[x, y])\n        delta_obj[2] = (distance_matrix_3[u, x] + distance_matrix_3[v, y] - distance_matrix_3[u, v] - distance_matrix_3[x, y])\n\n        # Apply reversal if it improves the weighted sum of objectives\n        if sum(delta_obj * obj_weights) < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.691907298668602,
            3.6178795218467714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj_sum = -float('inf')\n    selected_solution = None\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        current_sum = sum(normalized_obj)\n        if current_sum > max_obj_sum:\n            max_obj_sum = current_sum\n            selected_solution = sol\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment inversion\n    obj_weights = np.random.rand(3)\n    obj_weights /= obj_weights.sum()\n\n    # Select a segment to invert based on objective weights\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate the impact of inversion on each objective\n    impact = np.zeros(3)\n    for k in range(len(segment)-1):\n        u, v = segment[k], segment[k+1]\n        impact[0] += distance_matrix_1[u, v] - distance_matrix_1[v, u]\n        impact[1] += distance_matrix_2[u, v] - distance_matrix_2[v, u]\n        impact[2] += distance_matrix_3[u, v] - distance_matrix_3[v, u]\n\n    # Apply inversion if it improves the weighted sum of objectives\n    weighted_impact = sum(impact * obj_weights)\n    if weighted_impact > 0:\n        new_solution[i:j] = segment[::-1]\n\n    # Edge reversal based on objective improvement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        u, v = new_solution[a], new_solution[b]\n        x, y = new_solution[c], new_solution[d]\n\n        # Calculate the change in each objective\n        delta_obj = np.zeros(3)\n        delta_obj[0] = (distance_matrix_1[u, x] + distance_matrix_1[v, y] - distance_matrix_1[u, v] - distance_matrix_1[x, y])\n        delta_obj[1] = (distance_matrix_2[u, x] + distance_matrix_2[v, y] - distance_matrix_2[u, v] - distance_matrix_2[x, y])\n        delta_obj[2] = (distance_matrix_3[u, x] + distance_matrix_3[v, y] - distance_matrix_3[u, v] - distance_matrix_3[x, y])\n\n        # Apply reversal if it improves the weighted sum of objectives\n        if sum(delta_obj * obj_weights) < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1][i] - x[1][j] for i in range(3) for j in range(i+1, 3)))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    obj_weights = np.array([1.0, 1.5, 0.8])  # Weight for each objective\n    total_distances = np.zeros(n)\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1) % n]\n        total_distances[i] = (obj_weights[0] * distance_matrix_1[u, v] +\n                              obj_weights[1] * distance_matrix_2[u, v] +\n                              obj_weights[2] * distance_matrix_3[u, v])\n\n    # Select edges with highest total weighted distance for potential improvement\n    sorted_edges = np.argsort(-total_distances)\n    i, j = sorted_edges[0], sorted_edges[1]\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange with objective-aware selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Check if exchange improves at least one objective\n        u, v, w, x = new_solution[a], new_solution[b], new_solution[c], new_solution[d]\n        old_costs = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v] +\n                      distance_matrix_1[w, x] + distance_matrix_2[w, x] + distance_matrix_3[w, x])\n        new_costs = (distance_matrix_1[u, w] + distance_matrix_2[u, w] + distance_matrix_3[u, w] +\n                     distance_matrix_1[v, x] + distance_matrix_2[v, x] + distance_matrix_3[v, x])\n        if new_costs < old_costs:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6698758084535157,
            1.622389006614685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1][i] - x[1][j] for i in range(3) for j in range(i+1, 3)))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    obj_weights = np.array([1.0, 1.5, 0.8])  # Weight for each objective\n    total_distances = np.zeros(n)\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1) % n]\n        total_distances[i] = (obj_weights[0] * distance_matrix_1[u, v] +\n                              obj_weights[1] * distance_matrix_2[u, v] +\n                              obj_weights[2] * distance_matrix_3[u, v])\n\n    # Select edges with highest total weighted distance for potential improvement\n    sorted_edges = np.argsort(-total_distances)\n    i, j = sorted_edges[0], sorted_edges[1]\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange with objective-aware selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Check if exchange improves at least one objective\n        u, v, w, x = new_solution[a], new_solution[b], new_solution[c], new_solution[d]\n        old_costs = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v] +\n                      distance_matrix_1[w, x] + distance_matrix_2[w, x] + distance_matrix_3[w, x])\n        new_costs = (distance_matrix_1[u, w] + distance_matrix_2[u, w] + distance_matrix_3[u, w] +\n                     distance_matrix_1[v, x] + distance_matrix_2[v, x] + distance_matrix_3[v, x])\n        if new_costs < old_costs:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of its objective values, then applies a hybrid local search combining 2-opt and edge exchange with additional randomness to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a random edge exchange move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply a random insertion move for additional diversity\n    if n > 3:\n        pos = np.random.randint(0, n)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6094180505400891,
            1.1816758632659912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a random edge exchange move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply a random insertion move for additional diversity\n    if n > 3:\n        pos = np.random.randint(0, n)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of its objectives, then applies a hybrid local search combining 3-opt and node insertion, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 3-opt local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply node insertion for diversification\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[b]\n    new_solution = np.delete(new_solution, b)\n    new_solution = np.insert(new_solution, a, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5600678151891696,
            0.991240406036377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 3-opt local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply node insertion for diversification\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[b]\n    new_solution = np.delete(new_solution, b)\n    new_solution = np.insert(new_solution, a, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel multi-objective local search operator combining:\n    # 1. Random node insertion at a different position\n    # 2. Edge reversal between two random nodes\n    # 3. Objective-aware edge swapping\n\n    # Step 1: Random node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Edge reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 3: Objective-aware edge swapping\n    # Find the objective with the highest improvement potential\n    current_obj = [\n        sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    ]\n\n    # Try swapping edges that might improve the worst objective\n    worst_obj = np.argmax(current_obj)\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the two edges with the highest distance in the worst objective\n    edge_distances = [dm[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n    sorted_edges = sorted(range(n), key=lambda i: -edge_distances[i])\n    e1, e2 = sorted_edges[0], sorted_edges[1]\n\n    # Swap the edges if it improves the worst objective\n    temp_solution = new_solution.copy()\n    temp_solution[e1], temp_solution[(e1+1)%n], temp_solution[e2], temp_solution[(e2+1)%n] = (\n        temp_solution[e2], temp_solution[(e2+1)%n], temp_solution[e1], temp_solution[(e1+1)%n]\n    )\n\n    # Calculate new objective values\n    new_obj = [\n        sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    ]\n\n    # Accept the swap if it improves the worst objective\n    if new_obj[worst_obj] < current_obj[worst_obj]:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5549100992026132,
            1.1832093238830566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel multi-objective local search operator combining:\n    # 1. Random node insertion at a different position\n    # 2. Edge reversal between two random nodes\n    # 3. Objective-aware edge swapping\n\n    # Step 1: Random node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Edge reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 3: Objective-aware edge swapping\n    # Find the objective with the highest improvement potential\n    current_obj = [\n        sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    ]\n\n    # Try swapping edges that might improve the worst objective\n    worst_obj = np.argmax(current_obj)\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the two edges with the highest distance in the worst objective\n    edge_distances = [dm[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n    sorted_edges = sorted(range(n), key=lambda i: -edge_distances[i])\n    e1, e2 = sorted_edges[0], sorted_edges[1]\n\n    # Swap the edges if it improves the worst objective\n    temp_solution = new_solution.copy()\n    temp_solution[e1], temp_solution[(e1+1)%n], temp_solution[e2], temp_solution[(e2+1)%n] = (\n        temp_solution[e2], temp_solution[(e2+1)%n], temp_solution[e1], temp_solution[(e1+1)%n]\n    )\n\n    # Calculate new objective values\n    new_obj = [\n        sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    ]\n\n    # Accept the swap if it improves the worst objective\n    if new_obj[worst_obj] < current_obj[worst_obj]:\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This heuristic function selects a solution from the archive based on the worst-performing objective, applies a novel multi-objective inversion operator that reverses segments in all three objective spaces simultaneously, and combines it with a segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst-performing objective (most unbalanced)\n    objectives = [obj for _, obj in archive]\n    max_diff = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(max_diff)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Multi-objective inversion: reverse segments in all three spaces\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5738091073140908,
            1.6160171627998352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst-performing objective (most unbalanced)\n    objectives = [obj for _, obj in archive]\n    max_diff = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(max_diff)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Multi-objective inversion: reverse segments in all three spaces\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution, _ = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply node insertion\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7585537531456941,
            0.4187962532043457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution, _ = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply node insertion\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with a novel segment-based mutation to generate neighbors, ensuring feasibility through intelligent segment swapping and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted sum of objectives (weights: 0.4, 0.3, 0.3)\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [0.4*obj[0] + 0.3*obj[1] + 0.3*obj[2] for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments and perform 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt by reversing segments and reordering\n    segment1 = new_solution[i:j+1][::-1]\n    segment2 = new_solution[j+1:k+1][::-1]\n    new_solution[i:k+1] = np.concatenate([segment1, segment2])\n\n    # Segment-based mutation: swap a random segment with another solution's segment\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0].copy()\n        m = np.random.randint(1, n-2)\n        segment_len = np.random.randint(1, n-m)\n        new_solution[m:m+segment_len] = other_solution[m:m+segment_len]\n\n    # Repair duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6825666739591549,
            1.1197565197944641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted sum of objectives (weights: 0.4, 0.3, 0.3)\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [0.4*obj[0] + 0.3*obj[1] + 0.3*obj[2] for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments and perform 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt by reversing segments and reordering\n    segment1 = new_solution[i:j+1][::-1]\n    segment2 = new_solution[j+1:k+1][::-1]\n    new_solution[i:k+1] = np.concatenate([segment1, segment2])\n\n    # Segment-based mutation: swap a random segment with another solution's segment\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0].copy()\n        m = np.random.randint(1, n-2)\n        segment_len = np.random.randint(1, n-m)\n        new_solution[m:m+segment_len] = other_solution[m:m+segment_len]\n\n    # Repair duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The new algorithm selects a solution from the archive based on the worst objective value among the three objectives and applies a hybrid local search combining 2-opt with a novel segment-based perturbation to explore trade-offs across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, selected_obj = max(archive, key=lambda x: max(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment-based perturbation: randomly select a segment and insert it in a different position\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)\n    segment_end = (segment_start + segment_length) % n\n    segment = new_solution[segment_start:segment_end]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5058060164806737,
            0.9793698191642761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, selected_obj = max(archive, key=lambda x: max(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment-based perturbation: randomly select a segment and insert it in a different position\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)\n    segment_end = (segment_start + segment_length) % n\n    segment = new_solution[segment_start:segment_end]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-way edge exchange\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.52698985946324,
            1.0432279467582704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-way edge exchange\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it, then insert it at a new position\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Randomly select a node and insert it at a new position to improve multi-objective balance\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = new_solution[mask]\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6363282865759082,
            1.2994109869003296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it, then insert it at a new position\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Randomly select a node and insert it at a new position to improve multi-objective balance\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = new_solution[mask]\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a multi-objective-aware local search combining 3-opt moves with objective-space-aware edge exchanges to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply objective-aware edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Calculate objective impact\n            old_costs = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n            new_costs = (\n                distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[d-1], new_solution[b]]\n            )\n            if new_costs < old_costs:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.608747854306867,
            1.3724003314971924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply objective-aware edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Calculate objective impact\n            old_costs = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n            new_costs = (\n                distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[d-1], new_solution[b]]\n            )\n            if new_costs < old_costs:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a novel segment-based mutation that preserves critical segments while introducing diversity through random segment swaps, and ensures feasibility by repairing any duplicate nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on weighted sum of objectives\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based mutation: randomly select a segment and swap it with another random segment\n    seg_start = np.random.randint(0, n-2)\n    seg_end = np.random.randint(seg_start+1, n)\n    swap_start = np.random.randint(0, n-seg_end+seg_start)\n    swap_end = swap_start + (seg_end - seg_start)\n\n    # Swap segments\n    temp = new_solution[seg_start:seg_end].copy()\n    new_solution[seg_start:seg_end] = new_solution[swap_start:swap_end]\n    new_solution[swap_start:swap_end] = temp\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7134375717068806,
            1.5986142039299012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on weighted sum of objectives\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based mutation: randomly select a segment and swap it with another random segment\n    seg_start = np.random.randint(0, n-2)\n    seg_end = np.random.randint(seg_start+1, n)\n    swap_start = np.random.randint(0, n-seg_end+seg_start)\n    swap_end = swap_start + (seg_end - seg_start)\n\n    # Swap segments\n    temp = new_solution[seg_start:seg_end].copy()\n    new_solution[seg_start:seg_end] = new_solution[swap_start:swap_end]\n    new_solution[swap_start:swap_end] = temp\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Multi-objective aware segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on the worst objective\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    worst_solution = archive[worst_obj_idx][0]\n\n    # Find the segment where the worst solution differs from the selected solution\n    diff_indices = np.where(base_solution != worst_solution)[0]\n    if len(diff_indices) > 0:\n        start = diff_indices[0]\n        end = diff_indices[-1]\n        # Invert the segment to improve the worst objective\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply a multi-objective edge swap\n    for _ in range(2):  # Perform two edge swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Check if swap improves any objective\n        current_cost = (distance_matrix_1[base_solution[a-1], base_solution[a]] +\n                        distance_matrix_1[base_solution[b], base_solution[(b+1)%n]] +\n                        distance_matrix_2[base_solution[a-1], base_solution[a]] +\n                        distance_matrix_2[base_solution[b], base_solution[(b+1)%n]] +\n                        distance_matrix_3[base_solution[a-1], base_solution[a]] +\n                        distance_matrix_3[base_solution[b], base_solution[(b+1)%n]])\n        new_cost = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                    distance_matrix_1[base_solution[a], base_solution[(b+1)%n]] +\n                    distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                    distance_matrix_2[base_solution[a], base_solution[(b+1)%n]] +\n                    distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                    distance_matrix_3[base_solution[a], base_solution[(b+1)%n]])\n        if new_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7349278569227778,
            3.0839378476142882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Multi-objective aware segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on the worst objective\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    worst_solution = archive[worst_obj_idx][0]\n\n    # Find the segment where the worst solution differs from the selected solution\n    diff_indices = np.where(base_solution != worst_solution)[0]\n    if len(diff_indices) > 0:\n        start = diff_indices[0]\n        end = diff_indices[-1]\n        # Invert the segment to improve the worst objective\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply a multi-objective edge swap\n    for _ in range(2):  # Perform two edge swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Check if swap improves any objective\n        current_cost = (distance_matrix_1[base_solution[a-1], base_solution[a]] +\n                        distance_matrix_1[base_solution[b], base_solution[(b+1)%n]] +\n                        distance_matrix_2[base_solution[a-1], base_solution[a]] +\n                        distance_matrix_2[base_solution[b], base_solution[(b+1)%n]] +\n                        distance_matrix_3[base_solution[a-1], base_solution[a]] +\n                        distance_matrix_3[base_solution[b], base_solution[(b+1)%n]])\n        new_cost = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                    distance_matrix_1[base_solution[a], base_solution[(b+1)%n]] +\n                    distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                    distance_matrix_2[base_solution[a], base_solution[(b+1)%n]] +\n                    distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                    distance_matrix_3[base_solution[a], base_solution[(b+1)%n]])\n        if new_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel local search operator combining 2-opt and multi-objective edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform a multi-objective edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure the swap maintains feasibility\n    if a != c and b != d:\n        # Evaluate the swap in all three objectives\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        cost_after = (distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[c]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[d]])\n\n        # Only perform the swap if it improves at least one objective\n        if cost_after < cost_before:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6149110746813329,
            1.01693252325058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel local search operator combining 2-opt and multi-objective edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform a multi-objective edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure the swap maintains feasibility\n    if a != c and b != d:\n        # Evaluate the swap in all three objectives\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        cost_after = (distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[c]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[d]])\n\n        # Only perform the swap if it improves at least one objective\n        if cost_after < cost_before:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This heuristic function selects a solution from the archive based on the best trade-off between objectives, then applies a novel multi-objective segment inversion and insertion operator that intelligently combines elements from multiple segments of different solutions to create a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto dominance)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if all(o <= oo for o, oo in zip(obj, other_obj)) and any(o < oo for o, oo in zip(obj, other_obj)):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol\n            break\n    if selected_solution is None:\n        selected_solution = archive[np.random.choice(len(archive))][0]\n    base_solution = selected_solution.copy()\n\n    # Multi-objective segment inversion and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments\n    points = np.random.choice(n, 3, replace=False)\n    points.sort()\n    i, j, k = points\n\n    # Invert the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insert the third segment at a random position\n    segment = new_solution[j+1:k+1]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:-len(segment)]])\n\n    # Repair duplicates by replacing them with nodes from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n:\n            missing_nodes = np.setdiff1d(np.arange(n), unique)\n            for idx in range(n):\n                if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                    new_solution[idx] = missing_nodes[0]\n                    missing_nodes = np.delete(missing_nodes, 0)\n                    if len(missing_nodes) == 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6492666120229308,
            1.4727512359619142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto dominance)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if all(o <= oo for o, oo in zip(obj, other_obj)) and any(o < oo for o, oo in zip(obj, other_obj)):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol\n            break\n    if selected_solution is None:\n        selected_solution = archive[np.random.choice(len(archive))][0]\n    base_solution = selected_solution.copy()\n\n    # Multi-objective segment inversion and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments\n    points = np.random.choice(n, 3, replace=False)\n    points.sort()\n    i, j, k = points\n\n    # Invert the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insert the third segment at a random position\n    segment = new_solution[j+1:k+1]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:-len(segment)]])\n\n    # Repair duplicates by replacing them with nodes from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n:\n            missing_nodes = np.setdiff1d(np.arange(n), unique)\n            for idx in range(n):\n                if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                    new_solution[idx] = missing_nodes[0]\n                    missing_nodes = np.delete(missing_nodes, 0)\n                    if len(missing_nodes) == 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The new algorithm identifies promising solutions in the archive by selecting those with high potential for improvement across all three objectives, then applies a novel \"multi-objective segment inversion\" operator that reverses segments of the tour while considering the combined impact on all three objectives to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Generate multiple candidate segments and select the one with the best combined improvement\n    best_segment = None\n    best_improvement = 0\n\n    for _ in range(10):  # Try 10 random segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n\n        # Calculate the change in all three objectives\n        obj1_change = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                       distance_matrix_1[reversed_segment[-1], new_solution[j]] -\n                       distance_matrix_1[new_solution[i-1], segment[0]] -\n                       distance_matrix_1[segment[-1], new_solution[j]])\n\n        obj2_change = (distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                       distance_matrix_2[reversed_segment[-1], new_solution[j]] -\n                       distance_matrix_2[new_solution[i-1], segment[0]] -\n                       distance_matrix_2[segment[-1], new_solution[j]])\n\n        obj3_change = (distance_matrix_3[new_solution[i-1], reversed_segment[0]] +\n                       distance_matrix_3[reversed_segment[-1], new_solution[j]] -\n                       distance_matrix_3[new_solution[i-1], segment[0]] -\n                       distance_matrix_3[segment[-1], new_solution[j]])\n\n        total_improvement = obj1_change + obj2_change + obj3_change\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_segment = (i, j)\n\n    if best_segment is not None:\n        i, j = best_segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6422205090434496,
            1.6750804305076599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Generate multiple candidate segments and select the one with the best combined improvement\n    best_segment = None\n    best_improvement = 0\n\n    for _ in range(10):  # Try 10 random segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n\n        # Calculate the change in all three objectives\n        obj1_change = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                       distance_matrix_1[reversed_segment[-1], new_solution[j]] -\n                       distance_matrix_1[new_solution[i-1], segment[0]] -\n                       distance_matrix_1[segment[-1], new_solution[j]])\n\n        obj2_change = (distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                       distance_matrix_2[reversed_segment[-1], new_solution[j]] -\n                       distance_matrix_2[new_solution[i-1], segment[0]] -\n                       distance_matrix_2[segment[-1], new_solution[j]])\n\n        obj3_change = (distance_matrix_3[new_solution[i-1], reversed_segment[0]] +\n                       distance_matrix_3[reversed_segment[-1], new_solution[j]] -\n                       distance_matrix_3[new_solution[i-1], segment[0]] -\n                       distance_matrix_3[segment[-1], new_solution[j]])\n\n        total_improvement = obj1_change + obj2_change + obj3_change\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_segment = (i, j)\n\n    if best_segment is not None:\n        i, j = best_segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This heuristic selects a non-dominated solution from the archive by prioritizing those with the best trade-off between objectives, then applies a novel multi-objective segment inversion operator that intelligently combines 3-opt with a segment-based crossover to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives using hypervolume\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    hypervolumes = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    if n >= 3:\n        # Select three random positions for 3-opt\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Try all possible segment inversions\n        segments = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:]]),\n            np.concatenate([new_solution[:b], new_solution[b:c][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[a:c][::-1], new_solution[c:]])\n        ]\n\n        # Evaluate all segments across all objectives\n        costs = []\n        for seg in segments:\n            cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(n-1)) + distance_matrix_1[seg[-1], seg[0]]\n            cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(n-1)) + distance_matrix_2[seg[-1], seg[0]]\n            cost3 = sum(distance_matrix_3[seg[i], seg[i+1]] for i in range(n-1)) + distance_matrix_3[seg[-1], seg[0]]\n            costs.append((cost1, cost2, cost3))\n\n        # Select the best segment based on hypervolume\n        costs = np.array(costs)\n        min_costs = np.min(costs, axis=0)\n        max_costs = np.max(costs, axis=0)\n        normalized_costs = (costs - min_costs) / (max_costs - min_costs + 1e-8)\n        hypervolumes = np.prod(normalized_costs, axis=1)\n        best_idx = np.argmax(hypervolumes)\n        new_solution = segments[best_idx]\n\n    # Apply segment-based crossover with another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6770311169613261,
            2.409431004524231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives using hypervolume\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    hypervolumes = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    if n >= 3:\n        # Select three random positions for 3-opt\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Try all possible segment inversions\n        segments = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:]]),\n            np.concatenate([new_solution[:b], new_solution[b:c][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[a:c][::-1], new_solution[c:]])\n        ]\n\n        # Evaluate all segments across all objectives\n        costs = []\n        for seg in segments:\n            cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(n-1)) + distance_matrix_1[seg[-1], seg[0]]\n            cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(n-1)) + distance_matrix_2[seg[-1], seg[0]]\n            cost3 = sum(distance_matrix_3[seg[i], seg[i+1]] for i in range(n-1)) + distance_matrix_3[seg[-1], seg[0]]\n            costs.append((cost1, cost2, cost3))\n\n        # Select the best segment based on hypervolume\n        costs = np.array(costs)\n        min_costs = np.min(costs, axis=0)\n        max_costs = np.max(costs, axis=0)\n        normalized_costs = (costs - min_costs) / (max_costs - min_costs + 1e-8)\n        hypervolumes = np.prod(normalized_costs, axis=1)\n        best_idx = np.argmax(hypervolumes)\n        new_solution = segments[best_idx]\n\n    # Apply segment-based crossover with another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This heuristic function selects a diverse solution from the archive based on objective space dominance, then applies a novel multi-objective segment inversion operator that simultaneously optimizes all three objectives by flipping segments in each space while ensuring tour feasibility through a dominance-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (not just the best average)\n    objectives = [obj for _, obj in archive]\n    # Find solution with the most balanced objectives (minimize max difference)\n    max_diff = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmin(max_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    # Identify critical segments in each objective space\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Calculate segment costs\n        segment_costs = []\n        for i in range(n):\n            j = (i + 1) % n\n            segment_costs.append(dist_matrix[new_solution[i], new_solution[j]])\n\n        # Find segments with high cost in this objective\n        high_cost_indices = np.argsort(segment_costs)[-max(2, n//10):]\n\n        # Invert these segments\n        for idx in high_cost_indices:\n            i, j = idx, (idx + 1) % n\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i:] = new_solution[i:][::-1]\n                new_solution[:j] = new_solution[:j][::-1]\n\n    # Ensure feasibility through dominance-aware repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Replace duplicates with nodes that improve at least one objective\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                best_node = None\n                best_improvement = float('-inf')\n                for node in missing_nodes:\n                    # Calculate improvement across all objectives\n                    improvement = 0\n                    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n                        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                        next_node = new_solution[(i+1)%n]\n                        old_cost = dist_matrix[prev_node, new_solution[i]] + dist_matrix[new_solution[i], next_node]\n                        new_cost = dist_matrix[prev_node, node] + dist_matrix[node, next_node]\n                        improvement += (old_cost - new_cost)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                if best_node is not None:\n                    new_solution[i] = best_node\n                    missing_nodes = np.delete(missing_nodes, np.where(missing_nodes == best_node)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7740419384686394,
            2.2738145351409913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (not just the best average)\n    objectives = [obj for _, obj in archive]\n    # Find solution with the most balanced objectives (minimize max difference)\n    max_diff = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmin(max_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    # Identify critical segments in each objective space\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Calculate segment costs\n        segment_costs = []\n        for i in range(n):\n            j = (i + 1) % n\n            segment_costs.append(dist_matrix[new_solution[i], new_solution[j]])\n\n        # Find segments with high cost in this objective\n        high_cost_indices = np.argsort(segment_costs)[-max(2, n//10):]\n\n        # Invert these segments\n        for idx in high_cost_indices:\n            i, j = idx, (idx + 1) % n\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i:] = new_solution[i:][::-1]\n                new_solution[:j] = new_solution[:j][::-1]\n\n    # Ensure feasibility through dominance-aware repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Replace duplicates with nodes that improve at least one objective\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                best_node = None\n                best_improvement = float('-inf')\n                for node in missing_nodes:\n                    # Calculate improvement across all objectives\n                    improvement = 0\n                    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n                        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                        next_node = new_solution[(i+1)%n]\n                        old_cost = dist_matrix[prev_node, new_solution[i]] + dist_matrix[new_solution[i], next_node]\n                        new_cost = dist_matrix[prev_node, node] + dist_matrix[node, next_node]\n                        improvement += (old_cost - new_cost)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                if best_node is not None:\n                    new_solution[i] = best_node\n                    missing_nodes = np.delete(missing_nodes, np.where(missing_nodes == best_node)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted based on the relative importance of each objective, then applies a hybrid local search combining 3-opt with a segment-based mutation to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on objective variance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.std(objectives, axis=0)\n    weights = weights / np.sum(weights)  # Normalize weights\n\n    # Select solution with best weighted sum\n    weighted_sums = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    # Apply segment-based mutation: replace a random segment with another random solution's segment\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(k, n)\n        new_solution[k:l+1] = other_solution[k:l+1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.726701763965421,
            1.2705703973770142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on objective variance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.std(objectives, axis=0)\n    weights = weights / np.sum(weights)  # Normalize weights\n\n    # Select solution with best weighted sum\n    weighted_sums = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    # Apply segment-based mutation: replace a random segment with another random solution's segment\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(k, n)\n        new_solution[k:l+1] = other_solution[k:l+1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 2-opt and edge exchange with probabilistic selection\n    if np.random.rand() < 0.5:\n        # 2-opt move: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: swap two edges\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6678129295077347,
            1.0257421255111694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 2-opt and edge exchange with probabilistic selection\n    if np.random.rand() < 0.5:\n        # 2-opt move: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: swap two edges\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, applies a segment reversal with a dynamic segment length, and combines it with a random segment from another solution to create a neighbor while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (to encourage improvement)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic segment length for reversal\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Combine with a random segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Repair duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.671812364804263,
            1.6346561551094054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (to encourage improvement)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic segment length for reversal\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Combine with a random segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Repair duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and insert it in a different position\n    k = np.random.randint(n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.430815189158763,
            1.1039188027381897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and insert it in a different position\n    k = np.random.randint(n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.4939268584265891,
            0.8930303812026977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance rank and applies a multi-objective segment inversion and relocation operator to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank (simplified: select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective segment inversion and relocation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly relocate a segment to another position\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6791815253276943,
            0.3644261837005615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank (simplified: select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective segment inversion and relocation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly relocate a segment to another position\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a hybrid local search combining 2-opt and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 2-opt and edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6395733958078527,
            0.9649486780166626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 2-opt and edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective-aware local search combining 3-opt and node insertion\n    # First, perform a 3-opt move by selecting three random segments and reordering them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reorder segments to create a new permutation\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Then, perform a node insertion move to further optimize the tour\n    # Select a random node and insert it in a new random position\n    node = np.random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6048095325308226,
            1.0972971200942994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective-aware local search combining 3-opt and node insertion\n    # First, perform a 3-opt move by selecting three random segments and reordering them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reorder segments to create a new permutation\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Then, perform a node insertion move to further optimize the tour\n    # Select a random node and insert it in a new random position\n    node = np.random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This heuristic function selects a diverse solution from the archive based on multi-objective dominance analysis, then applies a novel segment-based mutation that combines node reinsertion with objective-aware edge swaps to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on multi-objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=np.ones(len(archive))/len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_objectives = objectives[selected_idx]\n\n    # Identify critical segments based on objective contributions\n    n = len(base_solution)\n    segment_length = max(3, n // 5)\n    segment_scores = np.zeros(n - segment_length + 1)\n\n    for i in range(n - segment_length + 1):\n        segment = base_solution[i:i+segment_length]\n        segment_costs = [\n            sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1)) +\n            distance_matrix_1[segment[-1], segment[0]],\n            sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1)) +\n            distance_matrix_2[segment[-1], segment[0]],\n            sum(distance_matrix_3[segment[j], segment[j+1]] for j in range(segment_length-1)) +\n            distance_matrix_3[segment[-1], segment[0]]\n        ]\n        segment_scores[i] = sum(segment_costs) / 3\n\n    # Select the worst segment for mutation\n    worst_segment_idx = np.argmax(segment_scores)\n    segment_start = worst_segment_idx\n    segment_end = worst_segment_idx + segment_length\n\n    # Apply segment-based mutation\n    new_solution = base_solution.copy()\n    segment = new_solution[segment_start:segment_end]\n\n    # Node reinsertion within the segment\n    if len(segment) > 2:\n        k = np.random.randint(1, len(segment)-1)\n        node = segment[k]\n        segment = np.concatenate([segment[:k], segment[k+1:]])\n        new_pos = np.random.randint(0, len(segment)+1)\n        segment = np.insert(segment, new_pos, node)\n        new_solution[segment_start:segment_end] = segment\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and i != (j + 1) % n and j != (i + 1) % n:\n            current_costs = [\n                distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_1[base_solution[j], base_solution[(j+1)%n]],\n                distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_2[base_solution[j], base_solution[(j+1)%n]],\n                distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n            ]\n            new_costs = [\n                distance_matrix_1[base_solution[i], base_solution[j]] +\n                distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]],\n                distance_matrix_2[base_solution[i], base_solution[j]] +\n                distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]],\n                distance_matrix_3[base_solution[i], base_solution[j]] +\n                distance_matrix_3[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n            ]\n            if sum(new_costs) < sum(current_costs):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution validity\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6876870239245733,
            2.0303666472434996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on multi-objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=np.ones(len(archive))/len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_objectives = objectives[selected_idx]\n\n    # Identify critical segments based on objective contributions\n    n = len(base_solution)\n    segment_length = max(3, n // 5)\n    segment_scores = np.zeros(n - segment_length + 1)\n\n    for i in range(n - segment_length + 1):\n        segment = base_solution[i:i+segment_length]\n        segment_costs = [\n            sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1)) +\n            distance_matrix_1[segment[-1], segment[0]],\n            sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1)) +\n            distance_matrix_2[segment[-1], segment[0]],\n            sum(distance_matrix_3[segment[j], segment[j+1]] for j in range(segment_length-1)) +\n            distance_matrix_3[segment[-1], segment[0]]\n        ]\n        segment_scores[i] = sum(segment_costs) / 3\n\n    # Select the worst segment for mutation\n    worst_segment_idx = np.argmax(segment_scores)\n    segment_start = worst_segment_idx\n    segment_end = worst_segment_idx + segment_length\n\n    # Apply segment-based mutation\n    new_solution = base_solution.copy()\n    segment = new_solution[segment_start:segment_end]\n\n    # Node reinsertion within the segment\n    if len(segment) > 2:\n        k = np.random.randint(1, len(segment)-1)\n        node = segment[k]\n        segment = np.concatenate([segment[:k], segment[k+1:]])\n        new_pos = np.random.randint(0, len(segment)+1)\n        segment = np.insert(segment, new_pos, node)\n        new_solution[segment_start:segment_end] = segment\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and i != (j + 1) % n and j != (i + 1) % n:\n            current_costs = [\n                distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_1[base_solution[j], base_solution[(j+1)%n]],\n                distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_2[base_solution[j], base_solution[(j+1)%n]],\n                distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n            ]\n            new_costs = [\n                distance_matrix_1[base_solution[i], base_solution[j]] +\n                distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]],\n                distance_matrix_2[base_solution[i], base_solution[j]] +\n                distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]],\n                distance_matrix_3[base_solution[i], base_solution[j]] +\n                distance_matrix_3[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n            ]\n            if sum(new_costs) < sum(current_costs):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution validity\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects the solution with the highest total objective value from the archive, then applies a hybrid local search combining 2-opt and edge exchange, followed by a novel segment inversion and node swap operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt move on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply a novel segment inversion and node swap operation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n-1)\n        new_solution[k:l] = new_solution[k:l][::-1]\n        m, n = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.6410409322256292,
            1.1031241774559022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt move on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply a novel segment inversion and node swap operation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n-1)\n        new_solution[k:l] = new_solution[k:l][::-1]\n        m, n = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum((x[1][i] / np.max(distance_matrix_1) for i in range(3))))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt variant)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an objective-aware edge insertion by selecting the best insertion point for a randomly chosen node\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos > 0:\n            # Calculate improvement based on all three objectives\n            original_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_3[new_solution[pos-1], new_solution[pos]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], node_to_insert] +\n                        distance_matrix_2[new_solution[pos-1], node_to_insert] +\n                        distance_matrix_3[new_solution[pos-1], node_to_insert])\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates (keeping only the first occurrence)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.6698719449837066,
            4.439823412895203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum((x[1][i] / np.max(distance_matrix_1) for i in range(3))))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt variant)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an objective-aware edge insertion by selecting the best insertion point for a randomly chosen node\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos > 0:\n            # Calculate improvement based on all three objectives\n            original_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_3[new_solution[pos-1], new_solution[pos]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], node_to_insert] +\n                        distance_matrix_2[new_solution[pos-1], node_to_insert] +\n                        distance_matrix_3[new_solution[pos-1], node_to_insert])\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates (keeping only the first occurrence)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A new algorithm that selects solutions based on a weighted sum of objective values with random weights, then applies a hybrid local search combining 3-opt and edge exchange to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(3)\n    selected_solution, _ = max(archive, key=lambda x: np.dot(weights, x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move: randomly select three edges and reverse the middle segment\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply edge exchange: randomly select two edges and exchange nodes\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.681079935791372,
            1.131554663181305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(3)\n    selected_solution, _ = max(archive, key=lambda x: np.dot(weights, x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move: randomly select three edges and reverse the middle segment\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply edge exchange: randomly select two edges and exchange nodes\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, then applies a novel multi-objective segment inversion and insertion operator that combines 3-opt with a segment-based crossover, ensuring feasibility through a repair mechanism that maintains tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (most potential for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt-like segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]  # Reverse the segment\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse another segment\n\n    # Apply segment-based crossover with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        l = np.random.randint(1, n-1)\n        new_solution[l:] = other_solution[l:]\n\n    # Repair to ensure no duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7233469506247074,
            1.880423939228058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (most potential for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt-like segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]  # Reverse the segment\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse another segment\n\n    # Apply segment-based crossover with another random solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        l = np.random.randint(1, n-1)\n        new_solution[l:] = other_solution[l:]\n\n    # Repair to ensure no duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{A novel multi-objective local search approach that prioritizes the least improved objective in selected solutions, applying a targeted segment inversion and edge replacement strategy to balance improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: max(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify the objective with the highest improvement (least improved)\n    worst_obj_idx = np.argmax(objectives)\n\n    # Apply segment inversion focused on the worst objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate segment cost in the worst objective before inversion\n    original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] if worst_obj_idx == 0 else\n                       distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] if worst_obj_idx == 1 else\n                       distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n    # Apply inversion and check if it improves the worst objective\n    inverted_segment = segment[::-1]\n    inverted_cost = sum(distance_matrix_1[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] if worst_obj_idx == 0 else\n                       distance_matrix_2[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] if worst_obj_idx == 1 else\n                       distance_matrix_3[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment)))\n\n    if inverted_cost < original_cost:\n        new_solution[i:j] = inverted_segment\n\n    # Apply edge replacement focused on the worst objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        original_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[b]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[a], new_solution[b]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[a], new_solution[b]]),\n            (distance_matrix_1[new_solution[c], new_solution[d]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[c], new_solution[d]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[c], new_solution[d]])\n        ]\n\n        new_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[c]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[a], new_solution[c]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[a], new_solution[c]]),\n            (distance_matrix_1[new_solution[b], new_solution[d]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[b], new_solution[d]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[b], new_solution[d]])\n        ]\n\n        if sum(new_edges) < sum(original_edges):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7094516284464519,
            2.2672807574272156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: max(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify the objective with the highest improvement (least improved)\n    worst_obj_idx = np.argmax(objectives)\n\n    # Apply segment inversion focused on the worst objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate segment cost in the worst objective before inversion\n    original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] if worst_obj_idx == 0 else\n                       distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] if worst_obj_idx == 1 else\n                       distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n    # Apply inversion and check if it improves the worst objective\n    inverted_segment = segment[::-1]\n    inverted_cost = sum(distance_matrix_1[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] if worst_obj_idx == 0 else\n                       distance_matrix_2[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] if worst_obj_idx == 1 else\n                       distance_matrix_3[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment)))\n\n    if inverted_cost < original_cost:\n        new_solution[i:j] = inverted_segment\n\n    # Apply edge replacement focused on the worst objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        original_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[b]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[a], new_solution[b]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[a], new_solution[b]]),\n            (distance_matrix_1[new_solution[c], new_solution[d]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[c], new_solution[d]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[c], new_solution[d]])\n        ]\n\n        new_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[c]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[a], new_solution[c]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[a], new_solution[c]]),\n            (distance_matrix_1[new_solution[b], new_solution[d]] if worst_obj_idx == 0 else\n             distance_matrix_2[new_solution[b], new_solution[d]] if worst_obj_idx == 1 else\n             distance_matrix_3[new_solution[b], new_solution[d]])\n        ]\n\n        if sum(new_edges) < sum(original_edges):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvements, then applies a novel three-way edge exchange operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def weighted_score(obj):\n        return 0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2]\n\n    selected_solution, _ = max(archive, key=lambda x: weighted_score(x[1]))\n\n    # Apply three-way edge exchange\n    n = len(selected_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    new_solution = selected_solution.copy()\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6324233310722431,
            1.0832695603370666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def weighted_score(obj):\n        return 0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2]\n\n    selected_solution, _ = max(archive, key=lambda x: weighted_score(x[1]))\n\n    # Apply three-way edge exchange\n    n = len(selected_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    new_solution = selected_solution.copy()\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A new algorithm that selects solutions with high potential for improvement by combining crowding distance and objective diversity, then applies a hybrid local search combining 3-opt and multi-objective edge exchange to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_dist = np.zeros(len(archive))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                    crowding_dist[sorted_idx[i]] += 0\n                else:\n                    crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_dist)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 3-opt with multi-objective edge exchange\n    if n >= 3:\n        # Randomly select three positions and perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Multi-objective edge exchange\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Calculate edge costs in all three objectives\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n            cost_after = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                          distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]])\n\n            # Only accept if improvement in at least one objective\n            if cost_after < cost_before:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7008467277708845,
            2.9203806161880492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_dist = np.zeros(len(archive))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                    crowding_dist[sorted_idx[i]] += 0\n                else:\n                    crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_dist)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 3-opt with multi-objective edge exchange\n    if n >= 3:\n        # Randomly select three positions and perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Multi-objective edge exchange\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Calculate edge costs in all three objectives\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n            cost_after = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                          distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]])\n\n            # Only accept if improvement in at least one objective\n            if cost_after < cost_before:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This heuristic function selects a solution from the archive based on its diversity in objective space, then applies a novel multi-objective segment inversion operator that considers the trade-offs between objectives to generate a neighbor solution, ensuring feasibility through careful segment selection and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on objective trade-offs\n    segment_length = max(3, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert the segment considering all three objectives\n    segment = new_solution[start:end]\n    inverted = segment[::-1]\n\n    # Evaluate the inversion's impact on all objectives\n    original_costs = [\n        sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n        sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n        sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    ]\n\n    inverted_costs = [\n        sum(distance_matrix_1[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted))),\n        sum(distance_matrix_2[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted))),\n        sum(distance_matrix_3[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted)))\n    ]\n\n    # Accept the inversion if it improves at least one objective\n    if any(inverted_costs[i] <= original_costs[i] for i in range(3)):\n        new_solution[start:end] = inverted\n\n    # Repair if duplicates exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6864481040602554,
            1.2588224172592164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on objective trade-offs\n    segment_length = max(3, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert the segment considering all three objectives\n    segment = new_solution[start:end]\n    inverted = segment[::-1]\n\n    # Evaluate the inversion's impact on all objectives\n    original_costs = [\n        sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n        sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n        sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    ]\n\n    inverted_costs = [\n        sum(distance_matrix_1[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted))),\n        sum(distance_matrix_2[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted))),\n        sum(distance_matrix_3[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted)))\n    ]\n\n    # Accept the inversion if it improves at least one objective\n    if any(inverted_costs[i] <= original_costs[i] for i in range(3)):\n        new_solution[start:end] = inverted\n\n    # Repair if duplicates exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm combines a segment reversal with a multi-objective edge insertion, prioritizing edges that improve the most underperforming objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Reverse a random segment to disrupt the tour\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Identify the worst-performing objective\n    worst_obj = np.argmax(objectives)\n\n    # Select edges to insert based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most promising edge to insert (shortest in worst objective space)\n    min_dist = float('inf')\n    best_insert = None\n\n    for a in range(n):\n        for b in range(a + 1, n):\n            node_a = new_solution[a]\n            node_b = new_solution[b]\n            if dist_matrix[node_a, node_b] < min_dist:\n                min_dist = dist_matrix[node_a, node_b]\n                best_insert = (a, b)\n\n    if best_insert:\n        a, b = best_insert\n        # Insert the edge by reversing the segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7237302843008109,
            0.934573519229889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Reverse a random segment to disrupt the tour\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Identify the worst-performing objective\n    worst_obj = np.argmax(objectives)\n\n    # Select edges to insert based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most promising edge to insert (shortest in worst objective space)\n    min_dist = float('inf')\n    best_insert = None\n\n    for a in range(n):\n        for b in range(a + 1, n):\n            node_a = new_solution[a]\n            node_b = new_solution[b]\n            if dist_matrix[node_a, node_b] < min_dist:\n                min_dist = dist_matrix[node_a, node_b]\n                best_insert = (a, b)\n\n    if best_insert:\n        a, b = best_insert\n        # Insert the edge by reversing the segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion combining objective values and solution diversity, then applies a novel segment-based local search operator that combines 2-opt with a multi-objective edge exchange to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * (1 + np.random.random()))\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Check feasibility and apply if beneficial\n    if a != c and b != d:\n        # Calculate objective improvements\n        obj1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n               distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] + \\\n               distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n        obj2 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(b+1)%n]] + \\\n               distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(b+1)%n]] + \\\n               distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[d], new_solution[(b+1)%n]]\n\n        if obj2 < obj1:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6278590095151718,
            1.5877896785736083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * (1 + np.random.random()))\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Check feasibility and apply if beneficial\n    if a != c and b != d:\n        # Calculate objective improvements\n        obj1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n               distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] + \\\n               distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n        obj2 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(b+1)%n]] + \\\n               distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(b+1)%n]] + \\\n               distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[d], new_solution[(b+1)%n]]\n\n        if obj2 < obj1:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel local search operator combining 3-opt and objective-aware edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move by selecting three random segments and reversing them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Identify the worst objective in the current solution\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    worst_obj = current_costs.index(max(current_costs))\n\n    # Perform objective-aware edge insertion: select a random node and insert it in a position that improves the worst objective\n    node_to_insert = np.random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_insert]\n    best_pos = 0\n    best_improvement = 0\n\n    for i in range(len(new_solution)):\n        candidate = np.insert(new_solution, i, node_to_insert)\n        candidate_cost = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        candidate_cost += sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        candidate_cost += sum(distance_matrix_3[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n\n        if worst_obj == 0:\n            improvement = current_costs[0] - sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        elif worst_obj == 1:\n            improvement = current_costs[1] - sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        else:\n            improvement = current_costs[2] - sum(distance_matrix_3[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.5341148086650622,
            4.3450546026229855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel local search operator combining 3-opt and objective-aware edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move by selecting three random segments and reversing them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Identify the worst objective in the current solution\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    worst_obj = current_costs.index(max(current_costs))\n\n    # Perform objective-aware edge insertion: select a random node and insert it in a position that improves the worst objective\n    node_to_insert = np.random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_insert]\n    best_pos = 0\n    best_improvement = 0\n\n    for i in range(len(new_solution)):\n        candidate = np.insert(new_solution, i, node_to_insert)\n        candidate_cost = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        candidate_cost += sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        candidate_cost += sum(distance_matrix_3[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n\n        if worst_obj == 0:\n            improvement = current_costs[0] - sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        elif worst_obj == 1:\n            improvement = current_costs[1] - sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        else:\n            improvement = current_costs[2] - sum(distance_matrix_3[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(sol, (obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max(), obj[2]/distance_matrix_3.max())) for sol, obj in archive]\n    selected_solution, _ = min(normalized_objectives, key=lambda x: sum(x[1]))\n\n    # Apply a novel hybrid local search operator combining 3-opt and objective-aware edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move by selecting three random segments and reversing them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Perform objective-aware edge swaps: identify the worst edge in each objective space and swap it with a better one\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        worst_edge = None\n        max_dist = -1\n        for idx in range(n):\n            u, v = new_solution[idx], new_solution[(idx + 1) % n]\n            dist = dm[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (idx, (idx + 1) % n)\n\n        if worst_edge:\n            a, b = worst_edge\n            # Find the best possible replacement edge\n            best_replacement = None\n            min_dist = float('inf')\n            for c in range(n):\n                if c != a and c != b:\n                    for d in range(n):\n                        if d != a and d != b and d != c:\n                            # Check if swapping edges (a,b) and (c,d) improves the worst edge\n                            new_dist = dm[new_solution[a], new_solution[d]] + dm[new_solution[c], new_solution[b]]\n                            if new_dist < min_dist:\n                                min_dist = new_dist\n                                best_replacement = (c, d)\n\n            if best_replacement:\n                c, d = best_replacement\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6228567262057192,
            3.8957934856414793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(sol, (obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max(), obj[2]/distance_matrix_3.max())) for sol, obj in archive]\n    selected_solution, _ = min(normalized_objectives, key=lambda x: sum(x[1]))\n\n    # Apply a novel hybrid local search operator combining 3-opt and objective-aware edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move by selecting three random segments and reversing them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Perform objective-aware edge swaps: identify the worst edge in each objective space and swap it with a better one\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        worst_edge = None\n        max_dist = -1\n        for idx in range(n):\n            u, v = new_solution[idx], new_solution[(idx + 1) % n]\n            dist = dm[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (idx, (idx + 1) % n)\n\n        if worst_edge:\n            a, b = worst_edge\n            # Find the best possible replacement edge\n            best_replacement = None\n            min_dist = float('inf')\n            for c in range(n):\n                if c != a and c != b:\n                    for d in range(n):\n                        if d != a and d != b and d != c:\n                            # Check if swapping edges (a,b) and (c,d) improves the worst edge\n                            new_dist = dm[new_solution[a], new_solution[d]] + dm[new_solution[c], new_solution[b]]\n                            if new_dist < min_dist:\n                                min_dist = new_dist\n                                best_replacement = (c, d)\n\n            if best_replacement:\n                c, d = best_replacement\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This new heuristic selects a solution from the archive based on a combined score of objective values and tour diversity, then applies a hybrid local search combining 3-opt with a multi-objective segment inversion to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and non-dominated status\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with multi-objective segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else np.array([])\n\n    # Reconstruct the tour in a different order\n    new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    new_solution[i:] = new_order\n\n    # Apply multi-objective segment inversion\n    for _ in range(2):\n        obj_idx = np.random.randint(3)\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Identify the worst segment in the selected objective\n        total_dist = 0\n        for idx in range(n-1):\n            total_dist += dist_matrix[new_solution[idx], new_solution[idx+1]]\n        total_dist += dist_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the segment with highest distance in this objective\n        max_segment_dist = 0\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+2, min(i+10, n)):\n                segment_dist = sum(dist_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n                if segment_dist > max_segment_dist:\n                    max_segment_dist = segment_dist\n                    best_i, best_j = i, j\n\n        # Reverse the worst segment\n        new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5406193985381641,
            3.640563464164734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and non-dominated status\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with multi-objective segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else np.array([])\n\n    # Reconstruct the tour in a different order\n    new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    new_solution[i:] = new_order\n\n    # Apply multi-objective segment inversion\n    for _ in range(2):\n        obj_idx = np.random.randint(3)\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Identify the worst segment in the selected objective\n        total_dist = 0\n        for idx in range(n-1):\n            total_dist += dist_matrix[new_solution[idx], new_solution[idx+1]]\n        total_dist += dist_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the segment with highest distance in this objective\n        max_segment_dist = 0\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+2, min(i+10, n)):\n                segment_dist = sum(dist_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n                if segment_dist > max_segment_dist:\n                    max_segment_dist = segment_dist\n                    best_i, best_j = i, j\n\n        # Reverse the worst segment\n        new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment-based local search with adaptive segment lengths, and uses a novel multi-objective repair mechanism to ensure feasibility while maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on preference\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based local search with adaptive segment lengths\n    segment_length = max(2, n // 5)  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Calculate improvement potential for each missing node\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                # Select node with best multi-objective improvement\n                improvements = []\n                for node in missing_nodes:\n                    # Calculate potential improvement across all objectives\n                    obj1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n                    obj1 -= distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                    obj2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[(i+1)%n]]\n                    obj2 -= distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                    obj3 = distance_matrix_3[new_solution[i-1], node] + distance_matrix_3[node, new_solution[(i+1)%n]]\n                    obj3 -= distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                    improvements.append((obj1 + obj2 + obj3, node))\n                best_node = min(improvements)[1]\n                new_solution[i] = best_node\n                missing_nodes = np.delete(missing_nodes, np.where(missing_nodes == best_node))\n\n    return new_solution\n\n",
        "score": [
            -0.6405082784593634,
            4.034799790382385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on preference\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based local search with adaptive segment lengths\n    segment_length = max(2, n // 5)  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Calculate improvement potential for each missing node\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                # Select node with best multi-objective improvement\n                improvements = []\n                for node in missing_nodes:\n                    # Calculate potential improvement across all objectives\n                    obj1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n                    obj1 -= distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                    obj2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[(i+1)%n]]\n                    obj2 -= distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                    obj3 = distance_matrix_3[new_solution[i-1], node] + distance_matrix_3[node, new_solution[(i+1)%n]]\n                    obj3 -= distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                    improvements.append((obj1 + obj2 + obj3, node))\n                best_node = min(improvements)[1]\n                new_solution[i] = best_node\n                missing_nodes = np.delete(missing_nodes, np.where(missing_nodes == best_node))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a multi-objective-aware 2-opt move that considers edge contributions across all three objectives, followed by a probabilistic edge exchange to further improve the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Combine with objective diversity\n        diversity_scores = crowding_distances * np.max(objectives, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate the segment in all three objectives\n    obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n    # Only reverse if it improves at least one objective\n    if np.random.rand() < 0.7:  # 70% chance to consider reversing\n        reversed_segment = segment[::-1]\n        rev_obj1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1))\n        rev_obj2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1))\n        rev_obj3 = sum(distance_matrix_3[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1))\n\n        if (rev_obj1 < obj1 or rev_obj2 < obj2 or rev_obj3 < obj3):\n            new_solution[i:j] = reversed_segment\n\n    # Probabilistic edge exchange considering all objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d and a != b and c != d:\n        # Evaluate the current and potential edges\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n]),\n            (new_solution[d], new_solution[(d+1)%n])\n        ]\n\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[d]),\n            (new_solution[a], new_solution[b]),\n            (new_solution[c], new_solution[d])\n        ]\n\n        # Calculate cost differences\n        current_cost = sum(distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j] for i, j in current_edges)\n        new_cost = sum(distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j] for i, j in new_edges)\n\n        if new_cost < current_cost or np.random.rand() < 0.3:  # 30% chance to accept worse solutions\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7024781211197608,
            3.8252665519714357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Combine with objective diversity\n        diversity_scores = crowding_distances * np.max(objectives, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate the segment in all three objectives\n    obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n    # Only reverse if it improves at least one objective\n    if np.random.rand() < 0.7:  # 70% chance to consider reversing\n        reversed_segment = segment[::-1]\n        rev_obj1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1))\n        rev_obj2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1))\n        rev_obj3 = sum(distance_matrix_3[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1))\n\n        if (rev_obj1 < obj1 or rev_obj2 < obj2 or rev_obj3 < obj3):\n            new_solution[i:j] = reversed_segment\n\n    # Probabilistic edge exchange considering all objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d and a != b and c != d:\n        # Evaluate the current and potential edges\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n]),\n            (new_solution[d], new_solution[(d+1)%n])\n        ]\n\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[d]),\n            (new_solution[a], new_solution[b]),\n            (new_solution[c], new_solution[d])\n        ]\n\n        # Calculate cost differences\n        current_cost = sum(distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j] for i, j in current_edges)\n        new_cost = sum(distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j] for i, j in new_edges)\n\n        if new_cost < current_cost or np.random.rand() < 0.3:  # 30% chance to accept worse solutions\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement across all three objectives, then applies a novel multi-objective segment inversion and insertion operator to generate a neighbor solution that balances exploration of different objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best average objective value\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert and a position to insert\n    segment_start = np.random.randint(0, n-2)\n    segment_length = np.random.randint(2, n-segment_start)\n    insert_pos = np.random.randint(0, n-segment_start-segment_length)\n\n    # Extract and invert the segment\n    segment = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Remove the original segment and insert the inverted one\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_start+segment_length:],\n        segment\n    ])\n\n    # Reinsert at the new position\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7225080990467752,
            0.3164482951164246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best average objective value\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert and a position to insert\n    segment_start = np.random.randint(0, n-2)\n    segment_length = np.random.randint(2, n-segment_start)\n    insert_pos = np.random.randint(0, n-segment_start-segment_length)\n\n    # Extract and invert the segment\n    segment = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Remove the original segment and insert the inverted one\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_start+segment_length:],\n        segment\n    ])\n\n    # Reinsert at the new position\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel multi-objective quality metric, then applies a hybrid local search combining a novel segment inversion with a multi-objective edge selection strategy, ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance across objectives (weighted sum)\n    weights = np.random.dirichlet(np.ones(3))\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    segment_length = np.random.randint(2, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Evaluate segment in all objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length)),\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length)),\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(segment_length))\n    ]\n\n    # Invert if it improves at least one objective\n    if any(segment_costs[i] > sum(distance_matrix_1[segment[i], segment[i-1]] for i in range(segment_length)) for i in range(3)):\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Multi-objective edge selection\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = np.random.choice(n, 2, replace=False)\n\n        # Calculate improvement potential\n        improvement = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j-1], new_solution[j]]\n            new_cost = dm[new_solution[i-1], new_solution[a]] + dm[new_solution[b], new_solution[j]]\n            improvement += (current_cost - new_cost)\n\n        if improvement > 0:\n            new_solution[[i, j]] = new_solution[[a, b]]\n\n    # Dynamic repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                if len(missing) > 0:\n                    new_solution[i] = missing[0]\n                    missing = np.delete(missing, 0)\n\n    return new_solution\n\n",
        "score": [
            -0.7366233650407421,
            2.8351850271224976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance across objectives (weighted sum)\n    weights = np.random.dirichlet(np.ones(3))\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    segment_length = np.random.randint(2, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Evaluate segment in all objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length)),\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length)),\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(segment_length))\n    ]\n\n    # Invert if it improves at least one objective\n    if any(segment_costs[i] > sum(distance_matrix_1[segment[i], segment[i-1]] for i in range(segment_length)) for i in range(3)):\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Multi-objective edge selection\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = np.random.choice(n, 2, replace=False)\n\n        # Calculate improvement potential\n        improvement = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j-1], new_solution[j]]\n            new_cost = dm[new_solution[i-1], new_solution[a]] + dm[new_solution[b], new_solution[j]]\n            improvement += (current_cost - new_cost)\n\n        if improvement > 0:\n            new_solution[[i, j]] = new_solution[[a, b]]\n\n    # Dynamic repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                if len(missing) > 0:\n                    new_solution[i] = missing[0]\n                    missing = np.delete(missing, 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted sum of the objectives, where weights are inversely proportional to the current objective values, then applies a novel segment-based local search that combines 3-opt with a multi-objective segment swapping strategy to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights inversely proportional to objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weighted_scores = np.sum(weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves\n    options = [\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k+1], new_solution[k+1:]])\n    ]\n\n    # Evaluate each option across three objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    # Select the best option based on weighted sum\n    objectives = [evaluate(opt) for opt in options]\n    weighted_scores = np.sum(np.array(objectives) * weights[selected_idx], axis=1)\n    best_idx = np.argmin(weighted_scores)\n    new_solution = options[best_idx]\n\n    # Ensure validity\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5078692621005555,
            2.1074296593666078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights inversely proportional to objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weighted_scores = np.sum(weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves\n    options = [\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k+1], new_solution[k+1:]])\n    ]\n\n    # Evaluate each option across three objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    # Select the best option based on weighted sum\n    objectives = [evaluate(opt) for opt in options]\n    weighted_scores = np.sum(np.array(objectives) * weights[selected_idx], axis=1)\n    best_idx = np.argmin(weighted_scores)\n    new_solution = options[best_idx]\n\n    # Ensure validity\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This heuristic function selects a solution from the archive based on the most balanced trade-off between the three objectives, then applies a novel multi-objective segment inversion and insertion operator that dynamically adapts the inversion length and insertion point based on the relative improvement potential in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (minimize range between objectives)\n    objectives = [obj for _, obj in archive]\n    ranges = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmin(ranges)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate relative improvement potential for each objective\n    current_obj = objectives[selected_idx]\n    obj_weights = [1/(val + 1e-6) for val in current_obj]  # Inverse objective as weight\n\n    # Dynamic segment inversion length based on objective weights\n    inv_length = max(2, min(n-1, int(sum(obj_weights) * 0.5)))\n    start = np.random.randint(0, n - inv_length)\n\n    # Invert segment with higher probability for objectives with higher weights\n    if np.random.rand() < sum(obj_weights)/3:\n        new_solution[start:start+inv_length] = new_solution[start:start+inv_length][::-1]\n\n    # Dynamic insertion point based on objective improvement potential\n    insertion_point = np.random.randint(0, n)\n    if np.random.rand() < sum(obj_weights)/3:\n        # Insert a randomly selected segment from another solution\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        seg_length = np.random.randint(2, min(5, n//2))\n        seg_start = np.random.randint(0, n - seg_length)\n        segment = other_solution[seg_start:seg_start+seg_length]\n\n        # Insert segment at insertion point\n        new_solution = np.concatenate([new_solution[:insertion_point], segment, new_solution[insertion_point:]])\n\n    # Ensure solution is valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution[:n]  # Ensure correct length\n\n",
        "score": [
            -0.6245528227662264,
            2.4419750452041624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (minimize range between objectives)\n    objectives = [obj for _, obj in archive]\n    ranges = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmin(ranges)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate relative improvement potential for each objective\n    current_obj = objectives[selected_idx]\n    obj_weights = [1/(val + 1e-6) for val in current_obj]  # Inverse objective as weight\n\n    # Dynamic segment inversion length based on objective weights\n    inv_length = max(2, min(n-1, int(sum(obj_weights) * 0.5)))\n    start = np.random.randint(0, n - inv_length)\n\n    # Invert segment with higher probability for objectives with higher weights\n    if np.random.rand() < sum(obj_weights)/3:\n        new_solution[start:start+inv_length] = new_solution[start:start+inv_length][::-1]\n\n    # Dynamic insertion point based on objective improvement potential\n    insertion_point = np.random.randint(0, n)\n    if np.random.rand() < sum(obj_weights)/3:\n        # Insert a randomly selected segment from another solution\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        seg_length = np.random.randint(2, min(5, n//2))\n        seg_start = np.random.randint(0, n - seg_length)\n        segment = other_solution[seg_start:seg_start+seg_length]\n\n        # Insert segment at insertion point\n        new_solution = np.concatenate([new_solution[:insertion_point], segment, new_solution[insertion_point:]])\n\n    # Ensure solution is valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution[:n]  # Ensure correct length\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The new algorithm will select a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted to favor objectives with higher potential for improvement, and then apply a novel \"objective-aware\" local search operator that performs a combination of 2-opt and edge exchange moves, prioritizing moves that improve at least one of the three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Dynamic weights\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware local search\n    for _ in range(2):  # Apply multiple moves\n        # 2-opt move prioritizing objective improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n        new_costs = [\n            sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]],\n            sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]],\n            sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        ]\n        if any(new_costs[i] < current_costs[i] for i in range(3)):\n            new_solution = candidate\n\n        # Edge exchange move prioritizing objective improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            candidate = new_solution.copy()\n            candidate[[a, b, c, d]] = candidate[[a, c, b, d]]\n            new_costs = [\n                sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]],\n                sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]],\n                sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            ]\n            if any(new_costs[i] < current_costs[i] for i in range(3)):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6899278817336263,
            2.0700827717781065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Dynamic weights\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware local search\n    for _ in range(2):  # Apply multiple moves\n        # 2-opt move prioritizing objective improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n        new_costs = [\n            sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]],\n            sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]],\n            sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        ]\n        if any(new_costs[i] < current_costs[i] for i in range(3)):\n            new_solution = candidate\n\n        # Edge exchange move prioritizing objective improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            candidate = new_solution.copy()\n            candidate[[a, b, c, d]] = candidate[[a, c, b, d]]\n            new_costs = [\n                sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]],\n                sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]],\n                sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            ]\n            if any(new_costs[i] < current_costs[i] for i in range(3)):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The new algorithm will select a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted based on the diversity of the archive, and apply a novel \"objective-aware segment inversion\" operator that reverses segments while considering the trade-offs between the three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    obj_std = np.std(objectives, axis=0)\n    weights = obj_std / np.sum(obj_std) if np.sum(obj_std) > 0 else np.ones(3) / 3\n\n    # Select solution with highest weighted sum of objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Compute objective trade-offs for the segment\n    original_costs = [\n        sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n        sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n        sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    ]\n\n    reversed_costs = [\n        sum(distance_matrix_1[segment[k], segment[k-1]] for k in range(len(segment)-1, 0, -1)),\n        sum(distance_matrix_2[segment[k], segment[k-1]] for k in range(len(segment)-1, 0, -1)),\n        sum(distance_matrix_3[segment[k], segment[k-1]] for k in range(len(segment)-1, 0, -1))\n    ]\n\n    # Apply inversion only if it improves at least one objective\n    if any(r < o for r, o in zip(reversed_costs, original_costs)):\n        new_solution[i:j] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7394108145079402,
            1.8013611555099487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    obj_std = np.std(objectives, axis=0)\n    weights = obj_std / np.sum(obj_std) if np.sum(obj_std) > 0 else np.ones(3) / 3\n\n    # Select solution with highest weighted sum of objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Compute objective trade-offs for the segment\n    original_costs = [\n        sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n        sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n        sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    ]\n\n    reversed_costs = [\n        sum(distance_matrix_1[segment[k], segment[k-1]] for k in range(len(segment)-1, 0, -1)),\n        sum(distance_matrix_2[segment[k], segment[k-1]] for k in range(len(segment)-1, 0, -1)),\n        sum(distance_matrix_3[segment[k], segment[k-1]] for k in range(len(segment)-1, 0, -1))\n    ]\n\n    # Apply inversion only if it improves at least one objective\n    if any(r < o for r, o in zip(reversed_costs, original_costs)):\n        new_solution[i:j] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objective values, then applies a multi-segment inversion and edge crossover operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Assign higher weight to the first objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-segment inversion\n    num_segments = np.random.randint(2, 4)\n    segments = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n    segments = [0] + segments + [n]\n    for i in range(len(segments) - 1):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply edge crossover\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5228359090288437,
            1.1992715835571288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Assign higher weight to the first objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-segment inversion\n    num_segments = np.random.randint(2, 4)\n    segments = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n    segments = [0] + segments + [n]\n    for i in range(len(segments) - 1):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply edge crossover\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform a 3-opt move (a more complex local search)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a + 1 < b and b + 1 < c:\n        # Reorder the segment between a and c to improve all three objectives\n        segment = new_solution[a:c+1]\n        best_segment = segment.copy()\n        best_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                        distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                        distance_matrix_3[segment[i], segment[(i+1)%len(segment)]]\n                        for i in range(len(segment)))\n\n        # Try all possible permutations of the segment (limited to 5 for efficiency)\n        for _ in range(5):\n            np.random.shuffle(segment)\n            current_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                              distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                              distance_matrix_3[segment[i], segment[(i+1)%len(segment)]]\n                              for i in range(len(segment)))\n            if current_cost < best_cost:\n                best_cost = current_cost\n                best_segment = segment.copy()\n\n        new_solution[a:c+1] = best_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6003521766397111,
            1.4707786083221435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform a 3-opt move (a more complex local search)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a + 1 < b and b + 1 < c:\n        # Reorder the segment between a and c to improve all three objectives\n        segment = new_solution[a:c+1]\n        best_segment = segment.copy()\n        best_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                        distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                        distance_matrix_3[segment[i], segment[(i+1)%len(segment)]]\n                        for i in range(len(segment)))\n\n        # Try all possible permutations of the segment (limited to 5 for efficiency)\n        for _ in range(5):\n            np.random.shuffle(segment)\n            current_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                              distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                              distance_matrix_3[segment[i], segment[(i+1)%len(segment)]]\n                              for i in range(len(segment)))\n            if current_cost < best_cost:\n                best_cost = current_cost\n                best_segment = segment.copy()\n\n        new_solution[a:c+1] = best_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with a novel edge exchange that considers the three objectives' distance matrices to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet(np.ones(3))\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    i = np.random.randint(n)\n    j = (i + np.random.randint(1, n)) % n\n    if i > j:\n        i, j = j, i\n\n    # Evaluate potential 2-opt moves across all objectives\n    current_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n    new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n    current_cost = (distance_matrix_1[current_edges[0][0], current_edges[0][1]] +\n                     distance_matrix_1[current_edges[1][0], current_edges[1][1]] +\n                     distance_matrix_2[current_edges[0][0], current_edges[0][1]] +\n                     distance_matrix_2[current_edges[1][0], current_edges[1][1]] +\n                     distance_matrix_3[current_edges[0][0], current_edges[0][1]] +\n                     distance_matrix_3[current_edges[1][0], current_edges[1][1]])\n\n    new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                distance_matrix_2[new_edges[1][0], new_edges[1][1]] +\n                distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform objective-aware edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Evaluate exchange across all objectives\n        current_pairs = [(new_solution[a], new_solution[b]), (new_solution[c], new_solution[d])]\n        new_pairs = [(new_solution[a], new_solution[d]), (new_solution[c], new_solution[b])]\n\n        current_exchange_cost = (distance_matrix_1[current_pairs[0][0], current_pairs[0][1]] +\n                                 distance_matrix_1[current_pairs[1][0], current_pairs[1][1]] +\n                                 distance_matrix_2[current_pairs[0][0], current_pairs[0][1]] +\n                                 distance_matrix_2[current_pairs[1][0], current_pairs[1][1]] +\n                                 distance_matrix_3[current_pairs[0][0], current_pairs[0][1]] +\n                                 distance_matrix_3[current_pairs[1][0], current_pairs[1][1]])\n\n        new_exchange_cost = (distance_matrix_1[new_pairs[0][0], new_pairs[0][1]] +\n                             distance_matrix_1[new_pairs[1][0], new_pairs[1][1]] +\n                             distance_matrix_2[new_pairs[0][0], new_pairs[0][1]] +\n                             distance_matrix_2[new_pairs[1][0], new_pairs[1][1]] +\n                             distance_matrix_3[new_pairs[0][0], new_pairs[0][1]] +\n                             distance_matrix_3[new_pairs[1][0], new_pairs[1][1]])\n\n        if new_exchange_cost < current_exchange_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5532684904224924,
            1.3518558740615845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet(np.ones(3))\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    i = np.random.randint(n)\n    j = (i + np.random.randint(1, n)) % n\n    if i > j:\n        i, j = j, i\n\n    # Evaluate potential 2-opt moves across all objectives\n    current_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n    new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n    current_cost = (distance_matrix_1[current_edges[0][0], current_edges[0][1]] +\n                     distance_matrix_1[current_edges[1][0], current_edges[1][1]] +\n                     distance_matrix_2[current_edges[0][0], current_edges[0][1]] +\n                     distance_matrix_2[current_edges[1][0], current_edges[1][1]] +\n                     distance_matrix_3[current_edges[0][0], current_edges[0][1]] +\n                     distance_matrix_3[current_edges[1][0], current_edges[1][1]])\n\n    new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                distance_matrix_2[new_edges[1][0], new_edges[1][1]] +\n                distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform objective-aware edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Evaluate exchange across all objectives\n        current_pairs = [(new_solution[a], new_solution[b]), (new_solution[c], new_solution[d])]\n        new_pairs = [(new_solution[a], new_solution[d]), (new_solution[c], new_solution[b])]\n\n        current_exchange_cost = (distance_matrix_1[current_pairs[0][0], current_pairs[0][1]] +\n                                 distance_matrix_1[current_pairs[1][0], current_pairs[1][1]] +\n                                 distance_matrix_2[current_pairs[0][0], current_pairs[0][1]] +\n                                 distance_matrix_2[current_pairs[1][0], current_pairs[1][1]] +\n                                 distance_matrix_3[current_pairs[0][0], current_pairs[0][1]] +\n                                 distance_matrix_3[current_pairs[1][0], current_pairs[1][1]])\n\n        new_exchange_cost = (distance_matrix_1[new_pairs[0][0], new_pairs[0][1]] +\n                             distance_matrix_1[new_pairs[1][0], new_pairs[1][1]] +\n                             distance_matrix_2[new_pairs[0][0], new_pairs[0][1]] +\n                             distance_matrix_2[new_pairs[1][0], new_pairs[1][1]] +\n                             distance_matrix_3[new_pairs[0][0], new_pairs[0][1]] +\n                             distance_matrix_3[new_pairs[1][0], new_pairs[1][1]])\n\n        if new_exchange_cost < current_exchange_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, applies a novel segment-shuffling local search that reorders non-adjacent segments in a way that preserves feasibility, and then uses a multi-objective segment replacement to further refine the solution while ensuring all nodes are visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (highest sum) as it likely has room for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-shuffling local search: randomly select three non-adjacent segments and reorder them\n    segment_indices = sorted(np.random.choice(range(1, n), 3, replace=False))\n    a, b, c = segment_indices\n    segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Multi-objective segment replacement: replace a segment with the best segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n-1)\n\n        # Evaluate segments in both solutions using all three objectives\n        def segment_cost(sol, start, end):\n            cost1 = distance_matrix_1[sol[end-1], sol[start]] + distance_matrix_1[sol[end], sol[start-1]]\n            cost2 = distance_matrix_2[sol[end-1], sol[start]] + distance_matrix_2[sol[end], sol[start-1]]\n            cost3 = distance_matrix_3[sol[end-1], sol[start]] + distance_matrix_3[sol[end], sol[start-1]]\n            return (cost1 + cost2 + cost3) / 3\n\n        current_cost = segment_cost(new_solution, k, l)\n        other_cost = segment_cost(other_solution, k, l)\n\n        if other_cost < current_cost:\n            new_solution[k:l] = other_solution[k:l]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5255750408235959,
            1.261927890777588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (highest sum) as it likely has room for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-shuffling local search: randomly select three non-adjacent segments and reorder them\n    segment_indices = sorted(np.random.choice(range(1, n), 3, replace=False))\n    a, b, c = segment_indices\n    segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Multi-objective segment replacement: replace a segment with the best segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n-1)\n\n        # Evaluate segments in both solutions using all three objectives\n        def segment_cost(sol, start, end):\n            cost1 = distance_matrix_1[sol[end-1], sol[start]] + distance_matrix_1[sol[end], sol[start-1]]\n            cost2 = distance_matrix_2[sol[end-1], sol[start]] + distance_matrix_2[sol[end], sol[start-1]]\n            cost3 = distance_matrix_3[sol[end-1], sol[start]] + distance_matrix_3[sol[end], sol[start-1]]\n            return (cost1 + cost2 + cost3) / 3\n\n        current_cost = segment_cost(new_solution, k, l)\n        other_cost = segment_cost(other_solution, k, l)\n\n        if other_cost < current_cost:\n            new_solution[k:l] = other_solution[k:l]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel multi-objective segment inversion and crossover operator that intelligently combines segments from the selected solution and another random solution, ensuring feasibility by repairing any duplicate nodes through a greedy replacement strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Segment-based crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Select a crossover point and merge segments\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n    # Repair duplicates by replacing with missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = np.delete(missing_nodes, 0)\n                else:\n                    # If no missing nodes left, replace with a random node not in the current solution\n                    available_nodes = np.setdiff1d(np.arange(n), new_solution)\n                    if len(available_nodes) > 0:\n                        new_solution[i] = np.random.choice(available_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.77094126411529,
            2.376960790157318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Segment-based crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Select a crossover point and merge segments\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n    # Repair duplicates by replacing with missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = np.delete(missing_nodes, 0)\n                else:\n                    # If no missing nodes left, replace with a random node not in the current solution\n                    available_nodes = np.setdiff1d(np.arange(n), new_solution)\n                    if len(available_nodes) > 0:\n                        new_solution[i] = np.random.choice(available_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This heuristic function selects a solution from the archive based on its diversity and applies a novel multi-objective segment inversion operator that simultaneously optimizes all three objectives by analyzing and inverting critical segments in the tour while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest diversity in objectives)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    # Randomly select a segment to invert\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Invert the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution, distance_matrix):\n        total = 0\n        for k in range(n):\n            total += distance_matrix[solution[k], solution[(k+1)%n]]\n        return total\n\n    new_obj1 = calculate_objective(new_solution, distance_matrix_1)\n    new_obj2 = calculate_objective(new_solution, distance_matrix_2)\n    new_obj3 = calculate_objective(new_solution, distance_matrix_3)\n    new_obj = (new_obj1, new_obj2, new_obj3)\n\n    # If the new solution is worse in all objectives, revert to base solution\n    base_obj = archive[selected_idx][1]\n    if all(new_obj[i] > base_obj[i] for i in range(3)):\n        new_solution = base_solution.copy()\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.440735401631504,
            1.544833207130432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest diversity in objectives)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    # Randomly select a segment to invert\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Invert the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution, distance_matrix):\n        total = 0\n        for k in range(n):\n            total += distance_matrix[solution[k], solution[(k+1)%n]]\n        return total\n\n    new_obj1 = calculate_objective(new_solution, distance_matrix_1)\n    new_obj2 = calculate_objective(new_solution, distance_matrix_2)\n    new_obj3 = calculate_objective(new_solution, distance_matrix_3)\n    new_obj = (new_obj1, new_obj2, new_obj3)\n\n    # If the new solution is worse in all objectives, revert to base solution\n    base_obj = archive[selected_idx][1]\n    if all(new_obj[i] > base_obj[i] for i in range(3)):\n        new_solution = base_solution.copy()\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining 2-opt with a novel edge reallocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge reallocation: move a random segment to a different position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7241819033705805,
            1.0170716404914857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge reallocation: move a random segment to a different position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search that combines 3-opt with a novel segment-based mutation to generate diverse neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best weighted objective)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment and swap positions\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Apply segment-based mutation with a random segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        m = np.random.randint(1, n-1)\n        new_solution[m:] = other_solution[m:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6934479817467136,
            1.928063404560089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best weighted objective)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment and swap positions\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Apply segment-based mutation with a random segment from another solution\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        m = np.random.randint(1, n-1)\n        new_solution[m:] = other_solution[m:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This heuristic function selects a promising solution from the archive by analyzing the trade-offs between objectives, then applies a novel multi-objective segment inversion and insertion operator that intelligently combines features from multiple solutions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective trade-offs\n    objectives = [obj for _, obj in archive]\n    tradeoff_scores = [max(obj)/sum(obj) for obj in objectives]  # Balance between objectives\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    if len(archive) > 1:\n        # Select another solution for reference\n        ref_solution = archive[np.random.choice(len(archive))][0].copy()\n\n        # Identify segments where objectives differ significantly\n        diff_indices = []\n        for i in range(n):\n            if base_solution[i] != ref_solution[i]:\n                diff_indices.append(i)\n\n        if diff_indices:\n            # Invert a segment between two differing nodes\n            i, j = np.random.choice(diff_indices, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n            # Insert a node from the reference solution\n            insert_pos = np.random.randint(0, n)\n            insert_node = ref_solution[np.random.randint(0, n)]\n            new_solution = np.insert(new_solution, insert_pos, insert_node)\n\n            # Remove duplicate (if any) by replacing with a missing node\n            unique, counts = np.unique(new_solution, return_counts=True)\n            if len(unique) != n:\n                missing_nodes = np.setdiff1d(np.arange(n), unique)\n                for i in range(n):\n                    if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                        new_solution[i] = missing_nodes[0]\n                        missing_nodes = np.delete(missing_nodes, 0)\n                        if len(missing_nodes) == 0:\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.6481497819232407,
            3.301671636104584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective trade-offs\n    objectives = [obj for _, obj in archive]\n    tradeoff_scores = [max(obj)/sum(obj) for obj in objectives]  # Balance between objectives\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    if len(archive) > 1:\n        # Select another solution for reference\n        ref_solution = archive[np.random.choice(len(archive))][0].copy()\n\n        # Identify segments where objectives differ significantly\n        diff_indices = []\n        for i in range(n):\n            if base_solution[i] != ref_solution[i]:\n                diff_indices.append(i)\n\n        if diff_indices:\n            # Invert a segment between two differing nodes\n            i, j = np.random.choice(diff_indices, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n            # Insert a node from the reference solution\n            insert_pos = np.random.randint(0, n)\n            insert_node = ref_solution[np.random.randint(0, n)]\n            new_solution = np.insert(new_solution, insert_pos, insert_node)\n\n            # Remove duplicate (if any) by replacing with a missing node\n            unique, counts = np.unique(new_solution, return_counts=True)\n            if len(unique) != n:\n                missing_nodes = np.setdiff1d(np.arange(n), unique)\n                for i in range(n):\n                    if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                        new_solution[i] = missing_nodes[0]\n                        missing_nodes = np.delete(missing_nodes, 0)\n                        if len(missing_nodes) == 0:\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance in all objectives, then applies a novel multi-objective segment inversion operator that reverses segments in all three objective spaces simultaneously, followed by a probabilistic edge swap to further improve the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution that is non-dominated in all objectives\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if all(o <= oo for o, oo in zip(obj, other_obj)) and any(o < oo for o, oo in zip(obj, other_obj)):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-objective segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    for k in range(i, j):\n        # Find the best node in the inverted segment for each objective\n        best_node = new_solution[k]\n        for node in new_solution[i:j]:\n            # Evaluate the impact of swapping with node in all three objectives\n            cost1 = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            cost2 = (distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            cost3 = (distance_matrix_3[new_solution[k-1], node] + distance_matrix_3[node, new_solution[(k+1)%n]]) - \\\n                    (distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n            if cost1 + cost2 + cost3 < 0:  # If better in all objectives\n                best_node = node\n        new_solution[k] = best_node\n\n    # Probabilistic edge swap\n    for _ in range(3):  # Perform 3 edge swaps\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.random() < 0.5:  # 50% chance to swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6109259311445261,
            1.6972538709640503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution that is non-dominated in all objectives\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if all(o <= oo for o, oo in zip(obj, other_obj)) and any(o < oo for o, oo in zip(obj, other_obj)):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-objective segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    for k in range(i, j):\n        # Find the best node in the inverted segment for each objective\n        best_node = new_solution[k]\n        for node in new_solution[i:j]:\n            # Evaluate the impact of swapping with node in all three objectives\n            cost1 = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            cost2 = (distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            cost3 = (distance_matrix_3[new_solution[k-1], node] + distance_matrix_3[node, new_solution[(k+1)%n]]) - \\\n                    (distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n            if cost1 + cost2 + cost3 < 0:  # If better in all objectives\n                best_node = node\n        new_solution[k] = best_node\n\n    # Probabilistic edge swap\n    for _ in range(3):  # Perform 3 edge swaps\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.random() < 0.5:  # 50% chance to swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, applies a 3-opt local search to improve the tour, and then performs a segment-based crossover with another solution to enhance diversity while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of objectives\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Generate all possible permutations of the segment\n    segment = new_solution[a:b+1]\n    permutations = [\n        segment,\n        np.concatenate([segment[:c-a], segment[c-a:][::-1]]),\n        np.concatenate([segment[:b-a+1-c], segment[b-a+1-c:][::-1]]),\n        segment[::-1]\n    ]\n\n    # Evaluate all permutations based on total distance across all objectives\n    def evaluate(sol):\n        total = 0\n        for i in range(len(sol)):\n            u, v = sol[i], sol[(i+1)%len(sol)]\n            total += distance_matrix_1[u, v] * weights[0]\n            total += distance_matrix_2[u, v] * weights[1]\n            total += distance_matrix_3[u, v] * weights[2]\n        return total\n\n    best_perm = min(permutations, key=evaluate)\n    new_solution[a:b+1] = best_perm\n\n    # Apply segment-based crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6867156099564309,
            3.410897433757782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of objectives\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Generate all possible permutations of the segment\n    segment = new_solution[a:b+1]\n    permutations = [\n        segment,\n        np.concatenate([segment[:c-a], segment[c-a:][::-1]]),\n        np.concatenate([segment[:b-a+1-c], segment[b-a+1-c:][::-1]]),\n        segment[::-1]\n    ]\n\n    # Evaluate all permutations based on total distance across all objectives\n    def evaluate(sol):\n        total = 0\n        for i in range(len(sol)):\n            u, v = sol[i], sol[(i+1)%len(sol)]\n            total += distance_matrix_1[u, v] * weights[0]\n            total += distance_matrix_2[u, v] * weights[1]\n            total += distance_matrix_3[u, v] * weights[2]\n        return total\n\n    best_perm = min(permutations, key=evaluate)\n    new_solution[a:b+1] = best_perm\n\n    # Apply segment-based crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted objective score (considering all three objectives with different weights), applies a novel segment-based mutation that preserves critical segments while randomly shuffling others, and ensures feasibility by repairing any duplicates through a segment-wise repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective score (0.4, 0.3, 0.3)\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2] for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based mutation: preserve critical segments, shuffle others\n    segment_size = max(2, n // 5)\n    num_segments = n // segment_size\n\n    # Randomly select segments to shuffle\n    segments_to_shuffle = np.random.choice(num_segments, size=num_segments // 2, replace=False)\n    for seg in segments_to_shuffle:\n        start = seg * segment_size\n        end = min((seg + 1) * segment_size, n)\n        new_solution[start:end] = np.random.permutation(new_solution[start:end])\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6695664709069651,
            1.1070682525634765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective score (0.4, 0.3, 0.3)\n    objectives = [obj for _, obj in archive]\n    weighted_scores = [0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2] for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based mutation: preserve critical segments, shuffle others\n    segment_size = max(2, n // 5)\n    num_segments = n // segment_size\n\n    # Randomly select segments to shuffle\n    segments_to_shuffle = np.random.choice(num_segments, size=num_segments // 2, replace=False)\n    for seg in segments_to_shuffle:\n        start = seg * segment_size\n        end = min((seg + 1) * segment_size, n)\n        new_solution[start:end] = np.random.permutation(new_solution[start:end])\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a multi-objective-aware segment inversion and insertion heuristic to generate a neighbor solution, ensuring feasibility by validating node uniqueness and repairing duplicates if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.sum(objectives, axis=1))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]  # Randomly pick from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective-aware segment inversion and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n-1)\n    end = np.random.randint(start+1, n)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly select another segment to insert elsewhere\n    insert_start = np.random.randint(0, n-1)\n    insert_end = np.random.randint(insert_start+1, n)\n    segment = new_solution[insert_start:insert_end]\n    new_solution = np.concatenate([new_solution[:insert_start], new_solution[insert_end:]])\n\n    # Insert the segment at a random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n                else:\n                    # If no missing nodes left, replace with a random node\n                    new_solution[i] = np.random.choice(np.setdiff1d(np.arange(n), new_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.7089712722698429,
            0.8483925223350525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.sum(objectives, axis=1))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]  # Randomly pick from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-objective-aware segment inversion and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n-1)\n    end = np.random.randint(start+1, n)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly select another segment to insert elsewhere\n    insert_start = np.random.randint(0, n-1)\n    insert_end = np.random.randint(insert_start+1, n)\n    segment = new_solution[insert_start:insert_end]\n    new_solution = np.concatenate([new_solution[:insert_start], new_solution[insert_end:]])\n\n    # Insert the segment at a random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n                else:\n                    # If no missing nodes left, replace with a random node\n                    new_solution[i] = np.random.choice(np.setdiff1d(np.arange(n), new_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a tri-objective-aware segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment inversion in all three objectives\n    cost_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n    cost_after = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                 distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                 distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                 distance_matrix_1[segment[-1], new_solution[j]] +\n                 distance_matrix_2[segment[-1], new_solution[j]] +\n                 distance_matrix_3[segment[-1], new_solution[j]])\n\n    if cost_after < cost_before:\n        new_solution[i:j] = segment[::-1]\n\n    # Perform a tri-objective-aware edge rotation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a != b and b != c and a != c:\n        # Evaluate edge rotation in all three objectives\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                       distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                       distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        cost_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[a], new_solution[c]] +\n                      distance_matrix_2[new_solution[a], new_solution[c]] +\n                      distance_matrix_3[new_solution[a], new_solution[c]])\n\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5379888123997578,
            1.1187599658966065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a tri-objective-aware segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment inversion in all three objectives\n    cost_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n    cost_after = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                 distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                 distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                 distance_matrix_1[segment[-1], new_solution[j]] +\n                 distance_matrix_2[segment[-1], new_solution[j]] +\n                 distance_matrix_3[segment[-1], new_solution[j]])\n\n    if cost_after < cost_before:\n        new_solution[i:j] = segment[::-1]\n\n    # Perform a tri-objective-aware edge rotation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a != b and b != c and a != c:\n        # Evaluate edge rotation in all three objectives\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                       distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                       distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        cost_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[a], new_solution[c]] +\n                      distance_matrix_2[new_solution[a], new_solution[c]] +\n                      distance_matrix_3[new_solution[a], new_solution[c]])\n\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted based on the diversity of the archive, then applies a hybrid local search combining 3-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using weighted sum of objectives with dynamic weights\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        l = np.random.randint(1, n-1)\n        new_solution[l:] = other_solution[l:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.662990486262582,
            1.8636342406272888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using weighted sum of objectives with dynamic weights\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments for 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        l = np.random.randint(1, n-1)\n        new_solution[l:] = other_solution[l:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment in all objectives\n    def segment_cost(s, dm1, dm2, dm3):\n        cost = 0\n        for k in range(len(s)-1):\n            cost += dm1[s[k], s[k+1]] + dm2[s[k], s[k+1]] + dm3[s[k], s[k+1]]\n        return cost\n\n    original_cost = segment_cost(segment, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n    inverted_cost = segment_cost(segment[::-1], distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Only invert if it improves at least one objective\n    if inverted_cost < original_cost:\n        new_solution[i:j] = segment[::-1]\n\n    # Multi-objective edge crossover\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b = sorted([a, b])\n    c, d = sorted([c, d])\n\n    # Calculate edge costs in all objectives\n    def edge_cost(a, b, dm1, dm2, dm3):\n        return dm1[a, b] + dm2[a, b] + dm3[a, b]\n\n    original_edges = edge_cost(new_solution[a], new_solution[b], distance_matrix_1, distance_matrix_2, distance_matrix_3) + \\\n                    edge_cost(new_solution[c], new_solution[d], distance_matrix_1, distance_matrix_2, distance_matrix_3)\n    swapped_edges = edge_cost(new_solution[a], new_solution[d], distance_matrix_1, distance_matrix_2, distance_matrix_3) + \\\n                   edge_cost(new_solution[b], new_solution[c], distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Only swap if it improves at least one objective\n    if swapped_edges < original_edges:\n        new_solution[[a, b, c, d]] = new_solution[[a, d, b, c]]\n\n    return new_solution\n\n",
        "score": [
            -0.7585275809764067,
            2.4838361859321596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment in all objectives\n    def segment_cost(s, dm1, dm2, dm3):\n        cost = 0\n        for k in range(len(s)-1):\n            cost += dm1[s[k], s[k+1]] + dm2[s[k], s[k+1]] + dm3[s[k], s[k+1]]\n        return cost\n\n    original_cost = segment_cost(segment, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n    inverted_cost = segment_cost(segment[::-1], distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Only invert if it improves at least one objective\n    if inverted_cost < original_cost:\n        new_solution[i:j] = segment[::-1]\n\n    # Multi-objective edge crossover\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b = sorted([a, b])\n    c, d = sorted([c, d])\n\n    # Calculate edge costs in all objectives\n    def edge_cost(a, b, dm1, dm2, dm3):\n        return dm1[a, b] + dm2[a, b] + dm3[a, b]\n\n    original_edges = edge_cost(new_solution[a], new_solution[b], distance_matrix_1, distance_matrix_2, distance_matrix_3) + \\\n                    edge_cost(new_solution[c], new_solution[d], distance_matrix_1, distance_matrix_2, distance_matrix_3)\n    swapped_edges = edge_cost(new_solution[a], new_solution[d], distance_matrix_1, distance_matrix_2, distance_matrix_3) + \\\n                   edge_cost(new_solution[b], new_solution[c], distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Only swap if it improves at least one objective\n    if swapped_edges < original_edges:\n        new_solution[[a, b, c, d]] = new_solution[[a, d, b, c]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a solution from the archive based on the best combined objective value, then applies a novel 3-opt local search combined with a segment-based insertion to improve the tour across multiple objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    objectives = [obj for _, obj in archive]\n    combined_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three segments and rearrange them\n    segments = [new_solution[:i], new_solution[i:j], new_solution[j:k], new_solution[k:]]\n    new_order = [segments[0], segments[2], segments[1], segments[3]]\n    new_solution = np.concatenate(new_order)\n\n    # Apply segment-based insertion\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        l = np.random.randint(1, n-1)\n        m = np.random.randint(l, n)\n        new_solution[l:m] = other_solution[l:m]\n\n    # Repair duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7421559224712811,
            1.3537908673286438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    objectives = [obj for _, obj in archive]\n    combined_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three segments and rearrange them\n    segments = [new_solution[:i], new_solution[i:j], new_solution[j:k], new_solution[k:]]\n    new_order = [segments[0], segments[2], segments[1], segments[3]]\n    new_solution = np.concatenate(new_order)\n\n    # Apply segment-based insertion\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        l = np.random.randint(1, n-1)\n        m = np.random.randint(l, n)\n        new_solution[l:m] = other_solution[l:m]\n\n    # Repair duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a novel 3-opt local search with segment inversion to explore multi-objective trade-offs, and ensures feasibility by repairing any duplicates while preserving the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted sum of objectives (prioritize better solutions)\n    objectives = [obj for _, obj in archive]\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt with segment inversion\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Invert three segments to explore multi-objective trade-offs\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6451806041933935,
            1.1730179190635681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted sum of objectives (prioritize better solutions)\n    objectives = [obj for _, obj in archive]\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt with segment inversion\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Invert three segments to explore multi-objective trade-offs\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This heuristic function selects a solution from the archive based on a multi-objective diversity metric, then applies a novel segment-based perturbation that combines node reinsertion with objective-aware edge swaps to generate diverse and high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and reinsert it at a different position\n    start = np.random.randint(0, n-1)\n    end = np.random.randint(start+1, n)\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Perform objective-aware edge swaps\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Only perform swap if it improves at least one objective\n        if delta1 <= 0 or delta2 <= 0 or delta3 <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7257140303869004,
            1.2491668462753296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and reinsert it at a different position\n    start = np.random.randint(0, n-1)\n    end = np.random.randint(start+1, n)\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Perform objective-aware edge swaps\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Only perform swap if it improves at least one objective\n        if delta1 <= 0 or delta2 <= 0 or delta3 <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a novel segment-based inversion and insertion operator to generate a neighbor solution, and ensures feasibility by repairing any duplicate nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a weighted combination of objectives\n    objectives = [obj for _, obj in archive]\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based inversion and insertion\n    if n > 2:\n        # Randomly select a segment to invert\n        segment_start = np.random.randint(0, n-1)\n        segment_end = np.random.randint(segment_start+1, n)\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n        # Randomly select another segment and insert it at a different position\n        insert_pos = np.random.randint(0, n)\n        if insert_pos < segment_start:\n            segment = new_solution[segment_start:segment_end+1]\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:segment_start], new_solution[segment_end+1:]])\n        else:\n            segment = new_solution[segment_start:segment_end+1]\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end+1:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.759463231445949,
            0.9393762588500977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a weighted combination of objectives\n    objectives = [obj for _, obj in archive]\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based inversion and insertion\n    if n > 2:\n        # Randomly select a segment to invert\n        segment_start = np.random.randint(0, n-1)\n        segment_end = np.random.randint(segment_start+1, n)\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n        # Randomly select another segment and insert it at a different position\n        insert_pos = np.random.randint(0, n)\n        if insert_pos < segment_start:\n            segment = new_solution[segment_start:segment_end+1]\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:segment_start], new_solution[segment_end+1:]])\n        else:\n            segment = new_solution[segment_start:segment_end+1]\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end+1:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, applies a novel segment inversion and edge rotation operator that preserves tour feasibility, and ensures the neighbor solution is valid by checking for duplicates and repairing if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best weighted objective\n    weights = np.array([0.4, 0.3, 0.3])  # Weight for each objective\n    weighted_scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a random segment by a random amount\n    k = np.random.randint(1, n)\n    new_solution = np.roll(new_solution, k)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6540839287897569,
            1.5233733177185058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best weighted objective\n    weights = np.array([0.4, 0.3, 0.3])  # Weight for each objective\n    weighted_scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a random segment by a random amount\n    k = np.random.randint(1, n)\n    new_solution = np.roll(new_solution, k)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This new heuristic selects a solution with the best average objective, identifies critical nodes using multi-objective dominance analysis, and applies a hybrid local search combining 3-opt with a novel node-swapping operator to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with node-swapping\n    if n >= 3:\n        # Randomly select three positions\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Apply node-swapping with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        swap_positions = np.random.choice(n, size=min(3, n), replace=False)\n        for pos in swap_positions:\n            new_solution[pos] = other_solution[pos]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7210854139872953,
            1.123946225643158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with node-swapping\n    if n >= 3:\n        # Randomly select three positions\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Apply node-swapping with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        swap_positions = np.random.choice(n, size=min(3, n), replace=False)\n        for pos in swap_positions:\n            new_solution[pos] = other_solution[pos]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{Select a solution from the archive with high objective values and apply a novel multi-objective local search operator that combines segment reversal, edge exchange, and objective-aware edge selection to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    segment_reversed = segment[::-1]\n    cost_diff = (\n        sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n        sum(distance_matrix_1[segment_reversed[k-1], segment_reversed[k]] for k in range(1, len(segment_reversed)))\n    )\n    if cost_diff < 0:\n        new_solution[i:j] = segment_reversed\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_edges = [(a, c), (b, d), (c, b), (d, a)]\n        old_edges = [(a, b), (c, d), (b, c), (d, a)]\n        cost_diff = (\n            sum(distance_matrix_1[old[0], old[1]] for old in old_edges) -\n            sum(distance_matrix_1[new[0], new[1]] for new in new_edges)\n        )\n        if cost_diff < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Objective-aware insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n        cost_diff = (\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] -\n            distance_matrix_1[new_solution[l-1], new_solution[(l+1)%n]]\n        )\n        if cost_diff > 0:\n            new_solution = np.delete(new_solution, l)\n            new_solution = np.insert(new_solution, k, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6957041196073189,
            1.1850259900093079
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    segment_reversed = segment[::-1]\n    cost_diff = (\n        sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n        sum(distance_matrix_1[segment_reversed[k-1], segment_reversed[k]] for k in range(1, len(segment_reversed)))\n    )\n    if cost_diff < 0:\n        new_solution[i:j] = segment_reversed\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_edges = [(a, c), (b, d), (c, b), (d, a)]\n        old_edges = [(a, b), (c, d), (b, c), (d, a)]\n        cost_diff = (\n            sum(distance_matrix_1[old[0], old[1]] for old in old_edges) -\n            sum(distance_matrix_1[new[0], new[1]] for new in new_edges)\n        )\n        if cost_diff < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Objective-aware insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n        cost_diff = (\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] -\n            distance_matrix_1[new_solution[l-1], new_solution[(l+1)%n]]\n        )\n        if cost_diff > 0:\n            new_solution = np.delete(new_solution, l)\n            new_solution = np.insert(new_solution, k, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A novel tri-objective TSP heuristic that intelligently selects solutions with high potential for improvement across all three objectives, then applies a hybrid local search combining 2-opt with a novel multi-objective edge exchange strategy to generate neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective consideration\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate improvement across all objectives\n    def calc_improvement(sol):\n        total = 0\n        for k in range(n-1):\n            total += distance_matrix_1[sol[k], sol[k+1]] + distance_matrix_2[sol[k], sol[k+1]] + distance_matrix_3[sol[k], sol[k+1]]\n        total += distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]] + distance_matrix_3[sol[-1], sol[0]]\n        return total\n\n    current_cost = calc_improvement(new_solution)\n    temp_solution = new_solution.copy()\n\n    if a != c and b != d:\n        temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n        temp_cost = calc_improvement(temp_solution)\n        if temp_cost < current_cost:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.44830359514652784,
            1.141685163974762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective consideration\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate improvement across all objectives\n    def calc_improvement(sol):\n        total = 0\n        for k in range(n-1):\n            total += distance_matrix_1[sol[k], sol[k+1]] + distance_matrix_2[sol[k], sol[k+1]] + distance_matrix_3[sol[k], sol[k+1]]\n        total += distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]] + distance_matrix_3[sol[-1], sol[0]]\n        return total\n\n    current_cost = calc_improvement(new_solution)\n    temp_solution = new_solution.copy()\n\n    if a != c and b != d:\n        temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n        temp_cost = calc_improvement(temp_solution)\n        if temp_cost < current_cost:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance rank, then applies a novel multi-segment inversion and edge insertion operator to generate a neighbor solution, ensuring feasibility through a repair mechanism that maintains tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank (simplified for this example)\n    objectives = [obj for _, obj in archive]\n    dominance_ranks = np.argsort([sum(obj) for obj in objectives])\n    selected_idx = dominance_ranks[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[j]\n    new_solution = np.delete(new_solution, j)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        duplicates = unique[counts > 1]\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][1:]\n            for i in idx:\n                if len(missing) > 0:\n                    new_solution[i] = missing[0]\n                    missing = np.delete(missing, 0)\n\n    return new_solution\n\n",
        "score": [
            -0.6781485134726714,
            1.2262527227401734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank (simplified for this example)\n    objectives = [obj for _, obj in archive]\n    dominance_ranks = np.argsort([sum(obj) for obj in objectives])\n    selected_idx = dominance_ranks[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[j]\n    new_solution = np.delete(new_solution, j)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        duplicates = unique[counts > 1]\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][1:]\n            for i in idx:\n                if len(missing) > 0:\n                    new_solution[i] = missing[0]\n                    missing = np.delete(missing, 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel heuristic that intelligently selects a solution from the archive based on a combined objective score, then applies a multi-objective-aware edge insertion and reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Higher weight for third objective\n    selected_solution, _ = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Apply objective-aware edge reversal\n    obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n    obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n    obj3_diff = (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n    # Only reverse if it improves at least one objective\n    if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6806970400308178,
            1.5025126218795777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Higher weight for third objective\n    selected_solution, _ = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Apply objective-aware edge reversal\n    obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n    obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n    obj3_diff = (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n    # Only reverse if it improves at least one objective\n    if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a multi-objective rank score, applies a novel segment-based mutation that combines 3-opt with a weighted edge selection strategy, and ensures feasibility by repairing any duplicate nodes using a greedy approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using multi-objective rank\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    rank_scores = np.sum(ranks, axis=1)\n    selected_idx = np.argmin(rank_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt mutation with weighted edge selection\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Calculate edge weights based on all three objectives\n    edge_weights = (\n        distance_matrix_1[base_solution[i], base_solution[j]] +\n        distance_matrix_2[base_solution[i], base_solution[j]] +\n        distance_matrix_3[base_solution[i], base_solution[j]]\n    ) + (\n        distance_matrix_1[base_solution[j], base_solution[k]] +\n        distance_matrix_2[base_solution[j], base_solution[k]] +\n        distance_matrix_3[base_solution[j], base_solution[k]]\n    ) - (\n        distance_matrix_1[base_solution[i], base_solution[k]] +\n        distance_matrix_2[base_solution[i], base_solution[k]] +\n        distance_matrix_3[base_solution[i], base_solution[k]]\n    )\n\n    if edge_weights > 0:\n        # Apply 3-opt if it improves the combined objective\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy repair: replace duplicates with nearest missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                nearest = missing_nodes[np.argmin(\n                    distance_matrix_1[new_solution[i], missing_nodes] +\n                    distance_matrix_2[new_solution[i], missing_nodes] +\n                    distance_matrix_3[new_solution[i], missing_nodes]\n                )]\n                new_solution[i] = nearest\n                missing_nodes = np.delete(missing_nodes, np.where(missing_nodes == nearest))\n\n    return new_solution\n\n",
        "score": [
            -0.6656854435159081,
            0.884626591205597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using multi-objective rank\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    rank_scores = np.sum(ranks, axis=1)\n    selected_idx = np.argmin(rank_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt mutation with weighted edge selection\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Calculate edge weights based on all three objectives\n    edge_weights = (\n        distance_matrix_1[base_solution[i], base_solution[j]] +\n        distance_matrix_2[base_solution[i], base_solution[j]] +\n        distance_matrix_3[base_solution[i], base_solution[j]]\n    ) + (\n        distance_matrix_1[base_solution[j], base_solution[k]] +\n        distance_matrix_2[base_solution[j], base_solution[k]] +\n        distance_matrix_3[base_solution[j], base_solution[k]]\n    ) - (\n        distance_matrix_1[base_solution[i], base_solution[k]] +\n        distance_matrix_2[base_solution[i], base_solution[k]] +\n        distance_matrix_3[base_solution[i], base_solution[k]]\n    )\n\n    if edge_weights > 0:\n        # Apply 3-opt if it improves the combined objective\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution is a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy repair: replace duplicates with nearest missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                nearest = missing_nodes[np.argmin(\n                    distance_matrix_1[new_solution[i], missing_nodes] +\n                    distance_matrix_2[new_solution[i], missing_nodes] +\n                    distance_matrix_3[new_solution[i], missing_nodes]\n                )]\n                new_solution[i] = nearest\n                missing_nodes = np.delete(missing_nodes, np.where(missing_nodes == nearest))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution with the highest total objective value from the archive, divides the tour into three segments, and applies a novel three-segment rotation operator that cyclically shifts nodes between segments while ensuring feasibility through careful node reassignment and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Divide the tour into three segments\n    seg1 = new_solution[:n//3]\n    seg2 = new_solution[n//3:2*(n//3)]\n    seg3 = new_solution[2*(n//3):]\n\n    # Perform a three-segment rotation\n    rotated = np.concatenate([seg2, seg3, seg1])\n\n    # Ensure all nodes are unique\n    unique, counts = np.unique(rotated, return_counts=True)\n    if len(unique) == n:\n        new_solution = rotated\n    else:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == rotated[i])[0][0]] > 1:\n                rotated[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n        new_solution = rotated\n\n    return new_solution\n\n",
        "score": [
            -0.6163798777838453,
            0.9650294184684753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Divide the tour into three segments\n    seg1 = new_solution[:n//3]\n    seg2 = new_solution[n//3:2*(n//3)]\n    seg3 = new_solution[2*(n//3):]\n\n    # Perform a three-segment rotation\n    rotated = np.concatenate([seg2, seg3, seg1])\n\n    # Ensure all nodes are unique\n    unique, counts = np.unique(rotated, return_counts=True)\n    if len(unique) == n:\n        new_solution = rotated\n    else:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == rotated[i])[0][0]] > 1:\n                rotated[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n        new_solution = rotated\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects solutions with high potential for improvement by combining crowding distance and objective diversity, then applies a hybrid of 3-opt and objective-aware edge exchange to generate high-quality neighbors across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 3-opt and objective-aware edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Objective-aware edge exchange\n    def objective_aware_exchange(sol, d1, d2, d3):\n        n = len(sol)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate exchange in all three objectives\n            original_cost = (d1[sol[a-1], sol[a]] + d1[sol[b-1], sol[b]] +\n                           d2[sol[a-1], sol[a]] + d2[sol[b-1], sol[b]] +\n                           d3[sol[a-1], sol[a]] + d3[sol[b-1], sol[b]])\n            new_cost = (d1[sol[a-1], sol[c]] + d1[sol[b-1], sol[d]] +\n                       d2[sol[a-1], sol[c]] + d2[sol[b-1], sol[d]] +\n                       d3[sol[a-1], sol[c]] + d3[sol[b-1], sol[d]])\n            if new_cost < original_cost:\n                sol[[a, b, c, d]] = sol[[a, c, b, d]]\n        return sol\n\n    new_solution = objective_aware_exchange(new_solution, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    return new_solution\n\n",
        "score": [
            -0.7150906941169178,
            1.384956955909729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 3-opt and objective-aware edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Objective-aware edge exchange\n    def objective_aware_exchange(sol, d1, d2, d3):\n        n = len(sol)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate exchange in all three objectives\n            original_cost = (d1[sol[a-1], sol[a]] + d1[sol[b-1], sol[b]] +\n                           d2[sol[a-1], sol[a]] + d2[sol[b-1], sol[b]] +\n                           d3[sol[a-1], sol[a]] + d3[sol[b-1], sol[b]])\n            new_cost = (d1[sol[a-1], sol[c]] + d1[sol[b-1], sol[d]] +\n                       d2[sol[a-1], sol[c]] + d2[sol[b-1], sol[d]] +\n                       d3[sol[a-1], sol[c]] + d3[sol[b-1], sol[d]])\n            if new_cost < original_cost:\n                sol[[a, b, c, d]] = sol[[a, c, b, d]]\n        return sol\n\n    new_solution = objective_aware_exchange(new_solution, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a diverse solution from the archive based on its Pareto front dominance, applies a novel multi-objective edge exchange operator that considers edge contributions across all three objectives, and uses a segment-based insertion to ensure feasibility while improving solution quality across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (not just the best average)\n    objectives = np.array([obj for _, obj in archive])\n    # Find solution with minimum sum of ranks across objectives\n    ranks = [np.sum(np.argsort(objectives[:, i])[::-1]) for i in range(3)]\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge exchange\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Calculate edge contributions across all objectives\n    def edge_contribution(a, b):\n        return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Find best edge to swap\n    best_improvement = 0\n    best_pair = (i, j)\n    for a in range(n):\n        for b in range(a+1, n):\n            current = edge_contribution(base_solution[a], base_solution[(a+1)%n]) + \\\n                      edge_contribution(base_solution[b], base_solution[(b+1)%n])\n            swapped = edge_contribution(base_solution[a], base_solution[b]) + \\\n                      edge_contribution(base_solution[(a+1)%n], base_solution[(b+1)%n])\n            improvement = current - swapped\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pair = (a, b)\n\n    # Perform the swap\n    a, b = best_pair\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment-based insertion for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            # Insert missing node in a position that minimizes total distance across objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_2[new_solution[pos-1], node] + distance_matrix_3[new_solution[pos-1], node]) + \\\n                       (distance_matrix_1[node, new_solution[pos]] + distance_matrix_2[node, new_solution[pos]] + distance_matrix_3[node, new_solution[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution[:n]  # Ensure correct length\n\n",
        "score": [
            -0.677801997527209,
            4.040592586994171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (not just the best average)\n    objectives = np.array([obj for _, obj in archive])\n    # Find solution with minimum sum of ranks across objectives\n    ranks = [np.sum(np.argsort(objectives[:, i])[::-1]) for i in range(3)]\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge exchange\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Calculate edge contributions across all objectives\n    def edge_contribution(a, b):\n        return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Find best edge to swap\n    best_improvement = 0\n    best_pair = (i, j)\n    for a in range(n):\n        for b in range(a+1, n):\n            current = edge_contribution(base_solution[a], base_solution[(a+1)%n]) + \\\n                      edge_contribution(base_solution[b], base_solution[(b+1)%n])\n            swapped = edge_contribution(base_solution[a], base_solution[b]) + \\\n                      edge_contribution(base_solution[(a+1)%n], base_solution[(b+1)%n])\n            improvement = current - swapped\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pair = (a, b)\n\n    # Perform the swap\n    a, b = best_pair\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment-based insertion for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            # Insert missing node in a position that minimizes total distance across objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_2[new_solution[pos-1], node] + distance_matrix_3[new_solution[pos-1], node]) + \\\n                       (distance_matrix_1[node, new_solution[pos]] + distance_matrix_2[node, new_solution[pos]] + distance_matrix_3[node, new_solution[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution[:n]  # Ensure correct length\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted objective score, then applies a novel tri-objective segment inversion operator that simultaneously optimizes all three objectives by selectively inverting segments while preserving feasibility, followed by a distance-aware edge swapping step to further refine the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Tri-objective segment inversion\n    if n > 3:\n        # Select three non-overlapping segments\n        segment_length = max(2, n // 4)\n        seg1 = np.random.randint(0, n - 2*segment_length)\n        seg2 = np.random.randint(seg1 + segment_length, n - segment_length)\n        seg3 = np.random.randint(seg2 + segment_length, n)\n\n        # Invert segments based on which objective is most improved\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Invert the segment that would most improve the worst objective\n        if obj1 <= obj2 and obj1 <= obj3:\n            new_solution[seg1:seg1+segment_length] = new_solution[seg1:seg1+segment_length][::-1]\n        elif obj2 <= obj1 and obj2 <= obj3:\n            new_solution[seg2:seg2+segment_length] = new_solution[seg2:seg2+segment_length][::-1]\n        else:\n            new_solution[seg3:seg3+segment_length] = new_solution[seg3:seg3+segment_length][::-1]\n\n    # Distance-aware edge swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all objectives\n        old_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        if sum(new_edges) < sum(old_edges):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity (shouldn't be needed due to careful implementation)\n    if len(np.unique(new_solution)) != n:\n        # Simple repair if needed\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = new_solution[np.where(np.bincount(new_solution) > 1)[0]]\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.5958296095700382,
            2.3038387060165406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Tri-objective segment inversion\n    if n > 3:\n        # Select three non-overlapping segments\n        segment_length = max(2, n // 4)\n        seg1 = np.random.randint(0, n - 2*segment_length)\n        seg2 = np.random.randint(seg1 + segment_length, n - segment_length)\n        seg3 = np.random.randint(seg2 + segment_length, n)\n\n        # Invert segments based on which objective is most improved\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Invert the segment that would most improve the worst objective\n        if obj1 <= obj2 and obj1 <= obj3:\n            new_solution[seg1:seg1+segment_length] = new_solution[seg1:seg1+segment_length][::-1]\n        elif obj2 <= obj1 and obj2 <= obj3:\n            new_solution[seg2:seg2+segment_length] = new_solution[seg2:seg2+segment_length][::-1]\n        else:\n            new_solution[seg3:seg3+segment_length] = new_solution[seg3:seg3+segment_length][::-1]\n\n    # Distance-aware edge swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all objectives\n        old_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        if sum(new_edges) < sum(old_edges):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity (shouldn't be needed due to careful implementation)\n    if len(np.unique(new_solution)) != n:\n        # Simple repair if needed\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = new_solution[np.where(np.bincount(new_solution) > 1)[0]]\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{A novel approach that intelligently selects a solution from the archive based on the diversity of its objectives and applies a multi-objective-aware local search operator combining 2-opt with a novel edge insertion move, prioritizing improvements in the most underperforming objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify the most underperforming objective\n    worst_obj = np.argmax(objectives)\n\n    # Apply 2-opt prioritizing the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    current_segment = new_solution[i:j]\n    reversed_segment = current_segment[::-1]\n\n    # Calculate improvement in worst objective\n    original_cost = sum(dist_matrix[new_solution[k-1], new_solution[k]] for k in range(i, j))\n    reversed_cost = sum(dist_matrix[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n    if reversed_cost < original_cost:\n        new_solution[i:j] = reversed_segment\n\n    # Apply edge insertion move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.4838735197529386,
            1.150231945514679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify the most underperforming objective\n    worst_obj = np.argmax(objectives)\n\n    # Apply 2-opt prioritizing the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    current_segment = new_solution[i:j]\n    reversed_segment = current_segment[::-1]\n\n    # Calculate improvement in worst objective\n    original_cost = sum(dist_matrix[new_solution[k-1], new_solution[k]] for k in range(i, j))\n    reversed_cost = sum(dist_matrix[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n    if reversed_cost < original_cost:\n        new_solution[i:j] = reversed_segment\n\n    # Apply edge insertion move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This heuristic function selects a solution from the archive based on its Pareto dominance rank, applies a novel segment-based mutation that combines 2-opt with a multi-objective aware insertion, and ensures feasibility by repairing duplicate nodes while preserving the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance (simplified: select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Apply segment-based mutation: randomly select a segment and reverse it\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective aware insertion: insert a node from another solution at a random position\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        node_to_insert = np.random.choice(other_solution)\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        # Remove a node to maintain tour length\n        if len(new_solution) > n:\n            new_solution = np.delete(new_solution, np.random.randint(0, len(new_solution)))\n\n    # Ensure feasibility: repair duplicates by replacing them with missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7091436246126088,
            1.5759836554527282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance (simplified: select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Apply segment-based mutation: randomly select a segment and reverse it\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective aware insertion: insert a node from another solution at a random position\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        node_to_insert = np.random.choice(other_solution)\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        # Remove a node to maintain tour length\n        if len(new_solution) > n:\n            new_solution = np.delete(new_solution, np.random.randint(0, len(new_solution)))\n\n    # Ensure feasibility: repair duplicates by replacing them with missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(len(new_solution)):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective-aware edge reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a multi-objective-aware edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7068545699472504,
            1.0361758708953857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective-aware edge reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a multi-objective-aware edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This algorithm selects a high-performing solution from the archive, identifies critical nodes based on their contributions to the objectives, and applies a novel node-swapping and segment-reversal hybrid operator to generate high-quality neighbors while ensuring feasibility through intelligent repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall performance (minimizing sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes based on their contribution to each objective\n    critical_nodes = []\n    for i in range(n):\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1) % n]\n        contribution = (\n            distance_matrix_1[prev_node, base_solution[i]] + distance_matrix_1[base_solution[i], next_node],\n            distance_matrix_2[prev_node, base_solution[i]] + distance_matrix_2[base_solution[i], next_node],\n            distance_matrix_3[prev_node, base_solution[i]] + distance_matrix_3[base_solution[i], next_node]\n        )\n        if any(c > np.median([distance_matrix_1[prev_node, next_node], distance_matrix_2[prev_node, next_node], distance_matrix_3[prev_node, next_node]]) for c in contribution):\n            critical_nodes.append(i)\n\n    if critical_nodes:\n        # Apply node-swapping for critical nodes\n        i, j = np.random.choice(critical_nodes, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply segment reversal between two critical nodes\n        i, j = sorted(np.random.choice(critical_nodes, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Fallback to random 2-opt if no critical nodes found\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7802720093224921,
            3.098057723045349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall performance (minimizing sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes based on their contribution to each objective\n    critical_nodes = []\n    for i in range(n):\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1) % n]\n        contribution = (\n            distance_matrix_1[prev_node, base_solution[i]] + distance_matrix_1[base_solution[i], next_node],\n            distance_matrix_2[prev_node, base_solution[i]] + distance_matrix_2[base_solution[i], next_node],\n            distance_matrix_3[prev_node, base_solution[i]] + distance_matrix_3[base_solution[i], next_node]\n        )\n        if any(c > np.median([distance_matrix_1[prev_node, next_node], distance_matrix_2[prev_node, next_node], distance_matrix_3[prev_node, next_node]]) for c in contribution):\n            critical_nodes.append(i)\n\n    if critical_nodes:\n        # Apply node-swapping for critical nodes\n        i, j = np.random.choice(critical_nodes, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply segment reversal between two critical nodes\n        i, j = sorted(np.random.choice(critical_nodes, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Fallback to random 2-opt if no critical nodes found\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This heuristic function selects a solution from the archive based on a multi-objective quality score, then applies a novel segment-based mutation that combines edge swaps with a probabilistic insertion of segments from another solution, ensuring feasibility through careful validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate multi-objective quality score (weighted sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized = np.array(objectives) / np.max(objectives, axis=0)\n    quality_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based mutation with probabilistic insertion\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Extract segment from other solution\n        segment = other_solution[a:b+1]\n\n        # Insert with probability based on segment quality\n        segment_lengths = [\n            sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]],\n            sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]],\n            sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_3[segment[-1], segment[0]]\n        ]\n        avg_length = sum(segment_lengths)/3\n        insert_prob = 1 / (1 + np.exp(-avg_length))  # Higher probability for shorter segments\n\n        if np.random.rand() < insert_prob:\n            # Find insertion point in base solution\n            c = np.random.randint(0, n)\n            new_solution = np.concatenate([base_solution[:c], segment, base_solution[c:]])\n\n            # Remove duplicates while preserving order\n            _, unique_indices = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(unique_indices)]\n\n            # Pad with missing nodes if needed\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing_nodes) > 0:\n                new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Final edge swap for local improvement\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6724465266343145,
            1.5034072041511535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate multi-objective quality score (weighted sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized = np.array(objectives) / np.max(objectives, axis=0)\n    quality_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-based mutation with probabilistic insertion\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Extract segment from other solution\n        segment = other_solution[a:b+1]\n\n        # Insert with probability based on segment quality\n        segment_lengths = [\n            sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]],\n            sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]],\n            sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_3[segment[-1], segment[0]]\n        ]\n        avg_length = sum(segment_lengths)/3\n        insert_prob = 1 / (1 + np.exp(-avg_length))  # Higher probability for shorter segments\n\n        if np.random.rand() < insert_prob:\n            # Find insertion point in base solution\n            c = np.random.randint(0, n)\n            new_solution = np.concatenate([base_solution[:c], segment, base_solution[c:]])\n\n            # Remove duplicates while preserving order\n            _, unique_indices = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(unique_indices)]\n\n            # Pad with missing nodes if needed\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing_nodes) > 0:\n                new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Final edge swap for local improvement\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment reversal, multi-objective edge exchange, and dominance-aware selection to generate high-quality neighbors by intelligently balancing improvements across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * (1 + np.random.uniform(0.5, 1.5)))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on objective weights\n    weights = np.random.dirichlet(np.ones(3))\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(2):\n        a, b, c, d = np.random.choice(n, 4, replace=False)\n        a, b = sorted([a, b])\n        c, d = sorted([c, d])\n        if a != c and b != d:\n            # Evaluate the exchange across all objectives\n            original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                        distance_matrix_1[new_solution[d], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[d], new_solution[(b+1)%n]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[d], new_solution[(b+1)%n]])\n\n            if new_cost < original_cost:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Dominance-aware edge swap\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and i != j-1 and i != j+1:\n            # Evaluate dominance of the swap\n            original_costs = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            new_costs = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n            if sum(new_costs) < sum(original_costs):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6929466641135363,
            2.079956221580505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * (1 + np.random.uniform(0.5, 1.5)))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on objective weights\n    weights = np.random.dirichlet(np.ones(3))\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(2):\n        a, b, c, d = np.random.choice(n, 4, replace=False)\n        a, b = sorted([a, b])\n        c, d = sorted([c, d])\n        if a != c and b != d:\n            # Evaluate the exchange across all objectives\n            original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                        distance_matrix_1[new_solution[d], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[d], new_solution[(b+1)%n]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[d], new_solution[(b+1)%n]])\n\n            if new_cost < original_cost:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Dominance-aware edge swap\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and i != j-1 and i != j+1:\n            # Evaluate dominance of the swap\n            original_costs = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            new_costs = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n            if sum(new_costs) < sum(original_costs):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel 3-way edge exchange operator that considers all three objectives simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 3-way edge exchange operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to exchange\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform the exchange while maintaining feasibility\n    if a < b < c:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Alternative exchange pattern\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6906384869769971,
            1.1325648427009583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 3-way edge exchange operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to exchange\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform the exchange while maintaining feasibility\n    if a < b < c:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Alternative exchange pattern\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining 3-opt and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.5, 1.5, 3)\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move with random selection\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply edge exchange with random selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5011294201901306,
            1.6130292534828186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.5, 1.5, 3)\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move with random selection\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply edge exchange with random selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted to prioritize less improved objectives, then applies a novel segment-based mutation that reorders critical segments while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic weights based on objective improvement potential\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    weights = 1 / (avg_objectives + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)\n\n    # Select solution with best weighted score\n    scores = [sum(w * obj for w, obj in zip(weights, objs)) for objs in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments (high total distance in any objective)\n    segment_size = max(2, n // 5)\n    segment_starts = np.arange(0, n, segment_size)\n    segment_ends = np.minimum(segment_starts + segment_size, n)\n\n    # Calculate segment scores (sum of distances in all objectives)\n    segment_scores = []\n    for start, end in zip(segment_starts, segment_ends):\n        segment = base_solution[start:end]\n        score = 0\n        for i in range(len(segment)-1):\n            score += (distance_matrix_1[segment[i], segment[i+1]] +\n                      distance_matrix_2[segment[i], segment[i+1]] +\n                      distance_matrix_3[segment[i], segment[i+1]])\n        segment_scores.append(score)\n\n    # Select top 3 segments for mutation\n    top_segments = np.argsort(segment_scores)[-3:]\n    for i in top_segments:\n        start, end = segment_starts[i], segment_ends[i]\n        # Reverse segment with probability 0.5, otherwise shift\n        if np.random.rand() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            shift = np.random.randint(1, end-start)\n            new_solution[start:end] = np.roll(new_solution[start:end], shift)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        duplicates = np.where(counts > 1)[0]\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == unique[dup])[0][1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6377971234083201,
            3.4488962411880495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic weights based on objective improvement potential\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    weights = 1 / (avg_objectives + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)\n\n    # Select solution with best weighted score\n    scores = [sum(w * obj for w, obj in zip(weights, objs)) for objs in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments (high total distance in any objective)\n    segment_size = max(2, n // 5)\n    segment_starts = np.arange(0, n, segment_size)\n    segment_ends = np.minimum(segment_starts + segment_size, n)\n\n    # Calculate segment scores (sum of distances in all objectives)\n    segment_scores = []\n    for start, end in zip(segment_starts, segment_ends):\n        segment = base_solution[start:end]\n        score = 0\n        for i in range(len(segment)-1):\n            score += (distance_matrix_1[segment[i], segment[i+1]] +\n                      distance_matrix_2[segment[i], segment[i+1]] +\n                      distance_matrix_3[segment[i], segment[i+1]])\n        segment_scores.append(score)\n\n    # Select top 3 segments for mutation\n    top_segments = np.argsort(segment_scores)[-3:]\n    for i in top_segments:\n        start, end = segment_starts[i], segment_ends[i]\n        # Reverse segment with probability 0.5, otherwise shift\n        if np.random.rand() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            shift = np.random.randint(1, end-start)\n            new_solution[start:end] = np.roll(new_solution[start:end], shift)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        duplicates = np.where(counts > 1)[0]\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == unique[dup])[0][1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value, then applies a novel multi-segment inversion and edge reordering operator to generate a neighbor solution while ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and edge reordering\n    segments = np.random.choice(n, size=3, replace=False)\n    segments.sort()\n    a, b, c = segments\n\n    # Invert three segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Randomly reorder edges in the middle segment\n    middle = new_solution[b:c]\n    np.random.shuffle(middle)\n    new_solution[b:c] = middle\n\n    # Dynamic repair to ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        duplicates = [x for x in unique if counts[np.where(unique == x)[0][0]] > 1]\n\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0]\n            for i in idx[1:]:\n                if len(missing) > 0:\n                    new_solution[i] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6394609219657587,
            0.8805581212043763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and edge reordering\n    segments = np.random.choice(n, size=3, replace=False)\n    segments.sort()\n    a, b, c = segments\n\n    # Invert three segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Randomly reorder edges in the middle segment\n    middle = new_solution[b:c]\n    np.random.shuffle(middle)\n    new_solution[b:c] = middle\n\n    # Dynamic repair to ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        duplicates = [x for x in unique if counts[np.where(unique == x)[0][0]] > 1]\n\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0]\n            for i in idx[1:]:\n                if len(missing) > 0:\n                    new_solution[i] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of its objectives, then applies a hybrid local search combining 2-opt and edge exchange, followed by a novel 3-opt move to further optimize the tour across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 2-opt to reduce the worst objective\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange to balance objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply 3-opt to further optimize across all objectives\n    x, y, z = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[x:y] = new_solution[x:y][::-1]\n    new_solution[y:z] = new_solution[y:z][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6139550792027867,
            1.0420694947242737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 2-opt to reduce the worst objective\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange to balance objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Apply 3-opt to further optimize across all objectives\n    x, y, z = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[x:y] = new_solution[x:y][::-1]\n    new_solution[y:z] = new_solution[y:z][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    # Apply a novel local search operator: Objective-Driven Segment Reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse the segment if it improves at least one objective\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    reversed_segment = new_solution[i:j].copy()[::-1]\n    new_solution[i:j] = reversed_segment\n\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Revert if no improvement in any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i:j] = reversed_segment[::-1]\n\n    # Apply a second move: Objective-Specific Edge Swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in each objective\n    obj1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n                  - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[b-1]])\n    obj2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n                  - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[b-1]])\n    obj3_change = (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n                  - distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b], new_solution[b-1]])\n\n    # Only perform the swap if it improves at least one objective\n    if obj1_change < 0 or obj2_change < 0 or obj3_change < 0:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.550534456713068,
            1.2499446630477906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    # Apply a novel local search operator: Objective-Driven Segment Reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse the segment if it improves at least one objective\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    reversed_segment = new_solution[i:j].copy()[::-1]\n    new_solution[i:j] = reversed_segment\n\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Revert if no improvement in any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i:j] = reversed_segment[::-1]\n\n    # Apply a second move: Objective-Specific Edge Swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in each objective\n    obj1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n                  - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[b-1]])\n    obj2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n                  - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[b-1]])\n    obj3_change = (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n                  - distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b], new_solution[b-1]])\n\n    # Only perform the swap if it improves at least one objective\n    if obj1_change < 0 or obj2_change < 0 or obj3_change < 0:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objective values, incorporating diversity and improvement potential, then applies a hybrid local search combining 3-opt and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted sum of objectives, favoring diverse and potentially improving solutions\n    weights = np.random.uniform(0.3, 0.7, size=3)\n    weights /= weights.sum()\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1, segment2, segment3 = new_solution[i:j], new_solution[j:k], new_solution[k:] if k != 0 else new_solution[k:]\n    new_segments = [segment1, segment2, segment3]\n    np.random.shuffle(new_segments)\n    new_solution = np.concatenate([new_solution[:i]] + new_segments + [new_solution[k:]])\n\n    # Apply edge exchange with a higher probability for better solutions\n    if np.random.random() < 0.7:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.729142908797406,
            0.6885061025619507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted sum of objectives, favoring diverse and potentially improving solutions\n    weights = np.random.uniform(0.3, 0.7, size=3)\n    weights /= weights.sum()\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1, segment2, segment3 = new_solution[i:j], new_solution[j:k], new_solution[k:] if k != 0 else new_solution[k:]\n    new_segments = [segment1, segment2, segment3]\n    np.random.shuffle(new_segments)\n    new_solution = np.concatenate([new_solution[:i]] + new_segments + [new_solution[k:]])\n\n    # Apply edge exchange with a higher probability for better solutions\n    if np.random.random() < 0.7:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst-performing objective, then applies a novel multi-objective segment inversion and insertion operator that intelligently reorders segments while preserving feasibility, ensuring balanced improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective to focus improvement\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select another segment and insert it elsewhere\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[k:l].copy()\n    m = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:m], segment, new_solution[m:k], new_solution[l:]])\n\n    # Ensure feasibility by repairing duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.46376064187834015,
            0.8695038914680481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective to focus improvement\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select another segment and insert it elsewhere\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[k:l].copy()\n    m = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:m], segment, new_solution[m:k], new_solution[l:]])\n\n    # Ensure feasibility by repairing duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for idx in range(n):\n            if counts[np.where(unique == new_solution[idx])[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This new heuristic selects a solution from the archive based on its dominance rank and applies a novel segment-based mutation combined with a multi-objective aware edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best dominance rank (simplified by selecting the one with best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment-based mutation: randomly select a segment and reverse it\n    if n > 2:\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware edge insertion\n    if n > 3:\n        # Select a random node to remove\n        remove_idx = np.random.randint(1, n-1)\n        node_to_remove = new_solution[remove_idx]\n\n        # Find the best insertion point based on the sum of distances across all objectives\n        best_insert_pos = 0\n        min_total_distance = float('inf')\n\n        for i in range(1, n):\n            if i == remove_idx or i == remove_idx + 1:\n                continue\n\n            # Calculate total distance for insertion at position i\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            total_distance = (distance_matrix_1[prev_node, node_to_remove] + distance_matrix_1[node_to_remove, next_node] -\n                             distance_matrix_1[prev_node, next_node]) + \\\n                            (distance_matrix_2[prev_node, node_to_remove] + distance_matrix_2[node_to_remove, next_node] -\n                             distance_matrix_2[prev_node, next_node]) + \\\n                            (distance_matrix_3[prev_node, node_to_remove] + distance_matrix_3[node_to_remove, next_node] -\n                             distance_matrix_3[prev_node, next_node])\n\n            if total_distance < min_total_distance:\n                min_total_distance = total_distance\n                best_insert_pos = i\n\n        # Perform the insertion\n        new_solution = np.delete(new_solution, remove_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node_to_remove)\n\n    return new_solution\n\n",
        "score": [
            -0.7265031226984593,
            1.445405626296997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best dominance rank (simplified by selecting the one with best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment-based mutation: randomly select a segment and reverse it\n    if n > 2:\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware edge insertion\n    if n > 3:\n        # Select a random node to remove\n        remove_idx = np.random.randint(1, n-1)\n        node_to_remove = new_solution[remove_idx]\n\n        # Find the best insertion point based on the sum of distances across all objectives\n        best_insert_pos = 0\n        min_total_distance = float('inf')\n\n        for i in range(1, n):\n            if i == remove_idx or i == remove_idx + 1:\n                continue\n\n            # Calculate total distance for insertion at position i\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            total_distance = (distance_matrix_1[prev_node, node_to_remove] + distance_matrix_1[node_to_remove, next_node] -\n                             distance_matrix_1[prev_node, next_node]) + \\\n                            (distance_matrix_2[prev_node, node_to_remove] + distance_matrix_2[node_to_remove, next_node] -\n                             distance_matrix_2[prev_node, next_node]) + \\\n                            (distance_matrix_3[prev_node, node_to_remove] + distance_matrix_3[node_to_remove, next_node] -\n                             distance_matrix_3[prev_node, next_node])\n\n            if total_distance < min_total_distance:\n                min_total_distance = total_distance\n                best_insert_pos = i\n\n        # Perform the insertion\n        new_solution = np.delete(new_solution, remove_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node_to_remove)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, identifies critical nodes using a multi-objective dominance analysis, and applies a novel segment-based mutation that combines adaptive 2-opt with a probabilistic edge swap to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective score (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_obj * np.array([0.4, 0.3, 0.3]), axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes using multi-objective dominance analysis\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Check if the node dominates its neighbors in any objective\n        dominates_prev = (distance_matrix_1[node, prev_node] <= distance_matrix_1[prev_node, node] and\n                          distance_matrix_2[node, prev_node] <= distance_matrix_2[prev_node, node] and\n                          distance_matrix_3[node, prev_node] <= distance_matrix_3[prev_node, node])\n        dominates_next = (distance_matrix_1[node, next_node] <= distance_matrix_1[next_node, node] and\n                          distance_matrix_2[node, next_node] <= distance_matrix_2[next_node, node] and\n                          distance_matrix_3[node, next_node] <= distance_matrix_3[next_node, node])\n\n        if not dominates_prev or not dominates_next:\n            critical_nodes.add(i)\n\n    # Apply adaptive 2-opt on critical nodes\n    if len(critical_nodes) >= 2:\n        i, j = sorted(np.random.choice(list(critical_nodes), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply probabilistic edge swap\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.random() < 0.7 and (i not in critical_nodes or j not in critical_nodes):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.670618173833003,
            1.5385932683944703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective score (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_obj * np.array([0.4, 0.3, 0.3]), axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes using multi-objective dominance analysis\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Check if the node dominates its neighbors in any objective\n        dominates_prev = (distance_matrix_1[node, prev_node] <= distance_matrix_1[prev_node, node] and\n                          distance_matrix_2[node, prev_node] <= distance_matrix_2[prev_node, node] and\n                          distance_matrix_3[node, prev_node] <= distance_matrix_3[prev_node, node])\n        dominates_next = (distance_matrix_1[node, next_node] <= distance_matrix_1[next_node, node] and\n                          distance_matrix_2[node, next_node] <= distance_matrix_2[next_node, node] and\n                          distance_matrix_3[node, next_node] <= distance_matrix_3[next_node, node])\n\n        if not dominates_prev or not dominates_next:\n            critical_nodes.add(i)\n\n    # Apply adaptive 2-opt on critical nodes\n    if len(critical_nodes) >= 2:\n        i, j = sorted(np.random.choice(list(critical_nodes), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply probabilistic edge swap\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.random() < 0.7 and (i not in critical_nodes or j not in critical_nodes):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining 3-opt with a novel segment-based mutation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Higher weight for first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three positions for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n\n    # Reconstruct with different order\n    new_segments = [segment1, segment2, segment3]\n    np.random.shuffle(new_segments)\n    new_solution = np.concatenate([new_solution[:i]] + new_segments)\n\n    # Apply segment-based mutation\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        m = np.random.randint(1, n-1)\n        new_solution[m:] = other_solution[m:]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.736825812877147,
            2.340468633174896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Higher weight for first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based mutation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three positions for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n\n    # Reconstruct with different order\n    new_segments = [segment1, segment2, segment3]\n    np.random.shuffle(new_segments)\n    new_solution = np.concatenate([new_solution[:i]] + new_segments)\n\n    # Apply segment-based mutation\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        m = np.random.randint(1, n-1)\n        new_solution[m:] = other_solution[m:]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel adaptive segment inversion operator that dynamically adjusts the segment length based on the solution's performance across the three objectives, ensuring feasibility and potentially improving multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of objectives\n    weights = np.random.dirichlet([1, 1, 1])  # Random weights for multi-objective selection\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate relative performance of the selected solution\n    objectives = archive[selected_idx][1]\n    relative_performance = [obj / sum(objectives) for obj in objectives]\n\n    # Adaptive segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment length based on relative performance\n    segment_length = max(2, int(n * (1 - min(relative_performance))))\n\n    # Randomly select segment and invert\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i in range(n):\n            if np.count_nonzero(new_solution == new_solution[i]) > 1:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6406575676135673,
            3.9515651941299437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of objectives\n    weights = np.random.dirichlet([1, 1, 1])  # Random weights for multi-objective selection\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate relative performance of the selected solution\n    objectives = archive[selected_idx][1]\n    relative_performance = [obj / sum(objectives) for obj in objectives]\n\n    # Adaptive segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment length based on relative performance\n    segment_length = max(2, int(n * (1 - min(relative_performance))))\n\n    # Randomly select segment and invert\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i in range(n):\n            if np.count_nonzero(new_solution == new_solution[i]) > 1:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def balance_score(obj):\n        return 1 - (max(obj) - min(obj)) / sum(obj)\n\n    selected_solution = max(archive, key=lambda x: balance_score(x[1]))[0].copy()\n    n = len(selected_solution)\n\n    # Novel multi-objective segment rotation and insertion\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and rotate it based on objective balance\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Rotate segment based on which objective needs most improvement\n    obj_diffs = [\n        distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] -\n        distance_matrix_1[selected_solution[i-1], selected_solution[i]]\n        for i in range(start, start+segment_length)\n    ]\n\n    if np.mean(obj_diffs) < 0:  # If segment is improving, rotate forward\n        segment = np.roll(segment, 1)\n    else:  # Otherwise rotate backward\n        segment = np.roll(segment, -1)\n\n    new_solution[start:start+segment_length] = segment\n\n    # Insert segment at a position that improves the most balanced objective\n    best_insert_pos = 0\n    best_balance = -float('inf')\n\n    for pos in range(n):\n        if pos >= start and pos < start + segment_length:\n            continue\n\n        # Temporarily insert segment\n        temp_solution = new_solution.copy()\n        temp_solution = np.insert(temp_solution, pos, segment)\n        if pos < start:\n            temp_solution = np.delete(temp_solution, start + len(segment))\n\n        # Calculate objective balance for this insertion\n        obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n        obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n        obj3 = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n        current_balance = balance_score((obj1, obj2, obj3))\n\n        if current_balance > best_balance:\n            best_balance = current_balance\n            best_insert_pos = pos\n\n    # Perform the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n    if best_insert_pos < start:\n        new_solution = np.delete(new_solution, start + len(segment))\n\n    return new_solution\n\n",
        "score": [
            -0.7468333367175114,
            2.8329780101776123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def balance_score(obj):\n        return 1 - (max(obj) - min(obj)) / sum(obj)\n\n    selected_solution = max(archive, key=lambda x: balance_score(x[1]))[0].copy()\n    n = len(selected_solution)\n\n    # Novel multi-objective segment rotation and insertion\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and rotate it based on objective balance\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Rotate segment based on which objective needs most improvement\n    obj_diffs = [\n        distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] -\n        distance_matrix_1[selected_solution[i-1], selected_solution[i]]\n        for i in range(start, start+segment_length)\n    ]\n\n    if np.mean(obj_diffs) < 0:  # If segment is improving, rotate forward\n        segment = np.roll(segment, 1)\n    else:  # Otherwise rotate backward\n        segment = np.roll(segment, -1)\n\n    new_solution[start:start+segment_length] = segment\n\n    # Insert segment at a position that improves the most balanced objective\n    best_insert_pos = 0\n    best_balance = -float('inf')\n\n    for pos in range(n):\n        if pos >= start and pos < start + segment_length:\n            continue\n\n        # Temporarily insert segment\n        temp_solution = new_solution.copy()\n        temp_solution = np.insert(temp_solution, pos, segment)\n        if pos < start:\n            temp_solution = np.delete(temp_solution, start + len(segment))\n\n        # Calculate objective balance for this insertion\n        obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n        obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n        obj3 = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n        current_balance = balance_score((obj1, obj2, obj3))\n\n        if current_balance > best_balance:\n            best_balance = current_balance\n            best_insert_pos = pos\n\n    # Perform the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n    if best_insert_pos < start:\n        new_solution = np.delete(new_solution, start + len(segment))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This algorithm selects a promising solution from the archive, performs a multi-objective segment reversal based on the most critical objective, and combines it with a novel segment insertion from another solution to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective in one space (to focus improvement)\n    objectives = [obj for _, obj in archive]\n    worst_space = np.argmax([sum(obj) for obj in zip(*objectives)])\n    selected_idx = np.argmax([obj[worst_space] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify the most critical segment to reverse based on the worst objective\n    n = len(base_solution)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    segment_costs = []\n    for i in range(n):\n        for j in range(i+1, n):\n            segment = base_solution[i:j+1]\n            cost = sum(distance_matrices[worst_space][segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            segment_costs.append((i, j, cost))\n\n    if not segment_costs:\n        return base_solution.copy()\n\n    i, j, _ = max(segment_costs, key=lambda x: x[2])\n    new_solution = base_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insert a segment from another solution to enhance multi-objective quality\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(k, n)\n        segment = other_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure validity (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.618179805480151,
            2.845424246788025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the worst objective in one space (to focus improvement)\n    objectives = [obj for _, obj in archive]\n    worst_space = np.argmax([sum(obj) for obj in zip(*objectives)])\n    selected_idx = np.argmax([obj[worst_space] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify the most critical segment to reverse based on the worst objective\n    n = len(base_solution)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    segment_costs = []\n    for i in range(n):\n        for j in range(i+1, n):\n            segment = base_solution[i:j+1]\n            cost = sum(distance_matrices[worst_space][segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            segment_costs.append((i, j, cost))\n\n    if not segment_costs:\n        return base_solution.copy()\n\n    i, j, _ = max(segment_costs, key=lambda x: x[2])\n    new_solution = base_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insert a segment from another solution to enhance multi-objective quality\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(k, n)\n        segment = other_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure validity (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8406698713651828,
            3.2292223811149596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
   
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This heuristic function selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a novel multi-segment inversion operator combined with a probabilistic edge insertion to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to ideal point (minimizing all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = objectives.min(axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment inversion with probabilistic edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select multiple segments and invert them\n    num_segments = np.random.randint(1, 4)\n    for _ in range(num_segments):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Probabilistic edge insertion\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, c, new_solution[b])\n        new_solution = np.delete(new_solution, b if b > c else b+1)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing[0]\n                missing = np.delete(missing, 0)\n                if len(missing) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6518682895799667,
            1.3908691883087159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to ideal point (minimizing all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = objectives.min(axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment inversion with probabilistic edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select multiple segments and invert them\n    num_segments = np.random.randint(1, 4)\n    for _ in range(num_segments):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Probabilistic edge insertion\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, c, new_solution[b])\n        new_solution = np.delete(new_solution, b if b > c else b+1)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing[0]\n                missing = np.delete(missing, 0)\n                if len(missing) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in multiple objectives, applies a segment-based mutation with a novel objective-aware segment selection, and combines it with a multi-objective 2-opt operation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    # Objective-aware segment selection\n    segment_length = np.random.randint(2, n//2)\n    start = np.random.randint(0, n - segment_length)\n\n    # Multi-objective 2-opt with segment inversion\n    for i in range(start, start + segment_length):\n        for j in range(i + 1, start + segment_length):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]))\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]))\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[j+1]]))\n\n            # Accept if any objective improves\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4523359132780357,
            2.62656626701355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    # Objective-aware segment selection\n    segment_length = np.random.randint(2, n//2)\n    start = np.random.randint(0, n - segment_length)\n\n    # Multi-objective 2-opt with segment inversion\n    for i in range(start, start + segment_length):\n        for j in range(i + 1, start + segment_length):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]))\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]))\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[j+1]]))\n\n            # Accept if any objective improves\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel edge-swapping and segment-reversal hybrid local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value and good diversity\n    selected_idx = np.random.choice(len(archive), p=np.array([sum(obj) for _, obj in archive]) / sum(sum(obj) for _, obj in archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge-swapping and segment-reversal\n    if n > 3:\n        # Edge-swapping for one objective\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n        # Segment-reversal for another objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Random swap for the third objective\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7519314750290269,
            1.1512256622314454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value and good diversity\n    selected_idx = np.random.choice(len(archive), p=np.array([sum(obj) for _, obj in archive]) / sum(sum(obj) for _, obj in archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge-swapping and segment-reversal\n    if n > 3:\n        # Edge-swapping for one objective\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n        # Segment-reversal for another objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Random swap for the third objective\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive, identifies critical segments in the tour using a multi-objective segment analysis, and applies a hybrid local search operator that combines 2-opt with a novel segment-based crossover to generate high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with segment-based crossover\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments for 2-opt\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment-based crossover with another random solution from archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0].copy()\n        k = np.random.randint(1, n-1)\n        new_solution[k:] = other_solution[k:]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if counts[np.where(unique == new_solution[i])[0][0]] > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = np.delete(missing_nodes, 0)\n                if len(missing_nodes) == 0:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a high-performing solution from the archive, identifies critical nodes based on their contributions to the objectives, and applies a novel segment insertion heuristic that combines edge swaps with multi-objective segment evaluation to generate improved neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    objectives = [obj for _, obj in archive]\n    weights = [0.4, 0.3, 0.3]  # Weighting for the three objectives\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes (high contribution to objectives)\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate edge contributions to objectives\n        edge_contrib = (\n            distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n            distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n        )\n\n        # If edge contributes significantly to any objective, mark node as critical\n        if any(contrib > 0.1 * sum(edge_contrib) for contrib in edge_contrib):\n            critical_nodes.add(node)\n\n    # Apply segment insertion heuristic\n    if len(critical_nodes) > 0:\n        # Select a random critical node and a random segment to insert it into\n        critical_node = np.random.choice(list(critical_nodes))\n        pos = np.where(new_solution == critical_node)[0][0]\n\n        # Remove the critical node from its current position\n        new_solution = np.delete(new_solution, pos)\n\n        # Choose a random position to insert it\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, critical_node)\n\n    # Apply edge swap if no critical nodes found\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6363868488994051,
            1.4764399409294129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    objectives = [obj for _, obj in archive]\n    weights = [0.4, 0.3, 0.3]  # Weighting for the three objectives\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes (high contribution to objectives)\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate edge contributions to objectives\n        edge_contrib = (\n            distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n            distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n        )\n\n        # If edge contributes significantly to any objective, mark node as critical\n        if any(contrib > 0.1 * sum(edge_contrib) for contrib in edge_contrib):\n            critical_nodes.add(node)\n\n    # Apply segment insertion heuristic\n    if len(critical_nodes) > 0:\n        # Select a random critical node and a random segment to insert it into\n        critical_node = np.random.choice(list(critical_nodes))\n        pos = np.where(new_solution == critical_node)[0][0]\n\n        # Remove the critical node from its current position\n        new_solution = np.delete(new_solution, pos)\n\n        # Choose a random position to insert it\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, critical_node)\n\n    # Apply edge swap if no critical nodes found\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This heuristic function selects a solution from the archive based on the maximum objective value to encourage exploration, applies a hybrid 2-opt and 3-opt local search with a novel objective-aware edge selection strategy, and ensures feasibility by repairing duplicates with a minimum-cost insertion method.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum objective value to encourage exploration\n    objectives = [obj for _, obj in archive]\n    max_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[max_obj_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt followed by 3-opt\n    def evaluate_2opt(sol, a, b):\n        # Create new solution by reversing segment between a and b\n        new_sol = np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]])\n        return new_sol\n\n    def evaluate_3opt(sol, a, b, c):\n        # Three possible reconnections\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate based on combined objective improvement\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        return min(costs, key=lambda x: x[0])[1]\n\n    # Apply 2-opt on edges with highest distance in any objective\n    max_dist_edges = []\n    for i in range(n):\n        j = (i + 1) % n\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        dist3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        max_dist_edges.append((max(dist1, dist2, dist3), i))\n\n    max_dist_edges.sort(reverse=True, key=lambda x: x[0])\n    selected_edges = [i for _, i in max_dist_edges[:3]]\n\n    for i in selected_edges:\n        j = (i + 1) % n\n        new_solution = evaluate_2opt(new_solution, i, j)\n\n    # Apply 3-opt on random segments\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    new_solution = evaluate_3opt(new_solution, a, b, c)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6957328067159934,
            1.0050215363502502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum objective value to encourage exploration\n    objectives = [obj for _, obj in archive]\n    max_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[max_obj_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt followed by 3-opt\n    def evaluate_2opt(sol, a, b):\n        # Create new solution by reversing segment between a and b\n        new_sol = np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]])\n        return new_sol\n\n    def evaluate_3opt(sol, a, b, c):\n        # Three possible reconnections\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate based on combined objective improvement\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        return min(costs, key=lambda x: x[0])[1]\n\n    # Apply 2-opt on edges with highest distance in any objective\n    max_dist_edges = []\n    for i in range(n):\n        j = (i + 1) % n\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        dist3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        max_dist_edges.append((max(dist1, dist2, dist3), i))\n\n    max_dist_edges.sort(reverse=True, key=lambda x: x[0])\n    selected_edges = [i for _, i in max_dist_edges[:3]]\n\n    for i in selected_edges:\n        j = (i + 1) % n\n        new_solution = evaluate_2opt(new_solution, i, j)\n\n    # Apply 3-opt on random segments\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    new_solution = evaluate_3opt(new_solution, a, b, c)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score function that considers both the solution's objective values and their diversity, then applies a hybrid local search combining 3-opt moves and a multi-objective edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol_obj):\n        obj = sol_obj[1]\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        return sum(obj) + diversity * 0.5\n\n    selected_solution, _ = max(archive, key=score)\n\n    # Hybrid local search: 3-opt move followed by multi-objective edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Multi-objective edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Choose the exchange that improves the worst objective\n            current_obj = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n            new_obj = (\n                distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                distance_matrix_1[new_solution[d-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                distance_matrix_2[new_solution[d-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[c]] +\n                distance_matrix_3[new_solution[d-1], new_solution[b]]\n            )\n            if new_obj < current_obj:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5845269475948984,
            1.400257909297943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol_obj):\n        obj = sol_obj[1]\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        return sum(obj) + diversity * 0.5\n\n    selected_solution, _ = max(archive, key=score)\n\n    # Hybrid local search: 3-opt move followed by multi-objective edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Multi-objective edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Choose the exchange that improves the worst objective\n            current_obj = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n            new_obj = (\n                distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                distance_matrix_1[new_solution[d-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                distance_matrix_2[new_solution[d-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[c]] +\n                distance_matrix_3[new_solution[d-1], new_solution[b]]\n            )\n            if new_obj < current_obj:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This heuristic function selects a solution from the archive based on its proximity to the ideal point in the objective space, applies a novel multi-objective segment inversion and relocation operator that simultaneously optimizes all three objectives, and ensures feasibility by repairing any invalid segments with a greedy segment repair strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to ideal point (minimizing all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.min(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion and relocation operator\n    segment_length = np.random.randint(2, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert segment and relocate\n    segment = new_solution[start:end][::-1]\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end:]])\n\n    # Find best insertion position for the segment\n    best_pos = start\n    best_cost = float('inf')\n    for pos in range(n - segment_length + 1):\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        segment,\n        new_solution[best_pos:]\n    ])\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy segment repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find best segment to insert the missing node\n            best_segment = None\n            best_segment_pos = 0\n            best_segment_cost = float('inf')\n\n            for seg_len in range(2, min(5, len(new_solution))):\n                for pos in range(len(new_solution) - seg_len + 1):\n                    # Remove segment and insert node\n                    segment = new_solution[pos:pos+seg_len]\n                    candidate = np.concatenate([\n                        new_solution[:pos],\n                        [node],\n                        np.delete(new_solution, np.arange(pos, pos+seg_len))\n                    ])\n\n                    # Evaluate cost\n                    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                    total_cost = cost1 + cost2 + cost3\n\n                    if total_cost < best_segment_cost:\n                        best_segment_cost = total_cost\n                        best_segment = segment\n                        best_segment_pos = pos\n\n            if best_segment is not None:\n                new_solution = np.concatenate([\n                    new_solution[:best_segment_pos],\n                    [node],\n                    np.delete(new_solution, np.arange(best_segment_pos, best_segment_pos + len(best_segment)))\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.6548327538753806,
            1.7203410506248473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to ideal point (minimizing all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.min(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion and relocation operator\n    segment_length = np.random.randint(2, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert segment and relocate\n    segment = new_solution[start:end][::-1]\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end:]])\n\n    # Find best insertion position for the segment\n    best_pos = start\n    best_cost = float('inf')\n    for pos in range(n - segment_length + 1):\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        segment,\n        new_solution[best_pos:]\n    ])\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy segment repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find best segment to insert the missing node\n            best_segment = None\n            best_segment_pos = 0\n            best_segment_cost = float('inf')\n\n            for seg_len in range(2, min(5, len(new_solution))):\n                for pos in range(len(new_solution) - seg_len + 1):\n                    # Remove segment and insert node\n                    segment = new_solution[pos:pos+seg_len]\n                    candidate = np.concatenate([\n                        new_solution[:pos],\n                        [node],\n                        np.delete(new_solution, np.arange(pos, pos+seg_len))\n                    ])\n\n                    # Evaluate cost\n                    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                    total_cost = cost1 + cost2 + cost3\n\n                    if total_cost < best_segment_cost:\n                        best_segment_cost = total_cost\n                        best_segment = segment\n                        best_segment_pos = pos\n\n            if best_segment is not None:\n                new_solution = np.concatenate([\n                    new_solution[:best_segment_pos],\n                    [node],\n                    np.delete(new_solution, np.arange(best_segment_pos, best_segment_pos + len(best_segment)))\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This heuristic function selects a solution from the archive based on the most balanced objectives, applies a novel 3-opt operator that considers all three objectives simultaneously, and ensures feasibility by repairing any duplicates with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            total_cost = (cost1 + cost2 + cost3) / 3  # Average cost across objectives\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = (cost1 + cost2 + cost3) / 3  # Average cost across objectives\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8872457108099188,
            2.955000579357147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            total_cost = (cost1 + cost2 + cost3) / 3  # Average cost across objectives\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = (cost1 + cost2 + cost3) / 3  # Average cost across objectives\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This new algorithm selects a solution from the archive using a multi-objective aware selection strategy, then applies a novel 3D-aware local search operator that combines segment reversal with objective-specific edge swaps to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3D-aware local search operator\n    # Step 1: Random segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Objective-specific edge swaps\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        if np.random.rand() < 0.3:  # 30% chance to perform swap for each objective\n            # Find the worst edge in this objective\n            current_cost = 0\n            worst_edge = (0, 1)\n            worst_cost = -float('inf')\n            for k in range(n):\n                u = new_solution[k]\n                v = new_solution[(k+1)%n]\n                cost = distance_matrix[u, v]\n                current_cost += cost\n                if cost > worst_cost:\n                    worst_cost = cost\n                    worst_edge = (k, (k+1)%n)\n\n            # Find the best possible swap for this edge\n            a, b = worst_edge\n            best_swap = None\n            best_improvement = 0\n            for c in range(n):\n                for d in range(n):\n                    if c == d or c == a or c == b or d == a or d == b:\n                        continue\n                    # Calculate potential improvement\n                    old_cost = distance_matrix[new_solution[a], new_solution[b]] + distance_matrix[new_solution[c], new_solution[d]]\n                    new_cost = distance_matrix[new_solution[a], new_solution[c]] + distance_matrix[new_solution[b], new_solution[d]]\n                    improvement = old_cost - new_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (c, d)\n\n            # Perform the best swap if it improves the solution\n            if best_swap and best_improvement > 0:\n                c, d = best_swap\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6116972494735075,
            2.608193838596344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3D-aware local search operator\n    # Step 1: Random segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Objective-specific edge swaps\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        if np.random.rand() < 0.3:  # 30% chance to perform swap for each objective\n            # Find the worst edge in this objective\n            current_cost = 0\n            worst_edge = (0, 1)\n            worst_cost = -float('inf')\n            for k in range(n):\n                u = new_solution[k]\n                v = new_solution[(k+1)%n]\n                cost = distance_matrix[u, v]\n                current_cost += cost\n                if cost > worst_cost:\n                    worst_cost = cost\n                    worst_edge = (k, (k+1)%n)\n\n            # Find the best possible swap for this edge\n            a, b = worst_edge\n            best_swap = None\n            best_improvement = 0\n            for c in range(n):\n                for d in range(n):\n                    if c == d or c == a or c == b or d == a or d == b:\n                        continue\n                    # Calculate potential improvement\n                    old_cost = distance_matrix[new_solution[a], new_solution[b]] + distance_matrix[new_solution[c], new_solution[d]]\n                    new_cost = distance_matrix[new_solution[a], new_solution[c]] + distance_matrix[new_solution[b], new_solution[d]]\n                    improvement = old_cost - new_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (c, d)\n\n            # Perform the best swap if it improves the solution\n            if best_swap and best_improvement > 0:\n                c, d = best_swap\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution from the archive with the best average objective value across all three objectives, then applies a novel multi-objective segment inversion and edge reconnection operator that intelligently balances improvements across all objectives while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best average objective value\n    avg_objectives = [(sum(obj)/3, idx) for idx, (_, obj) in enumerate(archive)]\n    selected_idx = max(avg_objectives, key=lambda x: x[0])[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(n//2, 10))\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_start < seg_end:\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n    else:\n        new_solution = np.concatenate([new_solution[seg_start:], new_solution[:seg_end][::-1], new_solution[seg_end:seg_start]])\n\n    # Multi-objective edge reconnection\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Evaluate all possible reconnections\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[b:c+1], new_solution[a+1:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[a:c+1], new_solution[b+1:a], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[c:b-1:-1], new_solution[a+1:c], new_solution[b+1:]])\n    ]\n\n    # Select best option based on multi-objective improvement\n    best_option = None\n    best_improvement = -float('inf')\n\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        original_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        improvement = (original_cost1 - cost1) + (original_cost2 - cost2) + (original_cost3 - cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_option = opt\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7466180044641804,
            1.1236290335655212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best average objective value\n    avg_objectives = [(sum(obj)/3, idx) for idx, (_, obj) in enumerate(archive)]\n    selected_idx = max(avg_objectives, key=lambda x: x[0])[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(n//2, 10))\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_start < seg_end:\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n    else:\n        new_solution = np.concatenate([new_solution[seg_start:], new_solution[:seg_end][::-1], new_solution[seg_end:seg_start]])\n\n    # Multi-objective edge reconnection\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Evaluate all possible reconnections\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[b:c+1], new_solution[a+1:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[a:c+1], new_solution[b+1:a], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[c:b-1:-1], new_solution[a+1:c], new_solution[b+1:]])\n    ]\n\n    # Select best option based on multi-objective improvement\n    best_option = None\n    best_improvement = -float('inf')\n\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        original_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        improvement = (original_cost1 - cost1) + (original_cost2 - cost2) + (original_cost3 - cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_option = opt\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance in one objective while being competitive in others, then applies a novel multi-segment inversion and insertion operator that simultaneously optimizes all three objectives by considering their trade-offs in the selection of segments to modify.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is Pareto-dominant in one objective but not extreme in others\n    objectives = [obj for _, obj in archive]\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    range_obj = max_obj - min_obj\n\n    # Find solutions that are not extreme in any objective\n    candidates = []\n    for i, obj in enumerate(objectives):\n        normalized = (obj - min_obj) / range_obj\n        if not any(normalized > 0.7 for normalized in normalized):\n            candidates.append(i)\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-segment inversion and insertion operator\n    k = np.random.randint(2, 5)  # Number of segments to modify\n    indices = sorted(np.random.choice(n, k, replace=False))\n\n    # Invert segments and consider objective trade-offs\n    for i in range(0, k-1, 2):\n        if i+1 < k:\n            a, b = indices[i], indices[i+1]\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Evaluate and select the best insertion points considering all objectives\n    for i in range(1, k):\n        a, b = indices[i-1], indices[i]\n        segment = new_solution[a:b]\n\n        # Find insertion points that balance all objectives\n        best_pos = a\n        best_cost = float('inf')\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            total_cost = (cost1 + cost2 + cost3) / (1 + abs(cost1-cost2) + abs(cost2-cost3))\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6974064358584117,
            4.155606591701508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is Pareto-dominant in one objective but not extreme in others\n    objectives = [obj for _, obj in archive]\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    range_obj = max_obj - min_obj\n\n    # Find solutions that are not extreme in any objective\n    candidates = []\n    for i, obj in enumerate(objectives):\n        normalized = (obj - min_obj) / range_obj\n        if not any(normalized > 0.7 for normalized in normalized):\n            candidates.append(i)\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-segment inversion and insertion operator\n    k = np.random.randint(2, 5)  # Number of segments to modify\n    indices = sorted(np.random.choice(n, k, replace=False))\n\n    # Invert segments and consider objective trade-offs\n    for i in range(0, k-1, 2):\n        if i+1 < k:\n            a, b = indices[i], indices[i+1]\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Evaluate and select the best insertion points considering all objectives\n    for i in range(1, k):\n        a, b = indices[i-1], indices[i]\n        segment = new_solution[a:b]\n\n        # Find insertion points that balance all objectives\n        best_pos = a\n        best_cost = float('inf')\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            total_cost = (cost1 + cost2 + cost3) / (1 + abs(cost1-cost2) + abs(cost2-cost3))\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This heuristic function selects a solution from the archive based on its objective diversity, applies a hybrid 2-opt and node relocation operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a nearest neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid 2-opt and node relocation\n    def evaluate_move(sol, a, b):\n        # Try 2-opt move\n        opt1 = np.concatenate([sol[:a], sol[a:b+1][::-1], sol[b+1:]])\n        # Try node relocation\n        opt2 = np.concatenate([sol[:a], sol[a+1:b+1], [sol[a]], sol[b+1:]])\n\n        # Evaluate both options across all three objectives\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (cost1 + cost2 + cost3, solution)\n\n        cost1, sol1 = calculate_cost(opt1)\n        cost2, sol2 = calculate_cost(opt2)\n\n        return sol1 if cost1 < cost2 else sol2\n\n    # Randomly select two nodes to modify\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    new_solution = evaluate_move(new_solution, a, b)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbor\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6318074570547314,
            1.227781629562378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid 2-opt and node relocation\n    def evaluate_move(sol, a, b):\n        # Try 2-opt move\n        opt1 = np.concatenate([sol[:a], sol[a:b+1][::-1], sol[b+1:]])\n        # Try node relocation\n        opt2 = np.concatenate([sol[:a], sol[a+1:b+1], [sol[a]], sol[b+1:]])\n\n        # Evaluate both options across all three objectives\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (cost1 + cost2 + cost3, solution)\n\n        cost1, sol1 = calculate_cost(opt1)\n        cost2, sol2 = calculate_cost(opt2)\n\n        return sol1 if cost1 < cost2 else sol2\n\n    # Randomly select two nodes to modify\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    new_solution = evaluate_move(new_solution, a, b)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbor\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt and edge exchange with additional constraints to ensure feasibility and potentially improve solutions across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with dynamic selection of segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with distance-based selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Additional move: reverse a random segment if it improves the worst objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    temp_solution = new_solution.copy()\n    temp_solution[k:l] = temp_solution[k:l][::-1]\n\n    # Calculate objectives for the new segment\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n    temp_obj = calculate_objective(temp_solution)\n\n    # Accept if at least one objective improves\n    if any(t < c for t, c in zip(temp_obj, current_obj)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6179916084087161,
            1.3428061723709106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with dynamic selection of segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with distance-based selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Additional move: reverse a random segment if it improves the worst objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    temp_solution = new_solution.copy()\n    temp_solution[k:l] = temp_solution[k:l][::-1]\n\n    # Calculate objectives for the new segment\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n    temp_obj = calculate_objective(temp_solution)\n\n    # Accept if at least one objective improves\n    if any(t < c for t, c in zip(temp_obj, current_obj)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) / 3)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges and perform a three-way rotation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a != 0 and b != 0 and c != 0:  # Ensure no rotation at the starting point\n        # Rotate the edges between a, b, and c\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.619792072901521,
            1.1592218995094299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) / 3)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges and perform a three-way rotation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a != 0 and b != 0 and c != 0:  # Ensure no rotation at the starting point\n        # Rotate the edges between a, b, and c\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a novel \"objective-aware segment inversion\" operator that inverts segments of the tour while considering the relative importance of each objective in the current solution, ensuring feasibility through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = objectives[selected_idx]\n\n    # Objective-aware segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment inversion based on objective weights\n    weights = current_obj / current_obj.sum()\n    obj_weights = np.cumsum(weights)\n    rand_val = np.random.rand()\n\n    if rand_val < obj_weights[0]:\n        # Invert segment based on first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif rand_val < obj_weights[1]:\n        # Invert segment based on second objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Invert segment based on third objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6004736545810924,
            1.401379907131195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = objectives[selected_idx]\n\n    # Objective-aware segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment inversion based on objective weights\n    weights = current_obj / current_obj.sum()\n    obj_weights = np.cumsum(weights)\n    rand_val = np.random.rand()\n\n    if rand_val < obj_weights[0]:\n        # Invert segment based on first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif rand_val < obj_weights[1]:\n        # Invert segment based on second objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Invert segment based on third objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest combined objective value, applies a novel multi-objective path relocation operator that simultaneously optimizes across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply path relocation operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Find the best position to insert the segment\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        candidate = np.insert(remaining, pos, segment)\n\n        # Calculate total cost across all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7008370415374583,
            2.7313024759292603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply path relocation operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Find the best position to insert the segment\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        candidate = np.insert(remaining, pos, segment)\n\n        # Calculate total cost across all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, applies a novel multi-segment inversion operator that simultaneously optimizes across all three objectives by inverting multiple non-overlapping segments of the tour, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-segment inversion operator\n    num_segments = np.random.randint(2, 4)  # Randomly choose 2 or 3 segments\n    segment_lengths = np.random.choice(range(2, n//2), size=num_segments, replace=False)\n    segment_starts = np.random.choice(range(n), size=num_segments, replace=False)\n\n    # Sort segments by start position\n    sorted_segments = sorted(zip(segment_starts, segment_lengths), key=lambda x: x[0])\n\n    # Apply inversions to non-overlapping segments\n    for start, length in sorted_segments:\n        end = start + length\n        if end <= n:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6758455253212723,
            1.2941911458969115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-segment inversion operator\n    num_segments = np.random.randint(2, 4)  # Randomly choose 2 or 3 segments\n    segment_lengths = np.random.choice(range(2, n//2), size=num_segments, replace=False)\n    segment_starts = np.random.choice(range(n), size=num_segments, replace=False)\n\n    # Sort segments by start position\n    sorted_segments = sorted(zip(segment_starts, segment_lengths), key=lambda x: x[0])\n\n    # Apply inversions to non-overlapping segments\n    for start, length in sorted_segments:\n        end = start + length\n        if end <= n:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement across all three objectives, then applies a hybrid local search operator that combines node insertion with a multi-objective-aware edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with multi-objective consideration\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i:\n        j = np.random.randint(0, n)\n\n    # Evaluate potential insertion points based on all three objectives\n    best_insert_pos = i\n    min_total_cost = float('inf')\n\n    for pos in range(n):\n        temp_solution = new_solution.copy()\n        temp_solution = np.insert(temp_solution, pos, temp_solution[j])\n        temp_solution = np.delete(temp_solution, j + (1 if pos <= j else 0))\n\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        cost3 = sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = pos\n\n    new_solution = np.insert(new_solution, best_insert_pos, new_solution[j])\n    new_solution = np.delete(new_solution, j + (1 if best_insert_pos <= j else 0))\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate the exchange based on all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[c]] +\n            distance_matrix_1[new_solution[d-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[c]] +\n            distance_matrix_2[new_solution[d-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[c]] +\n            distance_matrix_3[new_solution[d-1], new_solution[b]]\n        )\n\n        if new_cost < original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5937928254707343,
            4.23272750377655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with multi-objective consideration\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i:\n        j = np.random.randint(0, n)\n\n    # Evaluate potential insertion points based on all three objectives\n    best_insert_pos = i\n    min_total_cost = float('inf')\n\n    for pos in range(n):\n        temp_solution = new_solution.copy()\n        temp_solution = np.insert(temp_solution, pos, temp_solution[j])\n        temp_solution = np.delete(temp_solution, j + (1 if pos <= j else 0))\n\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        cost3 = sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = pos\n\n    new_solution = np.insert(new_solution, best_insert_pos, new_solution[j])\n    new_solution = np.delete(new_solution, j + (1 if best_insert_pos <= j else 0))\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate the exchange based on all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[c]] +\n            distance_matrix_1[new_solution[d-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[c]] +\n            distance_matrix_2[new_solution[d-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[c]] +\n            distance_matrix_3[new_solution[d-1], new_solution[b]]\n        )\n\n        if new_cost < original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of objective values, then applies a novel multi-segment inversion operator that reverses segments of varying lengths across all three objectives simultaneously, ensuring feasibility through a segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest sum of objectives (most \"challenging\" to improve)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply multi-segment inversion operator\n    num_segments = np.random.randint(2, 4)  # Random number of segments to invert (2-3)\n    segment_lengths = np.random.randint(2, n//3, size=num_segments)  # Random segment lengths\n    start_positions = np.random.choice(n, num_segments, replace=False)  # Random start positions\n\n    for length, start in zip(segment_lengths, start_positions):\n        end = start + length\n        if end > n:\n            end = n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Validate and repair the solution\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, replace them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if new_solution[i] in unique[counts > 1]:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7072854227486546,
            1.29503892660141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest sum of objectives (most \"challenging\" to improve)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply multi-segment inversion operator\n    num_segments = np.random.randint(2, 4)  # Random number of segments to invert (2-3)\n    segment_lengths = np.random.randint(2, n//3, size=num_segments)  # Random segment lengths\n    start_positions = np.random.choice(n, num_segments, replace=False)  # Random start positions\n\n    for length, start in zip(segment_lengths, start_positions):\n        end = start + length\n        if end > n:\n            end = n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Validate and repair the solution\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, replace them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if new_solution[i] in unique[counts > 1]:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Apply segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6674976812919937,
            1.117425537109375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Apply segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{A novel tri-objective local search algorithm that combines adaptive segment inversion with multi-objective edge exchange, prioritizing solutions with balanced improvement potential across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective diversity\n    obj_diff = max(objectives) - min(objectives)\n    segment_size = max(2, min(10, int(n * 0.2 * (1 + obj_diff / max(objectives)))))\n    i = np.random.randint(0, n - segment_size)\n    new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate exchange impact across all objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[d]]\n                     + distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_1[new_solution[a], new_solution[d]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[d]]\n                     + distance_matrix_2[new_solution[b], new_solution[c]] + distance_matrix_2[new_solution[a], new_solution[d]])\n            delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[c-1], new_solution[d]]\n                     + distance_matrix_3[new_solution[b], new_solution[c]] + distance_matrix_3[new_solution[a], new_solution[d]])\n            if (delta1 < objectives[0] or delta2 < objectives[1] or delta3 < objectives[2]):\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6012041175078446,
            1.3896565794944764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective diversity\n    obj_diff = max(objectives) - min(objectives)\n    segment_size = max(2, min(10, int(n * 0.2 * (1 + obj_diff / max(objectives)))))\n    i = np.random.randint(0, n - segment_size)\n    new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate exchange impact across all objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[d]]\n                     + distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_1[new_solution[a], new_solution[d]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[d]]\n                     + distance_matrix_2[new_solution[b], new_solution[c]] + distance_matrix_2[new_solution[a], new_solution[d]])\n            delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[c-1], new_solution[d]]\n                     + distance_matrix_3[new_solution[b], new_solution[c]] + distance_matrix_3[new_solution[a], new_solution[d]])\n            if (delta1 < objectives[0] or delta2 < objectives[1] or delta3 < objectives[2]):\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -float('inf')\n    selected_solution = None\n    for sol, obj in archive:\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        current_sum = sum(norm_obj)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator combining 3-opt and edge exchange\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5095723263135346,
            3.475905454158783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -float('inf')\n    selected_solution = None\n    for sol, obj in archive:\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        current_sum = sum(norm_obj)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator combining 3-opt and edge exchange\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution with the highest diversity in objectives from the archive, applies a hybrid local search combining 2-opt and insertion operators to optimize across all three objectives, and ensures feasibility by repairing any invalid tours with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest diversity in objectives)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.max(obj) - np.min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt + insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to flip (2-opt)\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    # Create two possible 2-opt moves and evaluate their impact across all objectives\n    def evaluate_2opt(sol, a, b):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_2opt(new_solution, a, b)\n\n    # Randomly select a node to reinsert (insertion operator)\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = new_solution[mask]\n\n    # Find the best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node_to_move)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4953484886846569,
            4.435470986366272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest diversity in objectives)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.max(obj) - np.min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt + insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to flip (2-opt)\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    # Create two possible 2-opt moves and evaluate their impact across all objectives\n    def evaluate_2opt(sol, a, b):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_2opt(new_solution, a, b)\n\n    # Randomly select a node to reinsert (insertion operator)\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = new_solution[mask]\n\n    # Find the best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node_to_move)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement across multiple objectives, applies a hybrid 4-opt local search operator that considers all three objectives simultaneously, and repairs any infeasibilities using a multi-objective greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmin([sum(obj) for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[d:c+1][::-1], sol[b+1:d], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[c:d+1][::-1], sol[a+1:c], sol[b:d+1][::-1], sol[c+1:b], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:c+1][::-1], sol[a+1:d], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7083335742738445,
            0.5052360892295837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmin([sum(obj) for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[d:c+1][::-1], sol[b+1:d], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[c:d+1][::-1], sol[a+1:c], sol[b:d+1][::-1], sol[c+1:b], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:c+1][::-1], sol[a+1:d], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel hybrid local search combining 2-opt, edge exchange, and objective-aware node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt move on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Objective-aware node insertion: find the node with the highest improvement potential\n    total_costs = [sum([distance_matrix_1[new_solution[k]][new_solution[k+1]] for k in range(n-1)] + [distance_matrix_1[new_solution[-1]][new_solution[0]]]),\n                   sum([distance_matrix_2[new_solution[k]][new_solution[k+1]] for k in range(n-1)] + [distance_matrix_2[new_solution[-1]][new_solution[0]]]),\n                   sum([distance_matrix_3[new_solution[k]][new_solution[k+1]] for k in range(n-1)] + [distance_matrix_3[new_solution[-1]][new_solution[0]]])]\n\n    # Find the node that, when moved, would most improve the worst-performing objective\n    worst_obj = np.argmax(total_costs)\n    if worst_obj == 0:\n        distances = distance_matrix_1\n    elif worst_obj == 1:\n        distances = distance_matrix_2\n    else:\n        distances = distance_matrix_3\n\n    best_improvement = 0\n    best_pos = -1\n    best_node = -1\n\n    for pos in range(n):\n        for node in range(n):\n            if node == new_solution[pos]:\n                continue\n            # Calculate the cost difference for moving node to position pos\n            old_cost = distances[new_solution[pos-1]][new_solution[pos]] + distances[new_solution[pos]][new_solution[(pos+1)%n]]\n            new_cost = distances[new_solution[pos-1]][node] + distances[node][new_solution[(pos+1)%n]]\n            improvement = old_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n                best_node = node\n\n    if best_pos != -1:\n        # Remove the node from its current position\n        current_pos = np.where(new_solution == best_node)[0][0]\n        new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:]])\n        # Insert it at the new position\n        new_solution = np.insert(new_solution, best_pos, best_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6044967866338157,
            3.282229447364807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a novel hybrid local search combining 2-opt, edge exchange, and objective-aware node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt move on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Objective-aware node insertion: find the node with the highest improvement potential\n    total_costs = [sum([distance_matrix_1[new_solution[k]][new_solution[k+1]] for k in range(n-1)] + [distance_matrix_1[new_solution[-1]][new_solution[0]]]),\n                   sum([distance_matrix_2[new_solution[k]][new_solution[k+1]] for k in range(n-1)] + [distance_matrix_2[new_solution[-1]][new_solution[0]]]),\n                   sum([distance_matrix_3[new_solution[k]][new_solution[k+1]] for k in range(n-1)] + [distance_matrix_3[new_solution[-1]][new_solution[0]]])]\n\n    # Find the node that, when moved, would most improve the worst-performing objective\n    worst_obj = np.argmax(total_costs)\n    if worst_obj == 0:\n        distances = distance_matrix_1\n    elif worst_obj == 1:\n        distances = distance_matrix_2\n    else:\n        distances = distance_matrix_3\n\n    best_improvement = 0\n    best_pos = -1\n    best_node = -1\n\n    for pos in range(n):\n        for node in range(n):\n            if node == new_solution[pos]:\n                continue\n            # Calculate the cost difference for moving node to position pos\n            old_cost = distances[new_solution[pos-1]][new_solution[pos]] + distances[new_solution[pos]][new_solution[(pos+1)%n]]\n            new_cost = distances[new_solution[pos-1]][node] + distances[node][new_solution[(pos+1)%n]]\n            improvement = old_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n                best_node = node\n\n    if best_pos != -1:\n        # Remove the node from its current position\n        current_pos = np.where(new_solution == best_node)[0][0]\n        new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:]])\n        # Insert it at the new position\n        new_solution = np.insert(new_solution, best_pos, best_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The new algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a novel \"multi-objective edge insertion\" operator that intelligently inserts and removes edges while considering all three objectives to balance improvements across all dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion operator\n    if n > 3:\n        # Select a random edge to remove\n        i = np.random.randint(0, n-1)\n        removed_node = new_solution[i+1]\n\n        # Calculate potential insertion points considering all three objectives\n        insertion_scores = []\n        for j in range(1, n-1):\n            if j != i and j != i+1:\n                # Calculate total cost change for all three objectives\n                cost_change = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                              distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] -\n                              distance_matrix_1[new_solution[i], new_solution[i+1]] -\n                              distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) * weights[0] + \\\n                             (distance_matrix_2[new_solution[i], new_solution[j]] +\n                              distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] -\n                              distance_matrix_2[new_solution[i], new_solution[i+1]] -\n                              distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) * weights[1] + \\\n                             (distance_matrix_3[new_solution[i], new_solution[j]] +\n                              distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]] -\n                              distance_matrix_3[new_solution[i], new_solution[i+1]] -\n                              distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) * weights[2]\n                insertion_scores.append((cost_change, j))\n\n        if insertion_scores:\n            # Choose the insertion point with the best multi-objective score\n            best_score, best_j = min(insertion_scores, key=lambda x: x[0])\n            new_solution = np.concatenate([new_solution[:i+1], [removed_node], new_solution[i+1:best_j], new_solution[best_j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6596570561967389,
            1.0306703090667724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion operator\n    if n > 3:\n        # Select a random edge to remove\n        i = np.random.randint(0, n-1)\n        removed_node = new_solution[i+1]\n\n        # Calculate potential insertion points considering all three objectives\n        insertion_scores = []\n        for j in range(1, n-1):\n            if j != i and j != i+1:\n                # Calculate total cost change for all three objectives\n                cost_change = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                              distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] -\n                              distance_matrix_1[new_solution[i], new_solution[i+1]] -\n                              distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) * weights[0] + \\\n                             (distance_matrix_2[new_solution[i], new_solution[j]] +\n                              distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] -\n                              distance_matrix_2[new_solution[i], new_solution[i+1]] -\n                              distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) * weights[1] + \\\n                             (distance_matrix_3[new_solution[i], new_solution[j]] +\n                              distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]] -\n                              distance_matrix_3[new_solution[i], new_solution[i+1]] -\n                              distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) * weights[2]\n                insertion_scores.append((cost_change, j))\n\n        if insertion_scores:\n            # Choose the insertion point with the best multi-objective score\n            best_score, best_j = min(insertion_scores, key=lambda x: x[0])\n            new_solution = np.concatenate([new_solution[:i+1], [removed_node], new_solution[i+1:best_j], new_solution[best_j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive with the highest average objective value, then applies a novel multi-objective segment inversion operator that inverts segments of the tour while considering the trade-offs across all three objectives, ensuring feasibility by repairing any duplicates with a minimal perturbation strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / 3)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective segment inversion\n    # Randomly select a segment to invert\n    k = np.random.randint(2, n // 2)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    inverted_segment = segment[::-1]\n\n    # Evaluate the inversion across all objectives\n    original_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    original_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n    original_cost3 = sum(distance_matrix_3[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) + distance_matrix_3[selected_solution[-1], selected_solution[0]]\n\n    new_solution[start:start+k] = inverted_segment\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # If the inversion doesn't improve at least one objective, revert it\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2 and new_cost3 >= original_cost3):\n        new_solution[start:start+k] = segment\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Minimal perturbation repair\n        for node in unique[counts > 1]:\n            # Find the first occurrence and swap with the next node\n            indices = np.where(new_solution == node)[0]\n            if len(indices) > 1:\n                new_solution[indices[0]], new_solution[indices[1]] = new_solution[indices[1]], new_solution[indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.7017217118363254,
            1.2748766660690307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / 3)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective segment inversion\n    # Randomly select a segment to invert\n    k = np.random.randint(2, n // 2)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    inverted_segment = segment[::-1]\n\n    # Evaluate the inversion across all objectives\n    original_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    original_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n    original_cost3 = sum(distance_matrix_3[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) + distance_matrix_3[selected_solution[-1], selected_solution[0]]\n\n    new_solution[start:start+k] = inverted_segment\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # If the inversion doesn't improve at least one objective, revert it\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2 and new_cost3 >= original_cost3):\n        new_solution[start:start+k] = segment\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Minimal perturbation repair\n        for node in unique[counts > 1]:\n            # Find the first occurrence and swap with the next node\n            indices = np.where(new_solution == node)[0]\n            if len(indices) > 1:\n                new_solution[indices[0]], new_solution[indices[1]] = new_solution[indices[1]], new_solution[indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement and applies a novel 3-way segment rotation operator that simultaneously reorders three randomly selected segments in the tour to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments and perform a 3-way segment rotation\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Rotate segments in a circular fashion\n    new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6095693146376243,
            0.8332667350769043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments and perform a 3-way segment rotation\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Rotate segments in a circular fashion\n    new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement across all three objectives, then applies a novel adaptive multi-segment inversion operator that dynamically adjusts the segment size based on the relative improvement potential in each objective space, ensuring feasibility through a repair mechanism that maintains tour validity while optimizing across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest potential for improvement (lowest min objective)\n    objectives = [min(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive multi-segment inversion\n    num_segments = np.random.randint(2, 4)  # Randomly choose 2 or 3 segments\n    segment_points = sorted(np.random.choice(n, num_segments + 1, replace=False))\n\n    # Determine segment sizes based on relative improvement potential\n    total_improvement = sum(archive[selected_idx][1])\n    segment_weights = []\n    for i in range(num_segments):\n        start, end = segment_points[i], segment_points[i+1]\n        segment_length = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n        segment_weights.append(segment_length / total_improvement)\n\n    # Invert segments with probability proportional to their weight\n    for i in range(num_segments):\n        if np.random.random() < segment_weights[i]:\n            start, end = segment_points[i], segment_points[i+1]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.37508114787590724,
            2.7931166887283325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest potential for improvement (lowest min objective)\n    objectives = [min(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive multi-segment inversion\n    num_segments = np.random.randint(2, 4)  # Randomly choose 2 or 3 segments\n    segment_points = sorted(np.random.choice(n, num_segments + 1, replace=False))\n\n    # Determine segment sizes based on relative improvement potential\n    total_improvement = sum(archive[selected_idx][1])\n    segment_weights = []\n    for i in range(num_segments):\n        start, end = segment_points[i], segment_points[i+1]\n        segment_length = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n        segment_weights.append(segment_length / total_improvement)\n\n    # Invert segments with probability proportional to their weight\n    for i in range(num_segments):\n        if np.random.random() < segment_weights[i]:\n            start, end = segment_points[i], segment_points[i+1]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This heuristic selects a solution from the archive with the highest sum of normalized objective values, applies a novel multi-objective 2.5-opt operator that combines 2-opt and 3-opt moves, and ensures feasibility by repairing duplicates with a greedy insertion strategy tailored to balance all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2.5-opt: combine 2-opt and 3-opt moves\n    def evaluate_move(sol):\n        # Randomly choose between 2-opt and 3-opt\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            a, b = np.random.choice(n, 2, replace=False)\n            a, b = sorted([a, b])\n            options = [\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n                np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n            ]\n        else:\n            # 3-opt move\n            a, b, c = np.random.choice(n, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n        # Evaluate options across all objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7000771880523535,
            1.0901769638061523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2.5-opt: combine 2-opt and 3-opt moves\n    def evaluate_move(sol):\n        # Randomly choose between 2-opt and 3-opt\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            a, b = np.random.choice(n, 2, replace=False)\n            a, b = sorted([a, b])\n            options = [\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n                np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n            ]\n        else:\n            # 3-opt move\n            a, b, c = np.random.choice(n, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n        # Evaluate options across all objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel multi-segment inversion and node swap operator that intelligently reorders segments and swaps nodes based on their relative performance across objectives, while ensuring feasibility through a dynamic repair mechanism that prioritizes nodes with high impact on objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion operator\n    num_segments = np.random.randint(2, 5)\n    segment_length = max(1, n // num_segments)\n    for i in range(num_segments):\n        start = i * segment_length\n        end = min((i + 1) * segment_length, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Node swap operator based on objective impact\n    for _ in range(min(3, n // 2)):\n        # Select two nodes to swap\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Evaluate potential swap across all objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i], new_solution[j+1 if j+1 < n else 0]]\n        )\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair to ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Find missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        # Find duplicate nodes\n        duplicate_nodes = unique[counts > 1]\n\n        # Replace duplicates with missing nodes\n        for dup in duplicate_nodes:\n            if len(missing_nodes) > 0:\n                new_solution[new_solution == dup] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6923771500145073,
            1.5884948134422303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion operator\n    num_segments = np.random.randint(2, 5)\n    segment_length = max(1, n // num_segments)\n    for i in range(num_segments):\n        start = i * segment_length\n        end = min((i + 1) * segment_length, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Node swap operator based on objective impact\n    for _ in range(min(3, n // 2)):\n        # Select two nodes to swap\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Evaluate potential swap across all objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[j+1 if j+1 < n else 0]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i], new_solution[j+1 if j+1 < n else 0]]\n        )\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair to ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Find missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        # Find duplicate nodes\n        duplicate_nodes = unique[counts > 1]\n\n        # Replace duplicates with missing nodes\n        for dup in duplicate_nodes:\n            if len(missing_nodes) > 0:\n                new_solution[new_solution == dup] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective hybrid local search operator combining 3-opt and 2-opt moves, and ensures feasibility by repairing any duplicate nodes with a greedy multi-objective insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search combining 3-opt and 2-opt\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments for modification\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Create hybrid move options\n    def evaluate_move(sol, x, y, z, w):\n        # Hybrid move combining 3-opt and 2-opt\n        options = [\n            # 3-opt style moves\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),\n            np.concatenate([sol[:x+1], sol[x:y+1][::-1], sol[y+1:z+1][::-1], sol[z+1:]]),\n\n            # 2-opt style moves\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n\n            # Multi-objective evaluation with weighted sum\n            weighted_cost = 0.33*(cost1 + cost2 + cost3)\n            costs.append((weighted_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy multi-objective insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n                # Multi-objective evaluation for insertion\n                total_cost = 0.33*(cost1 + cost2 + cost3)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8312281503136582,
            4.0771058917045595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search combining 3-opt and 2-opt\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments for modification\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Create hybrid move options\n    def evaluate_move(sol, x, y, z, w):\n        # Hybrid move combining 3-opt and 2-opt\n        options = [\n            # 3-opt style moves\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),\n            np.concatenate([sol[:x+1], sol[x:y+1][::-1], sol[y+1:z+1][::-1], sol[z+1:]]),\n\n            # 2-opt style moves\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n\n            # Multi-objective evaluation with weighted sum\n            weighted_cost = 0.33*(cost1 + cost2 + cost3)\n            costs.append((weighted_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy multi-objective insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n                # Multi-objective evaluation for insertion\n                total_cost = 0.33*(cost1 + cost2 + cost3)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective aware edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    if a != c and b != d:\n        # Calculate the change in objectives\n        old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]])\n\n        # Only accept if the new cost is better in at least one objective\n        if new_cost < old_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6366776953395439,
            1.1155241966247558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective aware edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    if a != c and b != d:\n        # Calculate the change in objectives\n        old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]])\n\n        # Only accept if the new cost is better in at least one objective\n        if new_cost < old_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest sum of normalized objective values, applies a hybrid 2-opt and edge insertion operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a nearest neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    sums = normalized.sum(axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and edge insertion\n    def evaluate_move(sol, a, b):\n        # Try 2-opt\n        opt1 = np.concatenate([sol[:a], sol[a:b+1][::-1], sol[b+1:]])\n        # Try edge insertion (move segment to another position)\n        segment = sol[a:b+1]\n        opt2 = np.concatenate([sol[:a], sol[b+1:]])\n        insert_pos = np.random.randint(0, len(opt2)+1)\n        opt2 = np.insert(opt2, insert_pos, segment)\n\n        # Evaluate both options across all objectives\n        def calculate_cost(s):\n            cost1 = sum(distance_matrix_1[s[i], s[i+1]] for i in range(n-1)) + distance_matrix_1[s[-1], s[0]]\n            cost2 = sum(distance_matrix_2[s[i], s[i+1]] for i in range(n-1)) + distance_matrix_2[s[-1], s[0]]\n            cost3 = sum(distance_matrix_3[s[i], s[i+1]] for i in range(n-1)) + distance_matrix_3[s[-1], s[0]]\n            return cost1 + cost2 + cost3\n\n        cost1 = calculate_cost(opt1)\n        cost2 = calculate_cost(opt2)\n\n        return opt1 if cost1 < cost2 else opt2\n\n    # Randomly select two edges to modify\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    new_solution = evaluate_move(new_solution, a, b)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        for node in np.setdiff1d(np.arange(n), unique):\n            # Find nearest neighbor in current solution\n            pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6958244875529165,
            1.586508297920227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    sums = normalized.sum(axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and edge insertion\n    def evaluate_move(sol, a, b):\n        # Try 2-opt\n        opt1 = np.concatenate([sol[:a], sol[a:b+1][::-1], sol[b+1:]])\n        # Try edge insertion (move segment to another position)\n        segment = sol[a:b+1]\n        opt2 = np.concatenate([sol[:a], sol[b+1:]])\n        insert_pos = np.random.randint(0, len(opt2)+1)\n        opt2 = np.insert(opt2, insert_pos, segment)\n\n        # Evaluate both options across all objectives\n        def calculate_cost(s):\n            cost1 = sum(distance_matrix_1[s[i], s[i+1]] for i in range(n-1)) + distance_matrix_1[s[-1], s[0]]\n            cost2 = sum(distance_matrix_2[s[i], s[i+1]] for i in range(n-1)) + distance_matrix_2[s[-1], s[0]]\n            cost3 = sum(distance_matrix_3[s[i], s[i+1]] for i in range(n-1)) + distance_matrix_3[s[-1], s[0]]\n            return cost1 + cost2 + cost3\n\n        cost1 = calculate_cost(opt1)\n        cost2 = calculate_cost(opt2)\n\n        return opt1 if cost1 < cost2 else opt2\n\n    # Randomly select two edges to modify\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    new_solution = evaluate_move(new_solution, a, b)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        for node in np.setdiff1d(np.arange(n), unique):\n            # Find nearest neighbor in current solution\n            pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This algorithm selects a solution with the highest diversity in objectives, applies a multi-objective 4-opt operator with adaptive segment selection, and repairs any infeasibilities using a Pareto-optimal insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search with adaptive segment selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select four edges to modify based on objective diversity\n    def select_segments():\n        obj_diffs = [abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0]) for _, obj in archive]\n        weights = np.exp(obj_diffs / np.sum(obj_diffs))  # Higher weight for more diverse solutions\n        selected = np.random.choice(len(archive), p=weights/np.sum(weights))\n        return archive[selected][0]\n\n    ref_solution = select_segments()\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create four possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[a:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist using Pareto-optimal insertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find insertion positions that improve at least one objective\n            candidates = []\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                candidates.append((cost1, cost2, cost3, pos))\n\n            # Select insertion that dominates most others\n            dominated = np.zeros(len(candidates))\n            for i, (c1, c2, c3, _) in enumerate(candidates):\n                for j, (c1j, c2j, c3j, _) in enumerate(candidates):\n                    if (c1 <= c1j and c2 <= c2j and c3 <= c3j) and (c1 < c1j or c2 < c2j or c3 < c3j):\n                        dominated[i] += 1\n            best_pos = candidates[np.argmax(dominated)][3]\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7258939165270559,
            1.31243999004364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search with adaptive segment selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select four edges to modify based on objective diversity\n    def select_segments():\n        obj_diffs = [abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0]) for _, obj in archive]\n        weights = np.exp(obj_diffs / np.sum(obj_diffs))  # Higher weight for more diverse solutions\n        selected = np.random.choice(len(archive), p=weights/np.sum(weights))\n        return archive[selected][0]\n\n    ref_solution = select_segments()\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create four possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[a:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist using Pareto-optimal insertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find insertion positions that improve at least one objective\n            candidates = []\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                candidates.append((cost1, cost2, cost3, pos))\n\n            # Select insertion that dominates most others\n            dominated = np.zeros(len(candidates))\n            for i, (c1, c2, c3, _) in enumerate(candidates):\n                for j, (c1j, c2j, c3j, _) in enumerate(candidates):\n                    if (c1 <= c1j and c2 <= c2j and c3 <= c3j) and (c1 < c1j or c2 < c2j or c3 < c3j):\n                        dominated[i] += 1\n            best_pos = candidates[np.argmax(dominated)][3]\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This heuristic function selects a solution with the highest sum of objectives to explore potentially under-optimized regions, applies a novel 2.5-opt operator that combines 2-opt and 3-opt moves to balance local and global improvements, and ensures feasibility by repairing duplicates with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (hybrid of 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments for modification\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, x, y, z, w):\n        # Create possible reconnections\n        options = [\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),  # 2-opt\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),  # 2-opt\n            np.concatenate([sol[:x+1], sol[x:y+1][::-1], sol[y+1:z+1][::-1], sol[z+1:]]),  # 3-opt\n            np.concatenate([sol[:y+1], sol[y:z+1][::-1], sol[x:y], sol[z+1:]]),  # 3-opt\n            np.concatenate([sol[:x+1], sol[z:w+1][::-1], sol[x+1:z], sol[w+1:]]),  # 2-opt\n            np.concatenate([sol[:w+1], sol[x:y+1][::-1], sol[w+1:x], sol[y+1:]]),  # 2-opt\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6670529228956924,
            1.0359162449836732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (hybrid of 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments for modification\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, x, y, z, w):\n        # Create possible reconnections\n        options = [\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),  # 2-opt\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),  # 2-opt\n            np.concatenate([sol[:x+1], sol[x:y+1][::-1], sol[y+1:z+1][::-1], sol[z+1:]]),  # 3-opt\n            np.concatenate([sol[:y+1], sol[y:z+1][::-1], sol[x:y], sol[z+1:]]),  # 3-opt\n            np.concatenate([sol[:x+1], sol[z:w+1][::-1], sol[x+1:z], sol[w+1:]]),  # 2-opt\n            np.concatenate([sol[:w+1], sol[x:y+1][::-1], sol[w+1:x], sol[y+1:]]),  # 2-opt\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt and multi-objective edge exchange with adaptive neighborhood selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=3)\n    weights /= weights.sum()\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search selection\n    if np.random.rand() < 0.7:\n        # 2-opt with multi-objective awareness\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        # Evaluate segment in all objectives\n        segment_costs = [\n            sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n            sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n            sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        ]\n        # Reverse if beneficial for at least one objective\n        if any(segment_costs[k] > sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment))) for k in range(3)):\n            new_solution[i:j] = segment[::-1]\n    else:\n        # Multi-objective edge exchange\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate all possible swaps\n            candidates = [\n                new_solution.copy(),\n                np.array([new_solution[a], new_solution[c], new_solution[b], new_solution[d]]),\n                np.array([new_solution[a], new_solution[d], new_solution[b], new_solution[c]]),\n                np.array([new_solution[c], new_solution[a], new_solution[d], new_solution[b]])\n            ]\n            # Select best candidate based on weighted sum\n            candidate_costs = [\n                (sum(distance_matrix_1[candidates[i][k], candidates[i][(k+1)%4]] for k in range(4)),\n                 sum(distance_matrix_2[candidates[i][k], candidates[i][(k+1)%4]] for k in range(4)),\n                 sum(distance_matrix_3[candidates[i][k], candidates[i][(k+1)%4]] for k in range(4)))\n                for i in range(4)\n            ]\n            best_idx = max(range(4), key=lambda i: sum(w * v for w, v in zip(weights, candidate_costs[i])))\n            new_solution[[a, b, c, d]] = candidates[best_idx][[0, 2, 1, 3]]\n\n    return new_solution\n\n",
        "score": [
            -0.7196495450493609,
            1.5031367540359497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=3)\n    weights /= weights.sum()\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search selection\n    if np.random.rand() < 0.7:\n        # 2-opt with multi-objective awareness\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        # Evaluate segment in all objectives\n        segment_costs = [\n            sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n            sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n            sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        ]\n        # Reverse if beneficial for at least one objective\n        if any(segment_costs[k] > sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment))) for k in range(3)):\n            new_solution[i:j] = segment[::-1]\n    else:\n        # Multi-objective edge exchange\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate all possible swaps\n            candidates = [\n                new_solution.copy(),\n                np.array([new_solution[a], new_solution[c], new_solution[b], new_solution[d]]),\n                np.array([new_solution[a], new_solution[d], new_solution[b], new_solution[c]]),\n                np.array([new_solution[c], new_solution[a], new_solution[d], new_solution[b]])\n            ]\n            # Select best candidate based on weighted sum\n            candidate_costs = [\n                (sum(distance_matrix_1[candidates[i][k], candidates[i][(k+1)%4]] for k in range(4)),\n                 sum(distance_matrix_2[candidates[i][k], candidates[i][(k+1)%4]] for k in range(4)),\n                 sum(distance_matrix_3[candidates[i][k], candidates[i][(k+1)%4]] for k in range(4)))\n                for i in range(4)\n            ]\n            best_idx = max(range(4), key=lambda i: sum(w * v for w, v in zip(weights, candidate_costs[i])))\n            new_solution[[a, b, c, d]] = candidates[best_idx][[0, 2, 1, 3]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel hybrid local search combining 3-opt with a multi-objective edge reversal strategy to explore diverse neighborhood structures while maintaining feasibility through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply hybrid local search combining 3-opt and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges and perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Three possible 3-opt moves\n    options = [\n        np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i+1], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    costs = []\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        costs.append((cost1 + cost2 + cost3, opt))\n\n    # Select the best 3-opt move\n    best_3opt = min(costs, key=lambda x: x[0])[1]\n    new_solution = best_3opt.copy()\n\n    # Apply edge reversal for further optimization\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6613596428374579,
            0.9907459497451783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply hybrid local search combining 3-opt and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges and perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Three possible 3-opt moves\n    options = [\n        np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i+1], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    costs = []\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        costs.append((cost1 + cost2 + cost3, opt))\n\n    # Select the best 3-opt move\n    best_3opt = min(costs, key=lambda x: x[0])[1]\n    new_solution = best_3opt.copy()\n\n    # Apply edge reversal for further optimization\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This heuristic function selects a solution with the most unbalanced objectives from the archive, applies a novel multi-objective segment reversal with adaptive edge swapping to optimize across all three objectives, and ensures feasibility by repairing any invalid nodes with a distance-based insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most unbalanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmax(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply adaptive segment reversal with edge swapping\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptively swap edges based on their contribution to each objective\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the current cost difference for each objective\n        cost1_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n                     - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n        cost2_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n                     - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n        cost3_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]]\n                     - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n        # Perform swap if it improves any objective\n        if cost1_diff < 0 or cost2_diff < 0 or cost3_diff < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair any duplicates with distance-based insertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5292695001130373,
            4.214944851398468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most unbalanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmax(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply adaptive segment reversal with edge swapping\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptively swap edges based on their contribution to each objective\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the current cost difference for each objective\n        cost1_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n                     - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n        cost2_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n                     - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n        cost3_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]]\n                     - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n        # Perform swap if it improves any objective\n        if cost1_diff < 0 or cost2_diff < 0 or cost3_diff < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair any duplicates with distance-based insertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This heuristic function selects a solution from the archive based on its proximity to the ideal point in objective space, applies a novel multi-objective segment inversion and edge exchange operator to optimize across all three objectives, and ensures feasibility by repairing any invalid nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to the ideal point (minimizing all objectives)\n    objectives = [obj for _, obj in archive]\n    ideal_point = np.min(objectives, axis=0)\n    distances = [np.linalg.norm(np.array(obj) - ideal_point) for obj in objectives]\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segment inversion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and exchange them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7484551207190795,
            1.7332236528396607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to the ideal point (minimizing all objectives)\n    objectives = [obj for _, obj in archive]\n    ideal_point = np.min(objectives, axis=0)\n    distances = [np.linalg.norm(np.array(obj) - ideal_point) for obj in objectives]\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segment inversion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and invert it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and exchange them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, applies a novel multi-segment inversion operator that considers all three objectives simultaneously, and ensures feasibility through a probabilistic repair mechanism that balances cost improvement with solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective (0.4, 0.3, 0.3)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.4, 0.3, 0.3])\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply multi-segment inversion operator\n    segments = np.random.choice(range(2, 6), size=1)[0]  # 2-5 segments\n    split_points = np.sort(np.random.choice(range(1, n-1), size=segments-1, replace=False))\n    split_points = np.concatenate([[0], split_points, [n]])\n\n    for i in range(len(split_points)-1):\n        start, end = split_points[i], split_points[i+1]\n        if np.random.rand() > 0.5:  # 50% chance to invert segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            if np.random.rand() < 0.7:  # 70% chance to insert\n                best_pos = np.random.choice(range(n))  # Random position with 30% chance\n                if np.random.rand() < 0.3:\n                    # Evaluate 3 random positions\n                    candidates = np.random.choice(range(n), size=3, replace=False)\n                    costs = []\n                    for pos in candidates:\n                        candidate = np.insert(new_solution, pos, node)\n                        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                        costs.append((cost1 + cost2 + cost3, pos))\n                    best_pos = min(costs, key=lambda x: x[0])[1]\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5843935844626811,
            1.5529435873031616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective (0.4, 0.3, 0.3)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.4, 0.3, 0.3])\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply multi-segment inversion operator\n    segments = np.random.choice(range(2, 6), size=1)[0]  # 2-5 segments\n    split_points = np.sort(np.random.choice(range(1, n-1), size=segments-1, replace=False))\n    split_points = np.concatenate([[0], split_points, [n]])\n\n    for i in range(len(split_points)-1):\n        start, end = split_points[i], split_points[i+1]\n        if np.random.rand() > 0.5:  # 50% chance to invert segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            if np.random.rand() < 0.7:  # 70% chance to insert\n                best_pos = np.random.choice(range(n))  # Random position with 30% chance\n                if np.random.rand() < 0.3:\n                    # Evaluate 3 random positions\n                    candidates = np.random.choice(range(n), size=3, replace=False)\n                    costs = []\n                    for pos in candidates:\n                        candidate = np.insert(new_solution, pos, node)\n                        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                        costs.append((cost1 + cost2 + cost3, pos))\n                    best_pos = min(costs, key=lambda x: x[0])[1]\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest average objective value, applies a novel multi-objective 2-opt* operator that considers pairwise edge swaps across all objectives, and ensures feasibility by repairing any duplicate nodes with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = [sum(obj)/3 for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt* local search considering all objectives\n    def evaluate_swap(sol, a, b):\n        # Create new solution with edges a-b and c-d swapped\n        new_sol = sol.copy()\n        new_sol[a], new_sol[b] = new_sol[b], new_sol[a]\n        return new_sol\n\n    # Randomly select two edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution = evaluate_swap(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbors\n            best_pos = 0\n            best_dist = float('inf')\n            for pos in range(n):\n                if pos > 0:\n                    prev_node = new_solution[pos-1]\n                else:\n                    prev_node = new_solution[-1]\n                next_node = new_solution[pos]\n\n                # Calculate combined distance across all objectives\n                dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                dist3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n                total_dist = dist1 + dist2 + dist3\n\n                if total_dist < best_dist:\n                    best_dist = total_dist\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6471577367067358,
            1.0381456732749939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = [sum(obj)/3 for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt* local search considering all objectives\n    def evaluate_swap(sol, a, b):\n        # Create new solution with edges a-b and c-d swapped\n        new_sol = sol.copy()\n        new_sol[a], new_sol[b] = new_sol[b], new_sol[a]\n        return new_sol\n\n    # Randomly select two edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution = evaluate_swap(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbors\n            best_pos = 0\n            best_dist = float('inf')\n            for pos in range(n):\n                if pos > 0:\n                    prev_node = new_solution[pos-1]\n                else:\n                    prev_node = new_solution[-1]\n                next_node = new_solution[pos]\n\n                # Calculate combined distance across all objectives\n                dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                dist3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n                total_dist = dist1 + dist2 + dist3\n\n                if total_dist < best_dist:\n                    best_dist = total_dist\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 3-opt and a novel three-dimensional edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply 3D edge exchange\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[[a, b, c]] = new_solution[[b, c, a]]\n\n    return new_solution\n\n",
        "score": [
            -0.7156902546404896,
            1.3711582899093628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply 3D edge exchange\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[[a, b, c]] = new_solution[[b, c, a]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objective values, then applies a hybrid local search combining 3-opt and a novel multi-objective edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate potential exchange in all three objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]])\n        if new_cost < original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6895988235968893,
            1.6328551530838014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate potential exchange in all three objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[b-1], new_solution[d]])\n        if new_cost < original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score function that combines normalized objective values and diversity measures, then applies a hybrid local search combining 2-opt with a multi-objective edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1) * (1 + 0.5 * np.random.rand(len(archive)))\n\n    # Select top 20% solutions and pick one randomly\n    top_indices = np.argsort(scores)[-max(1, len(archive)//5):]\n    selected_idx = np.random.choice(top_indices)\n    selected_solution, _ = archive[selected_idx]\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    if a != c and b != d:\n        # Evaluate potential exchange in all three objectives\n        original = sum([distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]]\n                        for i in [(a+1)%n, b, c, d]])\n        swapped = sum([distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[i]]\n                      for i in [(a+1)%n, c, b, d]])\n        if swapped < original:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5306849484012626,
            1.3637182116508484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1) * (1 + 0.5 * np.random.rand(len(archive)))\n\n    # Select top 20% solutions and pick one randomly\n    top_indices = np.argsort(scores)[-max(1, len(archive)//5):]\n    selected_idx = np.random.choice(top_indices)\n    selected_solution, _ = archive[selected_idx]\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    if a != c and b != d:\n        # Evaluate potential exchange in all three objectives\n        original = sum([distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]]\n                        for i in [(a+1)%n, b, c, d]])\n        swapped = sum([distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[i]]\n                      for i in [(a+1)%n, c, b, d]])\n        if swapped < original:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel local search operator: Multi-Objective Edge Insertion\n    # Randomly select a segment and insert it into another position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n\n    # Find a random position to insert the segment\n    insert_pos = np.random.randint(0, n - (b - a))\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Verify the solution remains feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.6185316634565539,
            1.1576587200164794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel local search operator: Multi-Objective Edge Insertion\n    # Randomly select a segment and insert it into another position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n\n    # Find a random position to insert the segment\n    insert_pos = np.random.randint(0, n - (b - a))\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Verify the solution remains feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This heuristic function selects a solution from the archive with high potential for improvement by analyzing objective diversity and applies a novel multi-objective segment inversion operator that simultaneously optimizes across all three objectives while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    sums = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply segment inversion with probabilistic selection\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Create two possible inversions (forward and backward)\n    options = [\n        np.concatenate([new_solution[:start], new_solution[start:end][::-1], new_solution[end:]]),\n        np.concatenate([new_solution[:start], new_solution[start:end], new_solution[end:]])\n    ]\n\n    # Evaluate both options across all three objectives\n    costs = []\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        costs.append((cost1 + cost2 + cost3, opt))\n\n    # Select the better option with probability based on improvement\n    if len(costs) > 1:\n        better, worse = sorted(costs, key=lambda x: x[0])\n        if better[0] < worse[0]:\n            improvement = (worse[0] - better[0]) / worse[0]\n            prob = min(0.9, improvement * 1.5)  # Higher probability for better improvements\n            if np.random.random() < prob:\n                new_solution = better[1]\n            else:\n                new_solution = worse[1]\n        else:\n            new_solution = better[1]\n    else:\n        new_solution = options[0]\n\n    # Probabilistic repair for missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            if np.random.random() < 0.7:  # 70% chance to repair\n                # Insert at random position (less expensive than greedy)\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7218202629024757,
            2.037089395523071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    sums = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply segment inversion with probabilistic selection\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Create two possible inversions (forward and backward)\n    options = [\n        np.concatenate([new_solution[:start], new_solution[start:end][::-1], new_solution[end:]]),\n        np.concatenate([new_solution[:start], new_solution[start:end], new_solution[end:]])\n    ]\n\n    # Evaluate both options across all three objectives\n    costs = []\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        costs.append((cost1 + cost2 + cost3, opt))\n\n    # Select the better option with probability based on improvement\n    if len(costs) > 1:\n        better, worse = sorted(costs, key=lambda x: x[0])\n        if better[0] < worse[0]:\n            improvement = (worse[0] - better[0]) / worse[0]\n            prob = min(0.9, improvement * 1.5)  # Higher probability for better improvements\n            if np.random.random() < prob:\n                new_solution = better[1]\n            else:\n                new_solution = worse[1]\n        else:\n            new_solution = better[1]\n    else:\n        new_solution = options[0]\n\n    # Probabilistic repair for missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            if np.random.random() < 0.7:  # 70% chance to repair\n                # Insert at random position (less expensive than greedy)\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of its objectives, then applies a hybrid local search combining 2-opt and edge exchange, with additional intelligent selection of promising solutions for further optimization across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with intelligent segment selection\n    if n > 2:\n        # Calculate the cost of each edge in all three objectives\n        edge_costs = np.zeros(n)\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            edge_costs[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n        edge_costs[-1] = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                          distance_matrix_2[new_solution[-1], new_solution[0]] +\n                          distance_matrix_3[new_solution[-1], new_solution[0]])\n\n        # Select the two most expensive edges to reverse\n        i, j = np.argsort(edge_costs)[-2:]\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange with objective-aware selection\n    if n > 3:\n        # Select edges from the two most expensive objectives\n        obj1_costs = np.zeros(n)\n        obj2_costs = np.zeros(n)\n        obj3_costs = np.zeros(n)\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            obj1_costs[i] = distance_matrix_1[u, v]\n            obj2_costs[i] = distance_matrix_2[u, v]\n            obj3_costs[i] = distance_matrix_3[u, v]\n        obj1_costs[-1] = distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2_costs[-1] = distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3_costs[-1] = distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Find the two most expensive edges in each objective\n        obj1_edges = np.argsort(obj1_costs)[-2:]\n        obj2_edges = np.argsort(obj2_costs)[-2:]\n        obj3_edges = np.argsort(obj3_costs)[-2:]\n\n        # Select the edge pair with the highest combined cost across objectives\n        edge_pairs = [(i, j) for i in obj1_edges for j in obj2_edges if i != j] + \\\n                     [(i, j) for i in obj1_edges for j in obj3_edges if i != j] + \\\n                     [(i, j) for i in obj2_edges for j in obj3_edges if i != j]\n\n        if edge_pairs:\n            a, b = min(edge_pairs, key=lambda x: -(obj1_costs[x[0]] + obj2_costs[x[0]] + obj3_costs[x[1]]))\n            c, d = min(edge_pairs, key=lambda x: -(obj1_costs[x[1]] + obj2_costs[x[1]] + obj3_costs[x[0]]))\n            if a != c and b != d:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6453611096743741,
            1.3510753989219666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with intelligent segment selection\n    if n > 2:\n        # Calculate the cost of each edge in all three objectives\n        edge_costs = np.zeros(n)\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            edge_costs[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n        edge_costs[-1] = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                          distance_matrix_2[new_solution[-1], new_solution[0]] +\n                          distance_matrix_3[new_solution[-1], new_solution[0]])\n\n        # Select the two most expensive edges to reverse\n        i, j = np.argsort(edge_costs)[-2:]\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange with objective-aware selection\n    if n > 3:\n        # Select edges from the two most expensive objectives\n        obj1_costs = np.zeros(n)\n        obj2_costs = np.zeros(n)\n        obj3_costs = np.zeros(n)\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            obj1_costs[i] = distance_matrix_1[u, v]\n            obj2_costs[i] = distance_matrix_2[u, v]\n            obj3_costs[i] = distance_matrix_3[u, v]\n        obj1_costs[-1] = distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2_costs[-1] = distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3_costs[-1] = distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Find the two most expensive edges in each objective\n        obj1_edges = np.argsort(obj1_costs)[-2:]\n        obj2_edges = np.argsort(obj2_costs)[-2:]\n        obj3_edges = np.argsort(obj3_costs)[-2:]\n\n        # Select the edge pair with the highest combined cost across objectives\n        edge_pairs = [(i, j) for i in obj1_edges for j in obj2_edges if i != j] + \\\n                     [(i, j) for i in obj1_edges for j in obj3_edges if i != j] + \\\n                     [(i, j) for i in obj2_edges for j in obj3_edges if i != j]\n\n        if edge_pairs:\n            a, b = min(edge_pairs, key=lambda x: -(obj1_costs[x[0]] + obj2_costs[x[0]] + obj3_costs[x[1]]))\n            c, d = min(edge_pairs, key=lambda x: -(obj1_costs[x[1]] + obj2_costs[x[1]] + obj3_costs[x[0]]))\n            if a != c and b != d:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm selects a solution with high variance in objectives to explore under-explored regions, then applies a novel multi-segment inversion and edge rotation operator that simultaneously optimizes all three objectives by considering their combined impact during segment selection and rotation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-segment inversion and edge rotation\n    k = np.random.randint(2, min(5, n//2))  # Number of segments to invert\n    segments = sorted(np.random.choice(n, k, replace=False))\n\n    # Invert segments\n    for i in range(k-1):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge rotation\n    m = np.random.randint(1, min(4, n//2))  # Number of edges to rotate\n    for _ in range(m):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        # Rotate edges between a and b\n        if b - a > 1:\n            new_solution[a+1:b] = np.roll(new_solution[a+1:b], np.random.randint(1, b-a))\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n+1):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.47457350278111515,
            3.8860787868499758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-segment inversion and edge rotation\n    k = np.random.randint(2, min(5, n//2))  # Number of segments to invert\n    segments = sorted(np.random.choice(n, k, replace=False))\n\n    # Invert segments\n    for i in range(k-1):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge rotation\n    m = np.random.randint(1, min(4, n//2))  # Number of edges to rotate\n    for _ in range(m):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        # Rotate edges between a and b\n        if b - a > 1:\n            new_solution[a+1:b] = np.roll(new_solution[a+1:b], np.random.randint(1, b-a))\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n+1):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance in the Pareto front, applies a hybrid local search combining 2-opt and node reinsertion to optimize across all three objectives while ensuring feasibility through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (lowest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(total_costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt + node reinsertion\n    # First apply 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then reinsert a randomly selected node\n    node_to_reinsert = np.random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_reinsert]\n\n    # Find best insertion position for the reinserted node\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node_to_reinsert)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node_to_reinsert)\n\n    # Repair any remaining duplicates (shouldn't happen but just in case)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = np.argmin([sum(distance_matrix_1[node, new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                      distance_matrix_2[node, new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                      distance_matrix_3[node, new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n                                 for i in range(n)])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6270593919861598,
            3.8214842915534972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (lowest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(total_costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt + node reinsertion\n    # First apply 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then reinsert a randomly selected node\n    node_to_reinsert = np.random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_reinsert]\n\n    # Find best insertion position for the reinserted node\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node_to_reinsert)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node_to_reinsert)\n\n    # Repair any remaining duplicates (shouldn't happen but just in case)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = np.argmin([sum(distance_matrix_1[node, new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                      distance_matrix_2[node, new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                      distance_matrix_3[node, new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n                                 for i in range(n)])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a 3-opt local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges and perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reconnect the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:k] = new_solution[i:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6948515520486346,
            1.0749610781669616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a 3-opt local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges and perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reconnect the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:k] = new_solution[i:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply partial reversal on another segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6478848303851912,
            1.0070995807647705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply partial reversal on another segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3-opt move to explore better solutions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply a crossover-inspired edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b]] = new_solution[[c, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7322198717104177,
            0.444489049911499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3-opt move to explore better solutions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply a crossover-inspired edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b]] = new_solution[[c, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This algorithm selects the most balanced solution from the archive, applies a novel multi-objective segment inversion and crossover operator, and ensures feasibility through a greedy insertion repair strategy while prioritizing solutions that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution (lowest standard deviation of objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments and perform a segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select another solution from the archive for crossover\n    if len(archive) > 1:\n        crossover_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0].copy()\n\n        # Perform a partial crossover between the two solutions\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        segment = crossover_solution[c:d]\n        mask = np.isin(new_solution, segment)\n        new_solution = np.concatenate([new_solution[~mask], segment])\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7148050270108492,
            3.93966281414032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution (lowest standard deviation of objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments and perform a segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select another solution from the archive for crossover\n    if len(archive) > 1:\n        crossover_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0].copy()\n\n        # Perform a partial crossover between the two solutions\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        segment = crossover_solution[c:d]\n        mask = np.isin(new_solution, segment)\n        new_solution = np.concatenate([new_solution[~mask], segment])\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = [(sol, (obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max(), obj[2]/distance_matrix_3.max())) for sol, obj in archive]\n    selected_solution, _ = max(normalized_archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 3-opt and edge exchange\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6070014623436508,
            3.1409541368484497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = [(sol, (obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max(), obj[2]/distance_matrix_3.max())) for sol, obj in archive]\n    selected_solution, _ = max(normalized_archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 3-opt and edge exchange\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement across all three objectives, then applies a novel multi-objective local search operator that combines 2-opt with a multi-dimensional edge exchange, ensuring feasibility while promoting diverse improvements in all three objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective 2-opt with objective-aware selection\n    for _ in range(3):  # Repeat for each objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.7:  # Higher chance for better objectives\n            # Evaluate 2-opt move across all objectives\n            original_costs = [\n                distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                distance_matrix_1[selected_solution[j-1], selected_solution[j]],\n                distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                distance_matrix_2[selected_solution[j-1], selected_solution[j]],\n                distance_matrix_3[selected_solution[i-1], selected_solution[i]] +\n                distance_matrix_3[selected_solution[j-1], selected_solution[j]]\n            ]\n            new_costs = [\n                distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                distance_matrix_1[selected_solution[j-1], selected_solution[i]],\n                distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                distance_matrix_2[selected_solution[j-1], selected_solution[i]],\n                distance_matrix_3[selected_solution[i-1], selected_solution[j]] +\n                distance_matrix_3[selected_solution[j-1], selected_solution[i]]\n            ]\n            if sum(new_costs) < sum(original_costs):  # Accept if better in any objective\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-dimensional edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate exchange across all objectives\n        original_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_1[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_2[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_3[selected_solution[b-1], selected_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[c]] +\n            distance_matrix_1[selected_solution[b-1], selected_solution[d]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[c]] +\n            distance_matrix_2[selected_solution[b-1], selected_solution[d]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[c]] +\n            distance_matrix_3[selected_solution[b-1], selected_solution[d]]\n        ]\n        if sum(new_costs) < sum(original_costs):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.4718130018362149,
            1.3972568273544312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective 2-opt with objective-aware selection\n    for _ in range(3):  # Repeat for each objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.7:  # Higher chance for better objectives\n            # Evaluate 2-opt move across all objectives\n            original_costs = [\n                distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                distance_matrix_1[selected_solution[j-1], selected_solution[j]],\n                distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                distance_matrix_2[selected_solution[j-1], selected_solution[j]],\n                distance_matrix_3[selected_solution[i-1], selected_solution[i]] +\n                distance_matrix_3[selected_solution[j-1], selected_solution[j]]\n            ]\n            new_costs = [\n                distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                distance_matrix_1[selected_solution[j-1], selected_solution[i]],\n                distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                distance_matrix_2[selected_solution[j-1], selected_solution[i]],\n                distance_matrix_3[selected_solution[i-1], selected_solution[j]] +\n                distance_matrix_3[selected_solution[j-1], selected_solution[i]]\n            ]\n            if sum(new_costs) < sum(original_costs):  # Accept if better in any objective\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-dimensional edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate exchange across all objectives\n        original_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_1[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_2[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_3[selected_solution[b-1], selected_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[c]] +\n            distance_matrix_1[selected_solution[b-1], selected_solution[d]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[c]] +\n            distance_matrix_2[selected_solution[b-1], selected_solution[d]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[c]] +\n            distance_matrix_3[selected_solution[b-1], selected_solution[d]]\n        ]\n        if sum(new_costs) < sum(original_costs):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced objectives, then applies a novel multi-objective segment-swap operator that intelligently exchanges segments between the current solution and a reference solution from the archive, with feasibility maintained through a specialized repair mechanism that ensures no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Select a reference solution (different from base_solution)\n    ref_idx = (selected_idx + 1) % len(archive)\n    ref_solution = archive[ref_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments from base and reference solutions\n    seg_length = max(2, n // 5)\n    start_base = np.random.randint(0, n - seg_length)\n    start_ref = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg_base = new_solution[start_base:start_base + seg_length]\n    seg_ref = ref_solution[start_ref:start_ref + seg_length]\n\n    # Swap segments\n    new_solution[start_base:start_base + seg_length] = seg_ref\n    new_solution[start_ref:start_ref + seg_length] = seg_base\n\n    # Repair duplicates and missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Remove duplicates while preserving order\n        seen = set()\n        new_solution = [x for x in new_solution if not (x in seen or seen.add(x))]\n\n        # Add missing nodes at random positions\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8148152953159482,
            3.6742557168006895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Select a reference solution (different from base_solution)\n    ref_idx = (selected_idx + 1) % len(archive)\n    ref_solution = archive[ref_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments from base and reference solutions\n    seg_length = max(2, n // 5)\n    start_base = np.random.randint(0, n - seg_length)\n    start_ref = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg_base = new_solution[start_base:start_base + seg_length]\n    seg_ref = ref_solution[start_ref:start_ref + seg_length]\n\n    # Swap segments\n    new_solution[start_base:start_base + seg_length] = seg_ref\n    new_solution[start_ref:start_ref + seg_length] = seg_base\n\n    # Repair duplicates and missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Remove duplicates while preserving order\n        seen = set()\n        new_solution = [x for x in new_solution if not (x in seen or seen.add(x))]\n\n        # Add missing nodes at random positions\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This heuristic function selects a solution from the archive that exhibits the least correlation between objectives, then applies a novel multi-objective segment-swap operator that intelligently exchanges segments between three randomly selected positions to optimize across all objectives while maintaining feasibility through a minimal repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with least objective correlation\n    objectives = np.array([obj for _, obj in archive])\n    correlations = [np.corrcoef(objectives[:,0], objectives[:,1])[0,1],\n                   np.corrcoef(objectives[:,1], objectives[:,2])[0,1],\n                   np.corrcoef(objectives[:,0], objectives[:,2])[0,1]]\n    selected_idx = np.argmin(np.abs(correlations))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segment-swap operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments to swap\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create three possible segment swaps\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n        np.concatenate([new_solution[:c], new_solution[a:b], new_solution[b:c], new_solution[c:]])\n    ]\n\n    # Evaluate each option across all objectives\n    def evaluate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return cost1 + cost2 + cost3\n\n    costs = [evaluate_cost(opt) for opt in options]\n    new_solution = options[np.argmin(costs)]\n\n    # Minimal repair for duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        for node in unique[counts > 1]:\n            idx = np.where(new_solution == node)[0][1]\n            new_solution[idx] = -1  # Mark duplicate\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if new_solution[i] == -1:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6530228328437299,
            2.303862202167511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with least objective correlation\n    objectives = np.array([obj for _, obj in archive])\n    correlations = [np.corrcoef(objectives[:,0], objectives[:,1])[0,1],\n                   np.corrcoef(objectives[:,1], objectives[:,2])[0,1],\n                   np.corrcoef(objectives[:,0], objectives[:,2])[0,1]]\n    selected_idx = np.argmin(np.abs(correlations))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segment-swap operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments to swap\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create three possible segment swaps\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n        np.concatenate([new_solution[:c], new_solution[a:b], new_solution[b:c], new_solution[c:]])\n    ]\n\n    # Evaluate each option across all objectives\n    def evaluate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return cost1 + cost2 + cost3\n\n    costs = [evaluate_cost(opt) for opt in options]\n    new_solution = options[np.argmin(costs)]\n\n    # Minimal repair for duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        for node in unique[counts > 1]:\n            idx = np.where(new_solution == node)[0][1]\n            new_solution[idx] = -1  # Mark duplicate\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(n):\n            if new_solution[i] == -1:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest potential for improvement across all three objectives by analyzing objective trade-offs, then applies a novel multi-segment inversion operator that simultaneously optimizes all three objectives while ensuring feasibility through a constrained repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest min objective but high max objective difference)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=1)\n    max_obj = np.max(objectives, axis=1)\n    improvement_potential = max_obj - min_obj\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply multi-segment inversion operator\n    # Randomly select 4 points to define 3 segments\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Create three possible inversions for the segments\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[a+1:b+1][::-1], new_solution[b+1:c+1], new_solution[c+1:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[a+1:c+1][::-1], new_solution[c+1:d+1], new_solution[d+1:b+1][::-1], new_solution[b+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[b+1:d+1][::-1], new_solution[d+1:c+1], new_solution[c+1:a+1][::-1], new_solution[a+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    def evaluate_option(opt):\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        return (cost1, cost2, cost3)\n\n    costs = [evaluate_option(opt) for opt in options]\n    best_idx = np.argmin([sum(cost) for cost in costs])\n    new_solution = options[best_idx]\n\n    # Repair duplicates if any exist using constrained insertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find insertion positions that maintain segment continuity\n            valid_positions = []\n            for pos in range(n):\n                if pos == 0 or pos == n-1 or abs(new_solution[pos-1] - node) <= 2 or abs(new_solution[pos] - node) <= 2:\n                    valid_positions.append(pos)\n            if valid_positions:\n                best_pos = valid_positions[0]\n                best_cost = float('inf')\n                for pos in valid_positions:\n                    candidate = np.insert(new_solution, pos, node)\n                    current_cost = sum(evaluate_option(candidate))\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_pos = pos\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4813205106960929,
            0.9601666927337646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest min objective but high max objective difference)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=1)\n    max_obj = np.max(objectives, axis=1)\n    improvement_potential = max_obj - min_obj\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply multi-segment inversion operator\n    # Randomly select 4 points to define 3 segments\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Create three possible inversions for the segments\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[a+1:b+1][::-1], new_solution[b+1:c+1], new_solution[c+1:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[a+1:c+1][::-1], new_solution[c+1:d+1], new_solution[d+1:b+1][::-1], new_solution[b+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[b+1:d+1][::-1], new_solution[d+1:c+1], new_solution[c+1:a+1][::-1], new_solution[a+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    def evaluate_option(opt):\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        return (cost1, cost2, cost3)\n\n    costs = [evaluate_option(opt) for opt in options]\n    best_idx = np.argmin([sum(cost) for cost in costs])\n    new_solution = options[best_idx]\n\n    # Repair duplicates if any exist using constrained insertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find insertion positions that maintain segment continuity\n            valid_positions = []\n            for pos in range(n):\n                if pos == 0 or pos == n-1 or abs(new_solution[pos-1] - node) <= 2 or abs(new_solution[pos] - node) <= 2:\n                    valid_positions.append(pos)\n            if valid_positions:\n                best_pos = valid_positions[0]\n                best_cost = float('inf')\n                for pos in valid_positions:\n                    candidate = np.insert(new_solution, pos, node)\n                    current_cost = sum(evaluate_option(candidate))\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_pos = pos\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel multi-criteria selection strategy, applies a hybrid 2-opt and 3-opt local search operator tailored for tri-objective optimization, and ensures feasibility through a dynamic repair mechanism that prioritizes the most improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objective improvements\n    objectives = [obj for _, obj in archive]\n    norm_objectives = np.array(objectives)\n    norm_objectives = (norm_objectives - np.min(norm_objectives, axis=0)) / (np.max(norm_objectives, axis=0) - np.min(norm_objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(norm_objectives, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for two objectives, 3-opt for the third\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt for first two objectives\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        candidate = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        if (cost1 + cost2) < (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] +\n                              sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    # Apply 3-opt for the third objective\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n    options = [\n        np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i+1], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n    ]\n    costs = []\n    for opt in options:\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        costs.append((cost3, opt))\n    new_solution = min(costs, key=lambda x: x[0])[1]\n\n    # Dynamic repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.60700598504681,
            1.1773551821708679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objective improvements\n    objectives = [obj for _, obj in archive]\n    norm_objectives = np.array(objectives)\n    norm_objectives = (norm_objectives - np.min(norm_objectives, axis=0)) / (np.max(norm_objectives, axis=0) - np.min(norm_objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(norm_objectives, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for two objectives, 3-opt for the third\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt for first two objectives\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        candidate = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        if (cost1 + cost2) < (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] +\n                              sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    # Apply 3-opt for the third objective\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n    options = [\n        np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i+1], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n    ]\n    costs = []\n    for opt in options:\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        costs.append((cost3, opt))\n    new_solution = min(costs, key=lambda x: x[0])[1]\n\n    # Dynamic repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective-aware local search operator\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a segment and shift it to a different position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.7274965788548775,
            1.0943200230598449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective-aware local search operator\n    # Randomly select a segment and reverse it (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a segment and shift it to a different position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a multi-objective-aware local search operator that combines 2-opt with a novel edge-insertion strategy to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Combine objective values and diversity metric\n        obj_score = sum(obj)  # Sum of objectives (can be replaced with a more sophisticated metric)\n        diversity_score = np.sum(np.abs(sol - np.mean(archive[0][0])))  # Simple diversity measure\n        return obj_score + diversity_score\n\n    selected_solution, _ = max(archive, key=selection_criteria)\n\n    # Apply a multi-objective-aware local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (standard)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-insertion strategy tailored for tri-objective optimization\n    if np.random.rand() < 0.5:  # 50% chance to apply this operator\n        # Select a random edge and insert it between two other edges\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        if a != c and b != d:\n            # Create a new path by inserting the selected edge\n            temp = new_solution.copy()\n            temp[[a, b]] = temp[[b, a]]  # Reverse the edge\n            temp[[c, d]] = temp[[d, c]]  # Reverse the other edge\n\n            # Calculate the change in all three objectives\n            def calculate_objective(sol):\n                total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (total1, total2, total3)\n\n            new_obj = calculate_objective(temp)\n            old_obj = calculate_objective(new_solution)\n\n            # Accept if at least one objective improves\n            if any(new_obj[i] < old_obj[i] for i in range(3)):\n                new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5440118745709058,
            3.8835413217544557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Combine objective values and diversity metric\n        obj_score = sum(obj)  # Sum of objectives (can be replaced with a more sophisticated metric)\n        diversity_score = np.sum(np.abs(sol - np.mean(archive[0][0])))  # Simple diversity measure\n        return obj_score + diversity_score\n\n    selected_solution, _ = max(archive, key=selection_criteria)\n\n    # Apply a multi-objective-aware local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (standard)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-insertion strategy tailored for tri-objective optimization\n    if np.random.rand() < 0.5:  # 50% chance to apply this operator\n        # Select a random edge and insert it between two other edges\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        if a != c and b != d:\n            # Create a new path by inserting the selected edge\n            temp = new_solution.copy()\n            temp[[a, b]] = temp[[b, a]]  # Reverse the edge\n            temp[[c, d]] = temp[[d, c]]  # Reverse the other edge\n\n            # Calculate the change in all three objectives\n            def calculate_objective(sol):\n                total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (total1, total2, total3)\n\n            new_obj = calculate_objective(temp)\n            old_obj = calculate_objective(new_solution)\n\n            # Accept if at least one objective improves\n            if any(new_obj[i] < old_obj[i] for i in range(3)):\n                new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1).flatten()\n    selected_solution, _ = max(archive, key=lambda x: -sum(w * c for w, c in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a segment inversion based on the objective with the highest variance in the archive\n    objective_variances = np.var([obj for _, obj in archive], axis=0)\n    target_obj = np.argmax(objective_variances)\n\n    # Find the segment with the highest cost in the target objective\n    segment_length = max(3, n // 5)\n    segment_costs = []\n    for i in range(n - segment_length + 1):\n        segment = new_solution[i:i+segment_length]\n        cost = sum(distance_matrix_1[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length)) if target_obj == 0 else \\\n               sum(distance_matrix_2[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length)) if target_obj == 1 else \\\n               sum(distance_matrix_3[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length))\n        segment_costs.append((i, cost))\n\n    i, _ = max(segment_costs, key=lambda x: x[1])\n    new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Perform objective-aware edge swaps\n    for _ in range(min(3, n // 2)):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a + 1 == b:  # Skip adjacent nodes\n            continue\n\n        # Evaluate the swap based on the most critical objective\n        current_cost = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] if target_obj == 0 else \\\n                       distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] if target_obj == 1 else \\\n                       distance_matrix_3[new_solution[a], new_solution[a+1]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]] if target_obj == 0 else \\\n                   distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]] if target_obj == 1 else \\\n                   distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a+1], new_solution[(b+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7081971390590909,
            2.425961804389954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1).flatten()\n    selected_solution, _ = max(archive, key=lambda x: -sum(w * c for w, c in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a segment inversion based on the objective with the highest variance in the archive\n    objective_variances = np.var([obj for _, obj in archive], axis=0)\n    target_obj = np.argmax(objective_variances)\n\n    # Find the segment with the highest cost in the target objective\n    segment_length = max(3, n // 5)\n    segment_costs = []\n    for i in range(n - segment_length + 1):\n        segment = new_solution[i:i+segment_length]\n        cost = sum(distance_matrix_1[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length)) if target_obj == 0 else \\\n               sum(distance_matrix_2[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length)) if target_obj == 1 else \\\n               sum(distance_matrix_3[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length))\n        segment_costs.append((i, cost))\n\n    i, _ = max(segment_costs, key=lambda x: x[1])\n    new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Perform objective-aware edge swaps\n    for _ in range(min(3, n // 2)):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a + 1 == b:  # Skip adjacent nodes\n            continue\n\n        # Evaluate the swap based on the most critical objective\n        current_cost = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] if target_obj == 0 else \\\n                       distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] if target_obj == 1 else \\\n                       distance_matrix_3[new_solution[a], new_solution[a+1]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]] if target_obj == 0 else \\\n                   distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]] if target_obj == 1 else \\\n                   distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a+1], new_solution[(b+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects solutions with high potential for improvement by combining adaptive segment swapping, edge exchange, and a multi-objective aware selection criterion, while ensuring feasibility through strict tour validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform adaptive segment swapping based on distance matrices\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        if len(segment) > 1:\n            segment_sorted = sorted(segment, key=lambda x: sum([distance_matrix_1[x, segment[0]], distance_matrix_2[x, segment[0]], distance_matrix_3[x, segment[0]]]))\n            new_solution[i:j] = segment_sorted\n\n    # Perform edge exchange with multi-objective consideration\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate exchange impact across all objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[b]] +\n                   distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[b]] +\n                   distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[d-1], new_solution[b]])\n        if new_cost <= original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6336645272114566,
            1.346701157093048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform adaptive segment swapping based on distance matrices\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        if len(segment) > 1:\n            segment_sorted = sorted(segment, key=lambda x: sum([distance_matrix_1[x, segment[0]], distance_matrix_2[x, segment[0]], distance_matrix_3[x, segment[0]]]))\n            new_solution[i:j] = segment_sorted\n\n    # Perform edge exchange with multi-objective consideration\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Evaluate exchange impact across all objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[b]] +\n                   distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[b]] +\n                   distance_matrix_3[new_solution[a-1], new_solution[c]] + distance_matrix_3[new_solution[d-1], new_solution[b]])\n        if new_cost <= original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search combining 2-opt with a novel edge-selection mechanism that considers all three objectives to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with edge selection based on all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Calculate edge costs in all three objectives\n        edge_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        # Apply 2-opt if the move improves the combined objective\n        if edge_costs > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel edge-selection mechanism based on objective diversity\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate objective diversity before and after exchange\n        before_diversity = (\n            abs(distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b-1], new_solution[b]]) +\n            abs(distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b-1], new_solution[b]]) +\n            abs(distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b-1], new_solution[b]])\n        )\n        after_diversity = (\n            abs(distance_matrix_1[new_solution[a-1], new_solution[c]] - distance_matrix_1[new_solution[b-1], new_solution[d]]) +\n            abs(distance_matrix_2[new_solution[a-1], new_solution[c]] - distance_matrix_2[new_solution[b-1], new_solution[d]]) +\n            abs(distance_matrix_3[new_solution[a-1], new_solution[c]] - distance_matrix_3[new_solution[b-1], new_solution[d]])\n        )\n        # Apply exchange if it increases objective diversity\n        if after_diversity > before_diversity:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6127515011835707,
            1.1194204211235046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with edge selection based on all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Calculate edge costs in all three objectives\n        edge_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        # Apply 2-opt if the move improves the combined objective\n        if edge_costs > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel edge-selection mechanism based on objective diversity\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate objective diversity before and after exchange\n        before_diversity = (\n            abs(distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b-1], new_solution[b]]) +\n            abs(distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b-1], new_solution[b]]) +\n            abs(distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b-1], new_solution[b]])\n        )\n        after_diversity = (\n            abs(distance_matrix_1[new_solution[a-1], new_solution[c]] - distance_matrix_1[new_solution[b-1], new_solution[d]]) +\n            abs(distance_matrix_2[new_solution[a-1], new_solution[c]] - distance_matrix_2[new_solution[b-1], new_solution[d]]) +\n            abs(distance_matrix_3[new_solution[a-1], new_solution[c]] - distance_matrix_3[new_solution[b-1], new_solution[d]])\n        )\n        # Apply exchange if it increases objective diversity\n        if after_diversity > before_diversity:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced objectives, then applies a novel multi-segment inversion and edge reassignment operator to optimize across all three objectives while ensuring feasibility through a greedy segment repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives (lowest standard deviation)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Apply multi-segment inversion and edge reassignment\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple segments and invert them\n    num_segments = np.random.randint(2, min(5, n // 2))\n    segment_indices = sorted(np.random.choice(n, num_segments * 2, replace=False))\n    for i in range(0, len(segment_indices), 2):\n        start, end = segment_indices[i], segment_indices[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly reassign edges between segments to improve multi-objective quality\n    for _ in range(min(3, n // 2)):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate the impact on all three objectives\n            original_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                            sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                            sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)))\n\n            temp_solution = new_solution.copy()\n            temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n\n            new_cost = (sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) +\n                        sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) +\n                        sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)))\n\n            if new_cost < original_cost:\n                new_solution = temp_solution\n\n    # Repair any duplicates using a greedy segment repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best segment to insert the missing node\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) +\n                        sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) +\n                        sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8340851286577573,
            4.372150778770447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives (lowest standard deviation)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Apply multi-segment inversion and edge reassignment\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple segments and invert them\n    num_segments = np.random.randint(2, min(5, n // 2))\n    segment_indices = sorted(np.random.choice(n, num_segments * 2, replace=False))\n    for i in range(0, len(segment_indices), 2):\n        start, end = segment_indices[i], segment_indices[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly reassign edges between segments to improve multi-objective quality\n    for _ in range(min(3, n // 2)):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Evaluate the impact on all three objectives\n            original_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                            sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                            sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)))\n\n            temp_solution = new_solution.copy()\n            temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n\n            new_cost = (sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) +\n                        sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) +\n                        sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)))\n\n            if new_cost < original_cost:\n                new_solution = temp_solution\n\n    # Repair any duplicates using a greedy segment repair mechanism\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best segment to insert the missing node\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) +\n                        sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) +\n                        sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_objectives.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment rotation\n    k = np.random.randint(3, n//2)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n    # Insert the rotated segment at a different position\n    insert_pos = np.random.randint(0, n - k)\n    if insert_pos >= start:\n        insert_pos += k\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        rotated_segment,\n        new_solution[insert_pos:start],\n        new_solution[start+k:]\n    ])\n\n    # Multi-objective-aware edge swap based on combined distance improvement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if i != a and j != b:\n            # Calculate combined distance improvement\n            orig_dist = (distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j] +\n                        distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b])\n            new_dist = (distance_matrix_1[i, a] + distance_matrix_2[i, a] + distance_matrix_3[i, a] +\n                       distance_matrix_1[j, b] + distance_matrix_2[j, b] + distance_matrix_3[j, b])\n            if new_dist < orig_dist:\n                new_solution[[i, j, a, b]] = new_solution[[i, a, j, b]]\n\n    return new_solution\n\n",
        "score": [
            -0.635192190503159,
            0.8735910296440125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_objectives.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment rotation\n    k = np.random.randint(3, n//2)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n    # Insert the rotated segment at a different position\n    insert_pos = np.random.randint(0, n - k)\n    if insert_pos >= start:\n        insert_pos += k\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        rotated_segment,\n        new_solution[insert_pos:start],\n        new_solution[start+k:]\n    ])\n\n    # Multi-objective-aware edge swap based on combined distance improvement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if i != a and j != b:\n            # Calculate combined distance improvement\n            orig_dist = (distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j] +\n                        distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b])\n            new_dist = (distance_matrix_1[i, a] + distance_matrix_2[i, a] + distance_matrix_3[i, a] +\n                       distance_matrix_1[j, b] + distance_matrix_2[j, b] + distance_matrix_3[j, b])\n            if new_dist < orig_dist:\n                new_solution[[i, j, a, b]] = new_solution[[i, a, j, b]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{The new algorithm selects a solution from the archive based on the worst-performing objective, then applies a novel local search operator that combines 2-opt with a multi-objective edge swap, favoring edges that improve at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: max(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform multi-objective edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Evaluate the current and swapped edges across all objectives\n        current_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[b]],\n             distance_matrix_2[new_solution[a], new_solution[b]],\n             distance_matrix_3[new_solution[a], new_solution[b]]),\n            (distance_matrix_1[new_solution[c], new_solution[d]],\n             distance_matrix_2[new_solution[c], new_solution[d]],\n             distance_matrix_3[new_solution[c], new_solution[d]])\n        ]\n\n        swapped_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[d]],\n             distance_matrix_2[new_solution[a], new_solution[d]],\n             distance_matrix_3[new_solution[a], new_solution[d]]),\n            (distance_matrix_1[new_solution[c], new_solution[b]],\n             distance_matrix_2[new_solution[c], new_solution[b]],\n             distance_matrix_3[new_solution[c], new_solution[b]])\n        ]\n\n        # Count how many objectives improve with the swap\n        improvements = sum(\n            sum(1 for curr, swapped in zip(curr_obj, swapped_obj) if swapped < curr)\n            for curr_obj, swapped_obj in zip(zip(*current_edges), zip(*swapped_edges))\n        )\n\n        # Only perform swap if at least one objective improves\n        if improvements > 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5375565194861835,
            1.3124526143074036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: max(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform multi-objective edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Evaluate the current and swapped edges across all objectives\n        current_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[b]],\n             distance_matrix_2[new_solution[a], new_solution[b]],\n             distance_matrix_3[new_solution[a], new_solution[b]]),\n            (distance_matrix_1[new_solution[c], new_solution[d]],\n             distance_matrix_2[new_solution[c], new_solution[d]],\n             distance_matrix_3[new_solution[c], new_solution[d]])\n        ]\n\n        swapped_edges = [\n            (distance_matrix_1[new_solution[a], new_solution[d]],\n             distance_matrix_2[new_solution[a], new_solution[d]],\n             distance_matrix_3[new_solution[a], new_solution[d]]),\n            (distance_matrix_1[new_solution[c], new_solution[b]],\n             distance_matrix_2[new_solution[c], new_solution[b]],\n             distance_matrix_3[new_solution[c], new_solution[b]])\n        ]\n\n        # Count how many objectives improve with the swap\n        improvements = sum(\n            sum(1 for curr, swapped in zip(curr_obj, swapped_obj) if swapped < curr)\n            for curr_obj, swapped_obj in zip(zip(*current_edges), zip(*swapped_edges))\n        )\n\n        # Only perform swap if at least one objective improves\n        if improvements > 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * val for w, val in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with probabilistic selection of critical nodes\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with probabilistic selection of critical edges\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6400532412210324,
            1.4249223828315736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * val for w, val in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with probabilistic selection of critical nodes\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with probabilistic selection of critical edges\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement across all three objectives, then applies a novel three-way segment inversion local search operator that simultaneously optimizes for all objectives by inverting three randomly selected segments of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply three-way segment inversion\n    points = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = points[0], points[1], points[2]\n\n    # Invert three segments to create a more diverse neighbor\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6528075713554087,
            1.0088406443595885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply three-way segment inversion\n    points = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = points[0], points[1], points[2]\n\n    # Invert three segments to create a more diverse neighbor\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This heuristic function selects a solution with the highest aggregate objective value from the archive, applies a novel multi-objective 2-opt operator that considers the trade-off between objectives, and ensures feasibility by repairing any invalid tours with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest aggregate objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt local search with multi-objective consideration\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create two possible 2-opt moves and evaluate their impact\n    def evaluate_move(sol, a, b):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            # Weighted sum with different weights for each objective\n            total_cost = 0.4 * cost1 + 0.3 * cost2 + 0.3 * cost3\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = 0.4 * cost1 + 0.3 * cost2 + 0.3 * cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6440940724145638,
            0.9718413829803467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest aggregate objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt local search with multi-objective consideration\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create two possible 2-opt moves and evaluate their impact\n    def evaluate_move(sol, a, b):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            # Weighted sum with different weights for each objective\n            total_cost = 0.4 * cost1 + 0.3 * cost2 + 0.3 * cost3\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = 0.4 * cost1 + 0.3 * cost2 + 0.3 * cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This heuristic function selects a solution with the highest combined improvement potential across all three objectives by analyzing the variance in their objective values, then applies a novel hybrid local search combining 4-opt with a multi-objective aware edge exchange strategy to generate a neighbor solution while ensuring feasibility through a minimal perturbation repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest min objective + highest std)\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.min(objectives, axis=1) + np.std(objectives, axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid 4-opt with multi-objective edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Generate all possible 4-opt moves\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[b:c+1][::-1], new_solution[a+1:b], new_solution[c:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[c:d+1][::-1], new_solution[a+1:c], new_solution[b:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[b:d+1][::-1], new_solution[a+1:b], new_solution[c:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[a:b+1][::-1], new_solution[b+1:c+1][::-1], new_solution[c+1:d+1][::-1], new_solution[d+1:]])\n    ]\n\n    # Evaluate each option with weighted multi-objective criterion\n    def evaluate_option(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        # Weighted sum with inverse of objective values to encourage balance\n        return (cost1 + cost2 + cost3) / (1 + (cost1 + cost2 + cost3) / 3)\n\n    best_option = min(options, key=evaluate_option)\n    new_solution = best_option.copy()\n\n    # Minimal perturbation repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        for node in np.setdiff1d(np.arange(n), unique):\n            pos = np.random.randint(n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7129203373985381,
            0.7495641589164734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest min objective + highest std)\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.min(objectives, axis=1) + np.std(objectives, axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid 4-opt with multi-objective edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Generate all possible 4-opt moves\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[b:c+1][::-1], new_solution[a+1:b], new_solution[c:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[c:d+1][::-1], new_solution[a+1:c], new_solution[b:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[b:d+1][::-1], new_solution[a+1:b], new_solution[c:d+1][::-1], new_solution[d+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[a:b+1][::-1], new_solution[b+1:c+1][::-1], new_solution[c+1:d+1][::-1], new_solution[d+1:]])\n    ]\n\n    # Evaluate each option with weighted multi-objective criterion\n    def evaluate_option(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        # Weighted sum with inverse of objective values to encourage balance\n        return (cost1 + cost2 + cost3) / (1 + (cost1 + cost2 + cost3) / 3)\n\n    best_option = min(options, key=evaluate_option)\n    new_solution = best_option.copy()\n\n    # Minimal perturbation repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        for node in np.setdiff1d(np.arange(n), unique):\n            pos = np.random.randint(n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective-aware segment rotation\n    # Randomly select a segment and rotate it based on the most critical objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Determine the most critical objective (highest variance)\n    objectives = np.array([x[1] for x in archive])\n    obj_variance = np.var(objectives, axis=0)\n    critical_obj = np.argmax(obj_variance)\n\n    # Rotate the segment based on the critical objective's distance matrix\n    if critical_obj == 0:\n        segment_distances = distance_matrix_1[np.ix_(segment, segment)]\n    elif critical_obj == 1:\n        segment_distances = distance_matrix_2[np.ix_(segment, segment)]\n    else:\n        segment_distances = distance_matrix_3[np.ix_(segment, segment)]\n\n    # Find the optimal rotation for the segment\n    best_rotation = 0\n    min_segment_cost = np.sum(segment_distances)\n    for k in range(1, len(segment)):\n        rotated_segment = np.roll(segment, k)\n        rotated_distances = distance_matrix_1[np.ix_(rotated_segment, rotated_segment)]\n        current_cost = np.sum(rotated_distances)\n        if current_cost < min_segment_cost:\n            min_segment_cost = current_cost\n            best_rotation = k\n\n    new_solution[i:j] = np.roll(segment, best_rotation)\n\n    # Apply a multi-objective edge swap based on the least critical objective\n    least_critical_obj = np.argmin(obj_variance)\n    if least_critical_obj == 0:\n        swap_matrix = distance_matrix_1\n    elif least_critical_obj == 1:\n        swap_matrix = distance_matrix_2\n    else:\n        swap_matrix = distance_matrix_3\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate the improvement in the least critical objective\n        original_cost = swap_matrix[a, b] + swap_matrix[c, d]\n        swapped_cost = swap_matrix[a, c] + swap_matrix[b, d]\n        if swapped_cost < original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5461692137456284,
            2.148471736907959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective-aware segment rotation\n    # Randomly select a segment and rotate it based on the most critical objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Determine the most critical objective (highest variance)\n    objectives = np.array([x[1] for x in archive])\n    obj_variance = np.var(objectives, axis=0)\n    critical_obj = np.argmax(obj_variance)\n\n    # Rotate the segment based on the critical objective's distance matrix\n    if critical_obj == 0:\n        segment_distances = distance_matrix_1[np.ix_(segment, segment)]\n    elif critical_obj == 1:\n        segment_distances = distance_matrix_2[np.ix_(segment, segment)]\n    else:\n        segment_distances = distance_matrix_3[np.ix_(segment, segment)]\n\n    # Find the optimal rotation for the segment\n    best_rotation = 0\n    min_segment_cost = np.sum(segment_distances)\n    for k in range(1, len(segment)):\n        rotated_segment = np.roll(segment, k)\n        rotated_distances = distance_matrix_1[np.ix_(rotated_segment, rotated_segment)]\n        current_cost = np.sum(rotated_distances)\n        if current_cost < min_segment_cost:\n            min_segment_cost = current_cost\n            best_rotation = k\n\n    new_solution[i:j] = np.roll(segment, best_rotation)\n\n    # Apply a multi-objective edge swap based on the least critical objective\n    least_critical_obj = np.argmin(obj_variance)\n    if least_critical_obj == 0:\n        swap_matrix = distance_matrix_1\n    elif least_critical_obj == 1:\n        swap_matrix = distance_matrix_2\n    else:\n        swap_matrix = distance_matrix_3\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Calculate the improvement in the least critical objective\n        original_cost = swap_matrix[a, b] + swap_matrix[c, d]\n        swapped_cost = swap_matrix[a, c] + swap_matrix[b, d]\n        if swapped_cost < original_cost:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{A novel heuristic that intelligently selects a solution from the archive based on its objective values and applies a hybrid local search combining 3-opt, edge insertion, and multi-objective edge swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply edge insertion for multi-objective optimization\n    if n > 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Apply multi-objective edge swapping\n    if n > 4:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7431253237187059,
            1.3167643547058105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply edge insertion for multi-objective optimization\n    if n > 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Apply multi-objective edge swapping\n    if n > 4:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This heuristic function selects a solution from the archive based on the most extreme objective values, applies a hybrid 2-opt and insertion operator to optimize across all three objectives, and repairs any infeasibilities by greedily inserting missing nodes while considering all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most extreme objective values\n    objectives = [obj for _, obj in archive]\n    extreme_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[extreme_idx][0].copy()\n\n    # Apply hybrid 2-opt and insertion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible reconnections\n    def evaluate_move(sol, a, b):\n        # Try both possible 2-opt moves\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair considering all objectives\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.49591932943569483,
            0.957547378540039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most extreme objective values\n    objectives = [obj for _, obj in archive]\n    extreme_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[extreme_idx][0].copy()\n\n    # Apply hybrid 2-opt and insertion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible reconnections\n    def evaluate_move(sol, a, b):\n        # Try both possible 2-opt moves\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair considering all objectives\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The new algorithm selects a solution from the archive based on the most improved objective, then applies a novel 3D-aware local search that combines segment reversal with node insertion from another promising solution to better optimize across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Select another solution for node insertion\n    other_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3D-aware segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Insert a node from another solution to improve multi-objective optimization\n    if n > 3:\n        insert_pos = np.random.randint(0, n)\n        node_to_insert = np.random.choice(other_solution)\n        if node_to_insert not in new_solution:\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n            # Remove a node to maintain tour length\n            remove_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.delete(new_solution, remove_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.7227707396309715,
            1.665783655643463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Select another solution for node insertion\n    other_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3D-aware segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Insert a node from another solution to improve multi-objective optimization\n    if n > 3:\n        insert_pos = np.random.randint(0, n)\n        node_to_insert = np.random.choice(other_solution)\n        if node_to_insert not in new_solution:\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n            # Remove a node to maintain tour length\n            remove_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.delete(new_solution, remove_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for multi-objective improvement, applies a novel segment-based local search that combines reverse and shift operations, and ensures feasibility by validating the tour structure while preserving all nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average objective value\n    selected_solution, _ = max(archive, key=lambda x: np.mean(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and apply reverse and shift operations\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n // 2))\n    segment_end = min(segment_start + segment_length, n)\n\n    # Reverse the selected segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Randomly shift a node within the segment\n    if segment_length > 1:\n        shift_pos = np.random.randint(segment_start, segment_end)\n        shift_node = new_solution[shift_pos]\n        new_solution = np.delete(new_solution, shift_pos)\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, shift_node)\n\n    # Validate the solution (ensure all nodes are present and no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = np.argmin([\n                distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[i%n]]\n                for i in range(n)\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7720663916311419,
            3.0458697080612183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average objective value\n    selected_solution, _ = max(archive, key=lambda x: np.mean(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and apply reverse and shift operations\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n // 2))\n    segment_end = min(segment_start + segment_length, n)\n\n    # Reverse the selected segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Randomly shift a node within the segment\n    if segment_length > 1:\n        shift_pos = np.random.randint(segment_start, segment_end)\n        shift_node = new_solution[shift_pos]\n        new_solution = np.delete(new_solution, shift_pos)\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, shift_node)\n\n    # Validate the solution (ensure all nodes are present and no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = np.argmin([\n                distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[i%n]]\n                for i in range(n)\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest sum of objectives, then applies a novel three-phase local search combining segment reversal, edge insertion, and objective-aware swaps to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Segment reversal with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    # Phase 2: Edge insertion with diversity consideration\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    insert_pos = np.random.choice(n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Phase 3: Objective-aware swap\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    target_obj = np.random.choice([i for i in range(3) if i != worst_obj])\n    swap_pos = np.random.choice(n)\n    new_node = np.random.choice(instance[:, 0])\n    while new_node in new_solution:\n        new_node = np.random.choice(instance[:, 0])\n    new_solution[swap_pos] = new_node\n\n    return new_solution\n\n",
        "score": [
            -0.7425780127092797,
            0.5960960030555725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Segment reversal with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    # Phase 2: Edge insertion with diversity consideration\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    insert_pos = np.random.choice(n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Phase 3: Objective-aware swap\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    target_obj = np.random.choice([i for i in range(3) if i != worst_obj])\n    swap_pos = np.random.choice(n)\n    new_node = np.random.choice(instance[:, 0])\n    while new_node in new_solution:\n        new_node = np.random.choice(instance[:, 0])\n    new_solution[swap_pos] = new_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel three-way edge exchange operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Example weights, can be adjusted\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Three-way edge exchange operator\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[[a, b, c]] = new_solution[[a, c, b]]\n\n    # Additional local improvement: swap two random nodes if it improves all objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Check if swap improves all objectives\n    old_costs = [sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))]\n\n    new_costs = [sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))]\n\n    if all(new_cost <= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5434055188816773,
            1.5786086797714234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Example weights, can be adjusted\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Three-way edge exchange operator\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[[a, b, c]] = new_solution[[a, c, b]]\n\n    # Additional local improvement: swap two random nodes if it improves all objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Check if swap improves all objectives\n    old_costs = [sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))]\n\n    new_costs = [sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n                 sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))]\n\n    if all(new_cost <= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This heuristic function selects a solution from the archive based on the most balanced objectives, applies a novel 4-opt local search to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create four possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[b:c+1][::-1], sol[c+1:d+1][::-1], sol[a:b+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8198006153407746,
            2.6005533933639526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create four possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:][::-1], sol[c+1:d]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[b:c+1][::-1], sol[c+1:d+1][::-1], sol[a:b+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This heuristic function selects a solution with the lowest total objective value from the archive, applies a hybrid multi-objective 2-opt and greedy insertion strategy to optimize across all three objectives, and ensures feasibility by repairing any missing nodes with a nearest-neighbor insertion approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest total objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply hybrid 2-opt and greedy insertion\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two edges to modify\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n\n        # Create two possible 2-opt moves\n        option1 = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n        option2 = np.concatenate([new_solution[:j+1], new_solution[i:j:-1], new_solution[i+1:]])\n\n        # Evaluate both options across all three objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1 + cost2 + cost3, sol)\n\n        cost1, sol1 = evaluate(option1)\n        cost2, sol2 = evaluate(option2)\n\n        # Select the better option\n        if cost1 < cost2:\n            new_solution = sol1\n        else:\n            new_solution = sol2\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbors\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6936477576103515,
            1.7736474871635437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest total objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply hybrid 2-opt and greedy insertion\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two edges to modify\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n\n        # Create two possible 2-opt moves\n        option1 = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n        option2 = np.concatenate([new_solution[:j+1], new_solution[i:j:-1], new_solution[i+1:]])\n\n        # Evaluate both options across all three objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1 + cost2 + cost3, sol)\n\n        cost1, sol1 = evaluate(option1)\n        cost2, sol2 = evaluate(option2)\n\n        # Select the better option\n        if cost1 < cost2:\n            new_solution = sol1\n        else:\n            new_solution = sol2\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbors\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their Pareto dominance and applies a multi-objective-aware 2-opt move combined with a dynamic edge exchange strategy to generate high-quality neighbors across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic edge exchange based on objective diversity\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Swap edges considering all three objectives\n        obj1_diff = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n        obj2_diff = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n        obj3_diff = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n\n        # Accept the swap if it improves at least one objective\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5817258244954842,
            0.972072982788086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic edge exchange based on objective diversity\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        # Swap edges considering all three objectives\n        obj1_diff = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n        obj2_diff = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n        obj3_diff = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n\n        # Accept the swap if it improves at least one objective\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances the three objectives, then applies a novel 3-opt local search operator that considers all three distance matrices simultaneously to ensure multi-objective improvement while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_score(obj):\n        return 3 / (1/obj[0] + 1/obj[1] + 1/obj[2])\n\n    selected_solution, _ = max(archive, key=lambda x: objective_score(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search considering all three objectives\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate all possible 3-opt moves and select the one with best combined improvement\n    best_move = None\n    best_score = float('inf')\n\n    # Generate all possible 3-opt moves (6 permutations)\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        if perm == (a, b, c):\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]:perm[1]+1] = temp_solution[perm[0]:perm[1]+1][::-1]\n\n        # Calculate total cost for all three objectives\n        total_cost = 0\n        for i in range(n):\n            u = temp_solution[i]\n            v = temp_solution[(i+1)%n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_move = perm\n\n    if best_move is not None:\n        new_solution[best_move[0]:best_move[1]+1] = new_solution[best_move[0]:best_move[1]+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6464660293879723,
            1.0511805772781373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_score(obj):\n        return 3 / (1/obj[0] + 1/obj[1] + 1/obj[2])\n\n    selected_solution, _ = max(archive, key=lambda x: objective_score(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search considering all three objectives\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate all possible 3-opt moves and select the one with best combined improvement\n    best_move = None\n    best_score = float('inf')\n\n    # Generate all possible 3-opt moves (6 permutations)\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        if perm == (a, b, c):\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]:perm[1]+1] = temp_solution[perm[0]:perm[1]+1][::-1]\n\n        # Calculate total cost for all three objectives\n        total_cost = 0\n        for i in range(n):\n            u = temp_solution[i]\n            v = temp_solution[(i+1)%n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_move = perm\n\n    if best_move is not None:\n        new_solution[best_move[0]:best_move[1]+1] = new_solution[best_move[0]:best_move[1]+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This heuristic function selects a solution from the archive with the lowest combined objective value, applies a novel 2.5-opt local search operator that intelligently reconnects segments of the tour while considering all three objectives, and ensures feasibility through a minimal repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2.5-opt local search (a hybrid between 2-opt and 3-opt)\n    def evaluate_move(sol, a, b, c):\n        # Create two possible reconnections\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    # Randomly select three points (a, b, c) where a < b < c\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Minimal repair: if duplicates exist, swap them with their immediate neighbors\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        for i in range(n):\n            if counts[unique == new_solution[i]] > 1:\n                # Find the next available node that's not a duplicate\n                for j in range(1, n):\n                    candidate = (i + j) % n\n                    if counts[unique == new_solution[candidate]] == 1:\n                        new_solution[i], new_solution[candidate] = new_solution[candidate], new_solution[i]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5698769007136596,
            0.596237051486969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2.5-opt local search (a hybrid between 2-opt and 3-opt)\n    def evaluate_move(sol, a, b, c):\n        # Create two possible reconnections\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    # Randomly select three points (a, b, c) where a < b < c\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Minimal repair: if duplicates exist, swap them with their immediate neighbors\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        for i in range(n):\n            if counts[unique == new_solution[i]] > 1:\n                # Find the next available node that's not a duplicate\n                for j in range(1, n):\n                    candidate = (i + j) % n\n                    if counts[unique == new_solution[candidate]] == 1:\n                        new_solution[i], new_solution[candidate] = new_solution[candidate], new_solution[i]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The new algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a novel local search operator that combines 3-opt moves with a multi-objective edge insertion strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet([1, 1, 1])\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move with multi-objective edge selection\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    # Multi-objective edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c = np.random.randint(n)\n    if a != c and b != c:\n        # Evaluate edge insertion in all objective spaces\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[c-1], new_solution[c]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_3[new_solution[c-1], new_solution[a]])\n\n        if new_cost < original_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6547294474901286,
            1.5601829290390015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet([1, 1, 1])\n    selected_solution, objectives = max(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move with multi-objective edge selection\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    # Multi-objective edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c = np.random.randint(n)\n    if a != c and b != c:\n        # Evaluate edge insertion in all objective spaces\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[c-1], new_solution[c]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_3[new_solution[c-1], new_solution[a]])\n\n        if new_cost < original_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This heuristic function selects a solution with the highest sum of normalized objectives from the archive, applies a novel multi-objective 2.5-opt operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (2-opt with edge insertion)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to remove and insert elsewhere\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible 2.5-opt moves and evaluate their impact\n    def evaluate_move(sol, a, b):\n        # Remove edges between a and b\n        segment = sol[a:b+1]\n        remaining = np.concatenate([sol[:a], sol[b+1:]])\n\n        # Try inserting the segment at different positions\n        best_cost = float('inf')\n        best_insert = None\n\n        for pos in range(len(remaining)):\n            # Insert in both directions\n            for reverse in [False, True]:\n                if reverse:\n                    candidate = np.concatenate([remaining[:pos], segment[::-1], remaining[pos:]])\n                else:\n                    candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n                # Evaluate across all three objectives\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_insert = candidate\n\n        return best_insert if best_insert is not None else sol\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6183032157104711,
            3.3056583166122437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (2-opt with edge insertion)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to remove and insert elsewhere\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible 2.5-opt moves and evaluate their impact\n    def evaluate_move(sol, a, b):\n        # Remove edges between a and b\n        segment = sol[a:b+1]\n        remaining = np.concatenate([sol[:a], sol[b+1:]])\n\n        # Try inserting the segment at different positions\n        best_cost = float('inf')\n        best_insert = None\n\n        for pos in range(len(remaining)):\n            # Insert in both directions\n            for reverse in [False, True]:\n                if reverse:\n                    candidate = np.concatenate([remaining[:pos], segment[::-1], remaining[pos:]])\n                else:\n                    candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n                # Evaluate across all three objectives\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_insert = candidate\n\n        return best_insert if best_insert is not None else sol\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement in all three objectives, applies a novel hybrid 2-opt and 3-opt local search strategy that dynamically adapts the move type based on the current solution's objective distribution, and ensures feasibility through a multi-objective aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (largest sum of normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential = normalized.sum(axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic move selection based on objective diversity\n    obj_std = np.std(objectives[selected_idx])\n    if obj_std > 0.3:  # High diversity - use 3-opt\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        def evaluate_3opt(sol, a, b, c):\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n            costs = []\n            for opt in options:\n                cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                costs.append((cost1 + cost2 + cost3, opt))\n\n            return min(costs, key=lambda x: x[0])[1]\n\n        new_solution = evaluate_3opt(new_solution, i, j, k)\n    else:  # Low diversity - use 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n\n        def evaluate_2opt(sol, a, b):\n            options = [\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]])\n            ]\n\n            costs = []\n            for opt in options:\n                cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                costs.append((cost1 + cost2 + cost3, opt))\n\n            return min(costs, key=lambda x: x[0])[1]\n\n        new_solution = evaluate_2opt(new_solution, i, j)\n\n    # Multi-objective aware repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n                # Weighted sum based on objective diversity\n                weights = np.exp(-objectives[selected_idx] / np.sum(objectives[selected_idx]))\n                total_cost = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6719102490745,
            1.1493287682533264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (largest sum of normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential = normalized.sum(axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic move selection based on objective diversity\n    obj_std = np.std(objectives[selected_idx])\n    if obj_std > 0.3:  # High diversity - use 3-opt\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        def evaluate_3opt(sol, a, b, c):\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n            costs = []\n            for opt in options:\n                cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                costs.append((cost1 + cost2 + cost3, opt))\n\n            return min(costs, key=lambda x: x[0])[1]\n\n        new_solution = evaluate_3opt(new_solution, i, j, k)\n    else:  # Low diversity - use 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n\n        def evaluate_2opt(sol, a, b):\n            options = [\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]])\n            ]\n\n            costs = []\n            for opt in options:\n                cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                costs.append((cost1 + cost2 + cost3, opt))\n\n            return min(costs, key=lambda x: x[0])[1]\n\n        new_solution = evaluate_2opt(new_solution, i, j)\n\n    # Multi-objective aware repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n                # Weighted sum based on objective diversity\n                weights = np.exp(-objectives[selected_idx] / np.sum(objectives[selected_idx]))\n                total_cost = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 3-opt local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges and perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.755848050116979,
            0.7989829897880554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply 3-opt local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges and perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement across multiple objectives, applies a novel hybrid local search operator that combines multi-objective 3-opt with adaptive segment reversal to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicates with a greedy insertion strategy that considers all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: multi-objective 3-opt with adaptive segment reversal\n    def hybrid_search(sol):\n        # Randomly select segments to modify\n        a, b, c, d = np.random.choice(n, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # Create hybrid options combining 3-opt and segment reversal\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]]),\n            np.concatenate([sol[:d+1], sol[a:b+1][::-1], sol[b+1:c+1], sol[c+1:d], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[c:d+1][::-1], sol[a+1:c], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = hybrid_search(new_solution)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair considering all objectives\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6359981851382239,
            0.704197108745575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: multi-objective 3-opt with adaptive segment reversal\n    def hybrid_search(sol):\n        # Randomly select segments to modify\n        a, b, c, d = np.random.choice(n, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # Create hybrid options combining 3-opt and segment reversal\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]]),\n            np.concatenate([sol[:d+1], sol[a:b+1][::-1], sol[b+1:c+1], sol[c+1:d], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[c:d+1][::-1], sol[a+1:c], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = hybrid_search(new_solution)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair considering all objectives\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest diversity in objective values, applies a multi-objective 4-opt operator to explore different tour configurations, and ensures feasibility by repairing any missing nodes with a local search approach that considers all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest standard deviation in objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmax(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[c:d+1][::-1], sol[a+1:c], sol[b:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:c+1][::-1], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Local search repair considering all objectives\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4894677404682324,
            3.6033166646957397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest standard deviation in objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmax(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[c:d+1][::-1], sol[a+1:c], sol[b:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[d:c+1][::-1], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Local search repair considering all objectives\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This heuristic function selects a solution from the archive based on the most balanced objectives, applies a novel 2.5-opt operator that combines 2-opt and 3-opt moves to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (combining 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two or three edges to modify\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Create three possible 3-opt moves and evaluate their impact across all objectives\n        def evaluate_move(sol, a, b, c):\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n            costs = []\n            for opt in options:\n                cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                costs.append((cost1 + cost2 + cost3, opt))\n\n            return min(costs, key=lambda x: x[0])[1]\n\n        new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8626845406996916,
            3.797964358329773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (combining 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two or three edges to modify\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Create three possible 3-opt moves and evaluate their impact across all objectives\n        def evaluate_move(sol, a, b, c):\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n            costs = []\n            for opt in options:\n                cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                costs.append((cost1 + cost2 + cost3, opt))\n\n            return min(costs, key=lambda x: x[0])[1]\n\n        new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This heuristic function selects a solution with the most diverse objectives from the archive, applies a novel multi-objective 2.5-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a hybrid insertion and swap strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most unbalanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmax(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (combination of 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments to modify\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create possible 2.5-opt moves (combination of 2-opt and 3-opt)\n    def evaluate_move(sol, a, b, c):\n        # Four possible reconnections for 2.5-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),  # 3-opt style\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),  # 3-opt style\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[c:][::-1], sol[b+1:c]]),  # 2.5-opt hybrid\n            np.concatenate([sol[:b+1], sol[b:c+1][::-1], sol[a:b+1][::-1], sol[c+1:]])  # 2.5-opt hybrid\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Hybrid repair: swap duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        duplicates = [node for node in unique if counts[np.where(unique == node)[0][0]] > 1]\n\n        for dup in duplicates:\n            if missing_nodes.size > 0:\n                replace_node = missing_nodes[0]\n                new_solution[new_solution == dup] = replace_node\n                missing_nodes = missing_nodes[1:]\n\n        # If still missing nodes, perform greedy insertion\n        missing_nodes = np.setdiff1d(np.arange(n), np.unique(new_solution))\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.46312349584331375,
            3.525651741027832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most unbalanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmax(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (combination of 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments to modify\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create possible 2.5-opt moves (combination of 2-opt and 3-opt)\n    def evaluate_move(sol, a, b, c):\n        # Four possible reconnections for 2.5-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),  # 3-opt style\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),  # 3-opt style\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[c:][::-1], sol[b+1:c]]),  # 2.5-opt hybrid\n            np.concatenate([sol[:b+1], sol[b:c+1][::-1], sol[a:b+1][::-1], sol[c+1:]])  # 2.5-opt hybrid\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Hybrid repair: swap duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        duplicates = [node for node in unique if counts[np.where(unique == node)[0][0]] > 1]\n\n        for dup in duplicates:\n            if missing_nodes.size > 0:\n                replace_node = missing_nodes[0]\n                new_solution[new_solution == dup] = replace_node\n                missing_nodes = missing_nodes[1:]\n\n        # If still missing nodes, perform greedy insertion\n        missing_nodes = np.setdiff1d(np.arange(n), np.unique(new_solution))\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This heuristic function selects a solution with the best trade-off between objectives using a novel weighted sum approach, then applies a multi-objective k-opt operator that dynamically adapts the number of edges to modify based on the current solution's objective diversity, ensuring feasibility through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using weighted sum\n    objectives = [obj for _, obj in archive]\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Determine k for k-opt based on objective diversity\n    obj_std = np.std(objectives[selected_idx])\n    k = min(4, max(2, int(np.ceil(2 + obj_std * 2))))\n\n    # Apply multi-objective k-opt\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select k edges to modify\n    points = sorted(np.random.choice(n, k, replace=False))\n\n    # Generate all possible reconnections for k-opt\n    def evaluate_kopt(sol, pts):\n        # Create all possible permutations of the selected segment\n        segment = sol[pts[0]:pts[-1]+1]\n        permutations = [segment.copy() for _ in range(len(pts)-1)]\n\n        for i in range(len(pts)-1):\n            # Apply different permutations\n            if i % 2 == 0:\n                permutations[i] = segment[::-1]\n            else:\n                permutations[i] = np.roll(segment, i)\n\n        # Evaluate each permutation across all objectives\n        costs = []\n        for perm in permutations:\n            candidate = np.concatenate([sol[:pts[0]], perm, sol[pts[-1]+1:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            total_cost = (cost1, cost2, cost3)\n            costs.append((total_cost, candidate))\n\n        # Return the best option\n        return min(costs, key=lambda x: sum(x[0]))[1]\n\n    new_solution = evaluate_kopt(new_solution, points)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8017691181842499,
            2.685310661792755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using weighted sum\n    objectives = [obj for _, obj in archive]\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in objectives]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Determine k for k-opt based on objective diversity\n    obj_std = np.std(objectives[selected_idx])\n    k = min(4, max(2, int(np.ceil(2 + obj_std * 2))))\n\n    # Apply multi-objective k-opt\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select k edges to modify\n    points = sorted(np.random.choice(n, k, replace=False))\n\n    # Generate all possible reconnections for k-opt\n    def evaluate_kopt(sol, pts):\n        # Create all possible permutations of the selected segment\n        segment = sol[pts[0]:pts[-1]+1]\n        permutations = [segment.copy() for _ in range(len(pts)-1)]\n\n        for i in range(len(pts)-1):\n            # Apply different permutations\n            if i % 2 == 0:\n                permutations[i] = segment[::-1]\n            else:\n                permutations[i] = np.roll(segment, i)\n\n        # Evaluate each permutation across all objectives\n        costs = []\n        for perm in permutations:\n            candidate = np.concatenate([sol[:pts[0]], perm, sol[pts[-1]+1:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            total_cost = (cost1, cost2, cost3)\n            costs.append((total_cost, candidate))\n\n        # Return the best option\n        return min(costs, key=lambda x: sum(x[0]))[1]\n\n    new_solution = evaluate_kopt(new_solution, points)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This new algorithm selects a solution from the archive with the highest diversity in objective values, applies a hybrid 3-opt operator that considers both local and global objective improvements, and ensures feasibility through a minimal perturbation repair strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest variance in objectives)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            # Weighted sum of objectives with adaptive weights\n            total_cost = 0.5 * cost1 + 0.3 * cost2 + 0.2 * cost3\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Minimal perturbation repair\n        for node in unique[counts > 1]:\n            # Find the first occurrence and swap with a missing node\n            idx = np.where(new_solution == node)[0][1]\n            missing_nodes = np.setdiff1d(np.arange(n), unique)\n            if len(missing_nodes) > 0:\n                new_solution[idx] = missing_nodes[0]\n\n    return new_solution\n\n",
        "score": [
            -0.4431582460452706,
            4.473567759990692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the highest variance in objectives)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            # Weighted sum of objectives with adaptive weights\n            total_cost = 0.5 * cost1 + 0.3 * cost2 + 0.2 * cost3\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Minimal perturbation repair\n        for node in unique[counts > 1]:\n            # Find the first occurrence and swap with a missing node\n            idx = np.where(new_solution == node)[0][1]\n            missing_nodes = np.setdiff1d(np.arange(n), unique)\n            if len(missing_nodes) > 0:\n                new_solution[idx] = missing_nodes[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest combined objective value, then applies a novel segment-based crossover operator with multi-objective evaluation to generate a neighbor solution, ensuring feasibility through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random segment from the base solution\n    n = len(base_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(6, n//2))\n    end = (start + length) % n\n    segment = base_solution[start:end] if start < end else np.concatenate([base_solution[start:], base_solution[:end]])\n\n    # Create a new solution by inserting the segment into a random position\n    new_solution = np.delete(base_solution, np.arange(start, end) % n)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Evaluate the new solution across all objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return cost1 + cost2 + cost3\n\n    # If the new solution is worse, try to improve it with a limited local search\n    if evaluate(new_solution) > evaluate(base_solution):\n        # Try swapping adjacent nodes to improve the solution\n        for _ in range(5):\n            i = np.random.randint(0, n)\n            j = (i + 1) % n\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            if evaluate(candidate) < evaluate(new_solution):\n                new_solution = candidate\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost = evaluate(candidate)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5662956462121654,
            1.6420042753219604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random segment from the base solution\n    n = len(base_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(6, n//2))\n    end = (start + length) % n\n    segment = base_solution[start:end] if start < end else np.concatenate([base_solution[start:], base_solution[:end]])\n\n    # Create a new solution by inserting the segment into a random position\n    new_solution = np.delete(base_solution, np.arange(start, end) % n)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Evaluate the new solution across all objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return cost1 + cost2 + cost3\n\n    # If the new solution is worse, try to improve it with a limited local search\n    if evaluate(new_solution) > evaluate(base_solution):\n        # Try swapping adjacent nodes to improve the solution\n        for _ in range(5):\n            i = np.random.randint(0, n)\n            j = (i + 1) % n\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            if evaluate(candidate) < evaluate(new_solution):\n                new_solution = candidate\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost = evaluate(candidate)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity in objective values, applies a hybrid 3-opt and 2-opt local search operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges for 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Randomly select two edges for 2-opt\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    def evaluate_2opt(sol, x, y):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:x+1], sol[y:x:-1], sol[y+1:]]),\n            np.concatenate([sol[:x+1], sol[y:x:-1], sol[y+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_2opt(new_solution, a, b)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5208168383940578,
            3.5575999140739443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges for 3-opt\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Randomly select two edges for 2-opt\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = sorted([a, b])\n\n    def evaluate_2opt(sol, x, y):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:x+1], sol[y:x:-1], sol[y+1:]]),\n            np.concatenate([sol[:x+1], sol[y:x:-1], sol[y+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_2opt(new_solution, a, b)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity and applies a novel multi-objective local search strategy that combines segment inversion with objective-aware edge swaps to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (different from others in archive)\n    selected_solution = archive[0][0]\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = sum(1 for i in range(len(sol)) if sol[i] != selected_solution[i])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate improvement potential for each objective\n    obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n    obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    # Only invert if at least one objective improves\n    if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n        new_solution[i:j] = segment[::-1]\n\n    # Apply objective-aware edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Calculate change in objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]] -\n                      distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[c], new_solution[d]])\n        delta_obj2 = (distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]] -\n                      distance_matrix_2[new_solution[a], new_solution[b]] - distance_matrix_2[new_solution[c], new_solution[d]])\n        delta_obj3 = (distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[d]] -\n                      distance_matrix_3[new_solution[a], new_solution[b]] - distance_matrix_3[new_solution[c], new_solution[d]])\n\n        # Only swap if at least one objective improves\n        if (delta_obj1 < 0) or (delta_obj2 < 0) or (delta_obj3 < 0):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6800735568694242,
            1.8700546145439148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (different from others in archive)\n    selected_solution = archive[0][0]\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = sum(1 for i in range(len(sol)) if sol[i] != selected_solution[i])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate improvement potential for each objective\n    obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n    obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    # Only invert if at least one objective improves\n    if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n        new_solution[i:j] = segment[::-1]\n\n    # Apply objective-aware edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Calculate change in objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]] -\n                      distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[c], new_solution[d]])\n        delta_obj2 = (distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]] -\n                      distance_matrix_2[new_solution[a], new_solution[b]] - distance_matrix_2[new_solution[c], new_solution[d]])\n        delta_obj3 = (distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[d]] -\n                      distance_matrix_3[new_solution[a], new_solution[b]] - distance_matrix_3[new_solution[c], new_solution[d]])\n\n        # Only swap if at least one objective improves\n        if (delta_obj1 < 0) or (delta_obj2 < 0) or (delta_obj3 < 0):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on the maximum diversity (using the sum of pairwise distances across objectives) and applies a multi-objective local search operator combining 3-opt and node insertion moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity(sol):\n        obj = sol[1]\n        return sum(obj)  # Simple diversity measure (can be enhanced)\n\n    selected_solution, _ = max(archive, key=diversity)\n\n    # Apply multi-objective local search operator combining 3-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Node insertion move\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.5915962667594824,
            1.1919976592063903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity(sol):\n        obj = sol[1]\n        return sum(obj)  # Simple diversity measure (can be enhanced)\n\n    selected_solution, _ = max(archive, key=diversity)\n\n    # Apply multi-objective local search operator combining 3-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Node insertion move\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This heuristic selects a solution from the archive that exhibits the most diverse objective values, applies a hybrid 4-opt and 2-opt operator to optimize across all three objectives, and ensures feasibility by repairing duplicates with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (highest variance in objectives)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 4-opt and 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, x, y, z, w):\n        # Create four possible hybrid moves (2-opt and 4-opt combinations)\n        options = [\n            np.concatenate([sol[:x+1], sol[w:z+1][::-1], sol[y:w], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:w+1], sol[z:w+1][::-1], sol[y:z], sol[x:y], sol[w+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_pos = np.argmin([distance_matrix_1[new_solution[i], node] + distance_matrix_2[new_solution[i], node] + distance_matrix_3[new_solution[i], node] for i in range(n)])\n            new_solution = np.insert(new_solution, nearest_pos + 1, node)\n\n    return new_solution\n\n",
        "score": [
            -0.48375101672258164,
            3.0378545761108398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (highest variance in objectives)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 4-opt and 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, x, y, z, w):\n        # Create four possible hybrid moves (2-opt and 4-opt combinations)\n        options = [\n            np.concatenate([sol[:x+1], sol[w:z+1][::-1], sol[y:w], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),\n            np.concatenate([sol[:x+1], sol[y:z+1][::-1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:w+1], sol[z:w+1][::-1], sol[y:z], sol[x:y], sol[w+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_pos = np.argmin([distance_matrix_1[new_solution[i], node] + distance_matrix_2[new_solution[i], node] + distance_matrix_3[new_solution[i], node] for i in range(n)])\n            new_solution = np.insert(new_solution, nearest_pos + 1, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This heuristic function selects a solution with the highest sum of normalized objective values from the archive, applies a novel multi-objective 2-opt* operator that considers all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a nearest neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    sums = normalized.sum(axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt* local search considering all three objectives\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Create the reversed segment\n    reversed_segment = new_solution[a:b+1][::-1]\n    candidate = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Evaluate the candidate solution across all three objectives\n    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n    # If the reversed segment improves at least one objective, accept it\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n    original_cost3 = sum(distance_matrix_3[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_3[base_solution[-1], base_solution[0]]\n\n    if (cost1 <= original_cost1 or cost2 <= original_cost2 or cost3 <= original_cost3):\n        new_solution = candidate\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_pos = np.argmin([distance_matrix_1[node, existing] + distance_matrix_2[node, existing] + distance_matrix_3[node, existing]\n                                   for existing in new_solution])\n            new_solution = np.insert(new_solution, nearest_pos + 1, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5875867258497058,
            1.455882441997528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    sums = normalized.sum(axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt* local search considering all three objectives\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Create the reversed segment\n    reversed_segment = new_solution[a:b+1][::-1]\n    candidate = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Evaluate the candidate solution across all three objectives\n    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n    # If the reversed segment improves at least one objective, accept it\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n    original_cost3 = sum(distance_matrix_3[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_3[base_solution[-1], base_solution[0]]\n\n    if (cost1 <= original_cost1 or cost2 <= original_cost2 or cost3 <= original_cost3):\n        new_solution = candidate\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_pos = np.argmin([distance_matrix_1[node, existing] + distance_matrix_2[node, existing] + distance_matrix_3[node, existing]\n                                   for existing in new_solution])\n            new_solution = np.insert(new_solution, nearest_pos + 1, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This heuristic function selects a solution from the archive based on its objective diversity, applies a novel multi-objective segment inversion and edge exchange operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a multi-objective greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply segment inversion and edge exchange\n    # Segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7322707505196442,
            4.029182517528534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply segment inversion and edge exchange\n    # Segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects a solution from the archive based on objective diversity, then applies a hybrid operator combining 3-opt and adaptive edge insertion to explore diverse regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, selected_objectives = max(archive, key=lambda x: np.std(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Adaptive edge insertion based on objective improvement\n    for _ in range(3):  # Perform multiple adaptive insertions\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5385188630721753,
            4.046273326873779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, selected_objectives = max(archive, key=lambda x: np.std(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Adaptive edge insertion based on objective improvement\n    for _ in range(3):  # Perform multiple adaptive insertions\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining 2-opt and edge exchange with randomized segment selection, and ensures feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.7\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with probability 0.5\n    if np.random.random() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6662064105446772,
            0.8974435091018677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.7\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with probability 0.5\n    if np.random.random() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its objective diversity, applies a novel multi-objective segment inversion and edge reallocation strategy to simultaneously optimize all three objectives, and ensures feasibility by repairing any invalid nodes through a cost-aware greedy insertion method.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    k = np.random.randint(2, min(n, 6))  # Random segment size\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    # Evaluate inversion across all objectives\n    def evaluate_inversion(sol, s, k):\n        inverted = sol.copy()\n        inverted[s:s+k] = inverted[s:s+k][::-1]\n\n        cost1 = sum(distance_matrix_1[inverted[i], inverted[i+1]] for i in range(n-1)) + distance_matrix_1[inverted[-1], inverted[0]]\n        cost2 = sum(distance_matrix_2[inverted[i], inverted[i+1]] for i in range(n-1)) + distance_matrix_2[inverted[-1], inverted[0]]\n        cost3 = sum(distance_matrix_3[inverted[i], inverted[i+1]] for i in range(n-1)) + distance_matrix_3[inverted[-1], inverted[0]]\n\n        return (cost1, cost2, cost3), inverted\n\n    current_costs, current_sol = evaluate_inversion(new_solution, start, k)\n    original_costs, _ = evaluate_inversion(new_solution, start, 0)\n\n    # Accept if at least two objectives improve\n    if sum(c1 < c2 for c1, c2 in zip(current_costs, original_costs)) >= 2:\n        new_solution = current_sol\n    else:\n        # Fall back to edge reallocation if inversion doesn't help\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[[a, b]] = new_solution[[b, a]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6868142677946113,
            1.9004624605178833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion\n    k = np.random.randint(2, min(n, 6))  # Random segment size\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    # Evaluate inversion across all objectives\n    def evaluate_inversion(sol, s, k):\n        inverted = sol.copy()\n        inverted[s:s+k] = inverted[s:s+k][::-1]\n\n        cost1 = sum(distance_matrix_1[inverted[i], inverted[i+1]] for i in range(n-1)) + distance_matrix_1[inverted[-1], inverted[0]]\n        cost2 = sum(distance_matrix_2[inverted[i], inverted[i+1]] for i in range(n-1)) + distance_matrix_2[inverted[-1], inverted[0]]\n        cost3 = sum(distance_matrix_3[inverted[i], inverted[i+1]] for i in range(n-1)) + distance_matrix_3[inverted[-1], inverted[0]]\n\n        return (cost1, cost2, cost3), inverted\n\n    current_costs, current_sol = evaluate_inversion(new_solution, start, k)\n    original_costs, _ = evaluate_inversion(new_solution, start, 0)\n\n    # Accept if at least two objectives improve\n    if sum(c1 < c2 for c1, c2 in zip(current_costs, original_costs)) >= 2:\n        new_solution = current_sol\n    else:\n        # Fall back to edge reallocation if inversion doesn't help\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[[a, b]] = new_solution[[b, a]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, applies a hybrid 2-opt and 3-opt local search operator that prioritizes moves improving the most imbalanced objective, and repairs solutions by greedily inserting missing nodes while minimizing the worst-case objective impact.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest variance in objectives (most imbalanced)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 2-opt and 3-opt local search\n    for _ in range(2):\n        # Randomly choose between 2-opt and 3-opt\n        if np.random.random() < 0.5:\n            # 2-opt move\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = np.random.choice(n, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n\n            def evaluate_move(sol, a, b, c):\n                # Generate all possible 3-opt reconnections\n                options = [\n                    np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                    np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                    np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n                ]\n\n                # Evaluate each option based on the most imbalanced objective\n                costs = []\n                for opt in options:\n                    cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                    cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                    cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                    worst_obj = max(cost1, cost2, cost3)\n                    costs.append((worst_obj, opt))\n\n                # Select the option that minimizes the worst objective\n                return min(costs, key=lambda x: x[0])[1]\n\n            new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position that minimizes the worst objective\n            best_pos = 0\n            best_worst_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                worst_cost = max(cost1, cost2, cost3)\n                if worst_cost < best_worst_cost:\n                    best_worst_cost = worst_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4820117469396119,
            4.042611622810364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest variance in objectives (most imbalanced)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 2-opt and 3-opt local search\n    for _ in range(2):\n        # Randomly choose between 2-opt and 3-opt\n        if np.random.random() < 0.5:\n            # 2-opt move\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = np.random.choice(n, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n\n            def evaluate_move(sol, a, b, c):\n                # Generate all possible 3-opt reconnections\n                options = [\n                    np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                    np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                    np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n                ]\n\n                # Evaluate each option based on the most imbalanced objective\n                costs = []\n                for opt in options:\n                    cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n                    cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n                    cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n                    worst_obj = max(cost1, cost2, cost3)\n                    costs.append((worst_obj, opt))\n\n                # Select the option that minimizes the worst objective\n                return min(costs, key=lambda x: x[0])[1]\n\n            new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position that minimizes the worst objective\n            best_pos = 0\n            best_worst_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                worst_cost = max(cost1, cost2, cost3)\n                if worst_cost < best_worst_cost:\n                    best_worst_cost = worst_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This heuristic function selects a solution from the archive based on its diversity in objective values, applies a novel multi-segment inversion and edge exchange operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any invalid nodes with a greedy insertion strategy tailored to the three-objective landscape.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most diverse objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.max(obj) - np.min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-segment inversion and edge exchange operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments and invert them\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if i != k and j != l:\n        new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4629872336109896,
            3.0252023696899415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most diverse objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.max(obj) - np.min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-segment inversion and edge exchange operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments and invert them\n    segments = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if i != k and j != l:\n        new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This heuristic function selects a solution with the highest total objective value from the archive, applies a novel multi-objective 2-opt+swap operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt+swap local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify and one node to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.choice(n)\n\n    # Create possible 2-opt+swap moves and evaluate their impact\n    def evaluate_move(sol, a, b, c):\n        # Possible reconnections: reverse segment and swap node\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),  # 2-opt\n            np.concatenate([sol[:a], sol[b:c+1], sol[a:b], sol[c+1:]]),  # swap\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a:b], sol[c+1:]])  # 2-opt + swap\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7332389408085603,
            0.6205914735794067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt+swap local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify and one node to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.choice(n)\n\n    # Create possible 2-opt+swap moves and evaluate their impact\n    def evaluate_move(sol, a, b, c):\n        # Possible reconnections: reverse segment and swap node\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),  # 2-opt\n            np.concatenate([sol[:a], sol[b:c+1], sol[a:b], sol[c+1:]]),  # swap\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a:b], sol[c+1:]])  # 2-opt + swap\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a solution from the archive by choosing the one with the highest average objective value, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor solution, ensuring feasibility by maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move: select three random segments and reverse them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node = np.random.choice(n)\n    pos = np.random.choice(n)\n    if node != pos:\n        new_solution = np.insert(np.delete(new_solution, node), pos, new_solution[node])\n\n    return new_solution\n\n",
        "score": [
            -0.5272209850260282,
            1.1454355239868164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move: select three random segments and reverse them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node = np.random.choice(n)\n    pos = np.random.choice(n)\n    if node != pos:\n        new_solution = np.insert(np.delete(new_solution, node), pos, new_solution[node])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm selects a solution from the archive with the highest crowding distance in the objective space, applies a novel multi-objective segment inversion operator that considers the trade-offs between objectives, and ensures feasibility by repairing any missing nodes with a least-cost insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    objectives = [obj for _, obj in archive]\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n    obj3 = np.array([obj[2] for obj in objectives])\n\n    # Calculate crowding distance for each objective\n    def crowding_distance(values):\n        sorted_idx = np.argsort(values)\n        sorted_values = values[sorted_idx]\n        distances = np.zeros(len(values))\n        distances[0] = distances[-1] = float('inf')\n        for i in range(1, len(values)-1):\n            distances[i] = sorted_values[i+1] - sorted_values[i-1]\n        return distances[sorted_idx.argsort()]\n\n    crowd1 = crowding_distance(obj1)\n    crowd2 = crowding_distance(obj2)\n    crowd3 = crowding_distance(obj3)\n    total_crowding = crowd1 + crowd2 + crowd3\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply multi-objective segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(10, n//2))\n    end = (start + length) % n\n\n    if start < end:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:] = new_solution[start:][::-1]\n        new_solution[:end] = new_solution[:end][::-1]\n\n    # Evaluate the inversion in terms of all objectives\n    def evaluate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = evaluate_cost(base_solution)\n    new_cost = evaluate_cost(new_solution)\n\n    # If inversion improves at least one objective, accept it\n    if any(new_cost[i] < original_cost[i] for i in range(3)):\n        base_solution = new_solution\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(base_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find least-cost insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(base_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            base_solution = np.insert(base_solution, best_pos, node)\n\n    return base_solution\n\n",
        "score": [
            -0.4340517869337166,
            1.4806252360343932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    objectives = [obj for _, obj in archive]\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n    obj3 = np.array([obj[2] for obj in objectives])\n\n    # Calculate crowding distance for each objective\n    def crowding_distance(values):\n        sorted_idx = np.argsort(values)\n        sorted_values = values[sorted_idx]\n        distances = np.zeros(len(values))\n        distances[0] = distances[-1] = float('inf')\n        for i in range(1, len(values)-1):\n            distances[i] = sorted_values[i+1] - sorted_values[i-1]\n        return distances[sorted_idx.argsort()]\n\n    crowd1 = crowding_distance(obj1)\n    crowd2 = crowding_distance(obj2)\n    crowd3 = crowding_distance(obj3)\n    total_crowding = crowd1 + crowd2 + crowd3\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply multi-objective segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(10, n//2))\n    end = (start + length) % n\n\n    if start < end:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:] = new_solution[start:][::-1]\n        new_solution[:end] = new_solution[:end][::-1]\n\n    # Evaluate the inversion in terms of all objectives\n    def evaluate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = evaluate_cost(base_solution)\n    new_cost = evaluate_cost(new_solution)\n\n    # If inversion improves at least one objective, accept it\n    if any(new_cost[i] < original_cost[i] for i in range(3)):\n        base_solution = new_solution\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(base_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find least-cost insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(base_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            base_solution = np.insert(base_solution, best_pos, node)\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, then applies a novel 3-way segment rotation operator that cyclically permutes three randomly selected segments to explore more diverse neighborhood structures in the multi-objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments and cyclically permute them\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Cyclic permutation: segment1 -> segment2, segment2 -> segment3, segment3 -> segment1\n    new_solution = np.concatenate([segment2, segment3, segment1, segment4])\n\n    return new_solution\n\n",
        "score": [
            -0.5252366655452514,
            1.7772042512893678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments and cyclically permute them\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Cyclic permutation: segment1 -> segment2, segment2 -> segment3, segment3 -> segment1\n    new_solution = np.concatenate([segment2, segment3, segment1, segment4])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Normalize objectives to balance their influence\n    norm_obj = [o / sum(objectives) for o in objectives]\n\n    # Apply 3-opt move with probability based on objective weights\n    if np.random.rand() < 0.7:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if np.random.rand() < norm_obj[0]:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif np.random.rand() < norm_obj[1]:\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Apply objective-specific edge exchanges\n    for obj_idx in range(3):\n        if np.random.rand() < norm_obj[obj_idx]:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if a != c and b != d:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5459837145308669,
            1.2570781350135802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Normalize objectives to balance their influence\n    norm_obj = [o / sum(objectives) for o in objectives]\n\n    # Apply 3-opt move with probability based on objective weights\n    if np.random.rand() < 0.7:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if np.random.rand() < norm_obj[0]:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif np.random.rand() < norm_obj[1]:\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Apply objective-specific edge exchanges\n    for obj_idx in range(3):\n        if np.random.rand() < norm_obj[obj_idx]:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if a != c and b != d:\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * np.random.uniform(0.8, 1.2))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Apply segment reversal with probability\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5953920774964805,
            1.808991503715515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * np.random.uniform(0.8, 1.2))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Apply segment reversal with probability\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighted focus on the first objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with a higher probability if the solution shows good diversity\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with a probability based on solution quality\n    if np.random.random() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.719722944238611,
            1.3722066521644591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighted focus on the first objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with a higher probability if the solution shows good diversity\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with a probability based on solution quality\n    if np.random.random() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This heuristic function selects a solution with the highest sum of objectives from the archive, applies a novel multi-objective segment reversal and node swap operator that considers the trade-offs between objectives, and ensures feasibility by repairing any duplicates with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two nodes and swap them\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.611704290340234,
            1.239744484424591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two nodes and swap them\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This heuristic function selects a solution with the highest sum of normalized objective values to focus on underperforming objectives, then applies a hybrid 2-opt and node relocation operator to simultaneously improve all objectives while ensuring feasibility through a greedy repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives to focus on underperforming objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and node relocation operator\n    if np.random.rand() < 0.5:  # 2-opt move\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Node relocation\n        node = np.random.choice(n)\n        pos = np.random.choice(n)\n        new_solution = np.insert(np.delete(new_solution, node), pos, base_solution[node])\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7408313633881941,
            1.4574284315109254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives to focus on underperforming objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and node relocation operator\n    if np.random.rand() < 0.5:  # 2-opt move\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Node relocation\n        node = np.random.choice(n)\n        pos = np.random.choice(n)\n        new_solution = np.insert(np.delete(new_solution, node), pos, base_solution[node])\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This heuristic function selects a solution with the best trade-off between objectives (using a weighted sum approach) and applies a novel multi-segment inversion operator that considers the combined impact of all three objectives, with feasibility maintained through a segment-based repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (weighted sum of objectives)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply multi-segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments and invert them\n    seg1_start, seg1_end = sorted(np.random.choice(n, 2, replace=False))\n    seg2_start, seg2_end = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments don't overlap\n    if seg1_end > seg2_start:\n        seg1_end, seg2_start = seg2_start, seg1_end\n\n    # Invert the selected segments\n    new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n    new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Segment-based repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best segment to insert the missing node\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                for j in range(i+1, n+1):\n                    candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                    total_cost = cost1 + cost2 + cost3\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7382528900305245,
            3.216632831096649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (weighted sum of objectives)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply multi-segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments and invert them\n    seg1_start, seg1_end = sorted(np.random.choice(n, 2, replace=False))\n    seg2_start, seg2_end = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments don't overlap\n    if seg1_end > seg2_start:\n        seg1_end, seg2_start = seg2_start, seg1_end\n\n    # Invert the selected segments\n    new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n    new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Segment-based repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best segment to insert the missing node\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                for j in range(i+1, n+1):\n                    candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                    total_cost = cost1 + cost2 + cost3\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The new algorithm selects a solution from the archive with the most diverse objective values, applies a novel multi-objective edge insertion and reversal operator that simultaneously optimizes all three objectives by considering their combined impact, and ensures feasibility by repairing any duplicate nodes with a two-phase repair strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = [obj for _, obj in archive]\n    max_range_idx = np.argmax([max(obj) - min(obj) for obj in objectives])\n    base_solution = archive[max_range_idx][0].copy()\n\n    # Apply multi-objective edge insertion and reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and reverse it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and insert it at a different position\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Remove duplicate node (if any) and insert missing node\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Remove first duplicate\n        for node in unique[counts > 1]:\n            idx = np.where(new_solution == node)[0][1]\n            new_solution = np.delete(new_solution, idx)\n        # Insert missing node at best position\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6817484226426181,
            0.38827764987945557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = [obj for _, obj in archive]\n    max_range_idx = np.argmax([max(obj) - min(obj) for obj in objectives])\n    base_solution = archive[max_range_idx][0].copy()\n\n    # Apply multi-objective edge insertion and reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and reverse it\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and insert it at a different position\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Remove duplicate node (if any) and insert missing node\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Remove first duplicate\n        for node in unique[counts > 1]:\n            idx = np.where(new_solution == node)[0][1]\n            new_solution = np.delete(new_solution, idx)\n        # Insert missing node at best position\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{A novel heuristic that intelligently selects a solution from the archive based on objective diversity and applies a multi-objective-aware local search combining segment inversion, edge insertion, and objective-weighted edge exchange to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        node = new_solution[b]\n        new_solution = np.delete(new_solution, b)\n        new_solution = np.insert(new_solution, a, node)\n\n    # Perform objective-weighted edge exchange\n    weights = np.random.dirichlet([1, 1, 1])\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        # Calculate edge costs in all objectives\n        cost1 = distance_matrix_1[new_solution[c], new_solution[d]] + distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]]\n        cost2 = distance_matrix_2[new_solution[c], new_solution[d]] + distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]]\n        cost3 = distance_matrix_3[new_solution[c], new_solution[d]] + distance_matrix_3[new_solution[c-1], new_solution[c]] + distance_matrix_3[new_solution[d], new_solution[(d+1)%n]]\n\n        # Calculate weighted cost\n        weighted_cost = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n\n        # Try alternative edge\n        alt_cost1 = distance_matrix_1[new_solution[c], new_solution[c-1]] + distance_matrix_1[new_solution[d], new_solution[d-1]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        alt_cost2 = distance_matrix_2[new_solution[c], new_solution[c-1]] + distance_matrix_2[new_solution[d], new_solution[d-1]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        alt_cost3 = distance_matrix_3[new_solution[c], new_solution[c-1]] + distance_matrix_3[new_solution[d], new_solution[d-1]] + distance_matrix_3[new_solution[c], new_solution[d]]\n        alt_weighted_cost = weights[0] * alt_cost1 + weights[1] * alt_cost2 + weights[2] * alt_cost3\n\n        if alt_weighted_cost < weighted_cost:\n            new_solution[[c, d]] = new_solution[[d, c]]\n\n    return new_solution\n\n",
        "score": [
            -0.5176711186895951,
            1.4856749057769776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        node = new_solution[b]\n        new_solution = np.delete(new_solution, b)\n        new_solution = np.insert(new_solution, a, node)\n\n    # Perform objective-weighted edge exchange\n    weights = np.random.dirichlet([1, 1, 1])\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        # Calculate edge costs in all objectives\n        cost1 = distance_matrix_1[new_solution[c], new_solution[d]] + distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]]\n        cost2 = distance_matrix_2[new_solution[c], new_solution[d]] + distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]]\n        cost3 = distance_matrix_3[new_solution[c], new_solution[d]] + distance_matrix_3[new_solution[c-1], new_solution[c]] + distance_matrix_3[new_solution[d], new_solution[(d+1)%n]]\n\n        # Calculate weighted cost\n        weighted_cost = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n\n        # Try alternative edge\n        alt_cost1 = distance_matrix_1[new_solution[c], new_solution[c-1]] + distance_matrix_1[new_solution[d], new_solution[d-1]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        alt_cost2 = distance_matrix_2[new_solution[c], new_solution[c-1]] + distance_matrix_2[new_solution[d], new_solution[d-1]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        alt_cost3 = distance_matrix_3[new_solution[c], new_solution[c-1]] + distance_matrix_3[new_solution[d], new_solution[d-1]] + distance_matrix_3[new_solution[c], new_solution[d]]\n        alt_weighted_cost = weights[0] * alt_cost1 + weights[1] * alt_cost2 + weights[2] * alt_cost3\n\n        if alt_weighted_cost < weighted_cost:\n            new_solution[[c, d]] = new_solution[[d, c]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objective values, then applies a hybrid local search combining 2-opt and edge exchange, with additional randomness to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 3)\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Random swap for diversification\n    if np.random.random() < 0.3:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5698099121089479,
            1.8113224744796752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 3)\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Random swap for diversification\n    if np.random.random() < 0.3:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This heuristic function selects a solution with high objective diversity from the archive, applies a novel multi-objective 2-opt with reverse segment insertion to optimize across all three objectives, and ensures feasibility by repairing any missing nodes with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (highest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt with reverse segment insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible 2-opt moves\n    def evaluate_move(sol, a, b):\n        # Reverse segment between a and b\n        reversed_segment = sol[a:b+1][::-1]\n        option = np.concatenate([sol[:a], reversed_segment, sol[b+1:]])\n\n        # Evaluate the option across all three objectives\n        cost1 = sum(distance_matrix_1[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n        cost3 = sum(distance_matrix_3[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_3[option[-1], option[0]]\n\n        return (cost1, cost2, cost3), option\n\n    _, new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_pos = 0\n            min_dist = float('inf')\n            for i in range(n):\n                dist1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                dist2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                dist3 = distance_matrix_3[new_solution[i-1], node] + distance_matrix_3[node, new_solution[i]]\n                total_dist = dist1 + dist2 + dist3\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    nearest_pos = i\n            new_solution = np.insert(new_solution, nearest_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7011642758047446,
            1.1112324357032777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (highest sum of objectives)\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt with reverse segment insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible 2-opt moves\n    def evaluate_move(sol, a, b):\n        # Reverse segment between a and b\n        reversed_segment = sol[a:b+1][::-1]\n        option = np.concatenate([sol[:a], reversed_segment, sol[b+1:]])\n\n        # Evaluate the option across all three objectives\n        cost1 = sum(distance_matrix_1[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n        cost3 = sum(distance_matrix_3[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_3[option[-1], option[0]]\n\n        return (cost1, cost2, cost3), option\n\n    _, new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_pos = 0\n            min_dist = float('inf')\n            for i in range(n):\n                dist1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                dist2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                dist3 = distance_matrix_3[new_solution[i-1], node] + distance_matrix_3[node, new_solution[i]]\n                total_dist = dist1 + dist2 + dist3\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    nearest_pos = i\n            new_solution = np.insert(new_solution, nearest_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This heuristic function selects a solution with the highest sum of objectives, applies a novel segment-based crossover with adaptive segment length to generate a neighbor solution, and ensures feasibility by repairing any duplicates with a minimal insertion strategy while maintaining the best segment from the original solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment length based on problem size\n    segment_length = max(2, n // 5)\n\n    # Randomly select a segment to preserve\n    start = np.random.randint(0, n - segment_length)\n    preserved_segment = base_solution[start:start+segment_length]\n\n    # Create a new solution by inserting the preserved segment in a random position\n    new_solution = np.roll(base_solution, np.random.randint(1, n))\n    insert_pos = np.random.randint(0, n - segment_length)\n    new_solution[insert_pos:insert_pos+segment_length] = preserved_segment\n\n    # Repair duplicates by removing them and inserting missing nodes at random positions\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            mask = (new_solution == dup)\n            indices = np.where(mask)[0]\n            for i in indices[1:]:\n                new_solution[i] = -1  # Mark duplicates for removal\n\n        new_solution = new_solution[new_solution != -1]\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5199039622317145,
            1.5688244462013246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment length based on problem size\n    segment_length = max(2, n // 5)\n\n    # Randomly select a segment to preserve\n    start = np.random.randint(0, n - segment_length)\n    preserved_segment = base_solution[start:start+segment_length]\n\n    # Create a new solution by inserting the preserved segment in a random position\n    new_solution = np.roll(base_solution, np.random.randint(1, n))\n    insert_pos = np.random.randint(0, n - segment_length)\n    new_solution[insert_pos:insert_pos+segment_length] = preserved_segment\n\n    # Repair duplicates by removing them and inserting missing nodes at random positions\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            mask = (new_solution == dup)\n            indices = np.where(mask)[0]\n            for i in indices[1:]:\n                new_solution[i] = -1  # Mark duplicates for removal\n\n        new_solution = new_solution[new_solution != -1]\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The new algorithm will select a solution from the archive based on the minimum sum of normalized objective values, then apply a novel \"multi-objective segment inversion\" operator that randomly inverts segments of the tour while ensuring feasibility, combined with a \"multi-objective edge rotation\" operator that rotates edges between segments to improve all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    k = np.random.randint(2, min(5, n//2))\n    segments = np.random.choice(n, k, replace=False)\n    segments.sort()\n    for i in range(0, len(segments)-1, 2):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge rotation\n    if n > 4:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        new_solution[[a, b, c, d]] = new_solution[[a, c, d, b]]\n\n    return new_solution\n\n",
        "score": [
            -0.6983739455685736,
            1.3721404075622559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    k = np.random.randint(2, min(5, n//2))\n    segments = np.random.choice(n, k, replace=False)\n    segments.sort()\n    for i in range(0, len(segments)-1, 2):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge rotation\n    if n > 4:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        new_solution[[a, b, c, d]] = new_solution[[a, c, d, b]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform path relinking with a solution from the archive\n    if len(archive) > 1:\n        reference_solution = archive[np.random.randint(1, len(archive))][0]\n        for idx in range(n):\n            if np.random.rand() < 0.3:  # 30% chance to adopt the node from the reference solution\n                if reference_solution[idx] not in new_solution[:idx]:\n                    new_solution[idx] = reference_solution[idx]\n\n    # Ensure feasibility by fixing any duplicates or missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    for i in range(n):\n        if new_solution[i] in new_solution[:i]:\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.7568604516172812,
            1.5524312496185302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform path relinking with a solution from the archive\n    if len(archive) > 1:\n        reference_solution = archive[np.random.randint(1, len(archive))][0]\n        for idx in range(n):\n            if np.random.rand() < 0.3:  # 30% chance to adopt the node from the reference solution\n                if reference_solution[idx] not in new_solution[:idx]:\n                    new_solution[idx] = reference_solution[idx]\n\n    # Ensure feasibility by fixing any duplicates or missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    for i in range(n):\n        if new_solution[i] in new_solution[:i]:\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move (select three edges and reconnect them)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Edge insertion (select a node and insert it in a different position)\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6130631638233514,
            1.0675382137298584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move (select three edges and reconnect them)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Edge insertion (select a node and insert it in a different position)\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This heuristic function selects a solution with the highest average objective value from the archive, applies a novel multi-objective 2-opt with adaptive segment selection to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = [sum(obj)/3 for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection for 2-opt\n    def evaluate_segment(sol, start, end):\n        segment = sol[start:end+1]\n        reversed_segment = segment[::-1]\n        new_sol = np.concatenate([sol[:start], reversed_segment, sol[end+1:]])\n\n        cost1 = sum(distance_matrix_1[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_1[new_sol[-1], new_sol[0]]\n        cost2 = sum(distance_matrix_2[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_2[new_sol[-1], new_sol[0]]\n        cost3 = sum(distance_matrix_3[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_3[new_sol[-1], new_sol[0]]\n        return (cost1 + cost2 + cost3, new_sol)\n\n    # Evaluate multiple segments adaptively\n    best_cost = float('inf')\n    best_sol = new_solution\n    for _ in range(3):  # Evaluate 3 random segments\n        start = np.random.randint(0, n)\n        length = np.random.randint(3, min(10, n//2))\n        end = (start + length) % n\n        if start > end:\n            cost, sol = evaluate_segment(new_solution, end, start)\n        else:\n            cost, sol = evaluate_segment(new_solution, start, end)\n        if cost < best_cost:\n            best_cost = cost\n            best_sol = sol\n\n    new_solution = best_sol\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbors\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos > 0:\n                    prev_node = new_solution[pos-1]\n                else:\n                    prev_node = new_solution[-1]\n                next_node = new_solution[pos]\n\n                # Calculate insertion cost across all objectives\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5704544431437788,
            1.3083356738090515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = [sum(obj)/3 for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection for 2-opt\n    def evaluate_segment(sol, start, end):\n        segment = sol[start:end+1]\n        reversed_segment = segment[::-1]\n        new_sol = np.concatenate([sol[:start], reversed_segment, sol[end+1:]])\n\n        cost1 = sum(distance_matrix_1[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_1[new_sol[-1], new_sol[0]]\n        cost2 = sum(distance_matrix_2[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_2[new_sol[-1], new_sol[0]]\n        cost3 = sum(distance_matrix_3[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_3[new_sol[-1], new_sol[0]]\n        return (cost1 + cost2 + cost3, new_sol)\n\n    # Evaluate multiple segments adaptively\n    best_cost = float('inf')\n    best_sol = new_solution\n    for _ in range(3):  # Evaluate 3 random segments\n        start = np.random.randint(0, n)\n        length = np.random.randint(3, min(10, n//2))\n        end = (start + length) % n\n        if start > end:\n            cost, sol = evaluate_segment(new_solution, end, start)\n        else:\n            cost, sol = evaluate_segment(new_solution, start, end)\n        if cost < best_cost:\n            best_cost = cost\n            best_sol = sol\n\n    new_solution = best_sol\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on nearest neighbors\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos > 0:\n                    prev_node = new_solution[pos-1]\n                else:\n                    prev_node = new_solution[-1]\n                next_node = new_solution[pos]\n\n                # Calculate insertion cost across all objectives\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted combination of objective values, applies a novel 2.5-opt local search operator that considers interactions between objectives, and ensures feasibility by repairing duplicates with a multi-objective greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, a, b, c, d):\n        # Create four possible 2.5-opt moves\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1], sol[a+1:b], sol[c+1:d+1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:d+1], sol[a+1:b], sol[c+1:d], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:d+1][::-1], sol[a+1:b], sol[c+1:d][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            total_cost = cost1 + cost2 + cost3\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5699544740472584,
            1.5867244601249695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    def evaluate_move(sol, a, b, c, d):\n        # Create four possible 2.5-opt moves\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1], sol[a+1:b], sol[c+1:d+1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:d+1], sol[a+1:b], sol[c+1:d], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:d+1][::-1], sol[a+1:b], sol[c+1:d][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            total_cost = cost1 + cost2 + cost3\n            costs.append((total_cost, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c, d)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment reversal impact on all objectives\n    original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n    reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]])\n\n    if reversed_cost < original_cost:\n        new_solution[i:j] = segment[::-1]\n\n    # Distance-balancing edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Calculate the change in total distance for all three objectives\n        delta = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                 distance_matrix_1[new_solution[c], new_solution[d]] -\n                 distance_matrix_1[new_solution[a], new_solution[c]] -\n                 distance_matrix_1[new_solution[b], new_solution[d]] +\n                 distance_matrix_2[new_solution[a], new_solution[b]] +\n                 distance_matrix_2[new_solution[c], new_solution[d]] -\n                 distance_matrix_2[new_solution[a], new_solution[c]] -\n                 distance_matrix_2[new_solution[b], new_solution[d]] +\n                 distance_matrix_3[new_solution[a], new_solution[b]] +\n                 distance_matrix_3[new_solution[c], new_solution[d]] -\n                 distance_matrix_3[new_solution[a], new_solution[c]] -\n                 distance_matrix_3[new_solution[b], new_solution[d]])\n\n        if delta < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6063425024031626,
            1.1443886160850525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment reversal impact on all objectives\n    original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n    reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]])\n\n    if reversed_cost < original_cost:\n        new_solution[i:j] = segment[::-1]\n\n    # Distance-balancing edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Calculate the change in total distance for all three objectives\n        delta = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                 distance_matrix_1[new_solution[c], new_solution[d]] -\n                 distance_matrix_1[new_solution[a], new_solution[c]] -\n                 distance_matrix_1[new_solution[b], new_solution[d]] +\n                 distance_matrix_2[new_solution[a], new_solution[b]] +\n                 distance_matrix_2[new_solution[c], new_solution[d]] -\n                 distance_matrix_2[new_solution[a], new_solution[c]] -\n                 distance_matrix_2[new_solution[b], new_solution[d]] +\n                 distance_matrix_3[new_solution[a], new_solution[b]] +\n                 distance_matrix_3[new_solution[c], new_solution[d]] -\n                 distance_matrix_3[new_solution[a], new_solution[c]] -\n                 distance_matrix_3[new_solution[b], new_solution[d]])\n\n        if delta < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This heuristic function selects a solution from the archive based on its diversity in objective values, applies a multi-objective 4-opt operator to simultaneously optimize all three objectives, and ensures feasibility by repairing any duplicate nodes with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most extreme objective values)\n    objectives = [obj for _, obj in archive]\n    max_diff = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(max_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create four possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:d+1][::-1], sol[a+1:b], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[a:d+1][::-1], sol[b+1:a], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_node = None\n            min_dist = float('inf')\n            for existing_node in new_solution:\n                dist1 = distance_matrix_1[node, existing_node]\n                dist2 = distance_matrix_2[node, existing_node]\n                dist3 = distance_matrix_3[node, existing_node]\n                total_dist = dist1 + dist2 + dist3\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    nearest_node = existing_node\n\n            # Insert after the nearest node\n            pos = np.where(new_solution == nearest_node)[0][0] + 1\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.46817013457864204,
            1.0008084416389464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most extreme objective values)\n    objectives = [obj for _, obj in archive]\n    max_diff = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(max_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 4-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four edges to modify\n    i, j, k, l = np.random.choice(n, 4, replace=False)\n    i, j, k, l = sorted([i, j, k, l])\n\n    # Create four possible 4-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c, d):\n        # Four possible reconnections for 4-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:d+1][::-1], sol[a+1:b], sol[d+1:]]),\n            np.concatenate([sol[:b+1], sol[a:d+1][::-1], sol[b+1:a], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:d+1][::-1], sol[d+1:]]),\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:d+1][::-1], sol[d+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k, l)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest existing node\n            nearest_node = None\n            min_dist = float('inf')\n            for existing_node in new_solution:\n                dist1 = distance_matrix_1[node, existing_node]\n                dist2 = distance_matrix_2[node, existing_node]\n                dist3 = distance_matrix_3[node, existing_node]\n                total_dist = dist1 + dist2 + dist3\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    nearest_node = existing_node\n\n            # Insert after the nearest node\n            pos = np.where(new_solution == nearest_node)[0][0] + 1\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This heuristic function selects a solution with the highest total objective value from the archive, applies a novel multi-objective segment inversion operator that considers the combined impact of all three objectives, and ensures feasibility by repairing any invalid tours with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(10, n//2))\n    end = (start + length) % n\n\n    if start < end:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        segment = segment[::-1]\n        new_solution[start:] = segment[:n-start]\n        new_solution[:end] = segment[n-start:]\n\n    # Repair any duplicates or missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest neighbor insertion point\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7141496763541412,
            0.9702700614929199
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(10, n//2))\n    end = (start + length) % n\n\n    if start < end:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        segment = segment[::-1]\n        new_solution[start:] = segment[:n-start]\n        new_solution[:end] = segment[n-start:]\n\n    # Repair any duplicates or missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest neighbor insertion point\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange between two randomly selected edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6162051576910893,
            1.1462380409240722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange between two randomly selected edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive with the highest sum of objectives, then applies a novel tri-objective-aware local search that combines 3-opt moves with objective-space-aware edge selection, ensuring feasibility while prioritizing diverse objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Tri-objective-aware 3-opt move\n    if n >= 3:\n        # Select three random edges\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate the potential improvement in each objective space\n        def calc_improvement(sol):\n            total = 0\n            for i in range(n):\n                u, v = sol[i], sol[(i+1)%n]\n                total += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n            return total\n\n        # Generate all possible 3-opt neighbors and select the best one\n        best_improvement = float('inf')\n        best_solution = new_solution.copy()\n\n        # Try all possible 3-opt configurations\n        for i in [a, b, c]:\n            for j in [a, b, c]:\n                if i != j:\n                    temp_sol = new_solution.copy()\n                    temp_sol[i:j] = temp_sol[i:j][::-1]\n                    current_improvement = calc_improvement(temp_sol)\n                    if current_improvement < best_improvement:\n                        best_improvement = current_improvement\n                        best_solution = temp_sol\n\n        new_solution = best_solution\n\n    # Objective-space-aware edge selection\n    for _ in range(2):\n        # Select two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate the potential improvement in each objective space\n        def calc_edge_improvement(u, v):\n            return (distance_matrix_1[new_solution[u], new_solution[v]] +\n                    distance_matrix_2[new_solution[u], new_solution[v]] +\n                    distance_matrix_3[new_solution[u], new_solution[v]])\n\n        # Find the best edge to swap\n        best_swap = None\n        best_improvement = 0\n\n        for k in range(n):\n            if k != i and k != j:\n                current_improvement = (calc_edge_improvement(i, k) + calc_edge_improvement(j, k) -\n                                      calc_edge_improvement(i, j))\n                if current_improvement < best_improvement:\n                    best_improvement = current_improvement\n                    best_swap = k\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7268274914477686,
            1.7785070776939391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Tri-objective-aware 3-opt move\n    if n >= 3:\n        # Select three random edges\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate the potential improvement in each objective space\n        def calc_improvement(sol):\n            total = 0\n            for i in range(n):\n                u, v = sol[i], sol[(i+1)%n]\n                total += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n            return total\n\n        # Generate all possible 3-opt neighbors and select the best one\n        best_improvement = float('inf')\n        best_solution = new_solution.copy()\n\n        # Try all possible 3-opt configurations\n        for i in [a, b, c]:\n            for j in [a, b, c]:\n                if i != j:\n                    temp_sol = new_solution.copy()\n                    temp_sol[i:j] = temp_sol[i:j][::-1]\n                    current_improvement = calc_improvement(temp_sol)\n                    if current_improvement < best_improvement:\n                        best_improvement = current_improvement\n                        best_solution = temp_sol\n\n        new_solution = best_solution\n\n    # Objective-space-aware edge selection\n    for _ in range(2):\n        # Select two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate the potential improvement in each objective space\n        def calc_edge_improvement(u, v):\n            return (distance_matrix_1[new_solution[u], new_solution[v]] +\n                    distance_matrix_2[new_solution[u], new_solution[v]] +\n                    distance_matrix_3[new_solution[u], new_solution[v]])\n\n        # Find the best edge to swap\n        best_swap = None\n        best_improvement = 0\n\n        for k in range(n):\n            if k != i and k != j:\n                current_improvement = (calc_edge_improvement(i, k) + calc_edge_improvement(j, k) -\n                                      calc_edge_improvement(i, j))\n                if current_improvement < best_improvement:\n                    best_improvement = current_improvement\n                    best_swap = k\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the objective space, applies a hybrid 2-opt and 3-opt local search to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a nearest-neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives (minimizing the sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 2-opt and 3-opt local search\n    def evaluate_move(sol, a, b, c=None):\n        if c is None:  # 2-opt move\n            options = [\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n                np.concatenate([sol[:b+1], sol[a:b:-1], sol[b+1:]])\n            ]\n        else:  # 3-opt move\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    # Randomly choose between 2-opt or 3-opt\n    if np.random.rand() < 0.7:  # Higher probability for 3-opt\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution = evaluate_move(new_solution, i, j, k)\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5455474573528789,
            1.2284374237060547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives (minimizing the sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 2-opt and 3-opt local search\n    def evaluate_move(sol, a, b, c=None):\n        if c is None:  # 2-opt move\n            options = [\n                np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n                np.concatenate([sol[:b+1], sol[a:b:-1], sol[b+1:]])\n            ]\n        else:  # 3-opt move\n            options = [\n                np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n                np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n                np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n            ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    # Randomly choose between 2-opt or 3-opt\n    if np.random.rand() < 0.7:  # Higher probability for 3-opt\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution = evaluate_move(new_solution, i, j, k)\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest-neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search operator that combines segment reversal with objective-aware edge swaps to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighting for the three objectives\n    selected_solution, _ = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment reversal impact on all objectives\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Revert if reversal worsens any objective\n    if any(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i:j] = segment\n\n    # Apply objective-aware edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Evaluate edge swap impact\n        original_edges = [\n            (new_solution[a], new_solution[b]),\n            (new_solution[c], new_solution[d])\n        ]\n\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[d])\n        ]\n\n        original_edge_costs = [\n            distance_matrix_1[original_edges[0][0], original_edges[0][1]] + distance_matrix_1[original_edges[1][0], original_edges[1][1]],\n            distance_matrix_2[original_edges[0][0], original_edges[0][1]] + distance_matrix_2[original_edges[1][0], original_edges[1][1]],\n            distance_matrix_3[original_edges[0][0], original_edges[0][1]] + distance_matrix_3[original_edges[1][0], original_edges[1][1]]\n        ]\n\n        new_edge_costs = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n        ]\n\n        # Apply swap if it improves at least one objective without worsening others\n        if not any(new_cost > original_cost for new_cost, original_cost in zip(new_edge_costs, original_edge_costs)):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6872567472222522,
            1.7709113001823424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighting for the three objectives\n    selected_solution, _ = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Evaluate segment reversal impact on all objectives\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) +\n        distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Revert if reversal worsens any objective\n    if any(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i:j] = segment\n\n    # Apply objective-aware edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Evaluate edge swap impact\n        original_edges = [\n            (new_solution[a], new_solution[b]),\n            (new_solution[c], new_solution[d])\n        ]\n\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[d])\n        ]\n\n        original_edge_costs = [\n            distance_matrix_1[original_edges[0][0], original_edges[0][1]] + distance_matrix_1[original_edges[1][0], original_edges[1][1]],\n            distance_matrix_2[original_edges[0][0], original_edges[0][1]] + distance_matrix_2[original_edges[1][0], original_edges[1][1]],\n            distance_matrix_3[original_edges[0][0], original_edges[0][1]] + distance_matrix_3[original_edges[1][0], original_edges[1][1]]\n        ]\n\n        new_edge_costs = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n        ]\n\n        # Apply swap if it improves at least one objective without worsening others\n        if not any(new_cost > original_cost for new_cost, original_cost in zip(new_edge_costs, original_edge_costs)):\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, applies a novel 2-opt with multi-objective evaluation, and uses a greedy repair mechanism to ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    combined_objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt with multi-objective evaluation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create two possible 2-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:a+1], sol[b+1:], sol[:b+1][::-1]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7204423370714489,
            0.4992441892623901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    combined_objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt with multi-objective evaluation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create two possible 2-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b):\n        # Two possible reconnections for 2-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:a+1], sol[b+1:], sol[:b+1][::-1]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6377025790937668,
            1.036594295501709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{The new algorithm combines multi-objective selection with a novel cyclic path reconstruction operator that selectively reverses segments to optimize across all three objectives while maintaining tour feasibility through a greedy segment replacement strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest aggregate improvement potential\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify critical segments for cyclic reconstruction\n    segment_length = max(3, n // 5)\n    segments = [selected_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Evaluate segment contributions across objectives\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        cost3 = sum(distance_matrix_3[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        segment_costs.append((cost1 + cost2 + cost3, seg))\n\n    # Select top k segments for reconstruction\n    k = max(1, len(segments) // 3)\n    worst_segments = sorted(segment_costs, key=lambda x: -x[0])[:k]\n\n    # Reconstruct segments with cyclic permutations\n    for cost, seg in worst_segments:\n        # Generate all cyclic permutations of the segment\n        permutations = [np.roll(seg, shift) for shift in range(1, len(seg))]\n\n        # Evaluate each permutation\n        best_perm = seg\n        best_cost = cost\n        for perm in permutations:\n            # Create candidate solution\n            candidate = new_solution.copy()\n            start_idx = np.where(new_solution == seg[0])[0][0]\n            candidate[start_idx:start_idx+len(seg)] = perm\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_perm = perm\n\n        # Apply best permutation\n        start_idx = np.where(new_solution == seg[0])[0][0]\n        new_solution[start_idx:start_idx+len(seg)] = best_perm\n\n    # Ensure feasibility by repairing duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6187632935166315,
            1.7037881851196288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest aggregate improvement potential\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify critical segments for cyclic reconstruction\n    segment_length = max(3, n // 5)\n    segments = [selected_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Evaluate segment contributions across objectives\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        cost3 = sum(distance_matrix_3[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        segment_costs.append((cost1 + cost2 + cost3, seg))\n\n    # Select top k segments for reconstruction\n    k = max(1, len(segments) // 3)\n    worst_segments = sorted(segment_costs, key=lambda x: -x[0])[:k]\n\n    # Reconstruct segments with cyclic permutations\n    for cost, seg in worst_segments:\n        # Generate all cyclic permutations of the segment\n        permutations = [np.roll(seg, shift) for shift in range(1, len(seg))]\n\n        # Evaluate each permutation\n        best_perm = seg\n        best_cost = cost\n        for perm in permutations:\n            # Create candidate solution\n            candidate = new_solution.copy()\n            start_idx = np.where(new_solution == seg[0])[0][0]\n            candidate[start_idx:start_idx+len(seg)] = perm\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_perm = perm\n\n        # Apply best permutation\n        start_idx = np.where(new_solution == seg[0])[0][0]\n        new_solution[start_idx:start_idx+len(seg)] = best_perm\n\n    # Ensure feasibility by repairing duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{The new algorithm selects a solution from the archive based on the most promising objective improvement potential, then applies a novel multi-objective segment reversal and insertion hybrid operator that intelligently balances local improvements across all three objectives while maintaining feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (most unbalanced objectives)\n    objectives = [obj for _, obj in archive]\n    improvement_potentials = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid segment reversal and insertion operator\n    # First, perform a segment reversal that shows potential for improvement\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the reversed segment across all objectives\n    def evaluate_segment(sol, seg, pos):\n        candidate = np.concatenate([sol[:pos], seg, sol[pos:]])\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = evaluate_segment(new_solution, segment, i)\n    reversed_cost = evaluate_segment(new_solution, reversed_segment, i)\n\n    # Only accept if at least one objective improves\n    if any(r < o for r, o in zip(reversed_cost, original_cost)):\n        new_solution[i:j] = reversed_segment\n\n    # Then perform an intelligent insertion of a randomly selected node\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(n):\n        candidate = np.insert(new_solution, pos, node_to_insert)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Calculate improvement across all objectives\n        original_total = sum(original_cost)\n        new_total = cost1 + cost2 + cost3\n        improvement = original_total - new_total\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_improvement > 0:\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates if any exist\n    unique, indices = np.unique(new_solution, return_index=True)\n    if len(unique) != n:\n        # Keep only the first occurrence of each node\n        new_solution = new_solution[np.sort(indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.5012171534338529,
            3.7373783469200133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (most unbalanced objectives)\n    objectives = [obj for _, obj in archive]\n    improvement_potentials = [max(obj) - min(obj) for obj in objectives]\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid segment reversal and insertion operator\n    # First, perform a segment reversal that shows potential for improvement\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the reversed segment across all objectives\n    def evaluate_segment(sol, seg, pos):\n        candidate = np.concatenate([sol[:pos], seg, sol[pos:]])\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = evaluate_segment(new_solution, segment, i)\n    reversed_cost = evaluate_segment(new_solution, reversed_segment, i)\n\n    # Only accept if at least one objective improves\n    if any(r < o for r, o in zip(reversed_cost, original_cost)):\n        new_solution[i:j] = reversed_segment\n\n    # Then perform an intelligent insertion of a randomly selected node\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(n):\n        candidate = np.insert(new_solution, pos, node_to_insert)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Calculate improvement across all objectives\n        original_total = sum(original_cost)\n        new_total = cost1 + cost2 + cost3\n        improvement = original_total - new_total\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_improvement > 0:\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates if any exist\n    unique, indices = np.unique(new_solution, return_index=True)\n    if len(unique) != n:\n        # Keep only the first occurrence of each node\n        new_solution = new_solution[np.sort(indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently combines a dominance-aware selection strategy with a hybrid 3-opt and edge exchange operator, leveraging the tri-objective nature of the problem to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def normalize_objectives(obj):\n        return (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n\n    selected_solution, _ = max(archive, key=lambda x: sum(normalize_objectives(x[1])))\n\n    # Apply a hybrid 3-opt and edge exchange operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move: select three random positions and reverse the middle segment\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge exchange: swap two edges if they don't create duplicates\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if i != k and j != l:\n        new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    return new_solution\n\n",
        "score": [
            -0.5176303126799111,
            3.1532165169715882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def normalize_objectives(obj):\n        return (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n\n    selected_solution, _ = max(archive, key=lambda x: sum(normalize_objectives(x[1])))\n\n    # Apply a hybrid 3-opt and edge exchange operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move: select three random positions and reverse the middle segment\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge exchange: swap two edges if they don't create duplicates\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if i != k and j != l:\n        new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * val for w, val in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.7\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with probability 0.5\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6824604544704027,
            1.4508763670921325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    selected_solution, _ = max(archive, key=lambda x: sum(w * val for w, val in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.7\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange with probability 0.5\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement in multiple objectives, applies a novel hybrid local search operator that combines 2-opt with a multi-objective aware node swap, and ensures feasibility by repairing any missing nodes through a cost-aware insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (minimizing the worst objective)\n    objectives = [obj for _, obj in archive]\n    min_worst = np.min([np.max(obj) for obj in objectives])\n    candidates = [i for i, obj in enumerate(objectives) if np.max(obj) == min_worst]\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware node swap\n    for _ in range(2):  # Perform multiple iterations\n        # Randomly select two edges to modify\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Create two possible 2-opt moves\n        options = [\n            np.concatenate([new_solution[:a+1], new_solution[b:a:-1], new_solution[b+1:]]),\n            np.concatenate([new_solution[:b+1], new_solution[a:b:-1], new_solution[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        def evaluate_option(opt):\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            return (cost1, cost2, cost3)\n\n        costs = [evaluate_option(opt) for opt in options]\n        best_idx = np.argmin([sum(cost) for cost in costs])\n        new_solution = options[best_idx]\n\n        # Multi-objective aware node swap\n        if np.random.random() < 0.3:  # 30% chance to perform swap\n            i, j = np.random.choice(n, 2, replace=False)\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Accept swap if it improves any objective\n            new_costs = evaluate_option(candidate)\n            current_costs = evaluate_option(new_solution)\n            if any(nc < cc for nc, cc in zip(new_costs, current_costs)):\n                new_solution = candidate\n\n    # Repair missing nodes if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5706885410854345,
            1.526992380619049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (minimizing the worst objective)\n    objectives = [obj for _, obj in archive]\n    min_worst = np.min([np.max(obj) for obj in objectives])\n    candidates = [i for i, obj in enumerate(objectives) if np.max(obj) == min_worst]\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware node swap\n    for _ in range(2):  # Perform multiple iterations\n        # Randomly select two edges to modify\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Create two possible 2-opt moves\n        options = [\n            np.concatenate([new_solution[:a+1], new_solution[b:a:-1], new_solution[b+1:]]),\n            np.concatenate([new_solution[:b+1], new_solution[a:b:-1], new_solution[a+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        def evaluate_option(opt):\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            return (cost1, cost2, cost3)\n\n        costs = [evaluate_option(opt) for opt in options]\n        best_idx = np.argmin([sum(cost) for cost in costs])\n        new_solution = options[best_idx]\n\n        # Multi-objective aware node swap\n        if np.random.random() < 0.3:  # 30% chance to perform swap\n            i, j = np.random.choice(n, 2, replace=False)\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Accept swap if it improves any objective\n            new_costs = evaluate_option(candidate)\n            current_costs = evaluate_option(new_solution)\n            if any(nc < cc for nc, cc in zip(new_costs, current_costs)):\n                new_solution = candidate\n\n    # Repair missing nodes if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position based on all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This heuristic function selects a solution with the highest worst-case objective value to target underperforming dimensions, then applies a novel 2.5-opt operator that combines 2-opt and 3-opt moves to balance exploration and exploitation across all three objectives while ensuring feasibility through a minimal repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest worst-case objective\n    objectives = [obj for _, obj in archive]\n    worst_case = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(worst_case)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (hybrid of 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments for modification\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create possible moves\n    def evaluate_move(sol, a, b, c):\n        # 2.5-opt options: 2-opt + 3-opt combinations\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),  # 3-opt\n            np.concatenate([sol[:b+1], sol[a:b+1][::-1], sol[b+1:]]),            # 2-opt\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]]),  # 3-opt\n            np.concatenate([sol[:a+1], sol[b:c+1], sol[a+1:b], sol[c+1:]])        # 2-opt with different segment\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Minimal repair if duplicates exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Swap duplicate nodes with missing nodes\n        duplicates = [node for node, count in zip(unique, counts) if count > 1]\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(min(len(duplicates), len(missing))):\n            idx = np.where(new_solution == duplicates[i])[0][0]\n            new_solution[idx] = missing[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5413193956991602,
            0.6218735814094544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest worst-case objective\n    objectives = [obj for _, obj in archive]\n    worst_case = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(worst_case)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (hybrid of 2-opt and 3-opt)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments for modification\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create possible moves\n    def evaluate_move(sol, a, b, c):\n        # 2.5-opt options: 2-opt + 3-opt combinations\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),  # 3-opt\n            np.concatenate([sol[:b+1], sol[a:b+1][::-1], sol[b+1:]]),            # 2-opt\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]]),  # 3-opt\n            np.concatenate([sol[:a+1], sol[b:c+1], sol[a+1:b], sol[c+1:]])        # 2-opt with different segment\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Minimal repair if duplicates exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Swap duplicate nodes with missing nodes\n        duplicates = [node for node, count in zip(unique, counts) if count > 1]\n        missing = np.setdiff1d(np.arange(n), unique)\n        for i in range(min(len(duplicates), len(missing))):\n            idx = np.where(new_solution == duplicates[i])[0][0]\n            new_solution[idx] = missing[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a 2.5-opt local search operator to generate a neighbor solution by randomly selecting and reversing segments, while ensuring feasibility and exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights for multi-objective optimization\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt local search\n    for _ in range(3):  # Perform multiple moves\n        # Randomly select two segments and perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Randomly select two edges and perform an edge exchange\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6274625072469033,
            1.4438616991043092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights for multi-objective optimization\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt local search\n    for _ in range(3):  # Perform multiple moves\n        # Randomly select two segments and perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Randomly select two edges and perform an edge exchange\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive with the highest total objective value, then applies a hybrid local search combining 2-opt with a novel edge-swap operation that considers all three objectives simultaneously to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in all three objectives\n    def objective_change(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    temp_solution = new_solution.copy()\n    temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n    new_cost = objective_change(temp_solution)\n\n    # Only accept the edge exchange if it improves at least one objective\n    if any(new_cost[i] < sum(x[1][i] for x in archive) for i in range(3)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5043071525597663,
            1.20853089094162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a multi-objective edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in all three objectives\n    def objective_change(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    temp_solution = new_solution.copy()\n    temp_solution[[a, b, c, d]] = temp_solution[[a, c, b, d]]\n    new_cost = objective_change(temp_solution)\n\n    # Only accept the edge exchange if it improves at least one objective\n    if any(new_cost[i] < sum(x[1][i] for x in archive) for i in range(3)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])\n\n    # Apply a novel local search operator combining segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (similar to 2-opt but with a fixed segment length)\n    segment_length = np.random.randint(3, min(10, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Randomly select a node and insert it in a different position\n    node_index = np.random.randint(0, n)\n    node = new_solution[node_index]\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, node_index)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.612582496190431,
            1.1278502941131592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])\n\n    # Apply a novel local search operator combining segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (similar to 2-opt but with a fixed segment length)\n    segment_length = np.random.randint(3, min(10, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Randomly select a node and insert it in a different position\n    node_index = np.random.randint(0, n)\n    node = new_solution[node_index]\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, node_index)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm combines a novel multi-objective segment reversal operator with a greedy node reinsertion strategy to balance improvement across all three objectives while ensuring feasibility through careful validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (most promising for improvement)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel segment reversal operator with objective-aware selection\n    # Select a random segment and reverse it if it improves at least one objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1][::-1]\n    candidate = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Evaluate the candidate across all objectives\n    cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n    cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n    cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n    # Accept if at least one objective improves\n    original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    original_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    if (cost1 < original_cost1) or (cost2 < original_cost2) or (cost3 < original_cost3):\n        new_solution = candidate\n\n    # Apply greedy node reinsertion to repair any feasibility issues\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6979596853384593,
            1.425344705581665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (most promising for improvement)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel segment reversal operator with objective-aware selection\n    # Select a random segment and reverse it if it improves at least one objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1][::-1]\n    candidate = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Evaluate the candidate across all objectives\n    cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n    cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n    cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n    # Accept if at least one objective improves\n    original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    original_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    if (cost1 < original_cost1) or (cost2 < original_cost2) or (cost3 < original_cost3):\n        new_solution = candidate\n\n    # Apply greedy node reinsertion to repair any feasibility issues\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This heuristic function selects a solution from the archive with the best overall objective balance, applies a novel multi-objective 2.5-opt local search operator that considers both edge swaps and partial reversals to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective balance\n    objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (combining 2-opt and partial reversal)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three points to define the operation area\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create three possible 2.5-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, x, y, z):\n        # Three possible reconnections for 2.5-opt\n        options = [\n            np.concatenate([sol[:x+1], sol[y:z+1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),\n            np.concatenate([sol[:x+1], sol[x:y+1][::-1], sol[y+1:z+1], sol[z+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6368424076585162,
            0.7163527965545654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective balance\n    objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2.5-opt local search (combining 2-opt and partial reversal)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three points to define the operation area\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create three possible 2.5-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, x, y, z):\n        # Three possible reconnections for 2.5-opt\n        options = [\n            np.concatenate([sol[:x+1], sol[y:z+1], sol[x+1:y], sol[z+1:]]),\n            np.concatenate([sol[:y+1], sol[x:z+1][::-1], sol[y+1:x], sol[z+1:]]),\n            np.concatenate([sol[:x+1], sol[x:y+1][::-1], sol[y+1:z+1], sol[z+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, a, b, c)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a segment-based local search that combines 2-opt and edge exchange with a novel probabilistic selection of segments and edges to balance exploration and exploitation across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search with probabilistic selection\n    if np.random.rand() < 0.5:\n        # 2-opt with segment selection based on edge weights\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        if len(segment) > 1:\n            # Select segments with higher total edge weights in any objective\n            weights = []\n            for k in range(len(segment)-1):\n                w1 = distance_matrix_1[segment[k], segment[k+1]]\n                w2 = distance_matrix_2[segment[k], segment[k+1]]\n                w3 = distance_matrix_3[segment[k], segment[k+1]]\n                weights.append(max(w1, w2, w3))\n            if len(weights) > 0 and max(weights) > np.median(weights):\n                new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange with probabilistic selection\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Select edges with higher weights in any objective\n            w1 = max(distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n            w2 = max(distance_matrix_1[c, d], distance_matrix_2[c, d], distance_matrix_3[c, d])\n            if w1 > np.median([distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b]]) or \\\n               w2 > np.median([distance_matrix_1[c, d], distance_matrix_2[c, d], distance_matrix_3[c, d]]):\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6493632812185476,
            1.266868007183075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search with probabilistic selection\n    if np.random.rand() < 0.5:\n        # 2-opt with segment selection based on edge weights\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        if len(segment) > 1:\n            # Select segments with higher total edge weights in any objective\n            weights = []\n            for k in range(len(segment)-1):\n                w1 = distance_matrix_1[segment[k], segment[k+1]]\n                w2 = distance_matrix_2[segment[k], segment[k+1]]\n                w3 = distance_matrix_3[segment[k], segment[k+1]]\n                weights.append(max(w1, w2, w3))\n            if len(weights) > 0 and max(weights) > np.median(weights):\n                new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange with probabilistic selection\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            # Select edges with higher weights in any objective\n            w1 = max(distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n            w2 = max(distance_matrix_1[c, d], distance_matrix_2[c, d], distance_matrix_3[c, d])\n            if w1 > np.median([distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b]]) or \\\n               w2 > np.median([distance_matrix_1[c, d], distance_matrix_2[c, d], distance_matrix_3[c, d]]):\n                new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This heuristic function selects a solution from the archive based on its objective diversity, applies a novel multi-objective hybrid local search combining 2-opt and node insertion, and ensures feasibility by repairing any duplicate nodes with a greedy strategy that optimizes across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.max(obj) - np.min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective evaluation\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create two possible 2-opt moves and evaluate across all objectives\n    def evaluate_move(sol, a, b):\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Node insertion for further optimization\n    node_to_move = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n\n    # Find best insertion position considering all objectives\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node_to_move)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5264314289089898,
            3.9822290539741516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.max(obj) - np.min(obj) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective evaluation\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create two possible 2-opt moves and evaluate across all objectives\n    def evaluate_move(sol, a, b):\n        options = [\n            np.concatenate([sol[:a+1], sol[b:a:-1], sol[b+1:]]),\n            np.concatenate([sol[:b+1], sol[a:b:-1], sol[a+1:]])\n        ]\n\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j)\n\n    # Node insertion for further optimization\n    node_to_move = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n\n    # Find best insertion position considering all objectives\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node_to_move)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive with the highest sum of objective values, then applies a hybrid local search combining 2-opt and edge exchange, ensuring feasibility by validating the tour structure after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 2-opt and edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.5730907749823816,
            1.1943873286247253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search combining 2-opt and edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining 2-opt and edge exchange, and ensures feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.4, 0.3, 0.3])  # Custom weights for tri-objective optimization\n    selected_solution, _ = max(archive, key=lambda x: np.dot(weights, x[1]))\n\n    # Apply hybrid local search combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange between two randomly selected edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.47055859656152405,
            1.5792305946350098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.4, 0.3, 0.3])  # Custom weights for tri-objective optimization\n    selected_solution, _ = max(archive, key=lambda x: np.dot(weights, x[1]))\n\n    # Apply hybrid local search combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange between two randomly selected edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects the most balanced solution from the archive (based on objective variance) and applies a novel multi-segment inversion operator that simultaneously optimizes all three objectives by randomly inverting multiple non-overlapping segments of the tour, ensuring feasibility through a greedy segment repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution (lowest objective variance)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply multi-segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select 2-4 segments and invert them\n    num_segments = np.random.randint(2, 5)\n    segment_lengths = np.random.randint(2, n//2, size=num_segments)\n    segment_starts = np.random.choice(n, num_segments, replace=False)\n    segment_starts = np.sort(segment_starts)\n\n    for start, length in zip(segment_starts, segment_lengths):\n        end = min(start + length, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Repair any duplicates by greedily inserting missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7139297951934485,
            3.1469687819480896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution (lowest objective variance)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply multi-segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select 2-4 segments and invert them\n    num_segments = np.random.randint(2, 5)\n    segment_lengths = np.random.randint(2, n//2, size=num_segments)\n    segment_starts = np.random.choice(n, num_segments, replace=False)\n    segment_starts = np.sort(segment_starts)\n\n    for start, length in zip(segment_starts, segment_lengths):\n        end = min(start + length, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Repair any duplicates by greedily inserting missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, applies a hybrid 2-opt and relocate operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a nearest neighbor insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse objectives\n    objectives = [obj for _, obj in archive]\n    max_diff = -1\n    selected_idx = 0\n    for i in range(len(objectives)):\n        diff = max(objectives[i]) - min(objectives[i])\n        if diff > max_diff:\n            max_diff = diff\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 2-opt and relocate operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible reconnections\n    options = [\n        np.concatenate([new_solution[:i+1], new_solution[j:][::-1], new_solution[i+1:j]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:j][::-1], new_solution[j+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    best_option = None\n    best_cost = float('inf')\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = opt\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Relocate a random node to a better position\n    node_pos = np.random.randint(n)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest neighbor in the current solution\n            min_dist = float('inf')\n            best_pos = 0\n            for pos in range(n-1):\n                dist = (distance_matrix_1[new_solution[pos], node] + distance_matrix_2[new_solution[pos], node] + distance_matrix_3[new_solution[pos], node]) / 3\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.458320472041786,
            2.7325136780738832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse objectives\n    objectives = [obj for _, obj in archive]\n    max_diff = -1\n    selected_idx = 0\n    for i in range(len(objectives)):\n        diff = max(objectives[i]) - min(objectives[i])\n        if diff > max_diff:\n            max_diff = diff\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid 2-opt and relocate operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to modify\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = sorted([i, j])\n\n    # Create possible reconnections\n    options = [\n        np.concatenate([new_solution[:i+1], new_solution[j:][::-1], new_solution[i+1:j]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:j][::-1], new_solution[j+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    best_option = None\n    best_cost = float('inf')\n    for opt in options:\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = opt\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Relocate a random node to a better position\n    node_pos = np.random.randint(n)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        candidate = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Nearest neighbor insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the nearest neighbor in the current solution\n            min_dist = float('inf')\n            best_pos = 0\n            for pos in range(n-1):\n                dist = (distance_matrix_1[new_solution[pos], node] + distance_matrix_2[new_solution[pos], node] + distance_matrix_3[new_solution[pos], node]) / 3\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This heuristic function selects a solution from the archive based on its multi-objective improvement potential, applies a novel hybrid local search combining segmented swaps and objective-aware edge flips to simultaneously optimize across all three objectives, and ensures feasibility by repairing any duplicates with a least-cost insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (min of max objective values)\n    objectives = [obj for _, obj in archive]\n    improvement_potentials = [min(obj) for obj in objectives]\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply segmented swap operator\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    new_solution[start:start+segment_size] = np.roll(new_solution[start:start+segment_size], np.random.randint(1, segment_size))\n\n    # Apply objective-aware edge flips\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate flip based on all three objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        flipped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if flipped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]] +\n                       sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]] +\n                       sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.727138771389444,
            1.396320140361786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (min of max objective values)\n    objectives = [obj for _, obj in archive]\n    improvement_potentials = [min(obj) for obj in objectives]\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply segmented swap operator\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    new_solution[start:start+segment_size] = np.roll(new_solution[start:start+segment_size], np.random.randint(1, segment_size))\n\n    # Apply objective-aware edge flips\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate flip based on all three objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        flipped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if flipped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair duplicates if any\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]] +\n                       sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]] +\n                       sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (x[1][0] / distance_matrix_1.sum() + x[1][1] / distance_matrix_2.sum() + x[1][2] / distance_matrix_3.sum()))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel three-way edge reversal operation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Perform a cross-space edge swap to balance objectives\n    if n > 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5890336626427022,
            2.8612109184265138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (x[1][0] / distance_matrix_1.sum() + x[1][1] / distance_matrix_2.sum() + x[1][2] / distance_matrix_3.sum()))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel three-way edge reversal operation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Perform a cross-space edge swap to balance objectives\n    if n > 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search using a novel 3D-aware edge exchange operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        combined_score = sum(obj) * (1 + np.random.uniform(0.5, 1.5))  # Add randomness to selection\n        scores.append(combined_score)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # 3D-aware hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3D-aware 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform a 3D-aware edge exchange\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    # Calculate the change in each objective space\n    obj1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[b], new_solution[(c+1)%n]])\n    obj2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[c], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[b], new_solution[(c+1)%n]])\n    obj3_change = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[c], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_3[new_solution[b], new_solution[(c+1)%n]])\n\n    # Only perform the exchange if it improves at least one objective\n    if obj1_change < 0 or obj2_change < 0 or obj3_change < 0:\n        new_solution[[a, b, c]] = new_solution[[a, c, b]]\n\n    return new_solution\n\n",
        "score": [
            -0.6282940595482874,
            1.6485093712806702
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        combined_score = sum(obj) * (1 + np.random.uniform(0.5, 1.5))  # Add randomness to selection\n        scores.append(combined_score)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # 3D-aware hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3D-aware 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform a 3D-aware edge exchange\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    # Calculate the change in each objective space\n    obj1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[b], new_solution[(c+1)%n]])\n    obj2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[c], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[b], new_solution[(c+1)%n]])\n    obj3_change = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[c], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_3[new_solution[b], new_solution[(c+1)%n]])\n\n    # Only perform the exchange if it improves at least one objective\n    if obj1_change < 0 or obj2_change < 0 or obj3_change < 0:\n        new_solution[[a, b, c]] = new_solution[[a, c, b]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This heuristic function selects a diverse solution from the archive, applies a novel hybrid local search operator that combines 3-opt with a multi-objective adaptive perturbation strategy to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy while prioritizing solutions that show the most balanced improvement potential across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution with high potential for improvement\n    objectives = [obj for _, obj in archive]\n    improvement_potentials = [np.sum(obj) / len(obj) for obj in objectives]  # Average objective value\n    selected_idx = np.argmin(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective perturbation\n    for _ in range(2):  # Perform multiple perturbations\n        # Select segments adaptively based on objective diversity\n        segment_length = max(3, n // 10)\n        start = np.random.randint(0, n - segment_length)\n        segment = slice(start, start + segment_length)\n\n        # Create a perturbation by reversing a segment\n        perturbed = np.concatenate([new_solution[:start], new_solution[segment][::-1], new_solution[start + segment_length:]])\n\n        # Evaluate the perturbation across all objectives\n        def evaluate_perturbation(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_costs = evaluate_perturbation(new_solution)\n        perturbed_costs = evaluate_perturbation(perturbed)\n\n        # Accept if any objective improves\n        if any(p < o for p, o in zip(perturbed_costs, original_costs)):\n            new_solution = perturbed\n        else:\n            # If no improvement, perform a random 3-opt move\n            i, j, k = np.random.choice(n, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n            options = [\n                np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n                np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n                np.concatenate([new_solution[:i+1], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n            ]\n            costs = [evaluate_perturbation(opt) for opt in options]\n            best_idx = min(range(3), key=lambda x: sum(costs[x]))\n            new_solution = options[best_idx]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6437301144753454,
            3.166152334213257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution with high potential for improvement\n    objectives = [obj for _, obj in archive]\n    improvement_potentials = [np.sum(obj) / len(obj) for obj in objectives]  # Average objective value\n    selected_idx = np.argmin(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective perturbation\n    for _ in range(2):  # Perform multiple perturbations\n        # Select segments adaptively based on objective diversity\n        segment_length = max(3, n // 10)\n        start = np.random.randint(0, n - segment_length)\n        segment = slice(start, start + segment_length)\n\n        # Create a perturbation by reversing a segment\n        perturbed = np.concatenate([new_solution[:start], new_solution[segment][::-1], new_solution[start + segment_length:]])\n\n        # Evaluate the perturbation across all objectives\n        def evaluate_perturbation(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_costs = evaluate_perturbation(new_solution)\n        perturbed_costs = evaluate_perturbation(perturbed)\n\n        # Accept if any objective improves\n        if any(p < o for p, o in zip(perturbed_costs, original_costs)):\n            new_solution = perturbed\n        else:\n            # If no improvement, perform a random 3-opt move\n            i, j, k = np.random.choice(n, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n            options = [\n                np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n                np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n                np.concatenate([new_solution[:i+1], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n            ]\n            costs = [evaluate_perturbation(opt) for opt in options]\n            best_idx = min(range(3), key=lambda x: sum(costs[x]))\n            new_solution = options[best_idx]\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position considering all objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining 3-opt and edge exchange, and ensures feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt creates duplicates\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4694764125394917,
            1.4234342694282531
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt creates duplicates\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective aware segment inversion\n    # Randomly select a segment and invert it, considering all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate the cost of the segment in all three objectives\n    cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    cost3 = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n    # Invert the segment if it improves any of the objectives\n    if np.random.rand() < 0.5 or (cost1 > 0 and cost2 > 0 and cost3 > 0):\n        new_solution[i:j] = segment[::-1]\n\n    # Apply a multi-objective aware edge swap\n    # Randomly select two edges and swap them, considering all three objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Calculate the cost of the current edges in all three objectives\n        current_cost1 = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_1[new_solution[c], new_solution[(c+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_2[new_solution[c], new_solution[(c+1)%n]])\n        current_cost3 = (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_3[new_solution[c], new_solution[(c+1)%n]])\n\n        # Calculate the cost of the swapped edges in all three objectives\n        new_cost1 = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                    distance_matrix_1[new_solution[b], new_solution[d]])\n        new_cost2 = (distance_matrix_2[new_solution[a], new_solution[c]] +\n                    distance_matrix_2[new_solution[b], new_solution[d]])\n        new_cost3 = (distance_matrix_3[new_solution[a], new_solution[c]] +\n                    distance_matrix_3[new_solution[b], new_solution[d]])\n\n        # Swap the edges if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.555096169275542,
            1.1921844601631164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a multi-objective aware segment inversion\n    # Randomly select a segment and invert it, considering all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Calculate the cost of the segment in all three objectives\n    cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    cost3 = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n    # Invert the segment if it improves any of the objectives\n    if np.random.rand() < 0.5 or (cost1 > 0 and cost2 > 0 and cost3 > 0):\n        new_solution[i:j] = segment[::-1]\n\n    # Apply a multi-objective aware edge swap\n    # Randomly select two edges and swap them, considering all three objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != c and b != d:\n        # Calculate the cost of the current edges in all three objectives\n        current_cost1 = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_1[new_solution[c], new_solution[(c+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_2[new_solution[c], new_solution[(c+1)%n]])\n        current_cost3 = (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_3[new_solution[c], new_solution[(c+1)%n]])\n\n        # Calculate the cost of the swapped edges in all three objectives\n        new_cost1 = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                    distance_matrix_1[new_solution[b], new_solution[d]])\n        new_cost2 = (distance_matrix_2[new_solution[a], new_solution[c]] +\n                    distance_matrix_2[new_solution[b], new_solution[d]])\n        new_cost3 = (distance_matrix_3[new_solution[a], new_solution[c]] +\n                    distance_matrix_3[new_solution[b], new_solution[d]])\n\n        # Swap the edges if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives with random weights, then applies a hybrid local search combining 2-opt with a novel edge exchange that considers all three objectives to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(3)\n    weights /= weights.sum()\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    if a != c and b != d:\n        # Calculate objective improvements for both options\n        def calc_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return cost1, cost2, cost3\n\n        current_cost = calc_cost(new_solution)\n        option1 = new_solution.copy()\n        option1[[a, b, c, d]] = option1[[a, c, b, d]]\n        cost_option1 = calc_cost(option1)\n\n        option2 = new_solution.copy()\n        option2[[a, b, c, d]] = option2[[a, b, d, c]]\n        cost_option2 = calc_cost(option2)\n\n        # Choose the option that improves the most in the weighted sum\n        weighted_improvement1 = sum(w * (c1 - c2) for w, c1, c2 in zip(weights, current_cost, cost_option1))\n        weighted_improvement2 = sum(w * (c1 - c2) for w, c1, c2 in zip(weights, current_cost, cost_option2))\n\n        if weighted_improvement1 > weighted_improvement2:\n            new_solution = option1\n        else:\n            new_solution = option2\n\n    return new_solution\n\n",
        "score": [
            -0.7024489425131012,
            1.8559720277786256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(3)\n    weights /= weights.sum()\n    selected_solution, _ = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge exchange\n    a, b, c, d = np.random.choice(n, 4, replace=False)\n    if a != c and b != d:\n        # Calculate objective improvements for both options\n        def calc_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return cost1, cost2, cost3\n\n        current_cost = calc_cost(new_solution)\n        option1 = new_solution.copy()\n        option1[[a, b, c, d]] = option1[[a, c, b, d]]\n        cost_option1 = calc_cost(option1)\n\n        option2 = new_solution.copy()\n        option2[[a, b, c, d]] = option2[[a, b, d, c]]\n        cost_option2 = calc_cost(option2)\n\n        # Choose the option that improves the most in the weighted sum\n        weighted_improvement1 = sum(w * (c1 - c2) for w, c1, c2 in zip(weights, current_cost, cost_option1))\n        weighted_improvement2 = sum(w * (c1 - c2) for w, c1, c2 in zip(weights, current_cost, cost_option2))\n\n        if weighted_improvement1 > weighted_improvement2:\n            new_solution = option1\n        else:\n            new_solution = option2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel local search operator combining edge reversal and block rotation\n    if n > 3:\n        # Randomly select a block of nodes to rotate\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n        block = new_solution[start:end]\n\n        # Rotate the block by a random amount\n        rotate_by = np.random.randint(1, len(block))\n        rotated_block = np.roll(block, rotate_by)\n\n        # Insert the rotated block back\n        new_solution[start:end] = rotated_block\n\n    # Randomly reverse a segment of the tour\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6888096174601461,
            1.2957683444023131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a novel local search operator combining edge reversal and block rotation\n    if n > 3:\n        # Randomly select a block of nodes to rotate\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n        block = new_solution[start:end]\n\n        # Rotate the block by a random amount\n        rotate_by = np.random.randint(1, len(block))\n        rotated_block = np.roll(block, rotate_by)\n\n        # Insert the rotated block back\n        new_solution[start:end] = rotated_block\n\n    # Randomly reverse a segment of the tour\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    }
]