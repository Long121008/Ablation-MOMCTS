[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The new algorithm selects a solution from the archive based on the sum of normalized objective values, then applies a segment-based crossover with a randomly selected solution from the archive to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_objectives.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    # Randomly select another solution from the archive\n    other_solution, _ = archive[np.random.randint(0, len(archive))]\n\n    # Apply segment-based crossover\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution = selected_solution.copy()\n    segment = other_solution[i:j]\n    remaining_nodes = np.setdiff1d(selected_solution, segment)\n\n    # Insert the segment into the new solution\n    new_solution[i:j] = segment\n\n    # Fill the remaining positions with nodes not in the segment\n    remaining_positions = np.setdiff1d(np.arange(n), np.arange(i, j))\n    np.random.shuffle(remaining_nodes)\n    new_solution[remaining_positions] = remaining_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7190648514548345,
            1.6887308716773988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_objectives.sum(axis=1))\n    selected_solution, _ = archive[selected_idx]\n\n    # Randomly select another solution from the archive\n    other_solution, _ = archive[np.random.randint(0, len(archive))]\n\n    # Apply segment-based crossover\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution = selected_solution.copy()\n    segment = other_solution[i:j]\n    remaining_nodes = np.setdiff1d(selected_solution, segment)\n\n    # Insert the segment into the new solution\n    new_solution[i:j] = segment\n\n    # Fill the remaining positions with nodes not in the segment\n    remaining_positions = np.setdiff1d(np.arange(n), np.arange(i, j))\n    np.random.shuffle(remaining_nodes)\n    new_solution[remaining_positions] = remaining_nodes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select two edges and perform an edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel three-segment inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.4, 0.3]  # Weight for each objective\n    selected = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n    base_solution = selected[0].copy()\n\n    # Apply three-segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select three distinct segments and invert them\n    points = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = points[0], points[1], points[2]\n\n    # Invert segments between points a-b, b-c, and c-a\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6471158094318303,
            1.0538456678390502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.4, 0.3]  # Weight for each objective\n    selected = max(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))\n    base_solution = selected[0].copy()\n\n    # Apply three-segment inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select three distinct segments and invert them\n    points = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = points[0], points[1], points[2]\n\n    # Invert segments between points a-b, b-c, and c-a\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a diverse solution from the archive, applies a novel multi-objective 3-opt operator to optimize across all three objectives simultaneously, and ensures feasibility by repairing any duplicate nodes with a greedy insertion strategy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (here, we select the one with the most balanced objectives)\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and evaluate their impact across all objectives\n    def evaluate_move(sol, a, b, c):\n        # Three possible reconnections for 3-opt\n        options = [\n            np.concatenate([sol[:a+1], sol[b:c+1][::-1], sol[a+1:b], sol[c+1:]]),\n            np.concatenate([sol[:b+1], sol[a:c+1][::-1], sol[b+1:a], sol[c+1:]]),\n            np.concatenate([sol[:a+1], sol[a:b+1][::-1], sol[b+1:c+1][::-1], sol[c+1:]])\n        ]\n\n        # Evaluate each option across all three objectives\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n            costs.append((cost1 + cost2 + cost3, opt))\n\n        # Return the best option\n        return min(costs, key=lambda x: x[0])[1]\n\n    new_solution = evaluate_move(new_solution, i, j, k)\n\n    # Repair duplicates if any exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Greedy insertion repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                candidate = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, applies a novel multi-objective 2.5-opt operator to optimize across all three objectives, and ensures feasibility by repairing any duplicate nodes with a hybrid greedy and random insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2.5-opt local search (a hybrid of 2-opt and 3-opt)\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create possible 2.5-opt moves\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[b:c+1][::-1], new_solution[a+1:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[a:c+1][::-1], new_solution[b+1:a], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[a:b+1][::-1], new_solution[b+1:c+1][::-1], new_solution[c+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    def evaluate_option(opt):\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        return (cost1 + cost2 + cost3, opt)\n\n    costs = [evaluate_option(opt) for opt in options]\n    best_cost, best_opt = min(costs, key=lambda x: x[0])\n    new_solution = best_opt\n\n    # Repair duplicates with a hybrid approach\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Random insertion for some nodes, greedy for others\n            if np.random.rand() < 0.5:\n                pos = np.random.randint(0, n)\n            else:\n                pos = 0\n                best_cost = float('inf')\n                for i in range(n):\n                    candidate = np.insert(new_solution, i, node)\n                    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                    total_cost = cost1 + cost2 + cost3\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        pos = i\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8142251791727088,
            4.117756736278534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most balanced objectives\n    objectives = [obj for _, obj in archive]\n    std_devs = [np.std(obj) for obj in objectives]\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2.5-opt local search (a hybrid of 2-opt and 3-opt)\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create possible 2.5-opt moves\n    options = [\n        np.concatenate([new_solution[:a+1], new_solution[b:c+1][::-1], new_solution[a+1:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[a:c+1][::-1], new_solution[b+1:a], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[a:b+1][::-1], new_solution[b+1:c+1][::-1], new_solution[c+1:]])\n    ]\n\n    # Evaluate each option across all three objectives\n    def evaluate_option(opt):\n        cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n        cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n        cost3 = sum(distance_matrix_3[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_3[opt[-1], opt[0]]\n        return (cost1 + cost2 + cost3, opt)\n\n    costs = [evaluate_option(opt) for opt in options]\n    best_cost, best_opt = min(costs, key=lambda x: x[0])\n    new_solution = best_opt\n\n    # Repair duplicates with a hybrid approach\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique)\n        for node in missing_nodes:\n            # Random insertion for some nodes, greedy for others\n            if np.random.rand() < 0.5:\n                pos = np.random.randint(0, n)\n            else:\n                pos = 0\n                best_cost = float('inf')\n                for i in range(n):\n                    candidate = np.insert(new_solution, i, node)\n                    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n                    total_cost = cost1 + cost2 + cost3\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        pos = i\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    }
]