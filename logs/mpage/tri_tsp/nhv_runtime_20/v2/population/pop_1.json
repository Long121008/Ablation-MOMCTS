[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate potential improvement for each solution\n    potential = []\n    for sol, obj in archive:\n        # Calculate potential as inverse of objective sum (lower objectives are better)\n        # and add some randomness to avoid bias\n        potential.append((1 / (sum(obj) + 1e-6)) * (1 + np.random.rand()))\n\n    # Select a solution using roulette wheel selection\n    selected_idx = np.random.choice(len(archive), p=np.array(potential)/sum(potential))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try 2-opt first\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # If not valid, revert to original\n        new_solution = base_solution.copy()\n\n    # Then try 3-objective-aware perturbation\n    if np.random.rand() < 0.5:  # 50% chance to apply this\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        subtour = new_solution[start:end+1]\n\n        # Calculate weighted distances for subtour\n        weights = np.random.rand(3)  # Random weights for objectives\n        weights /= weights.sum()     # Normalize\n\n        # Calculate total weighted distance for current order\n        current_dist = 0\n        for k in range(len(subtour)-1):\n            i, j = subtour[k], subtour[k+1]\n            current_dist += weights[0] * distance_matrix_1[i, j] + \\\n                           weights[1] * distance_matrix_2[i, j] + \\\n                           weights[2] * distance_matrix_3[i, j]\n\n        # Try random permutation of subtour\n        new_subtour = subtour.copy()\n        np.random.shuffle(new_subtour)\n\n        # Calculate new weighted distance\n        new_dist = 0\n        for k in range(len(new_subtour)-1):\n            i, j = new_subtour[k], new_subtour[k+1]\n            new_dist += weights[0] * distance_matrix_1[i, j] + \\\n                       weights[1] * distance_matrix_2[i, j] + \\\n                       weights[2] * distance_matrix_3[i, j]\n\n        # Accept if better\n        if new_dist < current_dist:\n            new_solution[start:end+1] = new_subtour\n\n    return new_solution\n\n",
          "score": [
               -0.8149859994248885,
               1.1998218536376952
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    # Here, we use a simple approach: select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no revisits)\n    if len(np.unique(new_solution)) == len(base_solution):\n        return new_solution\n    else:\n        return base_solution\n\n",
          "score": [
               -0.7773360332534743,
               0.8836707472801208
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] + weights[2] * obj[2] for (sol, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the total cost reduction for all three objectives\n    delta_cost = (\n        distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] -\n        distance_matrix_1[new_solution[i], new_solution[k]] - distance_matrix_1[new_solution[j], new_solution[l]]\n    ) + (\n        distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]] -\n        distance_matrix_2[new_solution[i], new_solution[k]] - distance_matrix_2[new_solution[j], new_solution[l]]\n    ) + (\n        distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[l]] -\n        distance_matrix_3[new_solution[i], new_solution[k]] - distance_matrix_3[new_solution[j], new_solution[l]]\n    )\n\n    # Apply the swap if it improves the total cost\n    if delta_cost < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.7925209462040909,
               2.587867248058319
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj_variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(obj_variances)\n\n    # Select random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap if it improves the target objective\n    if target_obj == 0:\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    elif target_obj == 1:\n        current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    else:\n        current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional edge swap for other objectives\n    m, o = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[m], new_solution[o] = new_solution[o], new_solution[m]\n\n    return new_solution\n\n",
          "score": [
               -0.7051402229421123,
               1.1361269235610962
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with low individual objective costs\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = np.min(normalized_objectives, axis=1)  # Min of normalized objectives to find solutions with at least one good objective\n        selected_idx = np.random.choice(np.argsort(scores)[-max(1, len(archive)//2):])  # Select from top half\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware segment swap\n        segment_length = np.random.randint(2, min(5, n//2))\n        k = np.random.randint(0, n - segment_length)\n        l = np.random.randint(0, n - segment_length)\n        if k != l:\n            new_solution[k:k+segment_length], new_solution[l:l+segment_length] = new_solution[l:l+segment_length], new_solution[k:k+segment_length]\n\n    # Ensure feasibility by repairing invalid tours\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If nodes are missing or duplicated, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.6412513545476096,
               1.0825375676155091
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for the three objectives\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] + weights[2] * obj[2] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)  # Select the solution with the lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and a novel segment-based improvement\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a random 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Identify segments with high improvement potential across objectives\n    # Calculate the current objective values for the base solution\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    base_obj = calculate_objectives(base_solution)\n\n    # Step 3: Perform segment-based improvement by reversing segments that improve at least one objective\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        seg_start = np.random.randint(0, n)\n        seg_length = np.random.randint(2, min(10, n//2))  # Random segment length\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            segment = new_solution[seg_start:seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n        reversed_segment = segment[::-1]\n        candidate_solution = new_solution.copy()\n\n        if seg_start < seg_end:\n            candidate_solution[seg_start:seg_end] = reversed_segment\n        else:\n            candidate_solution[seg_start:] = reversed_segment[:n-seg_start]\n            candidate_solution[:seg_end] = reversed_segment[n-seg_start:]\n\n        candidate_obj = calculate_objectives(candidate_solution)\n\n        # Accept if at least one objective improves\n        if any(candidate_obj[i] < base_obj[i] for i in range(3)):\n            new_solution = candidate_solution\n            base_obj = candidate_obj\n\n    return new_solution\n\n",
          "score": [
               -0.771977903135891,
               2.7856854796409607
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform a 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes that could improve at least one objective\n    for k in range(n):\n        for l in range(k+1, n):\n            # Calculate current and potential costs for each objective\n            current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            swap_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n            current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            swap_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n            current_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n            swap_cost3 = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n\n            # If swap improves at least one objective, perform it\n            if (swap_cost1 < current_cost1) or (swap_cost2 < current_cost2) or (swap_cost3 < current_cost3):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.6741726483576252,
               1.6425423502922059
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify promising solutions (top 30% by any objective)\n    objectives = [obj for (sol, obj) in archive]\n    obj1, obj2, obj3 = zip(*objectives)\n\n    # Normalize objectives to make them comparable\n    norm_obj1 = (np.array(obj1) - min(obj1)) / (max(obj1) - min(obj1) + 1e-10)\n    norm_obj2 = (np.array(obj2) - min(obj2)) / (max(obj2) - min(obj2) + 1e-10)\n    norm_obj3 = (np.array(obj3) - min(obj3)) / (max(obj3) - min(obj3) + 1e-10)\n\n    # Combined score for each solution\n    combined_scores = norm_obj1 + norm_obj2 + norm_obj3\n\n    # Select top 30% of solutions\n    threshold = np.percentile(combined_scores, 70)\n    promising_indices = [i for i, score in enumerate(combined_scores) if score >= threshold]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    # Randomly select a base solution from promising ones\n    base_idx = np.random.choice(promising_indices)\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search\n    n = len(base_solution)\n    improved = False\n\n    # Try 2-opt first on the worst segment\n    for _ in range(10):  # Limit iterations\n        # Find the worst segment in terms of combined distance\n        max_segment_cost = -1\n        i, j = 0, 0\n        for k in range(n-1):\n            for l in range(k+2, n):\n                cost1 = distance_matrix_1[base_solution[k], base_solution[k+1]] + distance_matrix_1[base_solution[l], base_solution[(l+1)%n]]\n                cost2 = distance_matrix_2[base_solution[k], base_solution[k+1]] + distance_matrix_2[base_solution[l], base_solution[(l+1)%n]]\n                cost3 = distance_matrix_3[base_solution[k], base_solution[k+1]] + distance_matrix_3[base_solution[l], base_solution[(l+1)%n]]\n                combined_cost = cost1 + cost2 + cost3\n                if combined_cost > max_segment_cost:\n                    max_segment_cost = combined_cost\n                    i, j = k, l\n\n        # Perform 2-opt\n        if i < j:\n            new_solution = base_solution.copy()\n            new_solution[i+1:j+1] = base_solution[j:i:-1]\n            # Check if the new solution is better in any objective\n            new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            old_obj1, old_obj2, old_obj3 = archive[base_idx][1]\n            if (new_obj1 < old_obj1) or (new_obj2 < old_obj2) or (new_obj3 < old_obj3):\n                improved = True\n                break\n\n    # If no improvement with 2-opt, try edge insertion\n    if not improved:\n        for _ in range(10):  # Limit iterations\n            # Randomly select a node to remove and insert elsewhere\n            k = np.random.randint(1, n-1)\n            node = new_solution[k]\n\n            # Remove the node\n            temp_solution = np.delete(new_solution, k)\n\n            # Find the best insertion point\n            best_cost = float('inf')\n            best_pos = 0\n            for pos in range(1, n-1):\n                cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[pos]]\n                cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[pos]]\n                cost3 = distance_matrix_3[temp_solution[pos-1], node] + distance_matrix_3[node, temp_solution[pos]]\n                combined_cost = cost1 + cost2 + cost3\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_pos = pos\n\n            # Insert the node\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n            # Check if the new solution is better in any objective\n            new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            old_obj1, old_obj2, old_obj3 = archive[base_idx][1]\n            if (new_obj1 < old_obj1) or (new_obj2 < old_obj2) or (new_obj3 < old_obj3):\n                improved = True\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.6845219359060304,
               3.8162273287773134
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify critical segments for improvement\n    # We look for segments where the total distance in any objective is above average\n    total_distances = np.zeros(3)\n    for i in range(len(selected_solution) - 1):\n        u, v = selected_solution[i], selected_solution[i+1]\n        total_distances[0] += distance_matrix_1[u, v]\n        total_distances[1] += distance_matrix_2[u, v]\n        total_distances[2] += distance_matrix_3[u, v]\n\n    avg_distance = np.mean(total_distances)\n    critical_segments = []\n    for i in range(len(selected_solution) - 2):\n        u, v, w = selected_solution[i], selected_solution[i+1], selected_solution[i+2]\n        segment_dist = (distance_matrix_1[u, v] + distance_matrix_1[v, w],\n                        distance_matrix_2[u, v] + distance_matrix_2[v, w],\n                        distance_matrix_3[u, v] + distance_matrix_3[v, w])\n        if any(d > avg_distance for d in segment_dist):\n            critical_segments.append(i)\n\n    # Step 3: Apply a hybrid local search operator\n    if critical_segments:\n        # Select a random critical segment\n        segment_idx = np.random.choice(critical_segments)\n        i = segment_idx\n        u, v, w = selected_solution[i], selected_solution[i+1], selected_solution[i+2]\n\n        # Find alternative paths between u and w that might improve multiple objectives\n        candidates = []\n        for k in range(len(selected_solution)):\n            if selected_solution[k] not in [u, v, w]:\n                # Calculate the new distances for all three objectives\n                new_dist1 = distance_matrix_1[u, selected_solution[k]] + distance_matrix_1[selected_solution[k], w]\n                new_dist2 = distance_matrix_2[u, selected_solution[k]] + distance_matrix_2[selected_solution[k], w]\n                new_dist3 = distance_matrix_3[u, selected_solution[k]] + distance_matrix_3[selected_solution[k], w]\n\n                # Check if this insertion improves at least one objective\n                old_dist1 = distance_matrix_1[u, v] + distance_matrix_1[v, w]\n                old_dist2 = distance_matrix_2[u, v] + distance_matrix_2[v, w]\n                old_dist3 = distance_matrix_3[u, v] + distance_matrix_3[v, w]\n\n                if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n                    candidates.append((selected_solution[k], new_dist1, new_dist2, new_dist3))\n\n        if candidates:\n            # Select the best candidate that improves the most objectives\n            best_candidate = min(candidates, key=lambda x: (x[1] + x[2] + x[3]))\n            new_solution = selected_solution.copy()\n            new_solution[i+1] = best_candidate[0]\n            return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i, j = np.random.choice(len(selected_solution), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    return new_solution\n\n",
          "score": [
               -0.668829554559385,
               1.7100487112998963
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    # Evaluate edges based on their contribution to all three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            a, b = selected_solution[i], selected_solution[(i + 1) % n]\n            c, d = selected_solution[j], selected_solution[(j + 1) % n]\n\n            # New edges if we reverse the segment between i and j\n            new_edges = [(a, c), (b, d)]\n\n            # Calculate improvement for each objective\n            improvement = 0\n            for (u, v), (x, y) in [(a, b), (c, d)], new_edges:\n                improvement += (distance_matrix_1[u, v] - distance_matrix_1[x, y]) + \\\n                               (distance_matrix_2[u, v] - distance_matrix_2[x, y]) + \\\n                               (distance_matrix_3[u, v] - distance_matrix_3[x, y])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Perform 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[best_i + 1 : best_j + 1] = selected_solution[best_i + 1 : best_j + 1][::-1]\n        return new_solution\n\n    # If no improvement found, apply a random swap to escape local optima\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution = selected_solution.copy()\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    return new_solution\n\n",
          "score": [
               -0.5976444480775651,
               2.335370421409607
          ]
     }
]