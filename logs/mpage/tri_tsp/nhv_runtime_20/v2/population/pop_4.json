[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate potential improvement for each solution\n    potential = []\n    for sol, obj in archive:\n        # Calculate potential as inverse of objective sum (lower objectives are better)\n        # and add some randomness to avoid bias\n        potential.append((1 / (sum(obj) + 1e-6)) * (1 + np.random.rand()))\n\n    # Select a solution using roulette wheel selection\n    selected_idx = np.random.choice(len(archive), p=np.array(potential)/sum(potential))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try 2-opt first\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # If not valid, revert to original\n        new_solution = base_solution.copy()\n\n    # Then try 3-objective-aware perturbation\n    if np.random.rand() < 0.5:  # 50% chance to apply this\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        subtour = new_solution[start:end+1]\n\n        # Calculate weighted distances for subtour\n        weights = np.random.rand(3)  # Random weights for objectives\n        weights /= weights.sum()     # Normalize\n\n        # Calculate total weighted distance for current order\n        current_dist = 0\n        for k in range(len(subtour)-1):\n            i, j = subtour[k], subtour[k+1]\n            current_dist += weights[0] * distance_matrix_1[i, j] + \\\n                           weights[1] * distance_matrix_2[i, j] + \\\n                           weights[2] * distance_matrix_3[i, j]\n\n        # Try random permutation of subtour\n        new_subtour = subtour.copy()\n        np.random.shuffle(new_subtour)\n\n        # Calculate new weighted distance\n        new_dist = 0\n        for k in range(len(new_subtour)-1):\n            i, j = new_subtour[k], new_subtour[k+1]\n            new_dist += weights[0] * distance_matrix_1[i, j] + \\\n                       weights[1] * distance_matrix_2[i, j] + \\\n                       weights[2] * distance_matrix_3[i, j]\n\n        # Accept if better\n        if new_dist < current_dist:\n            new_solution[start:end+1] = new_subtour\n\n    return new_solution\n\n",
          "score": [
               -0.8149859994248885,
               1.1998218536376952
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    # Here, we use a simple approach: select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no revisits)\n    if len(np.unique(new_solution)) == len(base_solution):\n        return new_solution\n    else:\n        return base_solution\n\n",
          "score": [
               -0.7773360332534743,
               0.8836707472801208
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Multi-objective path inversion operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select random segment to invert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate current and potential costs for all objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    current_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # Perform inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate new costs\n    new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # Weighted improvement calculation\n    weights = [0.3, 0.4, 0.3]  # Example weights for three objectives\n    current_weighted = sum(w * c for w, c in zip(weights, [current_cost1, current_cost2, current_cost3]))\n    new_weighted = sum(w * c for w, c in zip(weights, [new_cost1, new_cost2, new_cost3]))\n\n    # Accept if improvement or with small probability\n    if new_weighted < current_weighted or np.random.random() < 0.1:\n        return new_solution\n    else:\n        # If not accepted, restore original and try random swap\n        new_solution = selected_solution.copy()\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        return new_solution\n\n",
          "score": [
               -0.861910730098753,
               2.3665157318115235
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj_variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(obj_variances)\n\n    # Select random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap if it improves the target objective\n    if target_obj == 0:\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    elif target_obj == 1:\n        current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    else:\n        current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional edge swap for other objectives\n    m, o = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[m], new_solution[o] = new_solution[o], new_solution[m]\n\n    return new_solution\n\n",
          "score": [
               -0.7051402229421123,
               1.1361269235610962
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with low individual objective costs\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = np.min(normalized_objectives, axis=1)  # Min of normalized objectives to find solutions with at least one good objective\n        selected_idx = np.random.choice(np.argsort(scores)[-max(1, len(archive)//2):])  # Select from top half\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware segment swap\n        segment_length = np.random.randint(2, min(5, n//2))\n        k = np.random.randint(0, n - segment_length)\n        l = np.random.randint(0, n - segment_length)\n        if k != l:\n            new_solution[k:k+segment_length], new_solution[l:l+segment_length] = new_solution[l:l+segment_length], new_solution[k:k+segment_length]\n\n    # Ensure feasibility by repairing invalid tours\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If nodes are missing or duplicated, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.6412513545476096,
               1.0825375676155091
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of prioritizing solutions with good individual objectives from the first provided algorithm with an innovative multi-objective local search operator that performs a hybrid of 3-opt moves and objective-aware segment rotations, where the segment length is dynamically determined based on the current solution's quality across objectives. The operator first identifies critical segments where improvements in at least one objective can be made, then performs a rotation of these segments to explore better configurations while maintaining feasibility, and finally verifies the solution's validity by ensuring no nodes are skipped or revisited. This approach balances exploitation of good solutions with exploration of diverse neighborhoods in the multi-objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solution with highest average normalized objective value\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        avg_scores = np.mean(normalized_objectives, axis=1)\n        selected_idx = np.argmax(avg_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with objective-aware segment rotation\n    # Select three distinct positions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.6:\n        # Reverse middle segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Rotate segments to explore different configurations\n        segment_length = np.random.randint(2, min(5, n//3))\n        a = np.random.randint(0, n - segment_length)\n        b = np.random.randint(0, n - segment_length)\n        if a != b:\n            temp = new_solution[a:a+segment_length].copy()\n            new_solution[a:a+segment_length] = new_solution[b:b+segment_length]\n            new_solution[b:b+segment_length] = temp\n\n    # Objective-aware verification and repair\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If nodes are missing or duplicated, revert to base solution\n        new_solution = base_solution.copy()\n    else:\n        # Verify if the move improves at least one objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7480480529347507,
               1.9037314057350159
          ]
     },
     {
          "algorithm": "{This new algorithm employs a multi-objective-aware path relinking strategy that combines features from both existing approaches while introducing novel elements. It first identifies the most diverse solution in the archive by analyzing the variance of objectives, then performs a guided path relinking between this solution and a randomly selected archive member, where the path is constructed by selectively swapping nodes based on their potential to improve Pareto dominance through a weighted combination of objective improvements. The algorithm dynamically adjusts the weights during the relinking process to prioritize objectives that show the most improvement potential, while maintaining feasibility through a two-phase validation step that ensures no nodes are skipped or revisited. Additionally, it incorporates a probabilistic segment inversion mechanism that flips segments of the tour with a probability proportional to their current objective values, further diversifying the search while preserving solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most diverse solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    obj_variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(obj_variances)\n    diverse_idx = np.argmax(objectives[:, target_obj])\n    diverse_solution = archive[diverse_idx][0].copy()\n\n    # Select a random solution from the archive\n    random_idx = np.random.randint(len(archive))\n    random_solution = archive[random_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = diverse_solution.copy()\n    n = len(new_solution)\n\n    # Perform guided path relinking\n    for i in range(n):\n        if np.random.rand() < 0.3:  # Probability of swapping nodes\n            # Calculate potential improvement for each objective\n            obj1_diff = distance_matrix_1[new_solution[i-1], random_solution[i]] + distance_matrix_1[random_solution[i], new_solution[(i+1)%n]] - \\\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            obj2_diff = distance_matrix_2[new_solution[i-1], random_solution[i]] + distance_matrix_2[random_solution[i], new_solution[(i+1)%n]] - \\\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            obj3_diff = distance_matrix_3[new_solution[i-1], random_solution[i]] + distance_matrix_3[random_solution[i], new_solution[(i+1)%n]] - \\\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n\n            # Weighted improvement score\n            weights = np.random.rand(3)\n            weights /= weights.sum()\n            improvement = weights[0] * obj1_diff + weights[1] * obj2_diff + weights[2] * obj3_diff\n\n            if improvement < 0:  # If improvement is negative, perform the swap\n                new_solution[i] = random_solution[i]\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.5:\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.7:  # Higher probability to invert segments with better objectives\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.5910338529569468,
               0.9789687633514405
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] + weights[2] * obj[2] for (sol, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the total cost reduction for all three objectives\n    delta_cost = (\n        distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] -\n        distance_matrix_1[new_solution[i], new_solution[k]] - distance_matrix_1[new_solution[j], new_solution[l]]\n    ) + (\n        distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]] -\n        distance_matrix_2[new_solution[i], new_solution[k]] - distance_matrix_2[new_solution[j], new_solution[l]]\n    ) + (\n        distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[l]] -\n        distance_matrix_3[new_solution[i], new_solution[k]] - distance_matrix_3[new_solution[j], new_solution[l]]\n    )\n\n    # Apply the swap if it improves the total cost\n    if delta_cost < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.7925209462040909,
               2.587867248058319
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective path decomposition approach that first identifies Pareto-optimal sub-paths across all three objective spaces, then intelligently recombines these sub-paths using a novel dominance-preserving crossover operator that ensures no node is revisited or skipped. It prioritizes solutions with balanced objective contributions, uses a dynamic neighborhood selection mechanism based on objective correlation analysis, and applies a probabilistic edge exchange operator that favors edges with high potential for simultaneous improvement in multiple objectives while maintaining tour feasibility through a repair mechanism that preserves node coverage and order.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([], dtype=int)\n\n    # Step 1: Select a solution with balanced objective contributions\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = objectives.max(axis=0) - objectives.min(axis=0) + 1e-10\n    normalized = (objectives - objectives.min(axis=0)) / obj_ranges\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)  # Select most balanced solution\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Decompose the tour into Pareto-optimal sub-paths\n    sub_paths = []\n    current_path = [base_solution[0]]\n    for i in range(1, len(base_solution)):\n        u, v = base_solution[i-1], base_solution[i]\n        current_path.append(v)\n        # Check if adding this edge would dominate previous sub-paths\n        is_dominated = False\n        for j, path in enumerate(sub_paths):\n            path_dist = (sum(distance_matrix_1[path[k], path[k+1]] for k in range(len(path)-1)),\n                         sum(distance_matrix_2[path[k], path[k+1]] for k in range(len(path)-1)),\n                         sum(distance_matrix_3[path[k], path[k+1]] for k in range(len(path)-1)))\n            new_dist = (distance_matrix_1[u, v],\n                        distance_matrix_2[u, v],\n                        distance_matrix_3[u, v])\n            if all(new_dist[k] <= path_dist[k] for k in range(3)) and any(new_dist[k] < path_dist[k] for k in range(3)):\n                is_dominated = True\n                break\n        if is_dominated:\n            sub_paths.append(current_path.copy())\n            current_path = [v]\n    if current_path:\n        sub_paths.append(current_path)\n\n    # Step 3: Recombine sub-paths with dominance-preserving crossover\n    new_solution = []\n    used_nodes = set()\n    while len(new_solution) < len(base_solution):\n        # Select a sub-path that improves at least one objective\n        candidates = []\n        for path in sub_paths:\n            if not any(node in used_nodes for node in path):\n                path_dist = (sum(distance_matrix_1[path[k], path[k+1]] for k in range(len(path)-1)),\n                            sum(distance_matrix_2[path[k], path[k+1]] for k in range(len(path)-1)),\n                            sum(distance_matrix_3[path[k], path[k+1]] for k in range(len(path)-1)))\n                candidates.append((path, path_dist))\n\n        if not candidates:\n            # Fallback: add any remaining node\n            remaining = [node for node in base_solution if node not in used_nodes]\n            if remaining:\n                new_solution.append(remaining[0])\n                used_nodes.add(remaining[0])\n            continue\n\n        # Select path that improves the most objectives\n        best_path, _ = min(candidates, key=lambda x: sum(x[1]))\n        new_solution.extend(best_path)\n        used_nodes.update(best_path)\n\n    # Ensure the tour is valid\n    if len(new_solution) != len(base_solution) or len(set(new_solution)) != len(base_solution):\n        # Repair by adding missing nodes in order\n        missing = [node for node in base_solution if node not in new_solution]\n        new_solution.extend(missing)\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8069110703902554,
               3.4453540444374084
          ]
     },
     {
          "algorithm": "{The new algorithm will employ a multi-objective-aware insertion heuristic that selectively reinserts segments of the tour based on their potential to improve the combined objective values, where the selection probability is influenced by the relative performance of each objective across the archive. The algorithm will first compute a weighted objective score for each solution in the archive, combining the normalized objectives with random weights to encourage exploration, then use a tournament selection to choose the base solution. The neighbor generation will involve extracting a random segment of the tour and reinserting it at the best position that minimizes the weighted sum of distances across all three objectives, with the insertion position evaluated by considering both the immediate distance changes and the potential for long-term improvements. The algorithm will ensure feasibility by always maintaining a complete tour and verifying the uniqueness of node visits before returning the new solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using tournament selection based on weighted objectives\n    tournament_size = min(3, len(archive))\n    selected_idx = np.argmin([sum(archive[i][1]) for i in np.random.choice(len(archive), tournament_size, replace=False)])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reinsert\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Calculate weighted distances for potential insertion points\n    weights = np.random.rand(3)\n    weights /= weights.sum()\n\n    best_pos = 0\n    min_weighted_dist = float('inf')\n\n    # Evaluate all possible insertion positions\n    for pos in range(len(new_solution)):\n        # Insert segment at position pos\n        candidate = np.insert(new_solution, pos, segment)\n\n        # Calculate weighted distance change\n        weighted_dist = 0\n        for i in range(len(candidate)-1):\n            a, b = candidate[i], candidate[i+1]\n            weighted_dist += weights[0] * distance_matrix_1[a, b] + \\\n                            weights[1] * distance_matrix_2[a, b] + \\\n                            weights[2] * distance_matrix_3[a, b]\n\n        # Also consider the connection between segment and its neighbors\n        if pos > 0:\n            prev = candidate[pos-1]\n            first = candidate[pos]\n            weighted_dist += weights[0] * distance_matrix_1[prev, first] + \\\n                            weights[1] * distance_matrix_2[prev, first] + \\\n                            weights[2] * distance_matrix_3[prev, first]\n\n        if pos + len(segment) < len(candidate):\n            last = candidate[pos + len(segment) - 1]\n            next_node = candidate[pos + len(segment)]\n            weighted_dist += weights[0] * distance_matrix_1[last, next_node] + \\\n                           weights[1] * distance_matrix_2[last, next_node] + \\\n                           weights[2] * distance_matrix_3[last, next_node]\n\n        if weighted_dist < min_weighted_dist:\n            min_weighted_dist = weighted_dist\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
          "score": [
               -0.8078773852313962,
               4.405362689495087
          ]
     }
]