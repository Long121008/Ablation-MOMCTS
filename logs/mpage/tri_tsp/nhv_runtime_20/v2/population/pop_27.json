[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate potential improvement for each solution\n    potential = []\n    for sol, obj in archive:\n        # Calculate potential as inverse of objective sum (lower objectives are better)\n        # and add some randomness to avoid bias\n        potential.append((1 / (sum(obj) + 1e-6)) * (1 + np.random.rand()))\n\n    # Select a solution using roulette wheel selection\n    selected_idx = np.random.choice(len(archive), p=np.array(potential)/sum(potential))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try 2-opt first\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # If not valid, revert to original\n        new_solution = base_solution.copy()\n\n    # Then try 3-objective-aware perturbation\n    if np.random.rand() < 0.5:  # 50% chance to apply this\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        subtour = new_solution[start:end+1]\n\n        # Calculate weighted distances for subtour\n        weights = np.random.rand(3)  # Random weights for objectives\n        weights /= weights.sum()     # Normalize\n\n        # Calculate total weighted distance for current order\n        current_dist = 0\n        for k in range(len(subtour)-1):\n            i, j = subtour[k], subtour[k+1]\n            current_dist += weights[0] * distance_matrix_1[i, j] + \\\n                           weights[1] * distance_matrix_2[i, j] + \\\n                           weights[2] * distance_matrix_3[i, j]\n\n        # Try random permutation of subtour\n        new_subtour = subtour.copy()\n        np.random.shuffle(new_subtour)\n\n        # Calculate new weighted distance\n        new_dist = 0\n        for k in range(len(new_subtour)-1):\n            i, j = new_subtour[k], new_subtour[k+1]\n            new_dist += weights[0] * distance_matrix_1[i, j] + \\\n                       weights[1] * distance_matrix_2[i, j] + \\\n                       weights[2] * distance_matrix_3[i, j]\n\n        # Accept if better\n        if new_dist < current_dist:\n            new_solution[start:end+1] = new_subtour\n\n    return new_solution\n\n",
          "score": [
               -0.8149859994248885,
               1.1998218536376952
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    # Here, we use a simple approach: select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no revisits)\n    if len(np.unique(new_solution)) == len(base_solution):\n        return new_solution\n    else:\n        return base_solution\n\n",
          "score": [
               -0.7773360332534743,
               0.8836707472801208
          ]
     },
     {
          "algorithm": "{The new algorithm will first identify solutions in the archive with the most balanced objective values (minimizing the range between the best and worst objectives) to ensure diversity in selection, then apply a multi-objective-aware segment relocation operator that considers weighted combinations of all three objectives to intelligently reposition subtours, with a probabilistic acceptance criterion based on both improvement and objective balance to encourage exploration of promising regions while maintaining feasibility through careful segment handling and validation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Generate random weights for objectives\n    weights = np.random.rand(3)\n    weights /= weights.sum()\n\n    # Select two random segments\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments don't overlap\n    if b < c or d < a:\n        # Relocate segment [a:b+1] to position after c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate current and new costs\n        current_cost = (weights[0] * distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        weights[1] * distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        weights[2] * distance_matrix_3[new_solution[a-1], new_solution[a]]) + \\\n                       (weights[0] * distance_matrix_1[new_solution[b], new_solution[b+1]] +\n                        weights[1] * distance_matrix_2[new_solution[b], new_solution[b+1]] +\n                        weights[2] * distance_matrix_3[new_solution[b], new_solution[b+1]])\n\n        new_cost = (weights[0] * distance_matrix_1[new_solution[c], segment[0]] +\n                    weights[1] * distance_matrix_2[new_solution[c], segment[0]] +\n                    weights[2] * distance_matrix_3[new_solution[c], segment[0]]) + \\\n                   (weights[0] * distance_matrix_1[segment[-1], new_solution[c+1]] +\n                    weights[1] * distance_matrix_2[segment[-1], new_solution[c+1]] +\n                    weights[2] * distance_matrix_3[segment[-1], new_solution[c+1]])\n\n        # Accept if improvement or with small probability\n        if new_cost < current_cost or np.random.random() < 0.2:\n            return new_solution\n\n    # If not accepted, try a different operator\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8978028544356829,
               2.005447006225586
          ]
     },
     {
          "algorithm": "{The new algorithm combines the multi-objective selection strategy of prioritizing balanced solutions from the provided algorithms with an innovative hybrid local search operator that performs a dynamic segment-based crossover augmented with objective-aware inversion and probabilistic segment mutation. It first identifies the most balanced solution in the archive by analyzing the normalized objective values, then performs a guided segment exchange between this solution and a randomly selected archive member, where segments are selected based on their potential to improve Pareto dominance through a dynamic weighting scheme that prioritizes objectives with the highest relative improvement. The algorithm incorporates a probabilistic segment mutation mechanism that randomly reorders segments with a probability inversely proportional to their current objective values, further diversifying the search while preserving solution quality. Additionally, it includes a novel three-way objective-aware inversion operator that selectively inverts segments based on their contribution to each objective, ensuring balanced optimization across all three objectives, while dynamically adjusting the search focus based on the current Pareto front's distribution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most balanced solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.mean(normalized_objectives, axis=1)\n    balanced_idx = np.argmax(balance_scores)\n    balanced_solution = archive[balanced_idx][0].copy()\n\n    # Select a random solution from the archive\n    random_idx = np.random.randint(len(archive))\n    random_solution = archive[random_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = balanced_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective improvement potential\n    segment_length = np.random.randint(2, min(5, n//3))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Calculate potential improvement for each objective\n    obj1_diff = (distance_matrix_1[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_1[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj2_diff = (distance_matrix_2[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_2[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj3_diff = (distance_matrix_3[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_3[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    # Dynamic weighting based on relative improvement\n    total_diff = np.abs(obj1_diff) + np.abs(obj2_diff) + np.abs(obj3_diff)\n    if total_diff > 0:\n        weights = np.array([np.abs(obj1_diff), np.abs(obj2_diff), np.abs(obj3_diff)]) / total_diff\n    else:\n        weights = np.ones(3) / 3\n\n    # Perform segment exchange if improvement is expected\n    if (weights[0] * obj1_diff + weights[1] * obj2_diff + weights[2] * obj3_diff) < 0:\n        new_solution[start_pos:start_pos+segment_length] = random_solution[start_pos:start_pos+segment_length]\n\n    # Probabilistic segment mutation with objective-aware probability\n    mutation_prob = 0.3 * (1 - np.min(normalized_objectives[balanced_idx]) / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n    if np.random.rand() < mutation_prob:\n        mutate_pos = np.random.randint(0, n - segment_length)\n        new_solution[mutate_pos:mutate_pos+segment_length] = np.roll(new_solution[mutate_pos:mutate_pos+segment_length], np.random.randint(1, segment_length))\n\n    # Three-way objective-aware inversion with dynamic segment selection\n    inversion_prob = 0.4 * (1 - np.min(normalized_objectives[balanced_idx]) / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n    if np.random.rand() < inversion_prob:\n        # Select segment based on worst objective contribution\n        potential_segments = []\n        for i in range(n - segment_length):\n            segment = new_solution[i:i+segment_length]\n            obj1_contrib = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, segment_length))\n            obj2_contrib = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, segment_length))\n            obj3_contrib = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, segment_length))\n            worst_contrib = min(obj1_contrib, obj2_contrib, obj3_contrib)\n            potential_segments.append((i, worst_contrib))\n\n        if potential_segments:\n            selected_segment = max(potential_segments, key=lambda x: x[1])\n            invert_pos = selected_segment[0]\n            new_solution[invert_pos:invert_pos+segment_length] = new_solution[invert_pos:invert_pos+segment_length][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.7977656129040049,
               1.407644307613373
          ]
     },
     {
          "algorithm": "{This new algorithm combines multi-objective optimization with a novel hierarchical local search approach that first identifies the most balanced solution in the archive, then performs a tiered segment-based optimization where each tier focuses on improving a different objective, with the optimization depth and segment length dynamically adjusted based on the current Pareto front's distribution. It employs a probabilistic tier selection mechanism that prioritizes objectives with the highest relative improvement potential, while incorporating an adaptive segment inversion operator that selectively inverts segments based on their contribution to each objective, ensuring balanced optimization across all three objectives. The algorithm also includes a tiered mutation mechanism that randomly reorders segments with probabilities inversely proportional to their current objective values, further diversifying the search while preserving solution quality. Additionally, it features a dynamic tiered segment exchange operator that exchanges segments between the base solution and a randomly selected archive member, with segment selection based on their potential to improve Pareto dominance through a tiered weighting scheme that prioritizes objectives with the highest relative improvement in each tier.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most balanced solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.mean(normalized_objectives, axis=1)\n    balanced_idx = np.argmax(balance_scores)\n    base_solution = archive[balanced_idx][0].copy()\n\n    # Select a random solution from the archive\n    random_idx = np.random.randint(len(archive))\n    random_solution = archive[random_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Tiered segment-based optimization\n    tiers = 3  # One for each objective\n    for tier in range(tiers):\n        # Dynamic segment length based on tier and solution quality\n        segment_length = max(2, min(6, n // (tier + 2)))\n        start_pos = np.random.randint(0, n - segment_length)\n\n        # Calculate potential improvement for the current tier's objective\n        if tier == 0:\n            obj_diff = (distance_matrix_1[new_solution[start_pos-1], random_solution[start_pos]] +\n                        distance_matrix_1[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                        distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                        distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n        elif tier == 1:\n            obj_diff = (distance_matrix_2[new_solution[start_pos-1], random_solution[start_pos]] +\n                        distance_matrix_2[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                        distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                        distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n        else:\n            obj_diff = (distance_matrix_3[new_solution[start_pos-1], random_solution[start_pos]] +\n                        distance_matrix_3[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                        distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                        distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        # Probabilistic tier selection based on improvement potential\n        if obj_diff < 0 and np.random.rand() < 0.7:  # Higher probability for improving moves\n            new_solution[start_pos:start_pos+segment_length] = random_solution[start_pos:start_pos+segment_length]\n\n        # Tiered mutation with adaptive probability\n        mutation_prob = 0.3 * (1 - normalized_objectives[balanced_idx][tier] / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n        if np.random.rand() < mutation_prob:\n            mutate_pos = np.random.randint(0, n - segment_length)\n            new_solution[mutate_pos:mutate_pos+segment_length] = np.roll(new_solution[mutate_pos:mutate_pos+segment_length], np.random.randint(1, segment_length))\n\n        # Tiered segment inversion\n        inversion_prob = 0.4 * (1 - normalized_objectives[balanced_idx][tier] / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n        if np.random.rand() < inversion_prob:\n            invert_pos = np.random.randint(0, n - segment_length)\n            new_solution[invert_pos:invert_pos+segment_length] = new_solution[invert_pos:invert_pos+segment_length][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.7679118231989317,
               1.054365599155426
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a multi-objective-aware adaptive segment fusion approach that first identifies the most complementary solutions in the archive by analyzing the covariance structure of their objectives, then performs a tiered segment fusion process where each tier selectively combines segments from different archive members based on their potential to improve Pareto dominance through a dynamic weighting scheme that prioritizes objectives with the highest relative improvement, while maintaining feasibility through a multi-phase validation mechanism that ensures no nodes are skipped or revisited. The algorithm employs an adaptive segment fusion operator that merges segments from different solutions with probabilities proportional to their current objective values, combined with a probabilistic segment reordering mechanism that reorders segments with a probability inversely proportional to their current objective contributions, further enhancing the search diversity while preserving solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most complementary solutions in the archive\n    objectives = np.array([obj for _, obj in archive])\n    obj_cov = np.cov(objectives, rowvar=False)\n    target_obj = np.argmax(np.diag(obj_cov))\n    complementary_idx = np.argmin(objectives[:, target_obj])\n    base_solution = archive[complementary_idx][0].copy()\n\n    # Select two random solutions from the archive\n    random_idx1, random_idx2 = np.random.choice(len(archive), 2, replace=False)\n    random_solution1 = archive[random_idx1][0].copy()\n    random_solution2 = archive[random_idx2][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Tiered segment fusion process\n    tiers = 3  # One for each objective\n    for tier in range(tiers):\n        # Dynamic segment length based on tier\n        segment_length = max(2, min(6, n // (tier + 2)))\n        start_pos = np.random.randint(0, n - segment_length)\n\n        # Calculate potential improvement for the current tier's objective\n        if tier == 0:\n            obj_diff1 = (distance_matrix_1[new_solution[start_pos-1], random_solution1[start_pos]] +\n                         distance_matrix_1[random_solution1[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                         distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                         distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n            obj_diff2 = (distance_matrix_1[new_solution[start_pos-1], random_solution2[start_pos]] +\n                         distance_matrix_1[random_solution2[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                         distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                         distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n        elif tier == 1:\n            obj_diff1 = (distance_matrix_2[new_solution[start_pos-1], random_solution1[start_pos]] +\n                         distance_matrix_2[random_solution1[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                         distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                         distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n            obj_diff2 = (distance_matrix_2[new_solution[start_pos-1], random_solution2[start_pos]] +\n                         distance_matrix_2[random_solution2[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                         distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                         distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n        else:\n            obj_diff1 = (distance_matrix_3[new_solution[start_pos-1], random_solution1[start_pos]] +\n                         distance_matrix_3[random_solution1[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                         distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                         distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n            obj_diff2 = (distance_matrix_3[new_solution[start_pos-1], random_solution2[start_pos]] +\n                         distance_matrix_3[random_solution2[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                         distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                         distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        # Select the better segment from either random solution\n        if obj_diff1 < obj_diff2:\n            new_solution[start_pos:start_pos+segment_length] = random_solution1[start_pos:start_pos+segment_length]\n        else:\n            new_solution[start_pos:start_pos+segment_length] = random_solution2[start_pos:start_pos+segment_length]\n\n        # Probabilistic segment reordering\n        reorder_prob = 0.3 * (1 - objectives[complementary_idx][tier] / (np.sum(objectives[complementary_idx]) + 1e-10))\n        if np.random.rand() < reorder_prob:\n            reorder_pos = np.random.randint(0, n - segment_length)\n            new_solution[reorder_pos:reorder_pos+segment_length] = np.roll(new_solution[reorder_pos:reorder_pos+segment_length], np.random.randint(1, segment_length))\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.6680354652442285,
               0.9508396267890931
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of prioritizing solutions with balanced objective values from the first provided algorithm with an innovative multi-objective local search operator that performs a hybrid of path segment rotations and objective-aware node insertions, where the insertion candidates are dynamically selected based on their potential to improve the most underperforming objective. The operator first identifies critical segments where improvements can be made by analyzing the current solution's objective values, then performs targeted rotations of these segments to explore better configurations while maintaining feasibility, and finally inserts nodes from the most underperforming objective into the solution to address its weaknesses, verifying the solution's validity by ensuring no nodes are skipped or revisited. This approach balances exploitation of good solutions with exploration of diverse neighborhoods in the multi-objective space by focusing on the objective that has shown the least improvement, promoting more balanced progress across all objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solution with most balanced objectives (smallest range between best and worst objective)\n        objectives = np.array([obj for _, obj in archive])\n        objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_idx = np.argmin(objective_ranges)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current costs for all objectives\n    current_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Identify the most underperforming objective\n    worst_obj = np.argmax(current_costs)\n\n    # Hybrid path segment rotation with objective-aware node insertion\n    if np.random.rand() < 0.6:\n        # Perform path segment rotation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[i:j+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n    else:\n        # Perform objective-aware node insertion\n        # Find nodes that are most expensive in the worst objective\n        node_costs = []\n        for k in range(n):\n            prev_node = new_solution[k-1]\n            next_node = new_solution[(k+1)%n]\n            if worst_obj == 0:\n                cost = distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            elif worst_obj == 1:\n                cost = distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            else:\n                cost = distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n            node_costs.append(cost)\n\n        # Select the most expensive node and insert it elsewhere\n        expensive_node = np.argmax(node_costs)\n        insert_pos = np.random.randint(0, n)\n        node_to_insert = new_solution[expensive_node]\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [node_to_insert],\n            np.delete(new_solution, expensive_node)\n        ])\n\n    # Verify solution validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n    else:\n        # Verify if the move improved the worst objective\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        if new_costs[worst_obj] >= current_costs[worst_obj] and np.random.rand() > 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8675143517132626,
               2.784900164604187
          ]
     },
     {
          "algorithm": "{The new algorithm combines adaptive objective weighting with geometric fragmentation to create a solution selection strategy that dynamically prioritizes objectives based on their relative performance in the archive, then fragments the solution into spatially coherent segments that are reassembled using a novel \"objective-aware inversion\" operator. This operator inverts segments while considering the weighted contribution of each objective to the tour's cost, ensuring that improvements in multiple objectives are simultaneously pursued. The method incorporates a \"diversity-aware\" selection mechanism that prefers solutions from underrepresented regions of the objective space, and employs a multi-phase local search that first explores large-scale structural changes before fine-tuning with smaller perturbations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective weights based on archive performance\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    normalized_weights = 1 / (objective_ranges + 1e-6)\n    weights = normalized_weights / np.sum(normalized_weights)\n\n    # Select solution with probability proportional to its normalized weight\n    probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Geometric fragmentation and reassembly\n    if np.random.rand() < 0.8:\n        # Calculate spatial centroids for each objective space\n        coords1 = instance[base_solution, :2]\n        coords2 = instance[base_solution, 2:4]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Find nodes closest to centroids in each space\n        dist1 = np.linalg.norm(coords1 - centroid1, axis=1)\n        dist2 = np.linalg.norm(coords2 - centroid2, axis=1)\n        closest1 = np.argmin(dist1)\n        closest2 = np.argmin(dist2)\n\n        # Determine fragmentation points\n        if closest1 < closest2:\n            frag1, frag2 = closest1, closest2\n        else:\n            frag1, frag2 = closest2, closest1\n\n        # Create segments\n        seg1 = new_solution[:frag1+1]\n        seg2 = new_solution[frag1+1:frag2+1]\n        seg3 = new_solution[frag2+1:]\n\n        # Reassemble with objective-aware inversion\n        if np.random.rand() < 0.5:\n            seg2 = seg2[::-1]  # Invert middle segment\n\n        # Reconstruct solution\n        new_solution = np.concatenate([seg1, seg2, seg3])\n\n        # Verify solution validity\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    # Apply weighted objective improvement check\n    current_costs = [\n        sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(n))\n    ]\n\n    new_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Check for weighted improvement\n    weighted_current = sum(w * c for w, c in zip(weights, current_costs))\n    weighted_new = sum(w * c for w, c in zip(weights, new_costs))\n\n    if weighted_new >= weighted_current:\n        # Fall back to small perturbation if no improvement\n        if np.random.rand() < 0.3:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Swap two random nodes\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8651671293360679,
               2.2961432099342347
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = 1 - np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment exchange with adaptive weights\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Calculate potential improvement for each objective\n    obj1_diff = (distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj2_diff = (distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj3_diff = (distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    # Dynamic weighting based on current objective distribution\n    obj_weights = np.var(normalized_objectives, axis=0)\n    obj_weights = obj_weights / np.sum(obj_weights)\n\n    # Perform segment exchange if improvement is expected\n    weighted_diff = obj_weights[0] * obj1_diff + obj_weights[1] * obj2_diff + obj_weights[2] * obj3_diff\n    if weighted_diff < 0:\n        new_solution[start_pos:start_pos+segment_length] = new_solution[start_pos:start_pos+segment_length][::-1]\n\n    # Probabilistic segment rotation with objective-aware probability\n    rotation_prob = 0.3 * (1 - np.min(normalized_objectives[selected_idx]))\n    if np.random.rand() < rotation_prob:\n        rotate_pos = np.random.randint(0, n - segment_length)\n        shift = np.random.randint(1, segment_length)\n        new_solution[rotate_pos:rotate_pos+segment_length] = np.roll(new_solution[rotate_pos:rotate_pos+segment_length], shift)\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.8178225080550575,
               2.1869946360588073
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a multi-objective-aware adaptive segment fusion approach that first identifies the most complementary solutions in the archive by analyzing the covariance structure of their objectives, then performs a tiered segment fusion process where each tier selectively combines segments from different archive members based on their potential to improve Pareto dominance through a dynamic weighting scheme that prioritizes objectives with the highest relative improvement, while maintaining feasibility through a multi-phase validation mechanism that ensures no nodes are skipped or revisited. The algorithm employs an adaptive segment fusion operator that merges segments from different solutions with probabilities proportional to their current objective values, combined with a probabilistic segment reordering mechanism that reorders segments with a probability inversely proportional to their current objective contributions, further enhancing the search diversity while preserving solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective value\n    objectives = np.array([obj for _, obj in archive])\n    total_objectives = np.sum(objectives, axis=1)\n    best_idx = np.argmin(total_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    # Select two random solutions from the archive\n    random_idx1, random_idx2 = np.random.choice(len(archive), 2, replace=False)\n    random_solution1 = archive[random_idx1][0].copy()\n    random_solution2 = archive[random_idx2][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment fusion with multi-objective awareness\n    for _ in range(3):  # Perform 3 fusion operations\n        # Determine segment length based on solution size\n        segment_length = max(2, min(6, n // 3))\n        start_pos = np.random.randint(0, n - segment_length)\n\n        # Calculate improvement potential across all objectives\n        obj1_diff = (distance_matrix_1[new_solution[start_pos-1], random_solution1[start_pos]] +\n                     distance_matrix_1[random_solution1[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                     distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                     distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        obj2_diff = (distance_matrix_2[new_solution[start_pos-1], random_solution1[start_pos]] +\n                     distance_matrix_2[random_solution1[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                     distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                     distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        obj3_diff = (distance_matrix_3[new_solution[start_pos-1], random_solution1[start_pos]] +\n                     distance_matrix_3[random_solution1[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                     distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                     distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        total_diff = obj1_diff + obj2_diff + obj3_diff\n\n        # Calculate improvement potential for the second random solution\n        obj1_diff2 = (distance_matrix_1[new_solution[start_pos-1], random_solution2[start_pos]] +\n                      distance_matrix_1[random_solution2[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                      distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                      distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        obj2_diff2 = (distance_matrix_2[new_solution[start_pos-1], random_solution2[start_pos]] +\n                      distance_matrix_2[random_solution2[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                      distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                      distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        obj3_diff2 = (distance_matrix_3[new_solution[start_pos-1], random_solution2[start_pos]] +\n                      distance_matrix_3[random_solution2[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                      distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                      distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n        total_diff2 = obj1_diff2 + obj2_diff2 + obj3_diff2\n\n        # Select the better segment\n        if total_diff < total_diff2:\n            new_solution[start_pos:start_pos+segment_length] = random_solution1[start_pos:start_pos+segment_length]\n        else:\n            new_solution[start_pos:start_pos+segment_length] = random_solution2[start_pos:start_pos+segment_length]\n\n        # Probabilistic segment inversion for diversity\n        if np.random.rand() < 0.3:\n            invert_pos = np.random.randint(0, n - segment_length)\n            new_solution[invert_pos:invert_pos+segment_length] = new_solution[invert_pos:invert_pos+segment_length][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.6432412265626941,
               1.0864832997322083
          ]
     }
]