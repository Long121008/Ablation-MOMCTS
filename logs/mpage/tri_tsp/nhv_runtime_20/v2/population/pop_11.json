[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate potential improvement for each solution\n    potential = []\n    for sol, obj in archive:\n        # Calculate potential as inverse of objective sum (lower objectives are better)\n        # and add some randomness to avoid bias\n        potential.append((1 / (sum(obj) + 1e-6)) * (1 + np.random.rand()))\n\n    # Select a solution using roulette wheel selection\n    selected_idx = np.random.choice(len(archive), p=np.array(potential)/sum(potential))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try 2-opt first\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # If not valid, revert to original\n        new_solution = base_solution.copy()\n\n    # Then try 3-objective-aware perturbation\n    if np.random.rand() < 0.5:  # 50% chance to apply this\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        subtour = new_solution[start:end+1]\n\n        # Calculate weighted distances for subtour\n        weights = np.random.rand(3)  # Random weights for objectives\n        weights /= weights.sum()     # Normalize\n\n        # Calculate total weighted distance for current order\n        current_dist = 0\n        for k in range(len(subtour)-1):\n            i, j = subtour[k], subtour[k+1]\n            current_dist += weights[0] * distance_matrix_1[i, j] + \\\n                           weights[1] * distance_matrix_2[i, j] + \\\n                           weights[2] * distance_matrix_3[i, j]\n\n        # Try random permutation of subtour\n        new_subtour = subtour.copy()\n        np.random.shuffle(new_subtour)\n\n        # Calculate new weighted distance\n        new_dist = 0\n        for k in range(len(new_subtour)-1):\n            i, j = new_subtour[k], new_subtour[k+1]\n            new_dist += weights[0] * distance_matrix_1[i, j] + \\\n                       weights[1] * distance_matrix_2[i, j] + \\\n                       weights[2] * distance_matrix_3[i, j]\n\n        # Accept if better\n        if new_dist < current_dist:\n            new_solution[start:end+1] = new_subtour\n\n    return new_solution\n\n",
          "score": [
               -0.8149859994248885,
               1.1998218536376952
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    # Here, we use a simple approach: select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a 2-opt local search\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no revisits)\n    if len(np.unique(new_solution)) == len(base_solution):\n        return new_solution\n    else:\n        return base_solution\n\n",
          "score": [
               -0.7773360332534743,
               0.8836707472801208
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Multi-objective path inversion operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select random segment to invert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate current and potential costs for all objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    current_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # Perform inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate new costs\n    new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(1, n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # Weighted improvement calculation\n    weights = [0.3, 0.4, 0.3]  # Example weights for three objectives\n    current_weighted = sum(w * c for w, c in zip(weights, [current_cost1, current_cost2, current_cost3]))\n    new_weighted = sum(w * c for w, c in zip(weights, [new_cost1, new_cost2, new_cost3]))\n\n    # Accept if improvement or with small probability\n    if new_weighted < current_weighted or np.random.random() < 0.1:\n        return new_solution\n    else:\n        # If not accepted, restore original and try random swap\n        new_solution = selected_solution.copy()\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        return new_solution\n\n",
          "score": [
               -0.861910730098753,
               2.3665157318115235
          ]
     },
     {
          "algorithm": "{The new algorithm combines the multi-objective selection strategy of prioritizing balanced solutions from the provided algorithms with an innovative hybrid local search operator that performs a dynamic segment-based crossover augmented with objective-aware inversion and probabilistic segment mutation. It first identifies the most balanced solution in the archive by analyzing the normalized objective values, then performs a guided segment exchange between this solution and a randomly selected archive member, where segments are selected based on their potential to improve Pareto dominance through a dynamic weighting scheme that prioritizes objectives with the highest relative improvement. The algorithm incorporates a probabilistic segment mutation mechanism that randomly reorders segments with a probability inversely proportional to their current objective values, further diversifying the search while preserving solution quality. Additionally, it includes a novel three-way objective-aware inversion operator that selectively inverts segments based on their contribution to each objective, ensuring balanced optimization across all three objectives, while dynamically adjusting the search focus based on the current Pareto front's distribution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most balanced solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.mean(normalized_objectives, axis=1)\n    balanced_idx = np.argmax(balance_scores)\n    balanced_solution = archive[balanced_idx][0].copy()\n\n    # Select a random solution from the archive\n    random_idx = np.random.randint(len(archive))\n    random_solution = archive[random_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = balanced_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective improvement potential\n    segment_length = np.random.randint(2, min(5, n//3))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Calculate potential improvement for each objective\n    obj1_diff = (distance_matrix_1[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_1[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj2_diff = (distance_matrix_2[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_2[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj3_diff = (distance_matrix_3[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_3[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    # Dynamic weighting based on relative improvement\n    total_diff = np.abs(obj1_diff) + np.abs(obj2_diff) + np.abs(obj3_diff)\n    if total_diff > 0:\n        weights = np.array([np.abs(obj1_diff), np.abs(obj2_diff), np.abs(obj3_diff)]) / total_diff\n    else:\n        weights = np.ones(3) / 3\n\n    # Perform segment exchange if improvement is expected\n    if (weights[0] * obj1_diff + weights[1] * obj2_diff + weights[2] * obj3_diff) < 0:\n        new_solution[start_pos:start_pos+segment_length] = random_solution[start_pos:start_pos+segment_length]\n\n    # Probabilistic segment mutation with objective-aware probability\n    mutation_prob = 0.3 * (1 - np.min(normalized_objectives[balanced_idx]) / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n    if np.random.rand() < mutation_prob:\n        mutate_pos = np.random.randint(0, n - segment_length)\n        new_solution[mutate_pos:mutate_pos+segment_length] = np.roll(new_solution[mutate_pos:mutate_pos+segment_length], np.random.randint(1, segment_length))\n\n    # Three-way objective-aware inversion with dynamic segment selection\n    inversion_prob = 0.4 * (1 - np.min(normalized_objectives[balanced_idx]) / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n    if np.random.rand() < inversion_prob:\n        # Select segment based on worst objective contribution\n        potential_segments = []\n        for i in range(n - segment_length):\n            segment = new_solution[i:i+segment_length]\n            obj1_contrib = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, segment_length))\n            obj2_contrib = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, segment_length))\n            obj3_contrib = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, segment_length))\n            worst_contrib = min(obj1_contrib, obj2_contrib, obj3_contrib)\n            potential_segments.append((i, worst_contrib))\n\n        if potential_segments:\n            selected_segment = max(potential_segments, key=lambda x: x[1])\n            invert_pos = selected_segment[0]\n            new_solution[invert_pos:invert_pos+segment_length] = new_solution[invert_pos:invert_pos+segment_length][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.7977656129040049,
               1.407644307613373
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj_variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(obj_variances)\n\n    # Select random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the swap if it improves the target objective\n    if target_obj == 0:\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    elif target_obj == 1:\n        current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    else:\n        current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional edge swap for other objectives\n    m, o = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[m], new_solution[o] = new_solution[o], new_solution[m]\n\n    return new_solution\n\n",
          "score": [
               -0.7051402229421123,
               1.1361269235610962
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with low individual objective costs\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = np.min(normalized_objectives, axis=1)  # Min of normalized objectives to find solutions with at least one good objective\n        selected_idx = np.random.choice(np.argsort(scores)[-max(1, len(archive)//2):])  # Select from top half\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware segment swap\n        segment_length = np.random.randint(2, min(5, n//2))\n        k = np.random.randint(0, n - segment_length)\n        l = np.random.randint(0, n - segment_length)\n        if k != l:\n            new_solution[k:k+segment_length], new_solution[l:l+segment_length] = new_solution[l:l+segment_length], new_solution[k:k+segment_length]\n\n    # Ensure feasibility by repairing invalid tours\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If nodes are missing or duplicated, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.6412513545476096,
               1.0825375676155091
          ]
     },
     {
          "algorithm": "{This new algorithm employs a multi-objective-aware path relinking strategy that combines features from both existing approaches while introducing novel elements. It first identifies the most diverse solution in the archive by analyzing the variance of objectives, then performs a guided path relinking between this solution and a randomly selected archive member, where the path is constructed by selectively swapping nodes based on their potential to improve Pareto dominance through a weighted combination of objective improvements. The algorithm dynamically adjusts the weights during the relinking process to prioritize objectives that show the most improvement potential, while maintaining feasibility through a two-phase validation step that ensures no nodes are skipped or revisited. Additionally, it incorporates a probabilistic segment inversion mechanism that flips segments of the tour with a probability proportional to their current objective values, further diversifying the search while preserving solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most diverse solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    obj_variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(obj_variances)\n    diverse_idx = np.argmax(objectives[:, target_obj])\n    diverse_solution = archive[diverse_idx][0].copy()\n\n    # Select a random solution from the archive\n    random_idx = np.random.randint(len(archive))\n    random_solution = archive[random_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = diverse_solution.copy()\n    n = len(new_solution)\n\n    # Perform guided path relinking\n    for i in range(n):\n        if np.random.rand() < 0.3:  # Probability of swapping nodes\n            # Calculate potential improvement for each objective\n            obj1_diff = distance_matrix_1[new_solution[i-1], random_solution[i]] + distance_matrix_1[random_solution[i], new_solution[(i+1)%n]] - \\\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            obj2_diff = distance_matrix_2[new_solution[i-1], random_solution[i]] + distance_matrix_2[random_solution[i], new_solution[(i+1)%n]] - \\\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            obj3_diff = distance_matrix_3[new_solution[i-1], random_solution[i]] + distance_matrix_3[random_solution[i], new_solution[(i+1)%n]] - \\\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n\n            # Weighted improvement score\n            weights = np.random.rand(3)\n            weights /= weights.sum()\n            improvement = weights[0] * obj1_diff + weights[1] * obj2_diff + weights[2] * obj3_diff\n\n            if improvement < 0:  # If improvement is negative, perform the swap\n                new_solution[i] = random_solution[i]\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.5:\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.7:  # Higher probability to invert segments with better objectives\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.5910338529569468,
               0.9789687633514405
          ]
     },
     {
          "algorithm": "{This new algorithm employs a multi-objective-aware path decomposition strategy that first decomposes the current solution into segments based on the dominant objective for each segment, then selectively reorders these segments using a novel adaptive segment swapping mechanism that prioritizes segments with the highest potential for improvement in the least improved objective, while incorporating a probabilistic segment inversion mechanism that flips segments with a probability proportional to their current objective dominance rank, ensuring feasibility through a comprehensive validation step that verifies segment continuity and repairs any invalid tours by reinserting missing segments at the most promising positions while maintaining the overall tour structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solution with most balanced objectives (smallest range between best and worst objective)\n        objectives = np.array([obj for _, obj in archive])\n        objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_idx = np.argmin(objective_ranges)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current costs for all objectives\n    current_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Identify the objective with the least improvement\n    if len(archive) > 1:\n        prev_objectives = np.array([archive[i-1][1] for i in range(1, len(archive))])\n        improvements = objectives[1:] - prev_objectives\n        least_improved_obj = np.argmin(np.mean(improvements, axis=0))\n    else:\n        least_improved_obj = np.argmin(current_costs)\n\n    # Decompose solution into segments\n    segment_length = max(2, n // 5)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Calculate segment costs for the least improved objective\n    segment_costs = []\n    for seg in segments:\n        cost = 0\n        for i in range(len(seg)-1):\n            if least_improved_obj == 0:\n                cost += distance_matrix_1[seg[i], seg[i+1]]\n            elif least_improved_obj == 1:\n                cost += distance_matrix_2[seg[i], seg[i+1]]\n            else:\n                cost += distance_matrix_3[seg[i], seg[i+1]]\n        segment_costs.append(cost)\n\n    # Select top segments to reorder\n    num_to_reorder = min(3, len(segments))\n    top_segments = np.argsort(segment_costs)[-num_to_reorder:]\n\n    # Reorder selected segments\n    for i in range(num_to_reorder):\n        if np.random.rand() < 0.5:\n            segments[top_segments[i]] = segments[top_segments[i]][::-1]  # Invert segment\n        else:\n            # Swap with another segment\n            swap_idx = np.random.choice([j for j in range(len(segments)) if j != top_segments[i]])\n            segments[top_segments[i]], segments[swap_idx] = segments[swap_idx], segments[top_segments[i]]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Repair if invalid\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find best position to insert missing node\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                        distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] +\n                        distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert node at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution[:n]\n\n",
          "score": [
               -0.8409447126011894,
               2.6053948163986207
          ]
     },
     {
          "algorithm": "{This new algorithm combines the multi-objective selection strategy of prioritizing balanced solutions from the archive with an innovative adaptive segment-based crossover that dynamically adjusts segment lengths and positions based on the current Pareto front's distribution. It first identifies the most balanced solution in the archive by analyzing the normalized objective values, then performs a guided segment exchange between this solution and a randomly selected archive member, where segments are selected based on their potential to improve Pareto dominance through a dynamic weighting scheme that prioritizes objectives with the highest relative improvement. The algorithm incorporates an adaptive segment mutation mechanism that randomly reorders segments with a probability inversely proportional to their current objective values, further diversifying the search while preserving solution quality. Additionally, it includes a novel three-way objective-aware inversion operator that selectively inverts segments based on their contribution to each objective, ensuring balanced optimization across all three objectives, while dynamically adjusting the search focus based on the current Pareto front's distribution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify the most balanced solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.mean(normalized_objectives, axis=1)\n    balanced_idx = np.argmax(balance_scores)\n    balanced_solution = archive[balanced_idx][0].copy()\n\n    # Select a random solution from the archive\n    random_idx = np.random.randint(len(archive))\n    random_solution = archive[random_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = balanced_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective improvement potential\n    segment_length = np.random.randint(2, min(6, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Calculate potential improvement for each objective\n    obj1_diff = (distance_matrix_1[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_1[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_1[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj2_diff = (distance_matrix_2[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_2[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_2[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    obj3_diff = (distance_matrix_3[new_solution[start_pos-1], random_solution[start_pos]] +\n                 distance_matrix_3[random_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]] -\n                 distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] -\n                 distance_matrix_3[new_solution[start_pos+segment_length-1], new_solution[start_pos+segment_length]])\n\n    # Dynamic weighting based on relative improvement\n    total_diff = np.abs(obj1_diff) + np.abs(obj2_diff) + np.abs(obj3_diff)\n    if total_diff > 0:\n        weights = np.array([np.abs(obj1_diff), np.abs(obj2_diff), np.abs(obj3_diff)]) / total_diff\n    else:\n        weights = np.ones(3) / 3\n\n    # Perform segment exchange if improvement is expected\n    if (weights[0] * obj1_diff + weights[1] * obj2_diff + weights[2] * obj3_diff) < 0:\n        new_solution[start_pos:start_pos+segment_length] = random_solution[start_pos:start_pos+segment_length]\n\n    # Adaptive segment mutation with objective-aware probability\n    mutation_prob = 0.25 * (1 - np.min(normalized_objectives[balanced_idx]) / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n    if np.random.rand() < mutation_prob:\n        mutate_pos = np.random.randint(0, n - segment_length)\n        new_solution[mutate_pos:mutate_pos+segment_length] = np.roll(new_solution[mutate_pos:mutate_pos+segment_length], np.random.randint(1, segment_length))\n\n    # Three-way objective-aware inversion with dynamic segment selection\n    inversion_prob = 0.35 * (1 - np.min(normalized_objectives[balanced_idx]) / (np.sum(normalized_objectives[balanced_idx]) + 1e-10))\n    if np.random.rand() < inversion_prob:\n        # Select segment based on worst objective contribution\n        potential_segments = []\n        for i in range(n - segment_length):\n            segment = new_solution[i:i+segment_length]\n            obj1_contrib = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, segment_length))\n            obj2_contrib = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, segment_length))\n            obj3_contrib = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, segment_length))\n            worst_contrib = min(obj1_contrib, obj2_contrib, obj3_contrib)\n            potential_segments.append((i, worst_contrib))\n\n        if potential_segments:\n            selected_segment = max(potential_segments, key=lambda x: x[1])\n            invert_pos = selected_segment[0]\n            new_solution[invert_pos:invert_pos+segment_length] = new_solution[invert_pos:invert_pos+segment_length][::-1]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, perform a simple 2-opt move to repair\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
          "score": [
               -0.6684967688737105,
               1.1736530303955077
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of prioritizing solutions with balanced objective values from the first provided algorithm with an innovative multi-objective local search operator that performs a hybrid of 2-opt moves and objective-aware node swaps, where the swap candidates are dynamically selected based on their potential to improve the least improved objective. The operator first identifies critical nodes where improvements can be made by analyzing the current solution's objective values, then performs targeted swaps of these nodes to explore better configurations while maintaining feasibility, and finally verifies the solution's validity by ensuring no nodes are skipped or revisited. This approach balances exploitation of good solutions with exploration of diverse neighborhoods in the multi-objective space by focusing on the objective that has shown the least improvement, promoting more balanced progress across all objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solution with most balanced objectives (smallest range between best and worst objective)\n        objectives = np.array([obj for _, obj in archive])\n        objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_idx = np.argmin(objective_ranges)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current costs for all objectives\n    current_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Identify the objective with the least improvement\n    if len(archive) > 1:\n        prev_objectives = np.array([archive[i-1][1] for i in range(1, len(archive))])\n        improvements = objectives[1:] - prev_objectives\n        least_improved_obj = np.argmin(np.mean(improvements, axis=0))\n    else:\n        least_improved_obj = np.argmin(current_costs)\n\n    # Hybrid 2-opt with objective-aware node swaps\n    if np.random.rand() < 0.7:\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform objective-aware node swap\n        # Find nodes that are most expensive in the least improved objective\n        node_costs = []\n        for k in range(n):\n            prev_node = new_solution[k-1]\n            next_node = new_solution[(k+1)%n]\n            if least_improved_obj == 0:\n                cost = distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            elif least_improved_obj == 1:\n                cost = distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            else:\n                cost = distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n            node_costs.append(cost)\n\n        # Select top 2 most expensive nodes for swap\n        expensive_nodes = np.argsort(node_costs)[-2:]\n        new_solution[expensive_nodes[0]], new_solution[expensive_nodes[1]] = new_solution[expensive_nodes[1]], new_solution[expensive_nodes[0]]\n\n    # Verify solution validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n    else:\n        # Verify if the move improved the least improved objective\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        if new_costs[least_improved_obj] >= current_costs[least_improved_obj] and np.random.rand() > 0.2:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8247777719305841,
               3.055228662490845
          ]
     }
]