[
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour decomposition and reconstruction strategy that first decomposes the solution into three non-overlapping segments, each optimized for one of the objectives, then applies a novel objective-aware segment shuffling operation that reorders these segments based on their relative importance across objectives, followed by a probabilistic segment inversion step that flips segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose into three non-overlapping segments\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Objective-aware segment shuffling\n    objectives = archive[selected_idx][1]\n    normalized = [obj / sum(objectives) for obj in objectives]\n    shuffled_indices = np.argsort(normalized)[::-1]  # Sort by descending importance\n    shuffled_segments = [segments[i] for i in shuffled_indices]\n\n    # Reconstruct with shuffled segments\n    new_solution = np.concatenate(shuffled_segments)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.4:  # 40% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware edge exchange\n    for _ in range(15):  # Perform 15 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Exchanged cost\n        exchanged_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                         distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if exchanged_cost < orig_cost and np.random.rand() < 0.6:  # 60% chance to accept if beneficial\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour partitioning and reassembly strategy that first partitions the solution into three non-overlapping segments based on their contributions to each objective, then applies a novel objective-aware segment reordering operation that reorders these segments based on their relative importance across objectives, followed by a probabilistic segment inversion step that flips segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n    segment_weights = np.max(contributions, axis=1)  # Focus on segments with high max contribution\n    segment_weights = segment_weights / np.sum(segment_weights)\n\n    # Perform targeted segment inversions\n    for _ in range(3):\n        # Select segment with weighted probability\n        segment_idx = np.random.choice(n, p=segment_weights)\n        i, j = segment_idx, (segment_idx + 1) % n\n\n        # Invert the segment\n        if i < j:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j] = new_solution[:j][::-1]\n\n    # Relocate nodes to improve worst objective\n    worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(current_objectives, current_objectives)])\n    for _ in range(2):\n        # Select nodes from high-contribution segments\n        candidate_nodes = np.where(contributions[:, worst_obj_idx] > np.percentile(contributions[:, worst_obj_idx], 75))[0]\n        if len(candidate_nodes) > 0:\n            node_idx = np.random.choice(candidate_nodes)\n            node = new_solution[node_idx]\n            pos = np.random.randint(n)\n            if pos != node_idx:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, pos, node)\n\n    # Periodic diversification\n    if np.random.random() < 0.2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution hasn't been seen before\n    existing_solutions = [sol for sol, _ in archive]\n    while any(np.array_equal(new_solution, sol) for sol in existing_solutions):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The new algorithm employs a multi-objective aware tour segmentation and hierarchical optimization strategy that first partitions the solution into three non-overlapping segments based on their contributions to each objective, then applies a novel objective-aware segment reordering operation that reorders these segments based on their relative importance across objectives, followed by a probabilistic segment inversion step that flips segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution, while also incorporating a hierarchical optimization approach that prioritizes segments based on their contribution to the worst-performing objective, and a dynamic neighborhood exploration mechanism that adaptsively selects between local and global search operations based on the current optimization progress.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n    segment_weights = np.max(contributions, axis=1)\n    segment_weights = segment_weights / np.sum(segment_weights)\n\n    # Hierarchical segment optimization\n    worst_obj_idx = np.argmax(current_objectives)\n    segment_order = np.argsort(contributions[:, worst_obj_idx])[::-1]\n\n    # Apply segment reordering based on hierarchical priority\n    for i in range(n):\n        if np.random.random() < 0.7:  # 70% chance to reorder\n            target_pos = np.random.choice(n)\n            segment = new_solution[segment_order[i]]\n            new_solution = np.delete(new_solution, segment_order[i])\n            new_solution = np.insert(new_solution, target_pos, segment)\n\n    # Adaptive neighborhood exploration\n    if np.random.random() < 0.5:  # Local search\n        for _ in range(3):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Check if swap improves any objective\n            orig_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n            if new_cost < orig_cost and np.random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Global search\n        # Perform large-scale segment inversion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.680861848215085,
               3.882224130630493
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n    segment_weights = np.max(contributions, axis=1)\n    segment_weights = segment_weights / np.sum(segment_weights)\n\n    # Hierarchical segment optimization\n    worst_obj_idx = np.argmax(current_objectives)\n    segment_order = np.argsort(contributions[:, worst_obj_idx])[::-1]\n\n    # Apply segment reordering based on hierarchical priority\n    for i in range(n):\n        if np.random.random() < 0.7:  # 70% chance to reorder\n            target_pos = np.random.choice(n)\n            segment = new_solution[segment_order[i]]\n            new_solution = np.delete(new_solution, segment_order[i])\n            new_solution = np.insert(new_solution, target_pos, segment)\n\n    # Adaptive neighborhood exploration\n    if np.random.random() < 0.5:  # Local search\n        for _ in range(3):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Check if swap improves any objective\n            orig_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n            if new_cost < orig_cost and np.random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Global search\n        # Perform large-scale segment inversion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate segments, each optimized for one of the objectives, then selectively merges these segments using a novel objective-aware crossover operation that combines segments from different partitions while maintaining feasibility, followed by a probabilistic segment rotation step that rotates segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 3-opt local search that considers all three objectives simultaneously to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three segments\n    seg1 = new_solution[:n//3]\n    seg2 = new_solution[n//3:2*n//3]\n    seg3 = new_solution[2*n//3:]\n\n    # Objective-aware segment merge\n    merged = []\n    for i in range(max(len(seg1), len(seg2), len(seg3))):\n        source = np.random.randint(3)\n        if source == 0 and i < len(seg1):\n            merged.append(seg1[i])\n        elif source == 1 and i < len(seg2):\n            merged.append(seg2[i])\n        elif source == 2 and i < len(seg3):\n            merged.append(seg3[i])\n\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.3:\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n\n        segment = new_solution[idx1:idx2+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[idx1:idx2+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Multi-objective aware 3-opt local search\n    for _ in range(10):\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n        prev_k = new_solution[k]\n        next_k = new_solution[(k+1)%n]\n\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j] +\n                    distance_matrix_1[prev_k, next_k] + distance_matrix_2[prev_k, next_k] + distance_matrix_3[prev_k, next_k])\n\n        # Try all 8 possible 3-opt moves\n        best_cost = orig_cost\n        best_move = None\n\n        # Move 1: Reverse i-j\n        cost1 = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j] +\n                distance_matrix_1[prev_k, next_k] + distance_matrix_2[prev_k, next_k] + distance_matrix_3[prev_k, next_k])\n        if cost1 < best_cost:\n            best_cost = cost1\n            best_move = (i, j, k, 1)\n\n        # Move 2: Reverse j-k\n        cost2 = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                distance_matrix_1[prev_j, prev_k] + distance_matrix_2[prev_j, prev_k] + distance_matrix_3[prev_j, prev_k] +\n                distance_matrix_1[next_j, next_k] + distance_matrix_2[next_j, next_k] + distance_matrix_3[next_j, next_k])\n        if cost2 < best_cost:\n            best_cost = cost2\n            best_move = (i, j, k, 2)\n\n        # Move 3: Reverse i-k\n        cost3 = (distance_matrix_1[prev_i, prev_k] + distance_matrix_2[prev_i, prev_k] + distance_matrix_3[prev_i, prev_k] +\n                distance_matrix_1[next_i, next_k] + distance_matrix_2[next_i, next_k] + distance_matrix_3[next_i, next_k] +\n                distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n        if cost3 < best_cost:\n            best_cost = cost3\n            best_move = (i, j, k, 3)\n\n        # Apply best move if beneficial\n        if best_move and best_cost < orig_cost and np.random.rand() < 0.7:\n            i, j, k, move_type = best_move\n            if move_type == 1:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif move_type == 2:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            elif move_type == 3:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    assert len(new_solution) == len(np.unique(new_solution))\n    return new_solution\n\n",
          "score": [
               -0.8378500355771641,
               2.5438958764076234
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three segments\n    seg1 = new_solution[:n//3]\n    seg2 = new_solution[n//3:2*n//3]\n    seg3 = new_solution[2*n//3:]\n\n    # Objective-aware segment merge\n    merged = []\n    for i in range(max(len(seg1), len(seg2), len(seg3))):\n        source = np.random.randint(3)\n        if source == 0 and i < len(seg1):\n            merged.append(seg1[i])\n        elif source == 1 and i < len(seg2):\n            merged.append(seg2[i])\n        elif source == 2 and i < len(seg3):\n            merged.append(seg3[i])\n\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.3:\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n\n        segment = new_solution[idx1:idx2+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[idx1:idx2+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Multi-objective aware 3-opt local search\n    for _ in range(10):\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n        prev_k = new_solution[k]\n        next_k = new_solution[(k+1)%n]\n\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j] +\n                    distance_matrix_1[prev_k, next_k] + distance_matrix_2[prev_k, next_k] + distance_matrix_3[prev_k, next_k])\n\n        # Try all 8 possible 3-opt moves\n        best_cost = orig_cost\n        best_move = None\n\n        # Move 1: Reverse i-j\n        cost1 = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j] +\n                distance_matrix_1[prev_k, next_k] + distance_matrix_2[prev_k, next_k] + distance_matrix_3[prev_k, next_k])\n        if cost1 < best_cost:\n            best_cost = cost1\n            best_move = (i, j, k, 1)\n\n        # Move 2: Reverse j-k\n        cost2 = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                distance_matrix_1[prev_j, prev_k] + distance_matrix_2[prev_j, prev_k] + distance_matrix_3[prev_j, prev_k] +\n                distance_matrix_1[next_j, next_k] + distance_matrix_2[next_j, next_k] + distance_matrix_3[next_j, next_k])\n        if cost2 < best_cost:\n            best_cost = cost2\n            best_move = (i, j, k, 2)\n\n        # Move 3: Reverse i-k\n        cost3 = (distance_matrix_1[prev_i, prev_k] + distance_matrix_2[prev_i, prev_k] + distance_matrix_3[prev_i, prev_k] +\n                distance_matrix_1[next_i, next_k] + distance_matrix_2[next_i, next_k] + distance_matrix_3[next_i, next_k] +\n                distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n        if cost3 < best_cost:\n            best_cost = cost3\n            best_move = (i, j, k, 3)\n\n        # Apply best move if beneficial\n        if best_move and best_cost < orig_cost and np.random.rand() < 0.7:\n            i, j, k, move_type = best_move\n            if move_type == 1:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif move_type == 2:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            elif move_type == 3:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    assert len(new_solution) == len(np.unique(new_solution))\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic partitioning based on objective dominance\n    objectives = [archive[i][1] for i in range(len(archive))]\n    obj1, obj2, obj3 = zip(*objectives)\n    obj1_mean, obj2_mean, obj3_mean = np.mean(obj1), np.mean(obj2), np.mean(obj3)\n\n    # Determine which objective to prioritize\n    dominant_obj = np.argmin([obj1_mean, obj2_mean, obj3_mean])\n\n    # Partition into three sub-tours based on dominant objective\n    if dominant_obj == 0:\n        sub_tour1 = new_solution[:n//3]\n        sub_tour2 = new_solution[n//3:2*n//3]\n        sub_tour3 = new_solution[2*n//3:]\n    elif dominant_obj == 1:\n        sub_tour1 = new_solution[:n//4]\n        sub_tour2 = new_solution[n//4:3*n//4]\n        sub_tour3 = new_solution[3*n//4:]\n    else:\n        sub_tour1 = new_solution[:n//2]\n        sub_tour2 = new_solution[n//2:3*n//4]\n        sub_tour3 = new_solution[3*n//4:]\n\n    # Objective-aware crossover with probabilistic selection\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Higher probability to select from dominant objective\n        if np.random.rand() < 0.6:\n            source = dominant_obj\n        else:\n            source = np.random.randint(3)\n\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion with objective-specific logic\n    if np.random.rand() < 0.4:\n        # Select space based on least improved objective\n        obj_improvement = [obj1_mean - archive[selected_idx][1][0],\n                          obj2_mean - archive[selected_idx][1][1],\n                          obj3_mean - archive[selected_idx][1][2]]\n        space = np.argmax(obj_improvement)\n\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Enhanced multi-objective aware 2-opt local search\n    for _ in range(15):  # More iterations for better refinement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        # More aggressive acceptance\n        if rev_cost < orig_cost and np.random.rand() < 0.8:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour partitioning and reassembly strategy that first partitions the solution into three non-overlapping segments based on their contributions to each objective, then applies a novel objective-aware segment reordering operation that reorders these segments based on their relative importance across objectives, followed by a probabilistic segment inversion step that flips segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n    segment_weights = np.max(contributions, axis=1)  # Focus on segments with high max contribution\n    segment_weights = segment_weights / np.sum(segment_weights)\n\n    # Perform targeted segment inversions\n    for _ in range(3):\n        # Select segment with weighted probability\n        segment_idx = np.random.choice(n, p=segment_weights)\n        i, j = segment_idx, (segment_idx + 1) % n\n\n        # Invert the segment\n        if i < j:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j] = new_solution[:j][::-1]\n\n    # Relocate nodes to improve worst objective\n    worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(current_objectives, current_objectives)])\n    for _ in range(2):\n        # Select nodes from high-contribution segments\n        candidate_nodes = np.where(contributions[:, worst_obj_idx] > np.percentile(contributions[:, worst_obj_idx], 75))[0]\n        if len(candidate_nodes) > 0:\n            node_idx = np.random.choice(candidate_nodes)\n            node = new_solution[node_idx]\n            pos = np.random.randint(n)\n            if pos != node_idx:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, pos, node)\n\n    # Periodic diversification\n    if np.random.random() < 0.2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution hasn't been seen before\n    existing_solutions = [sol for sol, _ in archive]\n    while any(np.array_equal(new_solution, sol) for sol in existing_solutions):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The new algorithm employs a multi-objective tour reconstruction strategy that first identifies the most promising segments in each objective space by analyzing the solution's objective contributions, then dynamically partitions the tour into three non-overlapping segments based on these contributions, followed by a novel objective-aware segment reassembly operation that reconstructs the tour by interleaving segments from different spaces in a way that maximizes cross-objective synergy, then applies a probabilistic segment rotation operation that rotates segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n\n    # Identify most promising segments in each space\n    obj1_segments = np.argsort(contributions[:, 0])[::-1][:n//3]\n    obj2_segments = np.argsort(contributions[:, 1])[::-1][:n//3]\n    obj3_segments = np.argsort(contributions[:, 2])[::-1][:n//3]\n\n    # Dynamic partitioning based on segment importance\n    all_segments = np.concatenate([obj1_segments, obj2_segments, obj3_segments])\n    unique_segments = np.unique(all_segments)\n    if len(unique_segments) < 3:\n        # Fallback to equal partitioning if not enough unique segments\n        segments = [np.arange(n//3), np.arange(n//3, 2*n//3), np.arange(2*n//3, n)]\n    else:\n        segments = [unique_segments[:n//3], unique_segments[n//3:2*n//3], unique_segments[2*n//3:]]\n\n    # Reconstruct tour by interleaving segments from different spaces\n    merged = []\n    for i in range(max(len(seg) for seg in segments)):\n        for seg in segments:\n            if i < len(seg):\n                merged.append(new_solution[seg[i]])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.5:\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find segment with highest contribution in the selected space\n        segment_idx = np.argmax(contributions[:, space])\n        segment_start = segment_idx\n        segment_end = (segment_idx + 1) % n\n\n        # Rotate the segment\n        rotation = np.random.randint(1, n//4)\n        segment = new_solution[segment_start:segment_end]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[segment_start:segment_end] = rotated_segment\n\n    # Multi-objective aware edge exchange\n    for _ in range(10):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Swapped cost\n        swap_cost = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_3[prev_i, new_solution[j]] +\n                    distance_matrix_1[new_solution[j], next_i] + distance_matrix_2[new_solution[j], next_i] + distance_matrix_3[new_solution[j], next_i] +\n                    distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_3[prev_j, new_solution[i]] +\n                    distance_matrix_1[new_solution[i], next_j] + distance_matrix_2[new_solution[i], next_j] + distance_matrix_3[new_solution[i], next_j])\n\n        # More aggressive acceptance\n        if swap_cost < orig_cost and np.random.rand() < 0.9:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.6584332027017314,
               3.4261785745620728
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n\n    # Identify most promising segments in each space\n    obj1_segments = np.argsort(contributions[:, 0])[::-1][:n//3]\n    obj2_segments = np.argsort(contributions[:, 1])[::-1][:n//3]\n    obj3_segments = np.argsort(contributions[:, 2])[::-1][:n//3]\n\n    # Dynamic partitioning based on segment importance\n    all_segments = np.concatenate([obj1_segments, obj2_segments, obj3_segments])\n    unique_segments = np.unique(all_segments)\n    if len(unique_segments) < 3:\n        # Fallback to equal partitioning if not enough unique segments\n        segments = [np.arange(n//3), np.arange(n//3, 2*n//3), np.arange(2*n//3, n)]\n    else:\n        segments = [unique_segments[:n//3], unique_segments[n//3:2*n//3], unique_segments[2*n//3:]]\n\n    # Reconstruct tour by interleaving segments from different spaces\n    merged = []\n    for i in range(max(len(seg) for seg in segments)):\n        for seg in segments:\n            if i < len(seg):\n                merged.append(new_solution[seg[i]])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.5:\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find segment with highest contribution in the selected space\n        segment_idx = np.argmax(contributions[:, space])\n        segment_start = segment_idx\n        segment_end = (segment_idx + 1) % n\n\n        # Rotate the segment\n        rotation = np.random.randint(1, n//4)\n        segment = new_solution[segment_start:segment_end]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[segment_start:segment_end] = rotated_segment\n\n    # Multi-objective aware edge exchange\n    for _ in range(10):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Swapped cost\n        swap_cost = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_3[prev_i, new_solution[j]] +\n                    distance_matrix_1[new_solution[j], next_i] + distance_matrix_2[new_solution[j], next_i] + distance_matrix_3[new_solution[j], next_i] +\n                    distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_3[prev_j, new_solution[i]] +\n                    distance_matrix_1[new_solution[i], next_j] + distance_matrix_2[new_solution[i], next_j] + distance_matrix_3[new_solution[i], next_j])\n\n        # More aggressive acceptance\n        if swap_cost < orig_cost and np.random.rand() < 0.9:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions\n    segment_contributions = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        contrib = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i-1], new_solution[i]])\n        if contrib > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segment_contributions.append((current_segment, contrib))\n            current_segment = [new_solution[i]]\n    segment_contributions.append((current_segment, 0))\n\n    # Probabilistically select segments to fuse or reverse\n    segments = [seg for seg, _ in segment_contributions]\n    if len(segments) > 1:\n        # Calculate dynamic fusion probability based on solution quality\n        avg_contrib = np.mean([abs(contrib) for _, contrib in segment_contributions])\n        fusion_prob = min(0.8, 0.2 + avg_contrib / 100)  # Cap at 0.8\n\n        # Select segments with high contribution\n        weights = [abs(contrib) for seg, contrib in segment_contributions]\n        weights = np.array(weights) + 1e-6  # Avoid zero weights\n        weights = weights / np.sum(weights)\n\n        # Select segments to process\n        num_to_process = min(3, len(segments))\n        selected_indices = np.random.choice(len(segments), size=num_to_process, replace=False, p=weights)\n\n        for idx in selected_indices:\n            if np.random.rand() < fusion_prob:  # Dynamic fusion probability\n                # Adaptive segment fusion with objective-aware merging\n                if idx > 0 and np.random.rand() < 0.5:\n                    # Merge with left segment if it reduces combined objective\n                    left_contrib = (distance_matrix_1[segments[idx-1][-1], segments[idx][0]] +\n                                  distance_matrix_2[segments[idx-1][-1], segments[idx][0]] +\n                                  distance_matrix_3[segments[idx-1][-1], segments[idx][0]])\n                    if left_contrib < 0:  # Only merge if it improves\n                        segments[idx-1] += segments[idx]\n                        segments.pop(idx)\n                elif idx < len(segments)-1:\n                    # Merge with right segment if it reduces combined objective\n                    right_contrib = (distance_matrix_1[segments[idx][-1], segments[idx+1][0]] +\n                                   distance_matrix_2[segments[idx][-1], segments[idx+1][0]] +\n                                   distance_matrix_3[segments[idx][-1], segments[idx+1][0]])\n                    if right_contrib < 0:  # Only merge if it improves\n                        segments[idx] += segments[idx+1]\n                        segments.pop(idx+1)\n            else:\n                # Reverse segment with multi-objective consideration\n                original_contrib = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                     distance_matrix_3[new_solution[i-1], new_solution[i]]\n                                     for i in range(len(segments[idx])))\n                reversed_contrib = sum(distance_matrix_1[segments[idx][i], segments[idx][i+1]] +\n                                      distance_matrix_2[segments[idx][i], segments[idx][i+1]] +\n                                      distance_matrix_3[segments[idx][i], segments[idx][i+1]]\n                                      for i in range(len(segments[idx])-1))\n                if reversed_contrib < original_contrib:  # Only reverse if it improves\n                    segments[idx] = segments[idx][::-1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The new algorithm employs a dynamic objective-aware tour partitioning strategy that first identifies critical nodes in each objective space by analyzing their contribution to the total cost, then selectively merges these nodes into contiguous segments while preserving their relative ordering across objectives, followed by a probabilistic segment inversion operation that flips segments in one of the objective spaces with a probability proportional to the segment's contribution to the total cost, and finally applies a multi-objective aware 3-opt local search that considers all three objectives simultaneously to further refine the solution while maintaining feasibility through a novel segment swapping mechanism that ensures no node is skipped or revisited.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical nodes in each objective space\n    critical_nodes = []\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find nodes with highest contribution to the objective\n        node_contribs = []\n        for i in range(n):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[(i+1)%n]\n            contrib = dist_matrix[prev_node, new_solution[i]] + dist_matrix[new_solution[i], next_node]\n            node_contribs.append(contrib)\n        critical_nodes.append(np.argsort(node_contribs)[-n//3:])\n\n    # Merge critical nodes into contiguous segments\n    segments = []\n    used_nodes = set()\n    for obj_nodes in critical_nodes:\n        segment = []\n        for node in obj_nodes:\n            if node not in used_nodes:\n                segment.append(node)\n                used_nodes.add(node)\n        if segment:\n            segments.append(segment)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in used_nodes]\n    if remaining_nodes:\n        segments.append(remaining_nodes)\n\n    # Reconstruct solution with segments\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.4:  # 40% chance to invert\n        # Select objective space and segment\n        obj_space = np.random.randint(3)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find segment with highest contribution in the selected space\n        max_contrib = -1\n        best_seg_idx = 0\n        for i in range(len(segments)):\n            seg_contrib = sum(dist_matrix[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n            if seg_contrib > max_contrib:\n                max_contrib = seg_contrib\n                best_seg_idx = i\n\n        # Invert segment with probability proportional to contribution\n        if np.random.rand() < (max_contrib / np.max([distance_matrix_1.max(), distance_matrix_2.max(), distance_matrix_3.max()])):\n            segments[best_seg_idx] = segments[best_seg_idx][::-1]\n            new_solution = np.concatenate(segments)\n\n    # Multi-objective aware 3-opt local search\n    for _ in range(15):  # Perform 15 iterations\n        # Select three distinct positions\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate original cost\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        prev_j = new_solution[j-1]\n        prev_k = new_solution[k-1]\n        next_i = new_solution[i]\n        next_j = new_solution[j]\n        next_k = new_solution[(k+1)%n]\n\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j] +\n                    distance_matrix_1[prev_k, next_k] + distance_matrix_2[prev_k, next_k] + distance_matrix_3[prev_k, next_k])\n\n        # Calculate new cost for all possible 3-opt moves\n        # Move 1: Reverse segment i to j\n        rev_ij = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                 distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        # Move 2: Reverse segment j to k\n        rev_jk = (distance_matrix_1[prev_j, prev_k] + distance_matrix_2[prev_j, prev_k] + distance_matrix_3[prev_j, prev_k] +\n                 distance_matrix_1[next_j, next_k] + distance_matrix_2[next_j, next_k] + distance_matrix_3[next_j, next_k])\n\n        # Move 3: Reverse segment i to k\n        rev_ik = (distance_matrix_1[prev_i, prev_k] + distance_matrix_2[prev_i, prev_k] + distance_matrix_3[prev_i, prev_k] +\n                 distance_matrix_1[next_i, next_k] + distance_matrix_2[next_i, next_k] + distance_matrix_3[next_i, next_k])\n\n        # Select best move if it improves the solution\n        best_move = min(rev_ij, rev_jk, rev_ik)\n        if best_move < orig_cost and np.random.rand() < 0.6:  # 60% chance to accept if beneficial\n            if best_move == rev_ij:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif best_move == rev_jk:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.755054928515058,
               3.133277726173401
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical nodes in each objective space\n    critical_nodes = []\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find nodes with highest contribution to the objective\n        node_contribs = []\n        for i in range(n):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[(i+1)%n]\n            contrib = dist_matrix[prev_node, new_solution[i]] + dist_matrix[new_solution[i], next_node]\n            node_contribs.append(contrib)\n        critical_nodes.append(np.argsort(node_contribs)[-n//3:])\n\n    # Merge critical nodes into contiguous segments\n    segments = []\n    used_nodes = set()\n    for obj_nodes in critical_nodes:\n        segment = []\n        for node in obj_nodes:\n            if node not in used_nodes:\n                segment.append(node)\n                used_nodes.add(node)\n        if segment:\n            segments.append(segment)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in used_nodes]\n    if remaining_nodes:\n        segments.append(remaining_nodes)\n\n    # Reconstruct solution with segments\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.4:  # 40% chance to invert\n        # Select objective space and segment\n        obj_space = np.random.randint(3)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find segment with highest contribution in the selected space\n        max_contrib = -1\n        best_seg_idx = 0\n        for i in range(len(segments)):\n            seg_contrib = sum(dist_matrix[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n            if seg_contrib > max_contrib:\n                max_contrib = seg_contrib\n                best_seg_idx = i\n\n        # Invert segment with probability proportional to contribution\n        if np.random.rand() < (max_contrib / np.max([distance_matrix_1.max(), distance_matrix_2.max(), distance_matrix_3.max()])):\n            segments[best_seg_idx] = segments[best_seg_idx][::-1]\n            new_solution = np.concatenate(segments)\n\n    # Multi-objective aware 3-opt local search\n    for _ in range(15):  # Perform 15 iterations\n        # Select three distinct positions\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate original cost\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        prev_j = new_solution[j-1]\n        prev_k = new_solution[k-1]\n        next_i = new_solution[i]\n        next_j = new_solution[j]\n        next_k = new_solution[(k+1)%n]\n\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j] +\n                    distance_matrix_1[prev_k, next_k] + distance_matrix_2[prev_k, next_k] + distance_matrix_3[prev_k, next_k])\n\n        # Calculate new cost for all possible 3-opt moves\n        # Move 1: Reverse segment i to j\n        rev_ij = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                 distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        # Move 2: Reverse segment j to k\n        rev_jk = (distance_matrix_1[prev_j, prev_k] + distance_matrix_2[prev_j, prev_k] + distance_matrix_3[prev_j, prev_k] +\n                 distance_matrix_1[next_j, next_k] + distance_matrix_2[next_j, next_k] + distance_matrix_3[next_j, next_k])\n\n        # Move 3: Reverse segment i to k\n        rev_ik = (distance_matrix_1[prev_i, prev_k] + distance_matrix_2[prev_i, prev_k] + distance_matrix_3[prev_i, prev_k] +\n                 distance_matrix_1[next_i, next_k] + distance_matrix_2[next_i, next_k] + distance_matrix_3[next_i, next_k])\n\n        # Select best move if it improves the solution\n        best_move = min(rev_ij, rev_jk, rev_ik)\n        if best_move < orig_cost and np.random.rand() < 0.6:  # 60% chance to accept if beneficial\n            if best_move == rev_ij:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif best_move == rev_jk:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Create clusters based on combined distance in all three objectives\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined distance to previous node in all three spaces\n        combined_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]])\n\n        # Decide whether to start new cluster (probability based on inverse distance)\n        if np.random.rand() < 1 / (1 + combined_dist):\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n        else:\n            current_cluster.append(new_solution[i])\n    clusters.append(current_cluster)\n\n    # Cluster-based mutation: reinsert clusters at different positions\n    if len(clusters) > 1 and np.random.rand() < 0.5:\n        # Select two clusters to swap\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        # Remove both clusters\n        cluster_i = clusters.pop(max(i, j))\n        cluster_j = clusters.pop(min(i, j))\n        # Insert them at new positions\n        insert_pos = np.random.randint(len(clusters) + 1)\n        clusters.insert(insert_pos, cluster_j)\n        clusters.insert(insert_pos + 1, cluster_i)\n\n    # Probabilistic cluster inversion in one objective space\n    if np.random.rand() < 0.4:  # 40% chance to invert\n        cluster_idx = np.random.randint(len(clusters))\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes in the cluster with high distance in the selected space\n        cluster = clusters[cluster_idx]\n        if len(cluster) > 1:\n            max_dist = -1\n            best_pair = (0, 1)\n            for i in range(len(cluster)):\n                for j in range(i+1, len(cluster)):\n                    dist = dist_matrix[cluster[i], cluster[j]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_pair = (i, j)\n            i, j = best_pair\n            cluster[i], cluster[j] = cluster[j], cluster[i]\n\n    # Multi-objective aware cluster relocation\n    for _ in range(5):  # Perform 5 iterations\n        if len(clusters) > 1:\n            # Select a random cluster and a random position to move it to\n            cluster_idx = np.random.randint(len(clusters))\n            new_pos = np.random.randint(len(clusters) - 1)\n\n            # Calculate cost change for all three objectives\n            original_cost = 0\n            for c in range(len(clusters)):\n                if c > 0:\n                    original_cost += (distance_matrix_1[clusters[c-1][-1], clusters[c][0]] +\n                                     distance_matrix_2[clusters[c-1][-1], clusters[c][0]] +\n                                     distance_matrix_3[clusters[c-1][-1], clusters[c][0]])\n            if len(clusters) > 1:\n                original_cost += (distance_matrix_1[clusters[-1][-1], clusters[0][0]] +\n                                distance_matrix_2[clusters[-1][-1], clusters[0][0]] +\n                                distance_matrix_3[clusters[-1][-1], clusters[0][0]])\n\n            # Create new cluster order\n            new_clusters = clusters[:]\n            moved_cluster = new_clusters.pop(cluster_idx)\n            new_clusters.insert(new_pos, moved_cluster)\n\n            # Calculate new cost\n            new_cost = 0\n            for c in range(len(new_clusters)):\n                if c > 0:\n                    new_cost += (distance_matrix_1[new_clusters[c-1][-1], new_clusters[c][0]] +\n                                distance_matrix_2[new_clusters[c-1][-1], new_clusters[c][0]] +\n                                distance_matrix_3[new_clusters[c-1][-1], new_clusters[c][0]])\n            if len(new_clusters) > 1:\n                new_cost += (distance_matrix_1[new_clusters[-1][-1], new_clusters[0][0]] +\n                            distance_matrix_2[new_clusters[-1][-1], new_clusters[0][0]] +\n                            distance_matrix_3[new_clusters[-1][-1], new_clusters[0][0]])\n\n            if new_cost < original_cost and np.random.rand() < 0.6:  # 60% chance to accept if beneficial\n                clusters = new_clusters\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7352800564011017,
               2.7214432835578917
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Create clusters based on combined distance in all three objectives\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined distance to previous node in all three spaces\n        combined_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]])\n\n        # Decide whether to start new cluster (probability based on inverse distance)\n        if np.random.rand() < 1 / (1 + combined_dist):\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n        else:\n            current_cluster.append(new_solution[i])\n    clusters.append(current_cluster)\n\n    # Cluster-based mutation: reinsert clusters at different positions\n    if len(clusters) > 1 and np.random.rand() < 0.5:\n        # Select two clusters to swap\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        # Remove both clusters\n        cluster_i = clusters.pop(max(i, j))\n        cluster_j = clusters.pop(min(i, j))\n        # Insert them at new positions\n        insert_pos = np.random.randint(len(clusters) + 1)\n        clusters.insert(insert_pos, cluster_j)\n        clusters.insert(insert_pos + 1, cluster_i)\n\n    # Probabilistic cluster inversion in one objective space\n    if np.random.rand() < 0.4:  # 40% chance to invert\n        cluster_idx = np.random.randint(len(clusters))\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes in the cluster with high distance in the selected space\n        cluster = clusters[cluster_idx]\n        if len(cluster) > 1:\n            max_dist = -1\n            best_pair = (0, 1)\n            for i in range(len(cluster)):\n                for j in range(i+1, len(cluster)):\n                    dist = dist_matrix[cluster[i], cluster[j]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_pair = (i, j)\n            i, j = best_pair\n            cluster[i], cluster[j] = cluster[j], cluster[i]\n\n    # Multi-objective aware cluster relocation\n    for _ in range(5):  # Perform 5 iterations\n        if len(clusters) > 1:\n            # Select a random cluster and a random position to move it to\n            cluster_idx = np.random.randint(len(clusters))\n            new_pos = np.random.randint(len(clusters) - 1)\n\n            # Calculate cost change for all three objectives\n            original_cost = 0\n            for c in range(len(clusters)):\n                if c > 0:\n                    original_cost += (distance_matrix_1[clusters[c-1][-1], clusters[c][0]] +\n                                     distance_matrix_2[clusters[c-1][-1], clusters[c][0]] +\n                                     distance_matrix_3[clusters[c-1][-1], clusters[c][0]])\n            if len(clusters) > 1:\n                original_cost += (distance_matrix_1[clusters[-1][-1], clusters[0][0]] +\n                                distance_matrix_2[clusters[-1][-1], clusters[0][0]] +\n                                distance_matrix_3[clusters[-1][-1], clusters[0][0]])\n\n            # Create new cluster order\n            new_clusters = clusters[:]\n            moved_cluster = new_clusters.pop(cluster_idx)\n            new_clusters.insert(new_pos, moved_cluster)\n\n            # Calculate new cost\n            new_cost = 0\n            for c in range(len(new_clusters)):\n                if c > 0:\n                    new_cost += (distance_matrix_1[new_clusters[c-1][-1], new_clusters[c][0]] +\n                                distance_matrix_2[new_clusters[c-1][-1], new_clusters[c][0]] +\n                                distance_matrix_3[new_clusters[c-1][-1], new_clusters[c][0]])\n            if len(new_clusters) > 1:\n                new_cost += (distance_matrix_1[new_clusters[-1][-1], new_clusters[0][0]] +\n                            distance_matrix_2[new_clusters[-1][-1], new_clusters[0][0]] +\n                            distance_matrix_3[new_clusters[-1][-1], new_clusters[0][0]])\n\n            if new_cost < original_cost and np.random.rand() < 0.6:  # 60% chance to accept if beneficial\n                clusters = new_clusters\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate combined improvement\n        combined_improvement = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj1_cost + obj2_cost + obj3_cost)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj1_cost + obj2_cost + obj3_cost) / 3\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": "{The new algorithm introduces a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality, and uses a dynamic weight adjustment mechanism that adapts the importance of each objective based on the current solution's performance, allowing for more effective exploration of the Pareto front.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weight adjustment based on current solution's performance\n    obj_weights = [1.0, 1.0, 1.0]\n    if len(archive) > 1:\n        avg_obj = np.mean([obj for _, obj in archive], axis=0)\n        current_obj = archive[selected_idx][1]\n        for i in range(3):\n            if current_obj[i] > avg_obj[i]:\n                obj_weights[i] *= 1.2\n            else:\n                obj_weights[i] *= 0.8\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate weighted combined improvement\n        combined_improvement = (obj_weights[0] * obj1_improvement +\n                               obj_weights[1] * obj2_improvement +\n                               obj_weights[2] * obj3_improvement) / sum(obj_weights)\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj_weights[0] * obj1_cost +\n                            obj_weights[1] * obj2_cost +\n                            obj_weights[2] * obj3_cost) / sum(obj_weights)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj_weights[0] * obj1_cost +\n                         obj_weights[1] * obj2_cost +\n                         obj_weights[2] * obj3_cost) / sum(obj_weights)\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.6877546961849642,
               2.011621057987213
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weight adjustment based on current solution's performance\n    obj_weights = [1.0, 1.0, 1.0]\n    if len(archive) > 1:\n        avg_obj = np.mean([obj for _, obj in archive], axis=0)\n        current_obj = archive[selected_idx][1]\n        for i in range(3):\n            if current_obj[i] > avg_obj[i]:\n                obj_weights[i] *= 1.2\n            else:\n                obj_weights[i] *= 0.8\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate weighted combined improvement\n        combined_improvement = (obj_weights[0] * obj1_improvement +\n                               obj_weights[1] * obj2_improvement +\n                               obj_weights[2] * obj3_improvement) / sum(obj_weights)\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj_weights[0] * obj1_cost +\n                            obj_weights[1] * obj2_cost +\n                            obj_weights[2] * obj3_cost) / sum(obj_weights)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj_weights[0] * obj1_cost +\n                         obj_weights[1] * obj2_cost +\n                         obj_weights[2] * obj3_cost) / sum(obj_weights)\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective aware tour partitioning and reassembly strategy that first partitions the solution into three non-overlapping segments based on their contributions to each objective, then applies a novel objective-aware segment reordering operation that reorders these segments based on their relative importance across objectives, followed by a probabilistic segment inversion step that flips segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n    segment_weights = np.max(contributions, axis=1)  # Focus on segments with high max contribution\n    segment_weights = segment_weights / np.sum(segment_weights)\n\n    # Perform targeted segment inversions\n    for _ in range(3):\n        # Select segment with weighted probability\n        segment_idx = np.random.choice(n, p=segment_weights)\n        i, j = segment_idx, (segment_idx + 1) % n\n\n        # Invert the segment\n        if i < j:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j] = new_solution[:j][::-1]\n\n    # Relocate nodes to improve worst objective\n    worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(current_objectives, current_objectives)])\n    for _ in range(2):\n        # Select nodes from high-contribution segments\n        candidate_nodes = np.where(contributions[:, worst_obj_idx] > np.percentile(contributions[:, worst_obj_idx], 75))[0]\n        if len(candidate_nodes) > 0:\n            node_idx = np.random.choice(candidate_nodes)\n            node = new_solution[node_idx]\n            pos = np.random.randint(n)\n            if pos != node_idx:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, pos, node)\n\n    # Periodic diversification\n    if np.random.random() < 0.2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution hasn't been seen before\n    existing_solutions = [sol for sol, _ in archive]\n    while any(np.array_equal(new_solution, sol) for sol in existing_solutions):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 307,
          "algorithm": "{The new algorithm employs a multi-objective aware node swapping and insertion strategy that first identifies critical nodes based on their contributions to each objective, then performs a series of targeted node insertions and swaps that prioritize improving the worst-performing objective while maintaining balance across all three objectives, followed by a probabilistic node relocation step that moves nodes to positions that simultaneously improve multiple objectives, and finally applies a dynamic edge flipping operation that considers the trade-off between all three objectives to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate node contributions to each objective\n    def calculate_node_contributions(solution):\n        contributions = np.zeros((n, 3))\n        for i in range(n):\n            prev = solution[i-1]\n            curr = solution[i]\n            next_node = solution[(i+1)%n]\n            contributions[i, 0] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            contributions[i, 1] = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            contributions[i, 2] = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n        return contributions\n\n    contributions = calculate_node_contributions(new_solution)\n\n    # Identify critical nodes for each objective\n    worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(current_objectives, current_objectives)])\n    critical_nodes = np.where(contributions[:, worst_obj_idx] > np.percentile(contributions[:, worst_obj_idx], 75))[0]\n\n    # Perform targeted node swaps and insertions\n    for _ in range(3):\n        if len(critical_nodes) > 0:\n            node_idx = np.random.choice(critical_nodes)\n            node = new_solution[node_idx]\n\n            # Find insertion position that improves multiple objectives\n            best_pos = -1\n            best_score = -float('inf')\n            for pos in range(n):\n                if pos != node_idx:\n                    # Calculate potential improvement\n                    prev = new_solution[pos-1]\n                    next_node = new_solution[pos]\n                    current_cost = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] +\n                                   distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] +\n                                   distance_matrix_3[prev, node] + distance_matrix_3[node, next_node])\n\n                    original_prev = new_solution[node_idx-1]\n                    original_next = new_solution[(node_idx+1)%n]\n                    original_cost = (distance_matrix_1[original_prev, node] + distance_matrix_1[node, original_next] +\n                                    distance_matrix_2[original_prev, node] + distance_matrix_2[node, original_next] +\n                                    distance_matrix_3[original_prev, node] + distance_matrix_3[node, original_next])\n\n                    improvement = original_cost - current_cost\n                    if improvement > best_score:\n                        best_score = improvement\n                        best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic node relocation\n    if np.random.random() < 0.3:\n        for _ in range(2):\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find position that improves the worst objective\n            best_pos = -1\n            best_improvement = -float('inf')\n            for pos in range(n):\n                if pos != node_idx:\n                    prev = new_solution[pos-1]\n                    next_node = new_solution[pos]\n                    current_cost = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n                    original_prev = new_solution[node_idx-1]\n                    original_next = new_solution[(node_idx+1)%n]\n                    original_cost = distance_matrix_1[original_prev, node] + distance_matrix_1[node, original_next]\n                    improvement = original_cost - current_cost\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic edge flipping\n    if np.random.random() < 0.2:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 != j:\n                # Calculate trade-off score for flipping\n                original_cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                flipped_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                               distance_matrix_2[new_solution[i], new_solution[j]] +\n                               distance_matrix_3[new_solution[i], new_solution[j]] +\n                               distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] +\n                               distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] +\n                               distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n                if flipped_cost < original_cost:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure solution hasn't been seen before\n    existing_solutions = [sol for sol, _ in archive]\n    while any(np.array_equal(new_solution, sol) for sol in existing_solutions):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.7548171418552007,
               4.019280934333802
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate node contributions to each objective\n    def calculate_node_contributions(solution):\n        contributions = np.zeros((n, 3))\n        for i in range(n):\n            prev = solution[i-1]\n            curr = solution[i]\n            next_node = solution[(i+1)%n]\n            contributions[i, 0] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            contributions[i, 1] = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            contributions[i, 2] = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n        return contributions\n\n    contributions = calculate_node_contributions(new_solution)\n\n    # Identify critical nodes for each objective\n    worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(current_objectives, current_objectives)])\n    critical_nodes = np.where(contributions[:, worst_obj_idx] > np.percentile(contributions[:, worst_obj_idx], 75))[0]\n\n    # Perform targeted node swaps and insertions\n    for _ in range(3):\n        if len(critical_nodes) > 0:\n            node_idx = np.random.choice(critical_nodes)\n            node = new_solution[node_idx]\n\n            # Find insertion position that improves multiple objectives\n            best_pos = -1\n            best_score = -float('inf')\n            for pos in range(n):\n                if pos != node_idx:\n                    # Calculate potential improvement\n                    prev = new_solution[pos-1]\n                    next_node = new_solution[pos]\n                    current_cost = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] +\n                                   distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] +\n                                   distance_matrix_3[prev, node] + distance_matrix_3[node, next_node])\n\n                    original_prev = new_solution[node_idx-1]\n                    original_next = new_solution[(node_idx+1)%n]\n                    original_cost = (distance_matrix_1[original_prev, node] + distance_matrix_1[node, original_next] +\n                                    distance_matrix_2[original_prev, node] + distance_matrix_2[node, original_next] +\n                                    distance_matrix_3[original_prev, node] + distance_matrix_3[node, original_next])\n\n                    improvement = original_cost - current_cost\n                    if improvement > best_score:\n                        best_score = improvement\n                        best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic node relocation\n    if np.random.random() < 0.3:\n        for _ in range(2):\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find position that improves the worst objective\n            best_pos = -1\n            best_improvement = -float('inf')\n            for pos in range(n):\n                if pos != node_idx:\n                    prev = new_solution[pos-1]\n                    next_node = new_solution[pos]\n                    current_cost = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n                    original_prev = new_solution[node_idx-1]\n                    original_next = new_solution[(node_idx+1)%n]\n                    original_cost = distance_matrix_1[original_prev, node] + distance_matrix_1[node, original_next]\n                    improvement = original_cost - current_cost\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic edge flipping\n    if np.random.random() < 0.2:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 != j:\n                # Calculate trade-off score for flipping\n                original_cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                flipped_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                               distance_matrix_2[new_solution[i], new_solution[j]] +\n                               distance_matrix_3[new_solution[i], new_solution[j]] +\n                               distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] +\n                               distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] +\n                               distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n                if flipped_cost < original_cost:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure solution hasn't been seen before\n    existing_solutions = [sol for sol, _ in archive]\n    while any(np.array_equal(new_solution, sol) for sol in existing_solutions):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
     }
]