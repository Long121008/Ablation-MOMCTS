[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8061138255287508,
               1.0024596810340882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential (simplified example)\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)  # Simple heuristic\n        potential_scores.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Select three non-consecutive edges to swap (3-opt style)\n    i = np.random.randint(0, n-3)\n    j = np.random.randint(i+1, n-2)\n    k = np.random.randint(j+1, n-1)\n\n    # 2. Perform the swap while considering all three objectives\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = candidate1[i:j+1][::-1]\n    # Candidate 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k+1] = candidate2[j:k+1][::-1]\n    # Candidate 3: Reverse entire segment\n    candidate3 = new_solution.copy()\n    candidate3[i:k+1] = candidate3[i:k+1][::-1]\n    candidates = [candidate1, candidate2, candidate3]\n\n    # Evaluate candidates in all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost for all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7312398591023672,
               1.5018046021461486
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (simplified selection for this example)\n    # In practice, you would implement a more sophisticated selection mechanism\n    base_solution, _ = archive[np.random.randint(len(archive))]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with coordinate perturbation\n    n = len(new_solution)\n\n    # 2-opt local search\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Coordinate perturbation (randomly swap two nodes in one of the objective spaces)\n    space = np.random.randint(3)\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find two nodes with high distance in the selected space\n    node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n\n    # Swap these nodes in the solution\n    idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
          "score": [
               -0.7173722025420547,
               1.430956780910492
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    new_objectives = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try objective-aware swaps\n    if all(new_obj > old_obj for new_obj, old_obj in zip(new_objectives, objectives)):\n        # Find the worst objective to improve\n        worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(new_objectives, objectives)])\n\n        # Perform swaps to improve the worst objective\n        for _ in range(5):  # Try a few swaps\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_objectives = calculate_objective(temp_solution)\n\n            if temp_objectives[worst_obj_idx] < new_objectives[worst_obj_idx]:\n                new_solution = temp_solution\n                new_objectives = temp_objectives\n\n    return new_solution\n\n",
          "score": [
               -0.7112000903089013,
               1.101941978931427
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n",
          "score": [
               -0.7873491805548415,
               1.5758279323577882
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.mean(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swaps based on the worst-performing objective\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective space\n    max_cost = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        cost = dist_matrix[new_solution[i], new_solution[j]]\n        if cost > max_cost:\n            max_cost = cost\n            max_i, max_j = i, j\n\n    # Swap the nodes to reduce the worst objective cost\n    if max_i != max_j:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    return new_solution\n\n",
          "score": [
               -0.6414476807749279,
               1.4017594933509827
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Get the number of nodes\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt move)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Ensure i < j\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware edge selection\n    for _ in range(3):  # Try up to 3 times to find an improving swap\n        # Randomly select two edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a == b:\n            continue\n\n        # Calculate the current and new distances for all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_dist3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        new_dist3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Check if the swap improves at least one objective\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.5678252448903232,
               1.2791006445884705
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware segment inversion strategy that dynamically selects and inverts segments of the tour based on their contribution to each objective, using a weighted combination of objective-specific improvements. It first evaluates each segment's potential for improvement across all three objectives by calculating their weighted contributions, then probabilistically selects segments with high potential for inversion, and finally applies the inversion while ensuring feasibility by maintaining node uniqueness and tour continuity. The algorithm also incorporates a novel segment merging step that combines adjacent segments with complementary objective improvements to further enhance solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate weighted improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)  # Simple heuristic\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment improvement scores\n    segment_scores = []\n    for i in range(n-1):\n        # Calculate improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i], new_solution[i+1]] - \\\n                          (distance_matrix_1[new_solution[i], new_solution[(i+2)%n]] +\n                           distance_matrix_1[new_solution[(i+1)%n], new_solution[(i+3)%n]])\n\n        obj2_improvement = distance_matrix_2[new_solution[i], new_solution[i+1]] - \\\n                          (distance_matrix_2[new_solution[i], new_solution[(i+2)%n]] +\n                           distance_matrix_2[new_solution[(i+1)%n], new_solution[(i+3)%n]])\n\n        obj3_improvement = distance_matrix_3[new_solution[i], new_solution[i+1]] - \\\n                          (distance_matrix_3[new_solution[i], new_solution[(i+2)%n]] +\n                           distance_matrix_3[new_solution[(i+1)%n], new_solution[(i+3)%n]])\n\n        # Weighted score\n        total_score = obj1_improvement + obj2_improvement + obj3_improvement\n        segment_scores.append((i, total_score))\n\n    # Select segments with high improvement potential\n    segment_scores.sort(key=lambda x: -x[1])\n    selected_segments = [i for i, score in segment_scores[:max(1, len(segment_scores)//4)]]\n\n    # Apply segment inversion\n    for i in selected_segments:\n        # Invert the segment\n        j = (i + 2) % n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment merging step\n    if len(selected_segments) > 1:\n        # Find adjacent segments\n        selected_segments.sort()\n        merged_segments = []\n        current_start = selected_segments[0]\n\n        for i in range(1, len(selected_segments)):\n            if selected_segments[i] == selected_segments[i-1] + 1:\n                continue\n            else:\n                merged_segments.append((current_start, selected_segments[i-1]))\n                current_start = selected_segments[i]\n        merged_segments.append((current_start, selected_segments[-1]))\n\n        # Merge segments with complementary improvements\n        for start, end in merged_segments:\n            if end - start > 1:\n                # Calculate improvement for merged segment\n                obj1_improvement = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end+1)) - \\\n                                  (distance_matrix_1[new_solution[start], new_solution[end+1]] +\n                                   distance_matrix_1[new_solution[start], new_solution[end]])\n\n                obj2_improvement = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end+1)) - \\\n                                  (distance_matrix_2[new_solution[start], new_solution[end+1]] +\n                                   distance_matrix_2[new_solution[start], new_solution[end]])\n\n                obj3_improvement = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(start, end+1)) - \\\n                                  (distance_matrix_3[new_solution[start], new_solution[end+1]] +\n                                   distance_matrix_3[new_solution[start], new_solution[end]])\n\n                total_improvement = obj1_improvement + obj2_improvement + obj3_improvement\n\n                if total_improvement > 0:\n                    # Merge the segments\n                    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7072854970512357,
               1.90686274766922
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Multi-Objective Partial Reversal with Objective Weighting,\" selects a solution from the archive by first normalizing the objectives and then choosing the one with the highest weighted sum of normalized objectives, where weights are dynamically adjusted based on the current diversity of the archive. It then applies a partial reversal operation that selectively reverses a segment of the tour, prioritizing segments that improve the objectives with the highest weights. The algorithm also incorporates a probabilistic acceptance criterion that allows non-improving moves with a small probability to escape local optima, while ensuring feasibility by maintaining a valid TSP tour structure throughout all operations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate weights based on archive diversity\n    weights = 1.0 / (normalized_objectives.std(axis=0) + 1e-10)\n    weights /= weights.sum()\n\n    # Select solution with highest weighted sum of objectives\n    weighted_sums = (normalized_objectives * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using partial reversal with objective weighting\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random segment to reverse\n    segment_length = np.random.randint(2, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Calculate current and potential costs\n    current_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate[start:end] = candidate[start:end][::-1]\n\n    # Calculate candidate costs\n    candidate_costs = [\n        sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]],\n        sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]],\n        sum(distance_matrix_3[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n    ]\n\n    # Calculate improvement for each objective\n    improvements = [(current - candidate) for current, candidate in zip(current_costs, candidate_costs)]\n\n    # Calculate weighted improvement\n    weighted_improvement = sum(imp * w for imp, w in zip(improvements, weights))\n\n    # Accept if improvement is positive or with small probability\n    if weighted_improvement > 0 or np.random.random() < 0.1:\n        new_solution = candidate\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, perform a random valid move\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.7288693226778175,
               2.291697824001312
          ]
     },
     {
          "algorithm": "{The new algorithm will use a multi-objective aware selection strategy that prioritizes solutions with balanced objective improvements, combined with a novel \"objective-aware node relocation\" operator. It first identifies solutions in the archive that show diverse improvements across objectives, then selects one based on a weighted random selection favoring those with balanced objective contributions. The operator then relocates a node to a position that improves at least one objective while considering the trade-offs across all three objectives, using a greedy but objective-aware approach to ensure feasibility and potentially better Pareto dominance.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions based on objective diversity\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        diversity = (max(cost1, cost2, cost3) - min(cost1, cost2, cost3)) / (sum(objectives) + 1e-10)\n        evaluated_solutions.append((solution, diversity))\n\n    # Step 2: Select a solution with weighted randomness (favor diverse solutions)\n    weights = [1.0 / (diversity + 1e-10) for _, diversity in evaluated_solutions]\n    selected_idx = random.choices(range(len(evaluated_solutions)), weights=weights, k=1)[0]\n    base_solution = evaluated_solutions[selected_idx][0].copy()\n\n    # Step 3: Apply objective-aware node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n\n    # Find the best position to insert the node to improve at least one objective\n    best_pos = -1\n    best_improvement = [0, 0, 0]\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue\n\n        # Calculate the cost change for each objective\n        prev_node = new_solution[pos - 1]\n        next_node = new_solution[pos]\n\n        # Remove the node from its current position\n        current_cost1 = distance_matrix_1[new_solution[node_idx - 1], node] + distance_matrix_1[node, new_solution[(node_idx + 1) % n]]\n        new_cost1 = distance_matrix_1[new_solution[node_idx - 1], new_solution[(node_idx + 1) % n]]\n\n        current_cost2 = distance_matrix_2[new_solution[node_idx - 1], node] + distance_matrix_2[node, new_solution[(node_idx + 1) % n]]\n        new_cost2 = distance_matrix_2[new_solution[node_idx - 1], new_solution[(node_idx + 1) % n]]\n\n        current_cost3 = distance_matrix_3[new_solution[node_idx - 1], node] + distance_matrix_3[node, new_solution[(node_idx + 1) % n]]\n        new_cost3 = distance_matrix_3[new_solution[node_idx - 1], new_solution[(node_idx + 1) % n]]\n\n        # Insert the node at the new position\n        potential_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        potential_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        potential_cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Calculate the improvement\n        improvement1 = (new_cost1 - potential_cost1) if (new_cost1 - potential_cost1) > 0 else 0\n        improvement2 = (new_cost2 - potential_cost2) if (new_cost2 - potential_cost2) > 0 else 0\n        improvement3 = (new_cost3 - potential_cost3) if (new_cost3 - potential_cost3) > 0 else 0\n\n        # Check if at least one objective improves\n        if improvement1 > 0 or improvement2 > 0 or improvement3 > 0:\n            # Prioritize positions that improve multiple objectives\n            total_improvement = improvement1 + improvement2 + improvement3\n            if total_improvement > sum(best_improvement):\n                best_pos = pos\n                best_improvement = [improvement1, improvement2, improvement3]\n\n    # Apply the best relocation if found\n    if best_pos != -1:\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.7781533744341372,
               2.30068324804306
          ]
     }
]