[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8061138255287508,
               1.0024596810340882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential (simplified example)\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)  # Simple heuristic\n        potential_scores.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Select three non-consecutive edges to swap (3-opt style)\n    i = np.random.randint(0, n-3)\n    j = np.random.randint(i+1, n-2)\n    k = np.random.randint(j+1, n-1)\n\n    # 2. Perform the swap while considering all three objectives\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = candidate1[i:j+1][::-1]\n    # Candidate 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k+1] = candidate2[j:k+1][::-1]\n    # Candidate 3: Reverse entire segment\n    candidate3 = new_solution.copy()\n    candidate3[i:k+1] = candidate3[i:k+1][::-1]\n    candidates = [candidate1, candidate2, candidate3]\n\n    # Evaluate candidates in all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost for all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7312398591023672,
               1.5018046021461486
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (simplified selection for this example)\n    # In practice, you would implement a more sophisticated selection mechanism\n    base_solution, _ = archive[np.random.randint(len(archive))]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with coordinate perturbation\n    n = len(new_solution)\n\n    # 2-opt local search\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Coordinate perturbation (randomly swap two nodes in one of the objective spaces)\n    space = np.random.randint(3)\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find two nodes with high distance in the selected space\n    node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n\n    # Swap these nodes in the solution\n    idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
          "score": [
               -0.7173722025420547,
               1.430956780910492
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    new_objectives = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try objective-aware swaps\n    if all(new_obj > old_obj for new_obj, old_obj in zip(new_objectives, objectives)):\n        # Find the worst objective to improve\n        worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(new_objectives, objectives)])\n\n        # Perform swaps to improve the worst objective\n        for _ in range(5):  # Try a few swaps\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_objectives = calculate_objective(temp_solution)\n\n            if temp_objectives[worst_obj_idx] < new_objectives[worst_obj_idx]:\n                new_solution = temp_solution\n                new_objectives = temp_objectives\n\n    return new_solution\n\n",
          "score": [
               -0.7112000903089013,
               1.101941978931427
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n",
          "score": [
               -0.7873491805548415,
               1.5758279323577882
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.mean(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swaps based on the worst-performing objective\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective space\n    max_cost = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        cost = dist_matrix[new_solution[i], new_solution[j]]\n        if cost > max_cost:\n            max_cost = cost\n            max_i, max_j = i, j\n\n    # Swap the nodes to reduce the worst objective cost\n    if max_i != max_j:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    return new_solution\n\n",
          "score": [
               -0.6414476807749279,
               1.4017594933509827
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Get the number of nodes\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt move)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Ensure i < j\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware edge selection\n    for _ in range(3):  # Try up to 3 times to find an improving swap\n        # Randomly select two edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a == b:\n            continue\n\n        # Calculate the current and new distances for all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_dist3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        new_dist3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Check if the swap improves at least one objective\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.5678252448903232,
               1.2791006445884705
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search combining 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj = np.argmax(selected[1])\n    if worst_obj == 0:\n        dist_mat = distance_matrix_1\n    elif worst_obj == 1:\n        dist_mat = distance_matrix_2\n    else:\n        dist_mat = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        if dist_mat[u, v] > max_dist:\n            max_dist = dist_mat[u, v]\n            worst_edge = i\n\n    if worst_edge is not None:\n        # Try to reverse the segment between worst_edge and another point\n        for j in range(worst_edge + 2, n):\n            if j - worst_edge > 1:\n                new_sol = new_solution.copy()\n                new_sol[worst_edge + 1:j + 1] = new_sol[worst_edge + 1:j + 1][::-1]\n                # Check if this improves the worst objective\n                total = 0\n                for k in range(n):\n                    u = new_sol[k]\n                    v = new_sol[(k + 1) % n]\n                    total += dist_mat[u, v]\n                if total < max_dist:\n                    new_solution = new_sol\n                    break\n\n    # Then perform objective-aware swaps to improve other objectives\n    for _ in range(5):  # Limit the number of swaps to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential new objectives\n        current_obj = selected[1]\n        new_obj = list(current_obj)\n\n        # Calculate change in each objective\n        u1, u2 = new_solution[i], new_solution[(i + 1) % n]\n        v1, v2 = new_solution[j], new_solution[(j + 1) % n]\n\n        for k in range(3):\n            if k == 0:\n                mat = distance_matrix_1\n            elif k == 1:\n                mat = distance_matrix_2\n            else:\n                mat = distance_matrix_3\n\n            delta = (mat[v1, u1] + mat[v2, u2] + mat[u1, v2] + mat[u2, v1]) - (mat[u1, u2] + mat[v1, v2])\n            new_obj[k] = current_obj[k] + delta\n\n        # Accept if it improves at least one objective\n        if any(new_obj[k] < current_obj[k] for k in range(3)):\n            new_solution[i + 1:j + 1] = new_solution[i + 1:j + 1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.6579461619387963,
               2.055972135066986
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        # Normalize each objective component\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        normalized_objectives.append((sol, norm_obj))\n\n    # Sort solutions by the sum of normalized objectives in descending order\n    sorted_solutions = sorted(normalized_objectives, key=lambda x: sum(x[1]), reverse=True)\n\n    # Select the top 10% of solutions for further consideration\n    top_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 10)]\n\n    # Randomly select one solution from the top candidates\n    selected_sol, _ = random.choice(top_solutions)\n    base_solution = selected_sol.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment to perturb based on objective diversity\n    i, j = sorted(random.sample(range(n), 2))\n    segment = base_solution[i:j]\n\n    # Reverse the segment to create a 2-opt move\n    reversed_segment = segment[::-1]\n\n    # Reconstruct the solution\n    new_solution[i:j] = reversed_segment\n\n    # Further refine by selecting edges that are non-dominated in at least one objective space\n    for _ in range(5):  # Limited number of refinement steps\n        a, b = sorted(random.sample(range(n), 2))\n        edge_a = (new_solution[a], new_solution[(a+1)%n])\n        edge_b = (new_solution[b], new_solution[(b+1)%n])\n\n        # Check if swapping these edges would improve at least one objective\n        new_edge1 = (new_solution[a], new_solution[b])\n        new_edge2 = (new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        # Calculate the change in objectives\n        delta_obj1 = (distance_matrix_1[new_edge1[0], new_edge1[1]] + distance_matrix_1[new_edge2[0], new_edge2[1]] -\n                     (distance_matrix_1[edge_a[0], edge_a[1]] + distance_matrix_1[edge_b[0], edge_b[1]]))\n        delta_obj2 = (distance_matrix_2[new_edge1[0], new_edge1[1]] + distance_matrix_2[new_edge2[0], new_edge2[1]] -\n                     (distance_matrix_2[edge_a[0], edge_a[1]] + distance_matrix_2[edge_b[0], edge_b[1]]))\n        delta_obj3 = (distance_matrix_3[new_edge1[0], new_edge1[1]] + distance_matrix_3[new_edge2[0], new_edge2[1]] -\n                     (distance_matrix_3[edge_a[0], edge_a[1]] + distance_matrix_3[edge_b[0], edge_b[1]]))\n\n        # If at least one objective improves, perform the swap\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Perform the 2-opt swap\n            new_solution[a+1:b+1] = new_solution[b:a:-1]\n\n    return new_solution\n\n",
          "score": [
               -0.7434372016362242,
               2.970485007762909
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each objective\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        objectives_sorted = [objectives[j] for j in sorted_indices]\n\n        max_obj = max(obj[i] for obj in objectives)\n        min_obj = min(obj[i] for obj in objectives)\n\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n\n        for j in range(1, len(archive)-1):\n            if max_obj == min_obj:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives_sorted[j+1][i] - objectives_sorted[j-1][i]) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance (most promising)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using tri-objective 2.5-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to break\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = (j + 1) % n\n\n    # Find best insertion point considering all three objectives\n    best_insert_pos = -1\n    best_total_cost = float('inf')\n\n    for m in range(i+1, j):\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:k],\n            new_solution[i+1:j],\n            new_solution[k:]\n        ])\n\n        # Calculate total cost for candidate\n        total_cost = 0\n        for l in range(n-1):\n            total_cost += (distance_matrix_1[candidate[l], candidate[l+1]] +\n                          distance_matrix_2[candidate[l], candidate[l+1]] +\n                          distance_matrix_3[candidate[l], candidate[l+1]])\n        total_cost += (distance_matrix_1[candidate[-1], candidate[0]] +\n                      distance_matrix_2[candidate[-1], candidate[0]] +\n                      distance_matrix_3[candidate[-1], candidate[0]])\n\n        if total_cost < best_total_cost:\n            best_total_cost = total_cost\n            best_insert_pos = m\n\n    if best_insert_pos != -1:\n        # Apply the best move\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:k],\n            new_solution[i+1:j],\n            new_solution[k:]\n        ])\n\n    # Verify solution is valid\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, fall back to standard 2-opt\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.48806591526785414,
               3.035669040679932
          ]
     }
]