[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8061138255287508,
               1.0024596810340882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions\n    segment_contributions = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        contrib = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i-1], new_solution[i]])\n        if contrib > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segment_contributions.append((current_segment, contrib))\n            current_segment = [new_solution[i]]\n    segment_contributions.append((current_segment, 0))\n\n    # Probabilistically select segments to fuse or reverse\n    segments = [seg for seg, _ in segment_contributions]\n    if len(segments) > 1:\n        # Calculate dynamic fusion probability based on solution quality\n        avg_contrib = np.mean([abs(contrib) for _, contrib in segment_contributions])\n        fusion_prob = min(0.8, 0.2 + avg_contrib / 100)  # Cap at 0.8\n\n        # Select segments with high contribution\n        weights = [abs(contrib) for seg, contrib in segment_contributions]\n        weights = np.array(weights) + 1e-6  # Avoid zero weights\n        weights = weights / np.sum(weights)\n\n        # Select segments to process\n        num_to_process = min(3, len(segments))\n        selected_indices = np.random.choice(len(segments), size=num_to_process, replace=False, p=weights)\n\n        for idx in selected_indices:\n            if np.random.rand() < fusion_prob:  # Dynamic fusion probability\n                # Adaptive segment fusion with objective-aware merging\n                if idx > 0 and np.random.rand() < 0.5:\n                    # Merge with left segment if it reduces combined objective\n                    left_contrib = (distance_matrix_1[segments[idx-1][-1], segments[idx][0]] +\n                                  distance_matrix_2[segments[idx-1][-1], segments[idx][0]] +\n                                  distance_matrix_3[segments[idx-1][-1], segments[idx][0]])\n                    if left_contrib < 0:  # Only merge if it improves\n                        segments[idx-1] += segments[idx]\n                        segments.pop(idx)\n                elif idx < len(segments)-1:\n                    # Merge with right segment if it reduces combined objective\n                    right_contrib = (distance_matrix_1[segments[idx][-1], segments[idx+1][0]] +\n                                   distance_matrix_2[segments[idx][-1], segments[idx+1][0]] +\n                                   distance_matrix_3[segments[idx][-1], segments[idx+1][0]])\n                    if right_contrib < 0:  # Only merge if it improves\n                        segments[idx] += segments[idx+1]\n                        segments.pop(idx+1)\n            else:\n                # Reverse segment with multi-objective consideration\n                original_contrib = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                     distance_matrix_3[new_solution[i-1], new_solution[i]]\n                                     for i in range(len(segments[idx])))\n                reversed_contrib = sum(distance_matrix_1[segments[idx][i], segments[idx][i+1]] +\n                                      distance_matrix_2[segments[idx][i], segments[idx][i+1]] +\n                                      distance_matrix_3[segments[idx][i], segments[idx][i+1]]\n                                      for i in range(len(segments[idx])-1))\n                if reversed_contrib < original_contrib:  # Only reverse if it improves\n                    segments[idx] = segments[idx][::-1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.8094047134529673,
               1.5946277260780335
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.8116772616735375,
               2.1658200144767763
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.877696552449559,
               2.4248651266098022
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate combined improvement\n        combined_improvement = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj1_cost + obj2_cost + obj3_cost)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj1_cost + obj2_cost + obj3_cost) / 3\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7142097964801128,
               1.0437695622444152
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n",
          "score": [
               -0.7873491805548415,
               1.5758279323577882
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partition into three sub-tours (one for each objective)\n    sub_tour1 = new_solution[:n//3]\n    sub_tour2 = new_solution[n//3:2*n//3]\n    sub_tour3 = new_solution[2*n//3:]\n\n    # Objective-aware crossover: merge segments from different sub-tours\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Randomly select which sub-tour to take segment from\n        source = np.random.randint(3)\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion in one objective space\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        space = np.random.randint(3)\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Multi-objective aware 2-opt local search\n    for _ in range(10):  # Perform 10 iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        if rev_cost < orig_cost and np.random.rand() < 0.7:  # 70% chance to accept if beneficial\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.8077600415434022,
               2.113534188270569
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware tour reconstruction strategy that dynamically partitions the solution into three separate sub-tours, each optimized for one of the objectives, then selectively merges these sub-tours using a novel objective-aware crossover operation that combines segments from different sub-tours while maintaining feasibility, followed by a probabilistic segment inversion step that flips segments in one of the objective spaces to introduce diversity, and finally applies a multi-objective aware 2-opt local search that considers all three objectives simultaneously to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic partitioning based on objective dominance\n    objectives = [archive[i][1] for i in range(len(archive))]\n    obj1, obj2, obj3 = zip(*objectives)\n    obj1_mean, obj2_mean, obj3_mean = np.mean(obj1), np.mean(obj2), np.mean(obj3)\n\n    # Determine which objective to prioritize\n    dominant_obj = np.argmin([obj1_mean, obj2_mean, obj3_mean])\n\n    # Partition into three sub-tours based on dominant objective\n    if dominant_obj == 0:\n        sub_tour1 = new_solution[:n//3]\n        sub_tour2 = new_solution[n//3:2*n//3]\n        sub_tour3 = new_solution[2*n//3:]\n    elif dominant_obj == 1:\n        sub_tour1 = new_solution[:n//4]\n        sub_tour2 = new_solution[n//4:3*n//4]\n        sub_tour3 = new_solution[3*n//4:]\n    else:\n        sub_tour1 = new_solution[:n//2]\n        sub_tour2 = new_solution[n//2:3*n//4]\n        sub_tour3 = new_solution[3*n//4:]\n\n    # Objective-aware crossover with probabilistic selection\n    merged = []\n    for i in range(len(sub_tour1)):\n        # Higher probability to select from dominant objective\n        if np.random.rand() < 0.6:\n            source = dominant_obj\n        else:\n            source = np.random.randint(3)\n\n        if source == 0 and i < len(sub_tour1):\n            merged.append(sub_tour1[i])\n        elif source == 1 and i < len(sub_tour2):\n            merged.append(sub_tour2[i])\n        elif source == 2 and i < len(sub_tour3):\n            merged.append(sub_tour3[i])\n\n    # Fill remaining positions with remaining nodes\n    remaining_nodes = [node for node in new_solution if node not in merged]\n    merged.extend(remaining_nodes)\n    new_solution = np.array(merged)\n\n    # Probabilistic segment inversion with objective-specific logic\n    if np.random.rand() < 0.4:\n        # Select space based on least improved objective\n        obj_improvement = [obj1_mean - archive[selected_idx][1][0],\n                          obj2_mean - archive[selected_idx][1][1],\n                          obj3_mean - archive[selected_idx][1][2]]\n        space = np.argmax(obj_improvement)\n\n        if space == 0:\n            dist_matrix = distance_matrix_1\n        elif space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find two nodes with high distance in the selected space\n        node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n        idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        new_solution[idx1:idx2+1] = new_solution[idx1:idx2+1][::-1]\n\n    # Enhanced multi-objective aware 2-opt local search\n    for _ in range(15):  # More iterations for better refinement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for all three objectives\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j]\n        next_j = new_solution[(j+1)%n]\n\n        # Original cost\n        orig_cost = (distance_matrix_1[prev_i, next_i] + distance_matrix_2[prev_i, next_i] + distance_matrix_3[prev_i, next_i] +\n                    distance_matrix_1[prev_j, next_j] + distance_matrix_2[prev_j, next_j] + distance_matrix_3[prev_j, next_j])\n\n        # Reversed cost\n        rev_cost = (distance_matrix_1[prev_i, prev_j] + distance_matrix_2[prev_i, prev_j] + distance_matrix_3[prev_i, prev_j] +\n                   distance_matrix_1[next_i, next_j] + distance_matrix_2[next_i, next_j] + distance_matrix_3[next_i, next_j])\n\n        # More aggressive acceptance\n        if rev_cost < orig_cost and np.random.rand() < 0.8:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.83574391133461,
               2.654473125934601
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate combined improvement\n        combined_improvement = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj1_cost + obj2_cost + obj3_cost)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj1_cost + obj2_cost + obj3_cost) / 3\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.6936319386676534,
               1.6603838324546814
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware tour partitioning and reassembly strategy that first partitions the solution into three non-overlapping segments based on their contributions to each objective, then applies a novel objective-aware segment reordering operation that reorders these segments based on their relative importance across objectives, followed by a probabilistic segment inversion step that flips segments in a randomly selected objective space to introduce diversity, and finally applies a multi-objective aware edge exchange operation that considers all three objectives simultaneously to further refine the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment contributions to each objective\n    def calculate_segment_contributions(solution):\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            contributions.append((\n                distance_matrix_1[solution[i], solution[j]],\n                distance_matrix_2[solution[i], solution[j]],\n                distance_matrix_3[solution[i], solution[j]]\n            ))\n        return np.array(contributions)\n\n    contributions = calculate_segment_contributions(new_solution)\n    segment_weights = np.max(contributions, axis=1)  # Focus on segments with high max contribution\n    segment_weights = segment_weights / np.sum(segment_weights)\n\n    # Perform targeted segment inversions\n    for _ in range(3):\n        # Select segment with weighted probability\n        segment_idx = np.random.choice(n, p=segment_weights)\n        i, j = segment_idx, (segment_idx + 1) % n\n\n        # Invert the segment\n        if i < j:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j] = new_solution[:j][::-1]\n\n    # Relocate nodes to improve worst objective\n    worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(current_objectives, current_objectives)])\n    for _ in range(2):\n        # Select nodes from high-contribution segments\n        candidate_nodes = np.where(contributions[:, worst_obj_idx] > np.percentile(contributions[:, worst_obj_idx], 75))[0]\n        if len(candidate_nodes) > 0:\n            node_idx = np.random.choice(candidate_nodes)\n            node = new_solution[node_idx]\n            pos = np.random.randint(n)\n            if pos != node_idx:\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, pos, node)\n\n    # Periodic diversification\n    if np.random.random() < 0.2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution hasn't been seen before\n    existing_solutions = [sol for sol, _ in archive]\n    while any(np.array_equal(new_solution, sol) for sol in existing_solutions):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8207116036133671,
               4.1280186653137205
          ]
     }
]