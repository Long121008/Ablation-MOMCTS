[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8061138255287508,
               1.0024596810340882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with adaptive weighting\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    diversity = np.mean(normalized, axis=1)\n    weights = 1.0 / (diversity + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Determine strategy weights based on current performance\n    current_costs = archive[selected_idx][1]\n    total_cost = sum(current_costs)\n    strategy_weights = [cost / total_cost for cost in current_costs] if total_cost > 0 else [1/3, 1/3, 1/3]\n\n    # Step 3: Apply adaptive perturbation sequence\n    for _ in range(3):  # Try up to 3 strategies\n        strategy = np.random.choice(['insert', 'reverse', 'rotate'], p=strategy_weights)\n\n        if strategy == 'insert':\n            # Node insertion with objective-aware selection\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        elif strategy == 'reverse':\n            # Edge reversal with cost improvement check\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif strategy == 'rotate':\n            # Block rotation with objective balance\n            i, j, k = np.random.choice(n, size=3, replace=False)\n            i, j, k = sorted([i, j, k])\n            block = new_solution[i:j+1]\n            rotated = np.roll(block, k-i)\n            new_solution[i:j+1] = rotated\n\n    return new_solution\n\n",
          "score": [
               -0.8070791224378311,
               2.4406472206115724
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (simplified selection for this example)\n    # In practice, you would implement a more sophisticated selection mechanism\n    base_solution, _ = archive[np.random.randint(len(archive))]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with coordinate perturbation\n    n = len(new_solution)\n\n    # 2-opt local search\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Coordinate perturbation (randomly swap two nodes in one of the objective spaces)\n    space = np.random.randint(3)\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find two nodes with high distance in the selected space\n    node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n\n    # Swap these nodes in the solution\n    idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
          "score": [
               -0.7173722025420547,
               1.430956780910492
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n",
          "score": [
               -0.7873491805548415,
               1.5758279323577882
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate combined improvement\n        combined_improvement = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj1_cost + obj2_cost + obj3_cost)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj1_cost + obj2_cost + obj3_cost) / 3\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7142097964801128,
               1.0437695622444152
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective-aware segment-based reconstruction strategy that first identifies critical path segments by evaluating their contribution to each objective, then dynamically reconstructs the tour by selectively reversing these segments in a probabilistic manner while incorporating a novel segment swapping mechanism that ensures feasibility through node uniqueness verification and tour continuity maintenance. The algorithm prioritizes segments with high potential improvement across all objectives, uses a weighted random selection process to determine reversal candidates, and applies a segment swapping operation that exchanges entire segments between positions to create novel solution structures while preserving tour validity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments for each objective\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        if (obj1_improvement + obj2_improvement + obj3_improvement) > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Select segments for swapping based on their contribution\n    if len(segments) > 1:\n        segment_indices = list(range(len(segments)))\n        selected_indices = np.random.choice(segment_indices, size=min(3, len(segment_indices)), replace=False)\n\n        # Swap segments between positions\n        for i in range(len(selected_indices)-1):\n            idx1, idx2 = selected_indices[i], selected_indices[i+1]\n            segments[idx1], segments[idx2] = segments[idx2], segments[idx1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7429021976684232,
               1.476397955417633
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    new_objectives = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try objective-aware swaps\n    if all(new_obj > old_obj for new_obj, old_obj in zip(new_objectives, objectives)):\n        # Find the worst objective to improve\n        worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(new_objectives, objectives)])\n\n        # Perform swaps to improve the worst objective\n        for _ in range(5):  # Try a few swaps\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_objectives = calculate_objective(temp_solution)\n\n            if temp_objectives[worst_obj_idx] < new_objectives[worst_obj_idx]:\n                new_solution = temp_solution\n                new_objectives = temp_objectives\n\n    return new_solution\n\n",
          "score": [
               -0.7112000903089013,
               1.101941978931427
          ]
     },
     {
          "algorithm": "{The new algorithm will combine the selection strategy of favoring solutions with high potential improvement (from Algorithm 1) with a novel multi-objective local search operator that performs a weighted combination of edge swaps across all three objectives, where the weights are dynamically adjusted based on the current solution's performance in each objective space. The selection process will use a diversity-aware approach that considers both the solution's objective values and their spatial distribution in the objective space, ensuring that the chosen solution has the potential for significant improvement in at least one objective while maintaining diversity in the search process. The local search will then perform a series of edge swaps that simultaneously consider all three objectives, with the probability of selecting a swap being proportional to its potential improvement in the weighted combination of objectives, while ensuring that the solution remains feasible and that the search explores different regions of the solution space to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive with diversity consideration\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        # Normalize objectives for diversity consideration\n        norm_cost1 = cost1 / (cost1 + cost2 + cost3) if (cost1 + cost2 + cost3) > 0 else 0\n        norm_cost2 = cost2 / (cost1 + cost2 + cost3) if (cost1 + cost2 + cost3) > 0 else 0\n        norm_cost3 = cost3 / (cost1 + cost2 + cost3) if (cost1 + cost2 + cost3) > 0 else 0\n        # Calculate diversity score based on normalized objectives\n        diversity_score = norm_cost1 * norm_cost2 * norm_cost3\n        evaluated_solutions.append((solution, objectives, diversity_score))\n\n    # Step 2: Select a solution with weighted randomness considering both cost and diversity\n    weights = []\n    for _, (cost1, cost2, cost3), diversity_score in evaluated_solutions:\n        total_cost = cost1 + cost2 + cost3\n        # Combine cost and diversity in selection probability\n        weight = (1.0 / (total_cost + 1)) * (1.0 + diversity_score)\n        weights.append(weight)\n\n    selected_idx = random.choices(range(len(evaluated_solutions)), weights=weights, k=1)[0]\n    base_solution = evaluated_solutions[selected_idx][0].copy()\n    base_objectives = evaluated_solutions[selected_idx][1]\n\n    # Step 3: Perform multi-objective weighted edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    max_cost = max(base_objectives)\n    if max_cost == 0:\n        obj_weights = [1/3, 1/3, 1/3]\n    else:\n        obj_weights = [1 - (cost / max_cost) for cost in base_objectives]\n\n    # Perform a series of edge swaps considering all objectives\n    for _ in range(10):  # Limit the number of swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute weighted cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        weighted_delta = (delta_cost1 * obj_weights[0] +\n                         delta_cost2 * obj_weights[1] +\n                         delta_cost3 * obj_weights[2])\n\n        # Accept if it improves the weighted combination\n        if weighted_delta < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7849918370402775,
               2.677839183807373
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective-aware path reconstruction strategy that dynamically identifies critical path segments based on their contribution to each objective, then reconstructs the tour by selectively reversing these segments in a way that maximizes combined improvement across all objectives while maintaining feasibility through a novel segment merging and splitting mechanism that ensures node uniqueness and tour continuity. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reversal at positions that maximize the combined improvement across all objectives. The method also incorporates a segment merging step that combines adjacent segments when their combined contribution is more favorable than their individual contributions, further enhancing solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments for each objective\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Check if segment should be split\n        if (obj1_improvement + obj2_improvement + obj3_improvement) > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reverse segments probabilistically based on their contribution\n    for i in range(len(segments)):\n        if len(segments[i]) > 1 and np.random.rand() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    # Merge adjacent segments if beneficial\n    i = 0\n    while i < len(segments) - 1:\n        segment1 = segments[i]\n        segment2 = segments[i+1]\n\n        # Calculate merge cost\n        obj1_cost = distance_matrix_1[segment1[-1], segment2[0]] + \\\n                   (distance_matrix_1[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0) + \\\n                   (distance_matrix_1[segment2[1], segment2[0]] if len(segment2) > 1 else 0)\n\n        obj2_cost = distance_matrix_2[segment1[-1], segment2[0]] + \\\n                   (distance_matrix_2[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0) + \\\n                   (distance_matrix_2[segment2[1], segment2[0]] if len(segment2) > 1 else 0)\n\n        obj3_cost = distance_matrix_3[segment1[-1], segment2[0]] + \\\n                   (distance_matrix_3[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0) + \\\n                   (distance_matrix_3[segment2[1], segment2[0]] if len(segment2) > 1 else 0)\n\n        # Calculate current cost\n        current_cost = distance_matrix_1[segment1[-1], segment1[-2]] + \\\n                      distance_matrix_2[segment1[-1], segment1[-2]] + \\\n                      distance_matrix_3[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0\n\n        if obj1_cost + obj2_cost + obj3_cost < current_cost:\n            # Merge segments\n            segments[i] = segment1 + segment2\n            segments.pop(i+1)\n        else:\n            i += 1\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7831516507391023,
               1.7008926630020142
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential (simplified example)\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)  # Simple heuristic\n        potential_scores.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Select three non-consecutive edges to swap (3-opt style)\n    i = np.random.randint(0, n-3)\n    j = np.random.randint(i+1, n-2)\n    k = np.random.randint(j+1, n-1)\n\n    # 2. Perform the swap while considering all three objectives\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = candidate1[i:j+1][::-1]\n    # Candidate 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k+1] = candidate2[j:k+1][::-1]\n    # Candidate 3: Reverse entire segment\n    candidate3 = new_solution.copy()\n    candidate3[i:k+1] = candidate3[i:k+1][::-1]\n    candidates = [candidate1, candidate2, candidate3]\n\n    # Evaluate candidates in all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost for all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7312398591023672,
               1.5018046021461486
          ]
     }
]