[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8061138255287508,
               1.0024596810340882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential (simplified example)\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)  # Simple heuristic\n        potential_scores.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Select three non-consecutive edges to swap (3-opt style)\n    i = np.random.randint(0, n-3)\n    j = np.random.randint(i+1, n-2)\n    k = np.random.randint(j+1, n-1)\n\n    # 2. Perform the swap while considering all three objectives\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = candidate1[i:j+1][::-1]\n    # Candidate 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k+1] = candidate2[j:k+1][::-1]\n    # Candidate 3: Reverse entire segment\n    candidate3 = new_solution.copy()\n    candidate3[i:k+1] = candidate3[i:k+1][::-1]\n    candidates = [candidate1, candidate2, candidate3]\n\n    # Evaluate candidates in all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost for all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7312398591023672,
               1.5018046021461486
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (simplified selection for this example)\n    # In practice, you would implement a more sophisticated selection mechanism\n    base_solution, _ = archive[np.random.randint(len(archive))]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with coordinate perturbation\n    n = len(new_solution)\n\n    # 2-opt local search\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Coordinate perturbation (randomly swap two nodes in one of the objective spaces)\n    space = np.random.randint(3)\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find two nodes with high distance in the selected space\n    node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n\n    # Swap these nodes in the solution\n    idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
          "score": [
               -0.7173722025420547,
               1.430956780910492
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n",
          "score": [
               -0.7873491805548415,
               1.5758279323577882
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement for each objective\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Calculate combined improvement\n        combined_improvement = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n        # Add to current segment or start new segment based on improvement\n        if combined_improvement > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion with probabilistic selection\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost for all objectives\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj1_cost + obj2_cost + obj3_cost)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        # Probabilistically decide to insert based on improvement\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to insert\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping with multi-objective evaluation\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost for all objectives\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        combined_cost = (obj1_cost + obj2_cost + obj3_cost) / 3\n\n        if combined_cost < 0 and np.random.rand() < 0.5:  # 50% chance to swap if beneficial\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7142097964801128,
               1.0437695622444152
          ]
     },
     {
          "algorithm": "{The new algorithm will combine the selection strategy of favoring solutions with high potential improvement (from Algorithm 1) with a novel multi-objective local search operator that performs a weighted combination of edge swaps across all three objectives, where the weights are dynamically adjusted based on the current solution's performance in each objective space. The selection process will use a diversity-aware approach that considers both the solution's objective values and their spatial distribution in the objective space, ensuring that the chosen solution has the potential for significant improvement in at least one objective while maintaining diversity in the search process. The local search will then perform a series of edge swaps that simultaneously consider all three objectives, with the probability of selecting a swap being proportional to its potential improvement in the weighted combination of objectives, while ensuring that the solution remains feasible and that the search explores different regions of the solution space to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive with diversity consideration\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        # Normalize objectives for diversity consideration\n        norm_cost1 = cost1 / (cost1 + cost2 + cost3) if (cost1 + cost2 + cost3) > 0 else 0\n        norm_cost2 = cost2 / (cost1 + cost2 + cost3) if (cost1 + cost2 + cost3) > 0 else 0\n        norm_cost3 = cost3 / (cost1 + cost2 + cost3) if (cost1 + cost2 + cost3) > 0 else 0\n        # Calculate diversity score based on normalized objectives\n        diversity_score = norm_cost1 * norm_cost2 * norm_cost3\n        evaluated_solutions.append((solution, objectives, diversity_score))\n\n    # Step 2: Select a solution with weighted randomness considering both cost and diversity\n    weights = []\n    for _, (cost1, cost2, cost3), diversity_score in evaluated_solutions:\n        total_cost = cost1 + cost2 + cost3\n        # Combine cost and diversity in selection probability\n        weight = (1.0 / (total_cost + 1)) * (1.0 + diversity_score)\n        weights.append(weight)\n\n    selected_idx = random.choices(range(len(evaluated_solutions)), weights=weights, k=1)[0]\n    base_solution = evaluated_solutions[selected_idx][0].copy()\n    base_objectives = evaluated_solutions[selected_idx][1]\n\n    # Step 3: Perform multi-objective weighted edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    max_cost = max(base_objectives)\n    if max_cost == 0:\n        obj_weights = [1/3, 1/3, 1/3]\n    else:\n        obj_weights = [1 - (cost / max_cost) for cost in base_objectives]\n\n    # Perform a series of edge swaps considering all objectives\n    for _ in range(10):  # Limit the number of swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute weighted cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        weighted_delta = (delta_cost1 * obj_weights[0] +\n                         delta_cost2 * obj_weights[1] +\n                         delta_cost3 * obj_weights[2])\n\n        # Accept if it improves the weighted combination\n        if weighted_delta < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7849918370402775,
               2.677839183807373
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective-aware path decomposition and reassembly strategy that dynamically partitions the tour into critical and non-critical segments based on their contribution to each objective, then reconstructs the tour by selectively reordering and merging segments in a way that maximizes combined improvement across all objectives while maintaining feasibility through a novel segment decomposition and reassembly mechanism that ensures node uniqueness and tour continuity. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reordering based on their combined contribution, with segments being reassembled in an order that maximizes the overall improvement while minimizing the disruption to the existing tour structure. The method also incorporates a segment decomposition step that splits segments when their internal structure shows potential for further improvement, and a segment reassembly step that merges segments when their combined contribution is more favorable than their individual contributions, further enhancing solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        if (obj1_improvement + obj2_improvement + obj3_improvement) > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Segment reordering based on objective contributions\n    segment_scores = []\n    for seg in segments:\n        if len(seg) > 1:\n            total = 0\n            for i in range(len(seg)-1):\n                total += (distance_matrix_1[seg[i], seg[i+1]] +\n                         distance_matrix_2[seg[i], seg[i+1]] +\n                         distance_matrix_3[seg[i], seg[i+1]])\n            segment_scores.append(total / len(seg))\n        else:\n            segment_scores.append(0)\n\n    # Sort segments by their potential improvement\n    sorted_indices = np.argsort(segment_scores)[::-1]\n    sorted_segments = [segments[i] for i in sorted_indices]\n\n    # Reconstruct solution with segments in new order\n    new_solution = np.concatenate(sorted_segments)\n\n    # Segment decomposition for further improvement\n    for i in range(len(segments)):\n        seg = segments[i]\n        if len(seg) > 3:\n            # Split segment into two parts\n            split_point = len(seg) // 2\n            segments[i] = seg[:split_point]\n            segments.insert(i+1, seg[split_point:])\n\n    # Reconstruct solution with decomposed segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7473231267502582,
               1.6864570260047913
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective-aware path reconstruction strategy that dynamically identifies critical path segments based on their contribution to each objective, then reconstructs the tour by selectively reversing these segments in a way that maximizes combined improvement across all objectives while maintaining feasibility through a novel segment merging and splitting mechanism that ensures node uniqueness and tour continuity. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reversal at positions that maximize the combined improvement across all objectives. The method also incorporates a segment merging step that combines adjacent segments when their combined contribution is more favorable than their individual contributions, further enhancing solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments for each objective\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Check if segment should be split\n        if (obj1_improvement + obj2_improvement + obj3_improvement) > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reverse segments probabilistically based on their contribution\n    for i in range(len(segments)):\n        if len(segments[i]) > 1 and np.random.rand() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    # Merge adjacent segments if beneficial\n    i = 0\n    while i < len(segments) - 1:\n        segment1 = segments[i]\n        segment2 = segments[i+1]\n\n        # Calculate merge cost\n        obj1_cost = distance_matrix_1[segment1[-1], segment2[0]] + \\\n                   (distance_matrix_1[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0) + \\\n                   (distance_matrix_1[segment2[1], segment2[0]] if len(segment2) > 1 else 0)\n\n        obj2_cost = distance_matrix_2[segment1[-1], segment2[0]] + \\\n                   (distance_matrix_2[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0) + \\\n                   (distance_matrix_2[segment2[1], segment2[0]] if len(segment2) > 1 else 0)\n\n        obj3_cost = distance_matrix_3[segment1[-1], segment2[0]] + \\\n                   (distance_matrix_3[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0) + \\\n                   (distance_matrix_3[segment2[1], segment2[0]] if len(segment2) > 1 else 0)\n\n        # Calculate current cost\n        current_cost = distance_matrix_1[segment1[-1], segment1[-2]] + \\\n                      distance_matrix_2[segment1[-1], segment1[-2]] + \\\n                      distance_matrix_3[segment1[-1], segment1[-2]] if len(segment1) > 1 else 0\n\n        if obj1_cost + obj2_cost + obj3_cost < current_cost:\n            # Merge segments\n            segments[i] = segment1 + segment2\n            segments.pop(i+1)\n        else:\n            i += 1\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7831516507391023,
               1.7008926630020142
          ]
     },
     {
          "algorithm": "{This algorithm introduces a novel approach that combines objective-specific clustering with multi-objective path relinking, where solutions are first partitioned into clusters based on their dominance in individual objectives, then a path relinking process is applied between randomly selected solutions from different clusters to generate a new solution that balances improvements across all three objectives. The method prioritizes solutions that show strong performance in at least one objective while ensuring diversity, and uses a guided edge exchange mechanism that considers the trade-offs between objectives during the path relinking process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Cluster solutions based on objective dominance\n    clusters = [[] for _ in range(3)]\n    for solution, (cost1, cost2, cost3) in archive:\n        # Determine which objective this solution is best for\n        costs = [cost1, cost2, cost3]\n        best_obj = np.argmin(costs)\n        clusters[best_obj].append(solution)\n\n    # Step 2: Select two solutions from different clusters\n    cluster_indices = [i for i, c in enumerate(clusters) if len(c) > 0]\n    if len(cluster_indices) < 2:\n        # If only one cluster has solutions, use standard approach\n        weights = [1.0 / (i + 1) for i in range(len(archive))]\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n    # Select two different clusters\n    c1, c2 = random.sample(cluster_indices, 2)\n    sol1 = random.choice(clusters[c1])\n    sol2 = random.choice(clusters[c2])\n\n    # Step 3: Perform multi-objective path relinking\n    new_solution = sol1.copy()\n    n = len(new_solution)\n\n    # Identify common and differing edges\n    common_edges = set()\n    for i in range(n):\n        edge1 = (sol1[i], sol1[(i+1)%n])\n        edge2 = (sol2[i], sol2[(i+1)%n])\n        if edge1 == edge2:\n            common_edges.add(edge1)\n\n    # Guided edge exchange based on objective improvements\n    for _ in range(10):\n        # Find a position where solutions differ\n        diff_pos = [i for i in range(n) if (sol1[i], sol1[(i+1)%n]) != (sol2[i], sol2[(i+1)%n])]\n        if not diff_pos:\n            break\n        pos = random.choice(diff_pos)\n\n        # Try to make the new solution more similar to sol2 at this position\n        current_edge = (new_solution[pos], new_solution[(pos+1)%n])\n        target_edge = (sol2[pos], sol2[(pos+1)%n])\n\n        # Calculate cost differences\n        delta_cost1 = distance_matrix_1[target_edge[0]][target_edge[1]] - distance_matrix_1[current_edge[0]][current_edge[1]]\n        delta_cost2 = distance_matrix_2[target_edge[0]][target_edge[1]] - distance_matrix_2[current_edge[0]][current_edge[1]]\n        delta_cost3 = distance_matrix_3[target_edge[0]][target_edge[1]] - distance_matrix_3[current_edge[0]][current_edge[1]]\n\n        # Accept if it improves at least one objective or maintains others\n        if delta_cost1 <= 0 or delta_cost2 <= 0 or delta_cost3 <= 0:\n            # Perform the edge swap\n            new_solution[pos], new_solution[(pos+1)%n] = target_edge[0], target_edge[1]\n\n    return new_solution\n\n",
          "score": [
               -0.7241527891733062,
               1.661380362510681
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    new_objectives = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try objective-aware swaps\n    if all(new_obj > old_obj for new_obj, old_obj in zip(new_objectives, objectives)):\n        # Find the worst objective to improve\n        worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(new_objectives, objectives)])\n\n        # Perform swaps to improve the worst objective\n        for _ in range(5):  # Try a few swaps\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_objectives = calculate_objective(temp_solution)\n\n            if temp_objectives[worst_obj_idx] < new_objectives[worst_obj_idx]:\n                new_solution = temp_solution\n                new_objectives = temp_objectives\n\n    return new_solution\n\n",
          "score": [
               -0.7112000903089013,
               1.101941978931427
          ]
     }
]