[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        total_cost = cost1 + cost2 + cost3\n        evaluated_solutions.append((solution, total_cost))\n\n    # Step 2: Rank solutions by total cost and diversity\n    evaluated_solutions.sort(key=lambda x: x[1])\n    ranked_solutions = [sol for sol, _ in evaluated_solutions]\n\n    # Step 3: Select a solution with weighted randomness (favor better solutions)\n    weights = [1.0 / (i + 1) for i in range(len(ranked_solutions))]\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=weights, k=1)[0]\n    base_solution = ranked_solutions[selected_idx].copy()\n\n    # Step 4: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 4.1: Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4.2: Multi-objective edge selection heuristic\n    # Evaluate edges based on their contribution to the Pareto front\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        potential_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Compute cost differences\n        delta_cost1 = sum(distance_matrix_1[u][v] for u, v in potential_edges) - sum(distance_matrix_1[u][v] for u, v in current_edges)\n        delta_cost2 = sum(distance_matrix_2[u][v] for u, v in potential_edges) - sum(distance_matrix_2[u][v] for u, v in current_edges)\n        delta_cost3 = sum(distance_matrix_3[u][v] for u, v in potential_edges) - sum(distance_matrix_3[u][v] for u, v in current_edges)\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8061138255287508,
               1.0024596810340882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential (simplified example)\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)  # Simple heuristic\n        potential_scores.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Select three non-consecutive edges to swap (3-opt style)\n    i = np.random.randint(0, n-3)\n    j = np.random.randint(i+1, n-2)\n    k = np.random.randint(j+1, n-1)\n\n    # 2. Perform the swap while considering all three objectives\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = candidate1[i:j+1][::-1]\n    # Candidate 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k+1] = candidate2[j:k+1][::-1]\n    # Candidate 3: Reverse entire segment\n    candidate3 = new_solution.copy()\n    candidate3[i:k+1] = candidate3[i:k+1][::-1]\n    candidates = [candidate1, candidate2, candidate3]\n\n    # Evaluate candidates in all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost for all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.7312398591023672,
               1.5018046021461486
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (simplified selection for this example)\n    # In practice, you would implement a more sophisticated selection mechanism\n    base_solution, _ = archive[np.random.randint(len(archive))]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with coordinate perturbation\n    n = len(new_solution)\n\n    # 2-opt local search\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Coordinate perturbation (randomly swap two nodes in one of the objective spaces)\n    space = np.random.randint(3)\n    if space == 0:\n        dist_matrix = distance_matrix_1\n    elif space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find two nodes with high distance in the selected space\n    node1, node2 = np.unravel_index(np.argmax(dist_matrix), dist_matrix.shape)\n\n    # Swap these nodes in the solution\n    idx1, idx2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
          "score": [
               -0.7173722025420547,
               1.430956780910492
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with consideration for all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    new_objectives = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try objective-aware swaps\n    if all(new_obj > old_obj for new_obj, old_obj in zip(new_objectives, objectives)):\n        # Find the worst objective to improve\n        worst_obj_idx = np.argmax([new_obj - old_obj for new_obj, old_obj in zip(new_objectives, objectives)])\n\n        # Perform swaps to improve the worst objective\n        for _ in range(5):  # Try a few swaps\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_objectives = calculate_objective(temp_solution)\n\n            if temp_objectives[worst_obj_idx] < new_objectives[worst_obj_idx]:\n                new_solution = temp_solution\n                new_objectives = temp_objectives\n\n    return new_solution\n\n",
          "score": [
               -0.7112000903089013,
               1.101941978931427
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified selection for this example)\n    selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Apply a hybrid local search operator (simplified 2-opt for this example)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i + 1 != j:  # Ensure they're not consecutive\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    return new_solution\n\n",
          "score": [
               -0.7873491805548415,
               1.5758279323577882
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Get the number of nodes\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt move)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Ensure i < j\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware edge selection\n    for _ in range(3):  # Try up to 3 times to find an improving swap\n        # Randomly select two edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a == b:\n            continue\n\n        # Calculate the current and new distances for all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_dist3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        new_dist3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Check if the swap improves at least one objective\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.5678252448903232,
               1.2791006445884705
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective aware path decomposition strategy that dynamically decomposes the tour into segments based on their contribution to each objective, then selectively reorders these segments using a novel objective-aware insertion heuristic. The algorithm first evaluates each segment's contribution to all three objectives by calculating their weighted normalized improvements, then probabilistically selects segments for reinsertion at positions that maximize the combined improvement across all objectives, while ensuring feasibility by maintaining node uniqueness and tour continuity. The method also incorporates a segment swapping step that exchanges entire segments between promising positions to further enhance solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate normalized improvement potential\n        total_obj = sum(obj)\n        potential = total_obj / len(sol)\n        potential_scores.append(potential)\n\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decompose tour into segments\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate segment improvement\n        obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Add to current segment or start new segment\n        if (obj1_improvement + obj2_improvement + obj3_improvement) > 0:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reorder segments using objective-aware insertion\n    for i in range(1, len(segments)):\n        best_pos = -1\n        best_score = -float('inf')\n\n        # Evaluate insertion positions\n        for j in range(len(segments)):\n            if i == j:\n                continue\n\n            # Calculate insertion cost\n            prev_node = segments[j][-1] if j > 0 else segments[j-1][-1]\n            next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n            obj1_cost = distance_matrix_1[prev_node, segments[i][0]] + \\\n                        distance_matrix_1[segments[i][-1], next_node] - \\\n                        distance_matrix_1[prev_node, next_node]\n\n            obj2_cost = distance_matrix_2[prev_node, segments[i][0]] + \\\n                        distance_matrix_2[segments[i][-1], next_node] - \\\n                        distance_matrix_2[prev_node, next_node]\n\n            obj3_cost = distance_matrix_3[prev_node, segments[i][0]] + \\\n                        distance_matrix_3[segments[i][-1], next_node] - \\\n                        distance_matrix_3[prev_node, next_node]\n\n            total_score = - (obj1_cost + obj2_cost + obj3_cost)\n\n            if total_score > best_score:\n                best_score = total_score\n                best_pos = j\n\n        if best_pos != -1:\n            # Insert segment\n            if best_pos < i:\n                segments.insert(best_pos, segments.pop(i))\n            else:\n                segments.insert(best_pos, segments.pop(i))\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Segment swapping step\n    if len(segments) > 2:\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate swap cost\n        prev_node = segments[i-1][-1] if i > 0 else segments[-1][-1]\n        next_node = segments[j+1][0] if j+1 < len(segments) else segments[0][0]\n\n        obj1_cost = distance_matrix_1[prev_node, segments[j][0]] + \\\n                    distance_matrix_1[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_1[prev_node, segments[i][0]] - \\\n                    distance_matrix_1[segments[j][-1], next_node]\n\n        obj2_cost = distance_matrix_2[prev_node, segments[j][0]] + \\\n                    distance_matrix_2[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_2[prev_node, segments[i][0]] - \\\n                    distance_matrix_2[segments[j][-1], next_node]\n\n        obj3_cost = distance_matrix_3[prev_node, segments[j][0]] + \\\n                    distance_matrix_3[segments[i][-1], segments[j+1][0]] - \\\n                    distance_matrix_3[prev_node, segments[i][0]] - \\\n                    distance_matrix_3[segments[j][-1], next_node]\n\n        if obj1_cost + obj2_cost + obj3_cost < 0:\n            # Perform swap\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution))\n\n    return new_solution\n\n",
          "score": [
               -0.6984361318712439,
               1.3063410997390748
          ]
     },
     {
          "algorithm": "{The new algorithm will use a multi-objective aware selection strategy that prioritizes solutions with balanced objective improvements, combined with a novel \"objective-aware node relocation\" operator. It first identifies solutions in the archive that show diverse improvements across objectives, then selects one based on a weighted random selection favoring those with balanced objective contributions. The operator then relocates a node to a position that improves at least one objective while considering the trade-offs across all three objectives, using a greedy but objective-aware approach to ensure feasibility and potentially better Pareto dominance.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions based on objective diversity\n    evaluated_solutions = []\n    for solution, objectives in archive:\n        cost1, cost2, cost3 = objectives\n        diversity = (max(cost1, cost2, cost3) - min(cost1, cost2, cost3)) / (sum(objectives) + 1e-10)\n        evaluated_solutions.append((solution, diversity))\n\n    # Step 2: Select a solution with weighted randomness (favor diverse solutions)\n    weights = [1.0 / (diversity + 1e-10) for _, diversity in evaluated_solutions]\n    selected_idx = random.choices(range(len(evaluated_solutions)), weights=weights, k=1)[0]\n    base_solution = evaluated_solutions[selected_idx][0].copy()\n\n    # Step 3: Apply objective-aware node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n\n    # Find the best position to insert the node to improve at least one objective\n    best_pos = -1\n    best_improvement = [0, 0, 0]\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue\n\n        # Calculate the cost change for each objective\n        prev_node = new_solution[pos - 1]\n        next_node = new_solution[pos]\n\n        # Remove the node from its current position\n        current_cost1 = distance_matrix_1[new_solution[node_idx - 1], node] + distance_matrix_1[node, new_solution[(node_idx + 1) % n]]\n        new_cost1 = distance_matrix_1[new_solution[node_idx - 1], new_solution[(node_idx + 1) % n]]\n\n        current_cost2 = distance_matrix_2[new_solution[node_idx - 1], node] + distance_matrix_2[node, new_solution[(node_idx + 1) % n]]\n        new_cost2 = distance_matrix_2[new_solution[node_idx - 1], new_solution[(node_idx + 1) % n]]\n\n        current_cost3 = distance_matrix_3[new_solution[node_idx - 1], node] + distance_matrix_3[node, new_solution[(node_idx + 1) % n]]\n        new_cost3 = distance_matrix_3[new_solution[node_idx - 1], new_solution[(node_idx + 1) % n]]\n\n        # Insert the node at the new position\n        potential_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        potential_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        potential_cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Calculate the improvement\n        improvement1 = (new_cost1 - potential_cost1) if (new_cost1 - potential_cost1) > 0 else 0\n        improvement2 = (new_cost2 - potential_cost2) if (new_cost2 - potential_cost2) > 0 else 0\n        improvement3 = (new_cost3 - potential_cost3) if (new_cost3 - potential_cost3) > 0 else 0\n\n        # Check if at least one objective improves\n        if improvement1 > 0 or improvement2 > 0 or improvement3 > 0:\n            # Prioritize positions that improve multiple objectives\n            total_improvement = improvement1 + improvement2 + improvement3\n            if total_improvement > sum(best_improvement):\n                best_pos = pos\n                best_improvement = [improvement1, improvement2, improvement3]\n\n    # Apply the best relocation if found\n    if best_pos != -1:\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.7781533744341372,
               2.30068324804306
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = 1 - np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective-aware 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply a tailored edge-reversal operation considering all objectives\n    total_distances = np.array([\n        sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    ])\n    worst_obj_idx = np.argmax(total_distances)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Reverse the segment between the two nodes with the highest distance in the worst objective\n    max_dist = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = dist_matrix[new_solution[i], new_solution[j]]\n            if dist > max_dist:\n                max_dist = dist\n                best_i, best_j = i, j\n\n    if best_i < best_j:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n    else:\n        new_solution[best_i:] = new_solution[best_i:][::-1]\n        new_solution[:best_j+1] = new_solution[:best_j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.7448768170868245,
               1.7823224306106566
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.mean(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swaps based on the worst-performing objective\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective space\n    max_cost = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        cost = dist_matrix[new_solution[i], new_solution[j]]\n        if cost > max_cost:\n            max_cost = cost\n            max_i, max_j = i, j\n\n    # Swap the nodes to reduce the worst objective cost\n    if max_i != max_j:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    return new_solution\n\n",
          "score": [
               -0.6414476807749279,
               1.4017594933509827
          ]
     }
]