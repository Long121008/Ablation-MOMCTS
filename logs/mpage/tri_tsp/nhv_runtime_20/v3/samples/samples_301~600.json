[
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_score(obj):\n        return sum(obj)\n\n    scores = [objective_score(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores)/sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start1 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n\n    # Create a composite segment by combining segments from different objectives\n    composite_segment = []\n    for i in range(segment_length):\n        obj1 = distance_matrix_1[segment1[i], segment1[(i+1)%segment_length]]\n        obj2 = distance_matrix_2[segment1[i], segment1[(i+1)%segment_length]]\n        obj3 = distance_matrix_3[segment1[i], segment1[(i+1)%segment_length]]\n\n        if obj1 < obj2 and obj1 < obj3:\n            composite_segment.append(segment1[i])\n        elif obj2 < obj1 and obj2 < obj3:\n            composite_segment.append(segment1[(i+1)%segment_length])\n        else:\n            composite_segment.append(segment1[(i+2)%segment_length] if (i+2) < segment_length else segment1[0])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if fusion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Create a new segment by shuffling the selected segment\n    np.random.shuffle(segment)\n\n    # Insert the shuffled segment back into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if shuffling fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Create a new segment by reversing the selected segment\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = reversed_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.6801700754906843,
               0.5993322730064392
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Create a new segment by reversing the selected segment\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = reversed_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic segment exchange strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically exchanges segments of the tour with segments from other high-quality solutions in the archive, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment size determination based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure, and dynamically adjusts the exchange probability based on the relative performance of each objective to balance exploitation and exploration across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    exchange_prob = 0.5 + 0.4 * (1 - objectives[worst_obj_idx] / sum(objectives))\n\n    for _ in range(3):\n        if np.random.rand() < exchange_prob:\n            donor_idx = np.random.choice(len(archive_sorted))\n            donor_solution = archive_sorted[donor_idx][0]\n\n            segment_length = max(2, min(5, n // 4))\n            start = np.random.randint(0, n - segment_length)\n            donor_start = np.random.randint(0, n - segment_length)\n\n            new_solution[start:start+segment_length] = donor_solution[donor_start:donor_start+segment_length]\n\n    if len(new_solution) != len(set(new_solution)):\n        for i in range(n):\n            if np.sum(new_solution == new_solution[i]) > 1:\n                duplicates = np.where(new_solution == new_solution[i])[0]\n                for j in duplicates[1:]:\n                    new_solution[j] = np.random.choice([x for x in range(n) if x not in new_solution])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_score(obj):\n        return sum(obj)\n\n    scores = [objective_score(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores)/sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start1 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n\n    # Create a composite segment by combining segments from different objectives\n    composite_segment = []\n    for i in range(segment_length):\n        obj1 = distance_matrix_1[segment1[i], segment1[(i+1)%segment_length]]\n        obj2 = distance_matrix_2[segment1[i], segment1[(i+1)%segment_length]]\n        obj3 = distance_matrix_3[segment1[i], segment1[(i+1)%segment_length]]\n\n        if obj1 < obj2 and obj1 < obj3:\n            composite_segment.append(segment1[i])\n        elif obj2 < obj1 and obj2 < obj3:\n            composite_segment.append(segment1[(i+1)%segment_length])\n        else:\n            composite_segment.append(segment1[(i+2)%segment_length] if (i+2) < segment_length else segment1[0])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if fusion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_score(obj):\n        return sum(obj)\n\n    scores = [objective_score(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores)/sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start1 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n\n    # Create a composite segment by combining segments from different objectives\n    composite_segment = []\n    for i in range(segment_length):\n        obj1 = distance_matrix_1[segment1[i], segment1[(i+1)%segment_length]]\n        obj2 = distance_matrix_2[segment1[i], segment1[(i+1)%segment_length]]\n        obj3 = distance_matrix_3[segment1[i], segment1[(i+1)%segment_length]]\n\n        if obj1 < obj2 and obj1 < obj3:\n            composite_segment.append(segment1[i])\n        elif obj2 < obj1 and obj2 < obj3:\n            composite_segment.append(segment1[(i+1)%segment_length])\n        else:\n            composite_segment.append(segment1[(i+2)%segment_length] if (i+2) < segment_length else segment1[0])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if fusion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.6080441034407713,
               0.6139915704727172
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_score(obj):\n        return sum(obj)\n\n    scores = [objective_score(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores)/sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start1 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n\n    # Create a composite segment by combining segments from different objectives\n    composite_segment = []\n    for i in range(segment_length):\n        obj1 = distance_matrix_1[segment1[i], segment1[(i+1)%segment_length]]\n        obj2 = distance_matrix_2[segment1[i], segment1[(i+1)%segment_length]]\n        obj3 = distance_matrix_3[segment1[i], segment1[(i+1)%segment_length]]\n\n        if obj1 < obj2 and obj1 < obj3:\n            composite_segment.append(segment1[i])\n        elif obj2 < obj1 and obj2 < obj3:\n            composite_segment.append(segment1[(i+1)%segment_length])\n        else:\n            composite_segment.append(segment1[(i+2)%segment_length] if (i+2) < segment_length else segment1[0])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if fusion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Create a new segment by reversing the selected segment\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = reversed_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if reversal fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Create a new segment by shuffling the selected segment\n    np.random.shuffle(segment)\n\n    # Insert the shuffled segment back into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if shuffling fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The new algorithm introduces a tri-objective-aware multi-phase hybrid operator that first performs a dynamic objective-weighted segment extraction from multiple solutions, then applies a novel geometric transformation that aligns segments based on their Pareto-optimal properties across all three objectives, followed by a multi-criteria segment reassembly that preserves the relative ordering of nodes while optimizing edge contributions in each objective space, with feasibility maintained through a dynamic node replacement mechanism that ensures no node is skipped or revisited, and balances exploration with exploitation by adaptively adjusting transformation parameters based on the current Pareto front distribution, incorporating a novel edge dominance metric that prioritizes edges with balanced improvement across all objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective weights based on current archive\n    objectives = np.array([obj for _, obj in archive])\n    normalized_weights = np.mean(objectives, axis=0) / np.sum(np.mean(objectives, axis=0))\n\n    # Select base solution with probability proportional to its combined objective score\n    scores = np.dot(objectives, normalized_weights)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(10, n // 4))\n\n    # Phase 1: Dynamic segment extraction based on objective weights\n    candidates = []\n    for i in range(5):  # Try multiple candidate segments\n        start = np.random.randint(0, n - segment_length)\n        segment = base_solution[start:start+segment_length]\n\n        # Calculate segment's contribution to each objective\n        segment_costs = [0.0, 0.0, 0.0]\n        for j in range(len(segment)-1):\n            node1, node2 = segment[j], segment[j+1]\n            segment_costs[0] += distance_matrix_1[node1, node2]\n            segment_costs[1] += distance_matrix_2[node1, node2]\n            segment_costs[2] += distance_matrix_3[node1, node2]\n\n        # Weighted score for segment selection\n        segment_score = np.dot(segment_costs, normalized_weights)\n        candidates.append((segment_score, start, segment))\n\n    # Select the segment with highest weighted score\n    best_segment = max(candidates, key=lambda x: x[0])\n    start_pos, segment = best_segment[1], best_segment[2]\n\n    # Phase 2: Geometric transformation based on objective alignment\n    transformed_segment = segment.copy()\n    for i in range(len(segment)-1):\n        node1, node2 = segment[i], segment[i+1]\n\n        # Calculate edge dominance across objectives\n        edge_dominance = [\n            distance_matrix_1[node1, node2],\n            distance_matrix_2[node1, node2],\n            distance_matrix_3[node1, node2]\n        ]\n\n        # Find the most balanced edge (lowest max difference)\n        if len(segment) > 2:\n            # Try to find a better alignment\n            for j in range(i+1, len(segment)-1):\n                alt_node2 = segment[j]\n                alt_dominance = [\n                    distance_matrix_1[node1, alt_node2],\n                    distance_matrix_2[node1, alt_node2],\n                    distance_matrix_3[node1, alt_node2]\n                ]\n                if max(alt_dominance) < max(edge_dominance):\n                    transformed_segment[i+1] = alt_node2\n                    edge_dominance = alt_dominance\n\n    # Phase 3: Multi-criteria segment reassembly\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = transformed_segment\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Find missing and duplicate nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, unique_nodes)\n        duplicates = new_solution[np.where(np.isin(new_solution, unique_nodes, invert=True))[0]]\n\n        # Replace duplicates with missing nodes\n        for dup, miss in zip(duplicates, missing):\n            positions = np.where(new_solution == dup)[0]\n            for pos in positions:\n                if len(missing) > 0:\n                    new_solution[pos] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n",
          "score": [
               -0.6984778449539754,
               1.437357783317566
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective weights based on current archive\n    objectives = np.array([obj for _, obj in archive])\n    normalized_weights = np.mean(objectives, axis=0) / np.sum(np.mean(objectives, axis=0))\n\n    # Select base solution with probability proportional to its combined objective score\n    scores = np.dot(objectives, normalized_weights)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(10, n // 4))\n\n    # Phase 1: Dynamic segment extraction based on objective weights\n    candidates = []\n    for i in range(5):  # Try multiple candidate segments\n        start = np.random.randint(0, n - segment_length)\n        segment = base_solution[start:start+segment_length]\n\n        # Calculate segment's contribution to each objective\n        segment_costs = [0.0, 0.0, 0.0]\n        for j in range(len(segment)-1):\n            node1, node2 = segment[j], segment[j+1]\n            segment_costs[0] += distance_matrix_1[node1, node2]\n            segment_costs[1] += distance_matrix_2[node1, node2]\n            segment_costs[2] += distance_matrix_3[node1, node2]\n\n        # Weighted score for segment selection\n        segment_score = np.dot(segment_costs, normalized_weights)\n        candidates.append((segment_score, start, segment))\n\n    # Select the segment with highest weighted score\n    best_segment = max(candidates, key=lambda x: x[0])\n    start_pos, segment = best_segment[1], best_segment[2]\n\n    # Phase 2: Geometric transformation based on objective alignment\n    transformed_segment = segment.copy()\n    for i in range(len(segment)-1):\n        node1, node2 = segment[i], segment[i+1]\n\n        # Calculate edge dominance across objectives\n        edge_dominance = [\n            distance_matrix_1[node1, node2],\n            distance_matrix_2[node1, node2],\n            distance_matrix_3[node1, node2]\n        ]\n\n        # Find the most balanced edge (lowest max difference)\n        if len(segment) > 2:\n            # Try to find a better alignment\n            for j in range(i+1, len(segment)-1):\n                alt_node2 = segment[j]\n                alt_dominance = [\n                    distance_matrix_1[node1, alt_node2],\n                    distance_matrix_2[node1, alt_node2],\n                    distance_matrix_3[node1, alt_node2]\n                ]\n                if max(alt_dominance) < max(edge_dominance):\n                    transformed_segment[i+1] = alt_node2\n                    edge_dominance = alt_dominance\n\n    # Phase 3: Multi-criteria segment reassembly\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = transformed_segment\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Find missing and duplicate nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, unique_nodes)\n        duplicates = new_solution[np.where(np.isin(new_solution, unique_nodes, invert=True))[0]]\n\n        # Replace duplicates with missing nodes\n        for dup, miss in zip(duplicates, missing):\n            positions = np.where(new_solution == dup)[0]\n            for pos in positions:\n                if len(missing) > 0:\n                    new_solution[pos] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from the base solution\n    start1 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n\n    # Create a composite segment by combining segments from different objectives\n    composite_segment = []\n    for i in range(segment_length):\n        obj1 = distance_matrix_1[segment1[i], segment1[(i+1)%segment_length]]\n        obj2 = distance_matrix_2[segment1[i], segment1[(i+1)%segment_length]]\n        obj3 = distance_matrix_3[segment1[i], segment1[(i+1)%segment_length]]\n\n        if obj1 < obj2 and obj1 < obj3:\n            composite_segment.append(segment1[i])\n        elif obj2 < obj1 and obj2 < obj3:\n            composite_segment.append(segment1[(i+1)%segment_length])\n        else:\n            composite_segment.append(segment1[(i+2)%segment_length] if (i+2) < segment_length else segment1[0])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if fusion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines multi-objective optimization with a probabilistic node relocation strategy that first identifies the most promising solution by evaluating a dominance-based selection considering all three objectives, then applies a hybrid local search that probabilistically relocates nodes to different positions in the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive relocation criteria based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    for _ in range(5):\n        node_to_move = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        possible_positions = [i for i in range(n) if i != current_pos]\n        new_pos = np.random.choice(possible_positions)\n\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_1[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_1[node_to_move, new_solution[(new_pos+1)%n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_2[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_2[node_to_move, new_solution[(new_pos+1)%n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_3[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_3[node_to_move, new_solution[(new_pos+1)%n]])\n\n        if potential_dist < current_dist or np.random.rand() < 0.3:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the weighted sum of objectives for selection\n    def weighted_sum(obj, weights=[0.4, 0.3, 0.3]):\n        return sum(w * o for w, o in zip(weights, obj))\n\n    # Select a solution with a probability proportional to its weighted sum\n    objectives = [obj for _, obj in archive]\n    weighted_sums = [weighted_sum(obj) for obj in objectives]\n    selected_idx = np.random.choice(len(archive), p=np.array(weighted_sums)/sum(weighted_sums))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select a random segment from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Reorder the segment based on the best objective for each node\n    reordered_segment = []\n    for i in range(segment_length):\n        node = segment[i]\n        next_node = segment[(i+1)%segment_length]\n\n        # Calculate distances for all objectives\n        dist1 = distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[node, next_node]\n        dist3 = distance_matrix_3[node, next_node]\n\n        # Determine the best objective for this pair\n        if dist1 <= dist2 and dist1 <= dist3:\n            best_obj = 0\n        elif dist2 <= dist1 and dist2 <= dist3:\n            best_obj = 1\n        else:\n            best_obj = 2\n\n        # Use the best objective to determine the next node\n        if best_obj == 0:\n            candidates = np.argsort(distance_matrix_1[node])\n        elif best_obj == 1:\n            candidates = np.argsort(distance_matrix_2[node])\n        else:\n            candidates = np.argsort(distance_matrix_3[node])\n\n        # Find the first candidate not already in the segment\n        for candidate in candidates:\n            if candidate not in segment:\n                reordered_segment.append(candidate)\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(reordered_segment) < segment_length:\n        missing = segment_length - len(reordered_segment)\n        remaining = [node for node in base_solution if node not in reordered_segment]\n        reordered_segment.extend(remaining[:missing])\n\n    # Insert the reordered segment into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = reordered_segment\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.6809111209231593,
               1.2489777326583862
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the weighted sum of objectives for selection\n    def weighted_sum(obj, weights=[0.4, 0.3, 0.3]):\n        return sum(w * o for w, o in zip(weights, obj))\n\n    # Select a solution with a probability proportional to its weighted sum\n    objectives = [obj for _, obj in archive]\n    weighted_sums = [weighted_sum(obj) for obj in objectives]\n    selected_idx = np.random.choice(len(archive), p=np.array(weighted_sums)/sum(weighted_sums))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select a random segment from the base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Reorder the segment based on the best objective for each node\n    reordered_segment = []\n    for i in range(segment_length):\n        node = segment[i]\n        next_node = segment[(i+1)%segment_length]\n\n        # Calculate distances for all objectives\n        dist1 = distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[node, next_node]\n        dist3 = distance_matrix_3[node, next_node]\n\n        # Determine the best objective for this pair\n        if dist1 <= dist2 and dist1 <= dist3:\n            best_obj = 0\n        elif dist2 <= dist1 and dist2 <= dist3:\n            best_obj = 1\n        else:\n            best_obj = 2\n\n        # Use the best objective to determine the next node\n        if best_obj == 0:\n            candidates = np.argsort(distance_matrix_1[node])\n        elif best_obj == 1:\n            candidates = np.argsort(distance_matrix_2[node])\n        else:\n            candidates = np.argsort(distance_matrix_3[node])\n\n        # Find the first candidate not already in the segment\n        for candidate in candidates:\n            if candidate not in segment:\n                reordered_segment.append(candidate)\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(reordered_segment) < segment_length:\n        missing = segment_length - len(reordered_segment)\n        remaining = [node for node in base_solution if node not in reordered_segment]\n        reordered_segment.extend(remaining[:missing])\n\n    # Insert the reordered segment into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = reordered_segment\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic node insertion strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically inserts nodes into different positions in the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive insertion criteria based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    for _ in range(5):\n        node_to_move = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        if current_pos == 0:\n            neighbors = [1, n-1]\n        elif current_pos == n-1:\n            neighbors = [0, n-2]\n        else:\n            neighbors = [current_pos-1, current_pos+1]\n\n        new_pos = np.random.choice(neighbors)\n\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_1[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_1[node_to_move, new_solution[(new_pos+1)%n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_2[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_2[node_to_move, new_solution[(new_pos+1)%n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_3[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_3[node_to_move, new_solution[(new_pos+1)%n]])\n\n        if potential_dist < current_dist or np.random.rand() < 0.3:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select two additional solutions for segment fusion\n    other_indices = np.random.choice([i for i in range(len(archive)) if i != selected_idx], size=2, replace=False)\n    sol1 = archive[other_indices[0]][0].copy()\n    sol2 = archive[other_indices[1]][0].copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from all three solutions\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    start3 = np.random.randint(0, n - segment_length)\n\n    # Create composite segment by fusing segments from all three solutions\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n    segment3 = sol2[start3:start3+segment_length]\n\n    # Alternate between segments to create composite segment\n    composite_segment = []\n    for i in range(segment_length):\n        composite_segment.append(segment1[i % len(segment1)])\n        composite_segment.append(segment2[i % len(segment2)])\n        composite_segment.append(segment3[i % len(segment3)])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Dispersed insertion of composite segment\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if fusion fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": "{The new algorithm introduces a multi-objective adaptive path reconstruction strategy that dynamically selects solutions based on their Pareto front proximity and objective diversity, then applies a novel three-phase path reconstruction operator that first decomposes the solution into critical path segments based on objective-specific distance contributions, then reconstructs these segments using a probabilistic insertion mechanism that prioritizes nodes with complementary objective improvements, and finally validates and repairs the solution through an adaptive segment merging mechanism that ensures feasibility while maintaining diversity in the solution space by incorporating a weighted combination of objective-specific distance matrices and an acceptance criterion that balances immediate improvement with long-term structural stability.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_diversity(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: pareto_diversity(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    weighted_distance = (objectives[0] * distance_matrix_1 + objectives[1] * distance_matrix_2 + objectives[2] * distance_matrix_3) / sum(objectives)\n\n    for _ in range(3):\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        new_segment = segment.copy()\n        for i in range(segment_length):\n            for j in range(i+1, segment_length):\n                if np.random.rand() < 0.5:\n                    new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n                    if weighted_distance[new_segment[i-1], new_segment[i]] + weighted_distance[new_segment[i], new_segment[(i+1)%segment_length]] < weighted_distance[segment[i-1], segment[i]] + weighted_distance[segment[i], segment[(i+1)%segment_length]]:\n                        break\n                    else:\n                        new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n\n        new_solution[start:start+segment_length] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7754057159286438,
               2.603820502758026
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_diversity(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: pareto_diversity(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    weighted_distance = (objectives[0] * distance_matrix_1 + objectives[1] * distance_matrix_2 + objectives[2] * distance_matrix_3) / sum(objectives)\n\n    for _ in range(3):\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        new_segment = segment.copy()\n        for i in range(segment_length):\n            for j in range(i+1, segment_length):\n                if np.random.rand() < 0.5:\n                    new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n                    if weighted_distance[new_segment[i-1], new_segment[i]] + weighted_distance[new_segment[i], new_segment[(i+1)%segment_length]] < weighted_distance[segment[i-1], segment[i]] + weighted_distance[segment[i], segment[(i+1)%segment_length]]:\n                        break\n                    else:\n                        new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n\n        new_solution[start:start+segment_length] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic segment rotation strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically rotates segments of the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment sizes based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best trade-off using dominance-based selection\n    def dominance_score(obj):\n        sorted_obj = sorted(obj)\n        return sorted_obj[1] - sorted_obj[0]  # Middle objective as trade-off indicator\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Step 3: Apply probabilistic segment rotation with adaptive size\n    for _ in range(3):\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate current and potential distances for the worst objective\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_1[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_1[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_1[new_solution[start], new_solution[end % n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_2[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_2[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_2[new_solution[start], new_solution[end % n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_3[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_3[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_3[new_solution[start], new_solution[end % n]])\n\n        # Rotate segment with probability based on improvement\n        if potential_dist < current_dist or np.random.rand() < 0.4:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure solution remains valid\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a tri-objective-aware adaptive segment fusion and inversion strategy that first selects solutions based on their combined objective improvement potential and diversity in the archive, then applies a hybrid local search that probabilistically fuses and inverts segments from multiple solutions in a way that optimizes all three objectives simultaneously while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment sizes based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel segment fusion mechanism that combines segments from multiple solutions to create a composite segment that is then reordered using a multi-objective-aware permutation algorithm.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_score(obj):\n        return sum(obj)\n\n    scores = [objective_score(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores)/sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    other_indices = np.random.choice([i for i in range(len(archive)) if i != selected_idx], size=2, replace=False)\n    sol1 = archive[other_indices[0]][0].copy()\n    sol2 = archive[other_indices[1]][0].copy()\n\n    segment_length = max(2, min(5, n // 3))\n\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    start3 = np.random.randint(0, n - segment_length)\n\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n    segment3 = sol2[start3:start3+segment_length]\n\n    composite_segment = np.concatenate([segment1, segment2, segment3])\n    composite_segment = np.unique(composite_segment)\n\n    if len(composite_segment) < segment_length:\n        remaining = [node for node in base_solution if node not in composite_segment]\n        composite_segment = np.concatenate([composite_segment, np.random.choice(remaining, size=segment_length-len(composite_segment), replace=False)])\n\n    np.random.shuffle(composite_segment)\n\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = composite_segment[:segment_length]\n\n    if np.random.rand() < 0.5:\n        inversion_start = np.random.randint(0, n - segment_length)\n        inversion_end = inversion_start + segment_length\n        new_solution[inversion_start:inversion_end] = new_solution[inversion_start:inversion_end][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    def combined_score(obj):\n        return np.sum(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two other solutions for segment fusion\n    other_indices = [i for i in range(len(archive)) if i != selected_idx]\n    if len(other_indices) < 2:\n        other_indices = other_indices * 2\n    sol1 = archive[np.random.choice(other_indices)][0].copy()\n    sol2 = archive[np.random.choice(other_indices)][0].copy()\n\n    # Determine segment length based on problem size\n    segment_length = max(2, min(5, n // 3))\n\n    # Extract segments from different solutions\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n\n    # Create a composite segment by combining and shuffling\n    composite_segment = np.concatenate([segment1, segment2])\n    composite_segment = np.unique(composite_segment)\n\n    # Ensure segment has correct length\n    if len(composite_segment) < segment_length:\n        remaining = [node for node in base_solution if node not in composite_segment]\n        composite_segment = np.concatenate([composite_segment, np.random.choice(remaining, size=segment_length-len(composite_segment), replace=False)])\n\n    # Shuffle the composite segment\n    np.random.shuffle(composite_segment)\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = composite_segment[:segment_length]\n\n    # Apply inversion with probability\n    if np.random.rand() < 0.5:\n        inversion_start = np.random.randint(0, n - segment_length)\n        inversion_end = inversion_start + segment_length\n        new_solution[inversion_start:inversion_end] = new_solution[inversion_start:inversion_end][::-1]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two nodes if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.672997008327906,
               1.8381816506385804
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    def combined_score(obj):\n        return np.sum(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two other solutions for segment fusion\n    other_indices = [i for i in range(len(archive)) if i != selected_idx]\n    if len(other_indices) < 2:\n        other_indices = other_indices * 2\n    sol1 = archive[np.random.choice(other_indices)][0].copy()\n    sol2 = archive[np.random.choice(other_indices)][0].copy()\n\n    # Determine segment length based on problem size\n    segment_length = max(2, min(5, n // 3))\n\n    # Extract segments from different solutions\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n\n    # Create a composite segment by combining and shuffling\n    composite_segment = np.concatenate([segment1, segment2])\n    composite_segment = np.unique(composite_segment)\n\n    # Ensure segment has correct length\n    if len(composite_segment) < segment_length:\n        remaining = [node for node in base_solution if node not in composite_segment]\n        composite_segment = np.concatenate([composite_segment, np.random.choice(remaining, size=segment_length-len(composite_segment), replace=False)])\n\n    # Shuffle the composite segment\n    np.random.shuffle(composite_segment)\n\n    # Insert the composite segment into a random position\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = composite_segment[:segment_length]\n\n    # Apply inversion with probability\n    if np.random.rand() < 0.5:\n        inversion_start = np.random.randint(0, n - segment_length)\n        inversion_end = inversion_start + segment_length\n        new_solution[inversion_start:inversion_end] = new_solution[inversion_start:inversion_end][::-1]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two nodes if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic node insertion strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically inserts nodes into different positions in the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive insertion criteria based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    for _ in range(5):\n        node_to_move = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        if current_pos == 0:\n            neighbors = [1, n-1]\n        elif current_pos == n-1:\n            neighbors = [0, n-2]\n        else:\n            neighbors = [current_pos-1, current_pos+1]\n\n        new_pos = np.random.choice(neighbors)\n\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_1[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_1[node_to_move, new_solution[(new_pos+1)%n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_2[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_2[node_to_move, new_solution[(new_pos+1)%n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_3[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_3[node_to_move, new_solution[(new_pos+1)%n]])\n\n        if potential_dist < current_dist or np.random.rand() < 0.3:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic segment rotation strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically rotates segments of the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment sizes based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best trade-off using dominance-based selection\n    def dominance_score(obj):\n        sorted_obj = sorted(obj)\n        return sorted_obj[1] - sorted_obj[0]  # Middle objective as trade-off indicator\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Step 3: Apply probabilistic segment rotation with adaptive size\n    for _ in range(3):\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate current and potential distances for the worst objective\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_1[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_1[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_1[new_solution[start], new_solution[end % n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_2[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_2[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_2[new_solution[start], new_solution[end % n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_3[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_3[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_3[new_solution[start], new_solution[end % n]])\n\n        # Rotate segment with probability based on improvement\n        if potential_dist < current_dist or np.random.rand() < 0.4:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure solution remains valid\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 307,
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic node swap strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically swaps pairs of nodes in the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive swap selection based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        sorted_obj = sorted(obj)\n        return sorted_obj[1] - sorted_obj[0]\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    for _ in range(5):\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            potential_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            potential_dist = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n            potential_dist = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                             distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if potential_dist < current_dist or np.random.rand() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8210163390989867,
               1.2223439455032348
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        sorted_obj = sorted(obj)\n        return sorted_obj[1] - sorted_obj[0]\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    for _ in range(5):\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            potential_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            potential_dist = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n            potential_dist = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                             distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if potential_dist < current_dist or np.random.rand() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic segment exchange strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically exchanges segments of the tour with segments from other high-quality solutions in the archive, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment size determination based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure, and dynamically adjusts the exchange probability based on the relative performance of each objective to balance exploitation and exploration across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    exchange_prob = 0.5 + 0.4 * (1 - objectives[worst_obj_idx] / sum(objectives))\n\n    for _ in range(3):\n        if np.random.rand() < exchange_prob:\n            donor_idx = np.random.choice(len(archive_sorted))\n            donor_solution = archive_sorted[donor_idx][0]\n\n            segment_length = max(2, min(5, n // 4))\n            start = np.random.randint(0, n - segment_length)\n            donor_start = np.random.randint(0, n - segment_length)\n\n            new_solution[start:start+segment_length] = donor_solution[donor_start:donor_start+segment_length]\n\n    if len(new_solution) != len(set(new_solution)):\n        for i in range(n):\n            if np.sum(new_solution == new_solution[i]) > 1:\n                duplicates = np.where(new_solution == new_solution[i])[0]\n                for j in duplicates[1:]:\n                    new_solution[j] = np.random.choice([x for x in range(n) if x not in new_solution])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic node insertion strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically inserts nodes into different positions in the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive insertion criteria based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    for _ in range(5):\n        node_to_move = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        if current_pos == 0:\n            neighbors = [1, n-1]\n        elif current_pos == n-1:\n            neighbors = [0, n-2]\n        else:\n            neighbors = [current_pos-1, current_pos+1]\n\n        new_pos = np.random.choice(neighbors)\n\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_1[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_1[node_to_move, new_solution[(new_pos+1)%n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_2[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_2[node_to_move, new_solution[(new_pos+1)%n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[current_pos-1], new_solution[current_pos]] +\n                           distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n            potential_dist = (distance_matrix_3[new_solution[new_pos-1], node_to_move] +\n                            distance_matrix_3[node_to_move, new_solution[(new_pos+1)%n]])\n\n        if potential_dist < current_dist or np.random.rand() < 0.3:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 308,
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic segment replacement strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically replaces segments of the tour with segments from other high-quality solutions in the archive, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment size determination based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure, and dynamically adjusts the replacement probability based on the relative performance of each objective to balance exploitation and exploration across all three objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    replacement_prob = 0.5 + 0.4 * (1 - objectives[worst_obj_idx] / sum(objectives))\n\n    for _ in range(3):\n        if np.random.rand() < replacement_prob:\n            donor_idx = np.random.choice(len(archive_sorted))\n            donor_solution = archive_sorted[donor_idx][0]\n\n            segment_length = max(2, min(5, n // 4))\n            start = np.random.randint(0, n - segment_length)\n            donor_start = np.random.randint(0, n - segment_length)\n\n            new_segment = donor_solution[donor_start:donor_start+segment_length]\n            new_solution[start:start+segment_length] = new_segment\n\n            if worst_obj_idx == 0:\n                current_dist = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_dist = (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start)) +\n                            sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(1, segment_length)) +\n                            sum(distance_matrix_1[new_solution[(start+segment_length+i-1)%n], new_solution[(start+segment_length+i)%n]] for i in range(n - segment_length)))\n            elif worst_obj_idx == 1:\n                current_dist = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_dist = (sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start)) +\n                            sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(1, segment_length)) +\n                            sum(distance_matrix_2[new_solution[(start+segment_length+i-1)%n], new_solution[(start+segment_length+i)%n]] for i in range(n - segment_length)))\n            else:\n                current_dist = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_dist = (sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(start)) +\n                            sum(distance_matrix_3[new_segment[i-1], new_segment[i]] for i in range(1, segment_length)) +\n                            sum(distance_matrix_3[new_solution[(start+segment_length+i-1)%n], new_solution[(start+segment_length+i)%n]] for i in range(n - segment_length)))\n\n            if new_dist >= current_dist and np.random.rand() > 0.3:\n                new_solution[start:start+segment_length] = base_solution[start:start+segment_length]\n\n    if len(new_solution) != len(set(new_solution)):\n        for i in range(n):\n            if np.sum(new_solution == new_solution[i]) > 1:\n                duplicates = np.where(new_solution == new_solution[i])[0]\n                for j in duplicates[1:]:\n                    new_solution[j] = np.random.choice([x for x in range(n) if x not in new_solution])\n\n    return new_solution\n\n",
          "score": [
               -0.7439663737475042,
               2.5583173036575317
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    replacement_prob = 0.5 + 0.4 * (1 - objectives[worst_obj_idx] / sum(objectives))\n\n    for _ in range(3):\n        if np.random.rand() < replacement_prob:\n            donor_idx = np.random.choice(len(archive_sorted))\n            donor_solution = archive_sorted[donor_idx][0]\n\n            segment_length = max(2, min(5, n // 4))\n            start = np.random.randint(0, n - segment_length)\n            donor_start = np.random.randint(0, n - segment_length)\n\n            new_segment = donor_solution[donor_start:donor_start+segment_length]\n            new_solution[start:start+segment_length] = new_segment\n\n            if worst_obj_idx == 0:\n                current_dist = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_dist = (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start)) +\n                            sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(1, segment_length)) +\n                            sum(distance_matrix_1[new_solution[(start+segment_length+i-1)%n], new_solution[(start+segment_length+i)%n]] for i in range(n - segment_length)))\n            elif worst_obj_idx == 1:\n                current_dist = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_dist = (sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start)) +\n                            sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(1, segment_length)) +\n                            sum(distance_matrix_2[new_solution[(start+segment_length+i-1)%n], new_solution[(start+segment_length+i)%n]] for i in range(n - segment_length)))\n            else:\n                current_dist = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_dist = (sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(start)) +\n                            sum(distance_matrix_3[new_segment[i-1], new_segment[i]] for i in range(1, segment_length)) +\n                            sum(distance_matrix_3[new_solution[(start+segment_length+i-1)%n], new_solution[(start+segment_length+i)%n]] for i in range(n - segment_length)))\n\n            if new_dist >= current_dist and np.random.rand() > 0.3:\n                new_solution[start:start+segment_length] = base_solution[start:start+segment_length]\n\n    if len(new_solution) != len(set(new_solution)):\n        for i in range(n):\n            if np.sum(new_solution == new_solution[i]) > 1:\n                duplicates = np.where(new_solution == new_solution[i])[0]\n                for j in duplicates[1:]:\n                    new_solution[j] = np.random.choice([x for x in range(n) if x not in new_solution])\n\n    return new_solution\n\n"
     }
]