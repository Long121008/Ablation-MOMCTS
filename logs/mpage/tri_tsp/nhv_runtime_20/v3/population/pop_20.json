[
     {
          "algorithm": "{The heuristic function 'select_neighbor' first evaluates the archive of non-dominated solutions by computing the total improvement potential for each solution across all three objectives, where improvement potential is defined as the sum of the normalized differences between the current solution's objectives and the best-known objectives in each space. It then intelligently selects a solution from the archive with a high probability proportional to its improvement potential, ensuring diversity in selection through a temperature-based stochastic process. The selected solution undergoes a novel hybrid local search operator that combines 2-opt edge swaps with a multi-objective-aware segment reversal, where the reversal is biased towards segments that show the most promising reduction in the worst objective value among the three. The operator ensures feasibility by strictly maintaining the permutation property of the tour, and the neighbor solution is validated to confirm it remains a valid TSP tour before being returned.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential for each solution\n    best_objectives = (\n        min(obj[0] for _, obj in archive),\n        min(obj[1] for _, obj in archive),\n        min(obj[2] for _, obj in archive)\n    )\n\n    potentials = []\n    for sol, obj in archive:\n        potential = 0\n        for i in range(3):\n            if obj[i] > best_objectives[i]:\n                potential += (obj[i] - best_objectives[i]) / obj[i]\n        potentials.append(potential)\n\n    # Select solution with probability proportional to potential\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        # If all potentials are zero, select randomly\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        probs = [p / total_potential for p in potentials]\n        selected_idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment reversal biased by worst objective\n    if n > 3:\n        # Calculate objective values for current solution\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        # Find worst objective\n        worst_obj_idx = np.argmax(current_obj)\n\n        # Select segment to reverse based on worst objective\n        if worst_obj_idx == 0:\n            dm = distance_matrix_1\n        elif worst_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find segment with maximum potential improvement\n        max_improvement = -float('inf')\n        best_i, best_j = 0, 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate current segment cost\n                current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n\n                # Calculate reversed segment cost\n                reversed_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n\n                improvement = current_cost - reversed_cost\n                if improvement > max_improvement:\n                    max_improvement = improvement\n                    best_i, best_j = i, j\n\n        if max_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment reversal fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8315603071959217,
               2.3074897646903993
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic segment rotation strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically rotates segments of the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment sizes based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best trade-off using dominance-based selection\n    def dominance_score(obj):\n        sorted_obj = sorted(obj)\n        return sorted_obj[1] - sorted_obj[0]  # Middle objective as trade-off indicator\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Step 3: Apply probabilistic segment rotation with adaptive size\n    for _ in range(3):\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate current and potential distances for the worst objective\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_1[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_1[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_1[new_solution[start], new_solution[end % n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_2[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_2[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_2[new_solution[start], new_solution[end % n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_3[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_3[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_3[new_solution[start], new_solution[end % n]])\n\n        # Rotate segment with probability based on improvement\n        if potential_dist < current_dist or np.random.rand() < 0.4:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure solution remains valid\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8139701195918058,
               2.0111894369125367
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best balance across all objectives\n    def balance_score(obj):\n        return max(obj) - min(obj)  # Prefer solutions with balanced objectives\n\n    archive_sorted = sorted(archive, key=lambda x: balance_score(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Apply adaptive k-opt with objective-aware edge selection\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine k based on solution quality and problem size\n    k = min(4, max(2, n // 10))  # Adaptive k based on problem size\n\n    # Select k random edges to modify\n    edges = np.random.choice(n, size=k, replace=False)\n    edges = sorted(edges)\n\n    # Create segments to reverse\n    segments = []\n    for i in range(len(edges)):\n        start = edges[i]\n        end = edges[(i+1)%len(edges)]\n        if start < end:\n            segments.append((start, end))\n        else:\n            segments.append((start, n))\n            segments.append((0, end))\n\n    # Apply segment reversals in order\n    for start, end in segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure solution remains valid\n    if not (len(new_solution) == len(selected) and len(np.unique(new_solution)) == len(selected)):\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.7786516214110818,
               1.7315683007240295
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select two additional solutions for segment fusion\n    other_indices = np.random.choice([i for i in range(len(archive)) if i != selected_idx], size=2, replace=False)\n    sol1 = archive[other_indices[0]][0].copy()\n    sol2 = archive[other_indices[1]][0].copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from all three solutions\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    start3 = np.random.randint(0, n - segment_length)\n\n    # Create composite segment by fusing segments from all three solutions\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n    segment3 = sol2[start3:start3+segment_length]\n\n    # Alternate between segments to create composite segment\n    composite_segment = []\n    for i in range(segment_length):\n        composite_segment.append(segment1[i % len(segment1)])\n        composite_segment.append(segment2[i % len(segment2)])\n        composite_segment.append(segment3[i % len(segment3)])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Dispersed insertion of composite segment\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if fusion fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n",
          "score": [
               -0.7684475373833937,
               0.989448344707489
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive while introducing a novel approach that combines multi-objective optimization with a probabilistic edge-swap strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically swaps edges of the tour in a way that optimizes the combined objective space while maintaining feasibility, using an adaptive weighting scheme to balance the trade-offs between objectives and ensuring diversity through dynamic edge-selection criteria that are determined by the current objective values, with a special focus on improving the most underperforming objective in each iteration, while also incorporating a novel edge-swap acceptance mechanism that considers both the immediate improvement and the potential long-term impact on the tour structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best trade-off using dominance-based selection\n    def dominance_score(obj):\n        return sum(obj) - min(obj) - max(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Step 3: Apply probabilistic edge-swap with adaptive criteria\n    for _ in range(5):\n        # Select two edges to swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2 or abs(i - j) > n - 2:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Current edges: (i-1, i) and (j, j+1)\n        # Potential edges: (i-1, j) and (i, j+1)\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]])\n            potential_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[i], new_solution[j-1]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n            potential_dist = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[i], new_solution[j-1]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]])\n            potential_dist = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n        # Accept swap with probability based on improvement and long-term impact\n        improvement = current_dist - potential_dist\n        if improvement > 0 or np.random.rand() < 0.3:\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Periodic validation\n        if np.random.rand() < 0.1:\n            if len(new_solution) != len(set(new_solution)):\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8084498948603052,
               1.7770869851112365
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select two additional solutions for segment fusion\n    other_indices = np.random.choice([i for i in range(len(archive)) if i != selected_idx], size=2, replace=False)\n    sol1 = archive[other_indices[0]][0].copy()\n    sol2 = archive[other_indices[1]][0].copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from all three solutions\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    start3 = np.random.randint(0, n - segment_length)\n\n    # Create composite segment by fusing segments from all three solutions\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n    segment3 = sol2[start3:start3+segment_length]\n\n    # Alternate between segments to create composite segment\n    composite_segment = []\n    for i in range(segment_length):\n        composite_segment.append(segment1[i % len(segment1)])\n        composite_segment.append(segment2[i % len(segment2)])\n        composite_segment.append(segment3[i % len(segment3)])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Dispersed insertion of composite segment\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if fusion fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n",
          "score": [
               -0.6790159873569311,
               0.7484390020370484
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment permutation and reordering strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first identifies critical segments from multiple solutions to create a composite segment, then reorders this composite segment using a multi-objective-aware permutation algorithm that considers the relative performance of each objective, and finally integrates the reordered segment into the base solution while maintaining feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, while balancing exploitation of promising regions with exploration of the solution space by adaptively adjusting the permutation and integration parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_score(obj):\n        return sum(obj)\n\n    scores = [objective_score(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores)/sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    other_indices = np.random.choice([i for i in range(len(archive)) if i != selected_idx], size=2, replace=False)\n    sol1 = archive[other_indices[0]][0].copy()\n    sol2 = archive[other_indices[1]][0].copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    start3 = np.random.randint(0, n - segment_length)\n\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n    segment3 = sol2[start3:start3+segment_length]\n\n    composite_segment = np.concatenate([segment1, segment2, segment3])\n    composite_segment = np.unique(composite_segment)\n    np.random.shuffle(composite_segment)\n\n    if len(composite_segment) < segment_length:\n        remaining = [node for node in base_solution if node not in composite_segment]\n        composite_segment = np.concatenate([composite_segment, np.random.choice(remaining, size=segment_length-len(composite_segment), replace=False)])\n\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = composite_segment[:segment_length]\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.6520824907316697,
               0.6368107795715332
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select two additional solutions for segment fusion\n    other_indices = np.random.choice([i for i in range(len(archive)) if i != selected_idx], size=2, replace=False)\n    sol1 = archive[other_indices[0]][0].copy()\n    sol2 = archive[other_indices[1]][0].copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segments from all three solutions\n    start1 = np.random.randint(0, n - segment_length)\n    start2 = np.random.randint(0, n - segment_length)\n    start3 = np.random.randint(0, n - segment_length)\n\n    # Create composite segment by fusing segments from all three solutions\n    segment1 = base_solution[start1:start1+segment_length]\n    segment2 = sol1[start2:start2+segment_length]\n    segment3 = sol2[start3:start3+segment_length]\n\n    # Alternate between segments to create composite segment\n    composite_segment = []\n    for i in range(segment_length):\n        composite_segment.append(segment1[i % len(segment1)])\n        composite_segment.append(segment2[i % len(segment2)])\n        composite_segment.append(segment3[i % len(segment3)])\n\n    # Remove duplicates while preserving order\n    unique_composite = []\n    seen = set()\n    for node in composite_segment:\n        if node not in seen:\n            seen.add(node)\n            unique_composite.append(node)\n            if len(unique_composite) == segment_length:\n                break\n\n    # Ensure we have exactly segment_length nodes\n    if len(unique_composite) < segment_length:\n        missing = segment_length - len(unique_composite)\n        remaining = [node for node in base_solution if node not in seen]\n        unique_composite.extend(remaining[:missing])\n\n    # Dispersed insertion of composite segment\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = unique_composite\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if fusion fails\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n",
          "score": [
               -0.7362026885211979,
               0.7587544083595276
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a tri-objective-aware adaptive segment fusion and dispersion strategy that dynamically selects solutions based on their combined objective improvement potential, then applies a novel three-phase transformation operator that first fuses segments from multiple solutions to create a composite segment, then disperses this composite segment back into the base solution in a non-overlapping manner, while incorporating an adaptive segment fusion mechanism that prioritizes segments with complementary strengths across all three objectives, and maintains feasibility through a multi-phase validation and repair mechanism that ensures no node is skipped or revisited, and balances exploitation of promising regions with exploration of the solution space by adaptively adjusting the fusion and dispersion parameters based on the relative performance of each objective across the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective improvement potential\n    def improvement_potential(obj):\n        return sum(obj)\n\n    potentials = [improvement_potential(obj) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(potentials)/sum(potentials))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 3))\n\n    # Select random segment from base solution\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start+segment_length]\n\n    # Create multiple variations of the segment\n    variations = []\n    for _ in range(3):\n        # Randomly shuffle the segment\n        shuffled = segment.copy()\n        np.random.shuffle(shuffled)\n        variations.append(shuffled)\n\n    # Evaluate each variation across all objectives\n    def evaluate_segment(seg):\n        total_cost = 0\n        for i in range(len(seg)-1):\n            total_cost += distance_matrix_1[seg[i], seg[i+1]]\n            total_cost += distance_matrix_2[seg[i], seg[i+1]]\n            total_cost += distance_matrix_3[seg[i], seg[i+1]]\n        return total_cost\n\n    # Select the best variation\n    best_variation = min(variations, key=lambda x: evaluate_segment(x))\n\n    # Insert the best variation back into the solution\n    insertion_point = np.random.randint(0, n - segment_length)\n    new_solution[insertion_point:insertion_point+segment_length] = best_variation\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if invalid\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[insertion_point:insertion_point+segment_length]\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[insertion_point:insertion_point+segment_length] = new_segment\n\n    return new_solution\n\n",
          "score": [
               -0.6155838848606077,
               0.6695795655250549
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best harmonic mean of objectives\n    def harmonic_mean(obj):\n        return 3 / (1/obj[0] + 1/obj[1] + 1/obj[2])\n\n    archive_sorted = sorted(archive, key=lambda x: -harmonic_mean(x[1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Create combined distance matrix as weighted sum\n    weights = [1.0, 1.0, 1.0]\n    combined_matrix = (weights[0] * distance_matrix_1 +\n                      weights[1] * distance_matrix_2 +\n                      weights[2] * distance_matrix_3)\n\n    # Step 3: Probabilistic path reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        segment_length = np.random.randint(3, min(8, n//2))\n        start = np.random.randint(0, n - segment_length)\n\n        # Create probability distribution based on combined matrix\n        current_node = new_solution[start - 1] if start > 0 else new_solution[-1]\n        next_nodes = [node for node in new_solution[start:start+segment_length] if node != current_node]\n\n        if not next_nodes:\n            continue\n\n        # Calculate probabilities based on inverse distance\n        inv_distances = [1.0 / (combined_matrix[current_node, node] + 1e-6) for node in next_nodes]\n        probs = np.array(inv_distances) / sum(inv_distances)\n\n        # Sample new path\n        new_path = np.random.choice(next_nodes, size=segment_length, p=probs, replace=False)\n        new_solution[start:start+segment_length] = new_path\n\n        # Validate and repair\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple rotation if reconstruction fails\n            rotation = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_length] = new_segment\n\n    return new_solution\n\n",
          "score": [
               -0.7749293230400874,
               3.0253418564796446
          ]
     }
]