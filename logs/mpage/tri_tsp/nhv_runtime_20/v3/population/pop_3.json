[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on combined objective values\n    def combined_objective(obj):\n        return sum(obj)  # Simple sum for selection, could be more sophisticated\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform dynamic 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap if beneficial\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains valid\n    if not (len(new_solution) == len(selected) and len(np.unique(new_solution)) == len(selected)):\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7226799320627262,
               0.9984525322914124
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first evaluates the archive of non-dominated solutions by computing the total improvement potential for each solution across all three objectives, where improvement potential is defined as the sum of the normalized differences between the current solution's objectives and the best-known objectives in each space. It then intelligently selects a solution from the archive with a high probability proportional to its improvement potential, ensuring diversity in selection through a temperature-based stochastic process. The selected solution undergoes a novel hybrid local search operator that combines 2-opt edge swaps with a multi-objective-aware segment reversal, where the reversal is biased towards segments that show the most promising reduction in the worst objective value among the three. The operator ensures feasibility by strictly maintaining the permutation property of the tour, and the neighbor solution is validated to confirm it remains a valid TSP tour before being returned.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential for each solution\n    best_objectives = (\n        min(obj[0] for _, obj in archive),\n        min(obj[1] for _, obj in archive),\n        min(obj[2] for _, obj in archive)\n    )\n\n    potentials = []\n    for sol, obj in archive:\n        potential = 0\n        for i in range(3):\n            if obj[i] > best_objectives[i]:\n                potential += (obj[i] - best_objectives[i]) / obj[i]\n        potentials.append(potential)\n\n    # Select solution with probability proportional to potential\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        # If all potentials are zero, select randomly\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        probs = [p / total_potential for p in potentials]\n        selected_idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment reversal biased by worst objective\n    if n > 3:\n        # Calculate objective values for current solution\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        # Find worst objective\n        worst_obj_idx = np.argmax(current_obj)\n\n        # Select segment to reverse based on worst objective\n        if worst_obj_idx == 0:\n            dm = distance_matrix_1\n        elif worst_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find segment with maximum potential improvement\n        max_improvement = -float('inf')\n        best_i, best_j = 0, 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate current segment cost\n                current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n\n                # Calculate reversed segment cost\n                reversed_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n\n                improvement = current_cost - reversed_cost\n                if improvement > max_improvement:\n                    max_improvement = improvement\n                    best_i, best_j = i, j\n\n        if max_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment reversal fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8315603071959217,
               2.3074897646903993
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[(i+1)%len(solution)]] for i in range(len(solution)))\n        obj2 = sum(distance_matrix_2[solution[i], solution[(i+1)%len(solution)]] for i in range(len(solution)))\n        obj3 = sum(distance_matrix_3[solution[i], solution[(i+1)%len(solution)]] for i in range(len(solution)))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge swapping\n    for _ in range(10):  # Number of attempts\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try different operators\n        operators = [\n            lambda: new_solution[i:j+1],  # 2-opt\n            lambda: np.concatenate([new_solution[:i], new_solution[j:i-1:-1], new_solution[j+1:]]),  # 3-opt\n            lambda: np.concatenate([new_solution[:i], new_solution[j-1:i-1:-1], new_solution[j+1:]]),  # Modified 3-opt\n        ]\n\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for op in operators:\n            candidate = op()\n            candidate_obj = calculate_objective(candidate)\n\n            # Calculate improvement in worst objective\n            improvements = [current_obj[k] - candidate_obj[k] for k in range(3)]\n            worst_improvement = min(improvements)\n\n            if worst_improvement > best_improvement:\n                best_improvement = worst_improvement\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n            current_obj = calculate_objective(new_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.7643906253808396,
               1.5996400952339171
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic edge insertion strategy. It first identifies the most promising solution by evaluating a hypervolume indicator that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically inserts nodes in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through random restarts when local optima are encountered.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hypervolume contribution for each solution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    hypervolume = np.prod(normalized_objectives, axis=1)\n    best_idx = np.argmax(hypervolume)\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Probabilistic edge insertion strategy\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Calculate weighted distance change\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]])\n\n        # Insert with probability based on improvement\n        if new_dist < old_dist or np.random.rand() < 0.3:\n            # Insert node j after i\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[i+1:]])\n\n        # Ensure solution remains valid\n        if len(new_solution) != len(set(new_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7984761442158479,
               2.1160239815711974
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to compare across different scales\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate a weighted sum of normalized objectives to find the most promising solution\n    weights = np.array([0.3, 0.3, 0.4])  # Higher weight for the third objective\n    scores = np.dot(normalized_objectives, weights)\n    best_idx = np.argmin(scores)  # Minimize the weighted sum\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware swap\n            # Calculate the marginal gain for each objective\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure the solution remains valid\n        if len(new_solution) != len(set(new_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.647457655868909,
               1.414842391014099
          ]
     },
     {
          "algorithm": "{The new algorithm will first analyze the archive to identify solutions with low objective values in at least two of the three objectives, then prioritize them based on a dynamic weight that balances the trade-off between objectives, and apply a novel multi-objective local search operator that combines 2-opt moves with objective-aware node relocations, ensuring feasibility by maintaining a permutation of nodes and periodically validating the solution structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify solutions with low values in at least two objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    good_solutions = [i for i, obj in enumerate(normalized_objectives) if sum(obj < 0.5) >= 2]\n\n    if not good_solutions:\n        good_solutions = list(range(len(archive)))\n\n    # Select a solution with dynamic weight\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = np.dot(normalized_objectives[good_solutions], weights)\n    best_idx = good_solutions[np.argmin(scores)]\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply multi-objective local search\n    n = len(new_solution)\n    for _ in range(10):\n        # Perform 2-opt move with probability 0.6\n        if np.random.random() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware node relocation\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i != j:\n                # Calculate marginal gain for each objective\n                old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n                if new_cost < old_cost:\n                    # Perform the relocation\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n        # Periodically validate solution\n        if len(new_solution) != len(set(new_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8011113576554385,
               3.2020750880241393
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion based on multi-objective improvement\n    if np.random.rand() > 0.5:\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n        # Calculate objective improvements\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7186977737052327,
               1.424633300304413
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best trade-off between objectives\n    def tradeoff_score(obj):\n        return max(obj) - min(obj)  # Prefer solutions with balanced objectives\n\n    archive_sorted = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 4 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Calculate objective improvement potential\n    def improvement_potential(sol, obj):\n        # Calculate potential improvement for each objective\n        total_lengths = [\n            sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]],\n            sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]],\n            sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_3[sol[-1], sol[0]]\n        ]\n        return sum(total_lengths[i] - obj[i] for i in range(3))\n\n    # Step 3: Apply dynamic local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective balance\n    if tradeoff_score(archive[selected_idx][1]) < 0.5 * max(tradeoff_score(x[1]) for x in archive):\n        # For well-balanced solutions, do focused segment inversion\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # For unbalanced solutions, do more exploratory edge exchanges\n        for _ in range(3):\n            a, b = sorted(np.random.choice(range(n), 2, replace=False))\n            if a != b and abs(a - b) > 1:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validate the new solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7959209584078358,
               2.3082932353019716
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: 2-opt swap with multi-objective awareness\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i != j:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        # Check if candidate is better in at least two objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_obj = calculate_objective(new_solution)\n        candidate_obj = calculate_objective(candidate)\n\n        improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n        if improvements >= 2:\n            new_solution = candidate\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        # Select a random segment to remove\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Try to reinsert the segment in a better position\n        for _ in range(5):  # Limited attempts to maintain efficiency\n            pos = np.random.randint(0, n)\n            if pos not in range(a, b+1):\n                candidate = np.concatenate([new_solution[:a], new_solution[b+1:pos], segment, new_solution[pos:]])\n                candidate_obj = calculate_objective(candidate)\n\n                improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n                if improvements >= 2:\n                    new_solution = candidate\n                    break\n\n    # Step 3: Segment reversal with multi-objective check\n    if n > 2:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[b:a-1 if a > 0 else None:-1]\n\n        candidate_obj = calculate_objective(candidate)\n        improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n        if improvements >= 2:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               -0.7393179117733077,
               2.062208342552185
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in its objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator inspired by the \"k-opt\" family but with a focus on multi-objective improvement\n    n = len(new_solution)\n    k = np.random.randint(3, min(6, n))  # Randomly choose between 3-opt to 5-opt\n\n    # Select k random distinct positions in the tour\n    indices = np.random.choice(n, size=k, replace=False)\n    indices.sort()\n\n    # Extract the segment and apply a cycle reversal\n    segment = new_solution[indices]\n    new_segment = np.roll(segment, 1)  # Simple rotation to maintain feasibility\n\n    # Replace the segment in the solution\n    new_solution[indices] = new_segment\n\n    # Ensure the solution remains valid\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.771498043442395,
               2.2705294132232665
          ]
     }
]