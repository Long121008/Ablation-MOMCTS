[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on combined objective values\n    def combined_objective(obj):\n        return sum(obj)  # Simple sum for selection, could be more sophisticated\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform dynamic 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap if beneficial\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains valid\n    if not (len(new_solution) == len(selected) and len(np.unique(new_solution)) == len(selected)):\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7226799320627262,
               0.9984525322914124
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first evaluates the archive of non-dominated solutions by computing the total improvement potential for each solution across all three objectives, where improvement potential is defined as the sum of the normalized differences between the current solution's objectives and the best-known objectives in each space. It then intelligently selects a solution from the archive with a high probability proportional to its improvement potential, ensuring diversity in selection through a temperature-based stochastic process. The selected solution undergoes a novel hybrid local search operator that combines 2-opt edge swaps with a multi-objective-aware segment reversal, where the reversal is biased towards segments that show the most promising reduction in the worst objective value among the three. The operator ensures feasibility by strictly maintaining the permutation property of the tour, and the neighbor solution is validated to confirm it remains a valid TSP tour before being returned.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential for each solution\n    best_objectives = (\n        min(obj[0] for _, obj in archive),\n        min(obj[1] for _, obj in archive),\n        min(obj[2] for _, obj in archive)\n    )\n\n    potentials = []\n    for sol, obj in archive:\n        potential = 0\n        for i in range(3):\n            if obj[i] > best_objectives[i]:\n                potential += (obj[i] - best_objectives[i]) / obj[i]\n        potentials.append(potential)\n\n    # Select solution with probability proportional to potential\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        # If all potentials are zero, select randomly\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        probs = [p / total_potential for p in potentials]\n        selected_idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment reversal biased by worst objective\n    if n > 3:\n        # Calculate objective values for current solution\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        # Find worst objective\n        worst_obj_idx = np.argmax(current_obj)\n\n        # Select segment to reverse based on worst objective\n        if worst_obj_idx == 0:\n            dm = distance_matrix_1\n        elif worst_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find segment with maximum potential improvement\n        max_improvement = -float('inf')\n        best_i, best_j = 0, 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate current segment cost\n                current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n\n                # Calculate reversed segment cost\n                reversed_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n\n                improvement = current_cost - reversed_cost\n                if improvement > max_improvement:\n                    max_improvement = improvement\n                    best_i, best_j = i, j\n\n        if max_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment reversal fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8315603071959217,
               2.3074897646903993
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[(i+1)%len(solution)]] for i in range(len(solution)))\n        obj2 = sum(distance_matrix_2[solution[i], solution[(i+1)%len(solution)]] for i in range(len(solution)))\n        obj3 = sum(distance_matrix_3[solution[i], solution[(i+1)%len(solution)]] for i in range(len(solution)))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge swapping\n    for _ in range(10):  # Number of attempts\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try different operators\n        operators = [\n            lambda: new_solution[i:j+1],  # 2-opt\n            lambda: np.concatenate([new_solution[:i], new_solution[j:i-1:-1], new_solution[j+1:]]),  # 3-opt\n            lambda: np.concatenate([new_solution[:i], new_solution[j-1:i-1:-1], new_solution[j+1:]]),  # Modified 3-opt\n        ]\n\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for op in operators:\n            candidate = op()\n            candidate_obj = calculate_objective(candidate)\n\n            # Calculate improvement in worst objective\n            improvements = [current_obj[k] - candidate_obj[k] for k in range(3)]\n            worst_improvement = min(improvements)\n\n            if worst_improvement > best_improvement:\n                best_improvement = worst_improvement\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n            current_obj = calculate_objective(new_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.7643906253808396,
               1.5996400952339171
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic segment rotation strategy. It first identifies the most promising solution by evaluating a dominance-based selection that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically rotates segments of the tour in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through adaptive segment sizes based on objective trade-offs, with a special focus on improving the most underperforming objective in each iteration.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with best trade-off using dominance-based selection\n    def dominance_score(obj):\n        sorted_obj = sorted(obj)\n        return sorted_obj[1] - sorted_obj[0]  # Middle objective as trade-off indicator\n\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Step 3: Apply probabilistic segment rotation with adaptive size\n    for _ in range(3):\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate current and potential distances for the worst objective\n        if worst_obj_idx == 0:\n            current_dist = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_1[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_1[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_1[new_solution[start], new_solution[end % n]])\n        elif worst_obj_idx == 1:\n            current_dist = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_2[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_2[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_2[new_solution[start], new_solution[end % n]])\n        else:\n            current_dist = (distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                           distance_matrix_3[new_solution[end-1], new_solution[end % n]])\n            potential_dist = (distance_matrix_3[new_solution[start-1], new_solution[end-1]] +\n                             distance_matrix_3[new_solution[start], new_solution[end % n]])\n\n        # Rotate segment with probability based on improvement\n        if potential_dist < current_dist or np.random.rand() < 0.4:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure solution remains valid\n    if len(new_solution) != len(set(new_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8139701195918058,
               2.0111894369125367
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion based on multi-objective improvement\n    if np.random.rand() > 0.5:\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n        # Calculate objective improvements\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7186977737052327,
               1.424633300304413
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of evaluating solutions based on objective improvement potential with a novel multi-objective-aware segment insertion operator that adaptively chooses segments to insert based on the relative dominance of each objective, while ensuring feasibility through careful permutation validation and incorporating a diversity-preserving mechanism that selectively reintroduces previously explored segments when local optima are encountered, thereby balancing exploitation of promising regions with exploration of the solution space to maintain population diversity across all objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective dominance scores\n    dominance_scores = []\n    for sol, obj in archive:\n        dominance = [0, 0, 0]\n        for i in range(3):\n            for j in range(3):\n                if obj[i] < obj[j]:\n                    dominance[i] += 1\n        dominance_scores.append(sum(dominance))\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate objective-specific segment potential\n    def segment_potential(sol, obj_idx):\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        total = 0\n        n = len(sol)\n        for i in range(n):\n            total += dm[sol[i-1], sol[i]]\n        return total\n\n    # Find the objective with the highest potential for improvement\n    potentials = [segment_potential(base_solution, i) for i in range(3)]\n    worst_obj = np.argmax(potentials)\n\n    # Apply adaptive segment insertion based on worst objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the best segment to insert\n    max_improvement = -float('inf')\n    best_i, best_j = 0, 0\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):  # Limit segment length for efficiency\n            # Calculate current segment cost\n            current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n\n            # Calculate inserted segment cost\n            inserted_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n\n            improvement = current_cost - inserted_cost\n            if improvement > max_improvement:\n                max_improvement = improvement\n                best_i, best_j = i, j\n\n    if max_improvement > 0:\n        # Perform segment insertion\n        segment = new_solution[best_i:best_j+1]\n        new_solution = np.concatenate([new_solution[:best_i], segment, new_solution[best_i:best_j+1], new_solution[best_j+1:]])\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.7157872328264562,
               1.2665020823478699
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from the archive and applying local search operators, but introduces a novel approach by combining multi-objective optimization with a probabilistic edge insertion strategy. It first identifies the most promising solution by evaluating a hypervolume indicator that considers all three objectives simultaneously, then applies a hybrid local search that probabilistically inserts nodes in a way that optimizes the combined objective space while maintaining feasibility, using a weighted combination of distance matrices to guide the search and ensuring diversity through random restarts when local optima are encountered.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hypervolume contribution for each solution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    hypervolume = np.prod(normalized_objectives, axis=1)\n    best_idx = np.argmax(hypervolume)\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Probabilistic edge insertion strategy\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Calculate weighted distance change\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]])\n\n        # Insert with probability based on improvement\n        if new_dist < old_dist or np.random.rand() < 0.3:\n            # Insert node j after i\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[i+1:]])\n\n        # Ensure solution remains valid\n        if len(new_solution) != len(set(new_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7984761442158479,
               2.1160239815711974
          ]
     },
     {
          "algorithm": "{The new algorithm will first analyze the archive to identify solutions with low objective values in at least two of the three objectives, then prioritize them based on a dynamic weight that balances the trade-off between objectives, and apply a novel multi-objective local search operator that combines 2-opt moves with objective-aware node relocations, ensuring feasibility by maintaining a permutation of nodes and periodically validating the solution structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify solutions with low values in at least two objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    good_solutions = [i for i, obj in enumerate(normalized_objectives) if sum(obj < 0.5) >= 2]\n\n    if not good_solutions:\n        good_solutions = list(range(len(archive)))\n\n    # Select a solution with dynamic weight\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = np.dot(normalized_objectives[good_solutions], weights)\n    best_idx = good_solutions[np.argmin(scores)]\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply multi-objective local search\n    n = len(new_solution)\n    for _ in range(10):\n        # Perform 2-opt move with probability 0.6\n        if np.random.random() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware node relocation\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i != j:\n                # Calculate marginal gain for each objective\n                old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n                if new_cost < old_cost:\n                    # Perform the relocation\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n        # Periodically validate solution\n        if len(new_solution) != len(set(new_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8011113576554385,
               3.2020750880241393
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: 2-opt swap with multi-objective awareness\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i != j:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        # Check if candidate is better in at least two objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_obj = calculate_objective(new_solution)\n        candidate_obj = calculate_objective(candidate)\n\n        improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n        if improvements >= 2:\n            new_solution = candidate\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        # Select a random segment to remove\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Try to reinsert the segment in a better position\n        for _ in range(5):  # Limited attempts to maintain efficiency\n            pos = np.random.randint(0, n)\n            if pos not in range(a, b+1):\n                candidate = np.concatenate([new_solution[:a], new_solution[b+1:pos], segment, new_solution[pos:]])\n                candidate_obj = calculate_objective(candidate)\n\n                improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n                if improvements >= 2:\n                    new_solution = candidate\n                    break\n\n    # Step 3: Segment reversal with multi-objective check\n    if n > 2:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[b:a-1 if a > 0 else None:-1]\n\n        candidate_obj = calculate_objective(candidate)\n        improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n        if improvements >= 2:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               -0.7393179117733077,
               2.062208342552185
          ]
     },
     {
          "algorithm": "{The new algorithm combines the multi-objective selection strategy from Algorithm 1 with the objective-aware edge swapping from Algorithm 2, but instead of using traditional local search operators, it employs a novel \"objective-aware segment rotation\" approach. This involves selecting a segment of nodes, rotating it in a direction that minimizes the worst-case objective improvement, and reinserting it at a position that maximizes the total improvement across all objectives. The algorithm prioritizes solutions with high potential for improvement by selecting from the archive with a probability distribution that favors better solutions, while ensuring the generated neighbor remains feasible through careful segment manipulation and validation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment rotation and reinsertion\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment_length = b - a + 1\n        segment = new_solution[a:b+1]\n\n        # Determine rotation direction based on worst objective improvement\n        rotated_left = np.concatenate([segment[1:], [segment[0]]])\n        rotated_right = np.concatenate([[segment[-1]], segment[:-1]])\n\n        # Create candidate solutions\n        candidates = [\n            np.concatenate([new_solution[:a], rotated_left, new_solution[b+1:]]),\n            np.concatenate([new_solution[:a], rotated_right, new_solution[b+1:]])\n        ]\n\n        # Evaluate candidates\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for candidate in candidates:\n            candidate_obj = calculate_objective(candidate)\n            improvements = [current_obj[k] - candidate_obj[k] for k in range(3)]\n            worst_improvement = min(improvements)\n            total_improvement = sum(improvements)\n\n            # Prioritize candidates that improve the worst objective and maximize total improvement\n            if worst_improvement > best_improvement or (worst_improvement == best_improvement and total_improvement > best_improvement):\n                best_improvement = worst_improvement\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Try reinserting the segment at a different position\n        for _ in range(3):\n            pos = np.random.randint(0, n)\n            if pos not in range(a, b+1):\n                candidate = np.concatenate([new_solution[:a], new_solution[b+1:pos], segment, new_solution[pos:]])\n                candidate_obj = calculate_objective(candidate)\n                improvements = [current_obj[k] - candidate_obj[k] for k in range(3)]\n                worst_improvement = min(improvements)\n                total_improvement = sum(improvements)\n\n                if worst_improvement > 0 or (worst_improvement == 0 and total_improvement > 0):\n                    new_solution = candidate\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8123079175884657,
               3.6478265643119814
          ]
     }
]