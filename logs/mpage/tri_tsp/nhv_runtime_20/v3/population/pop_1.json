[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on combined objective values\n    def combined_objective(obj):\n        return sum(obj)  # Simple sum for selection, could be more sophisticated\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform dynamic 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap if beneficial\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains valid\n    if not (len(new_solution) == len(selected) and len(np.unique(new_solution)) == len(selected)):\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7226799320627262,
               0.9984525322914124
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first evaluates the archive of non-dominated solutions by computing the total improvement potential for each solution across all three objectives, where improvement potential is defined as the sum of the normalized differences between the current solution's objectives and the best-known objectives in each space. It then intelligently selects a solution from the archive with a high probability proportional to its improvement potential, ensuring diversity in selection through a temperature-based stochastic process. The selected solution undergoes a novel hybrid local search operator that combines 2-opt edge swaps with a multi-objective-aware segment reversal, where the reversal is biased towards segments that show the most promising reduction in the worst objective value among the three. The operator ensures feasibility by strictly maintaining the permutation property of the tour, and the neighbor solution is validated to confirm it remains a valid TSP tour before being returned.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential for each solution\n    best_objectives = (\n        min(obj[0] for _, obj in archive),\n        min(obj[1] for _, obj in archive),\n        min(obj[2] for _, obj in archive)\n    )\n\n    potentials = []\n    for sol, obj in archive:\n        potential = 0\n        for i in range(3):\n            if obj[i] > best_objectives[i]:\n                potential += (obj[i] - best_objectives[i]) / obj[i]\n        potentials.append(potential)\n\n    # Select solution with probability proportional to potential\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        # If all potentials are zero, select randomly\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        probs = [p / total_potential for p in potentials]\n        selected_idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment reversal biased by worst objective\n    if n > 3:\n        # Calculate objective values for current solution\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        # Find worst objective\n        worst_obj_idx = np.argmax(current_obj)\n\n        # Select segment to reverse based on worst objective\n        if worst_obj_idx == 0:\n            dm = distance_matrix_1\n        elif worst_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find segment with maximum potential improvement\n        max_improvement = -float('inf')\n        best_i, best_j = 0, 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate current segment cost\n                current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n\n                # Calculate reversed segment cost\n                reversed_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n\n                improvement = current_cost - reversed_cost\n                if improvement > max_improvement:\n                    max_improvement = improvement\n                    best_i, best_j = i, j\n\n        if max_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment reversal fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8315603071959217,
               2.3074897646903993
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: 2-opt swap with multi-objective awareness\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i != j:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        # Check if candidate is better in at least two objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_obj = calculate_objective(new_solution)\n        candidate_obj = calculate_objective(candidate)\n\n        improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n        if improvements >= 2:\n            new_solution = candidate\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        # Select a random segment to remove\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Try to reinsert the segment in a better position\n        for _ in range(5):  # Limited attempts to maintain efficiency\n            pos = np.random.randint(0, n)\n            if pos not in range(a, b+1):\n                candidate = np.concatenate([new_solution[:a], new_solution[b+1:pos], segment, new_solution[pos:]])\n                candidate_obj = calculate_objective(candidate)\n\n                improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n                if improvements >= 2:\n                    new_solution = candidate\n                    break\n\n    # Step 3: Segment reversal with multi-objective check\n    if n > 2:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[b:a-1 if a > 0 else None:-1]\n\n        candidate_obj = calculate_objective(candidate)\n        improvements = sum([1 for a, b in zip(original_obj, candidate_obj) if b < a])\n        if improvements >= 2:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               -0.7393179117733077,
               2.062208342552185
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion based on multi-objective improvement\n    if np.random.rand() > 0.5:\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n        # Calculate objective improvements\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7186977737052327,
               1.424633300304413
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator (simplified for demonstration)\n    # In practice, implement a more sophisticated operator\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid TSP tour\n    # This is a simplified check; in practice, implement a more robust validation\n    if len(set(new_solution)) != n:\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.6857427945934585,
               1.4224166989326477
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to compare across different scales\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate a weighted sum of normalized objectives to find the most promising solution\n    weights = np.array([0.3, 0.3, 0.4])  # Higher weight for the third objective\n    scores = np.dot(normalized_objectives, weights)\n    best_idx = np.argmin(scores)  # Minimize the weighted sum\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware swap\n            # Calculate the marginal gain for each objective\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure the solution remains valid\n        if len(new_solution) != len(set(new_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.647457655868909,
               1.414842391014099
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Score each solution in the archive based on potential for improvement\n    scores = []\n    for sol, obj in archive:\n        # Calculate the sum of objective values\n        total_obj = sum(obj)\n        # Calculate the diversity of the neighborhood (simplified)\n        diversity = len(np.unique(sol))  # More unique nodes indicate higher diversity\n        # Combine into a score (higher is better)\n        score = total_obj + diversity\n        scores.append(score)\n\n    # Step 2: Select a solution based on the scores (probability proportional to score)\n    probs = np.array(scores) / sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try a 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Try a 3-opt move (if the 2-opt didn't improve)\n    if np.random.rand() > 0.5:\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7319903058269637,
               2.7952613711357115
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for sol, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-specific edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move for diversity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply objective-specific edge swaps to improve each objective\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective space\n        worst_edge = None\n        worst_cost = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            cost = distance_matrix[u, v]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = (k, (k+1)%n)\n\n        # Try to replace this edge with a better one\n        if worst_edge:\n            i, j = worst_edge\n            # Find a node not in the current path to insert\n            available_nodes = set(range(n)) - set(new_solution)\n            if available_nodes:\n                new_node = np.random.choice(list(available_nodes))\n                # Replace the worst edge with a new node\n                new_solution = np.insert(new_solution, i+1, new_node)\n                new_solution = np.delete(new_solution, (i+2)%(n+1))\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
          "score": [
               -0.6290091460164113,
               1.8245219469070435
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose a random segment of the tour to modify\n    n = len(best_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n - 1))  # Ensure at least 2 nodes and at most 4 nodes\n    end = (start + length) % n\n\n    # Extract the segment and reverse it to create a 2-opt move\n    segment = best_solution[start:end]\n    new_segment = np.flip(segment)\n\n    # Create the new solution by replacing the segment\n    new_solution = np.concatenate([best_solution[:start], new_segment, best_solution[end:]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
          "score": [
               -0.5926355972202317,
               1.5963434815406798
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate dominance and diversity\n    dominated_counts = np.zeros(len(archive))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and archive[i][1][2] <= archive[j][1][2]) and \\\n                   (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1] or archive[i][1][2] < archive[j][1][2]):\n                    dominated_counts[j] += 1\n\n    # Step 2: Select a promising solution (low dominance, high crowding distance)\n    selected_idx = np.argmin(dominated_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt swap with multi-objective awareness\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate the new solution\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n",
          "score": [
               -0.7038782847272451,
               3.638184916973114
          ]
     }
]