[
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for improvement using a combination of objective dominance, crowding distance, and solution diversity metrics. It then intelligently selects a base solution from these candidates using a weighted random selection that prioritizes solutions with higher crowding distances and lower dominance counts. The local search operator employs a hybrid strategy that combines item swapping, random flipping, and adaptive perturbation to explore the neighborhood, ensuring feasibility by dynamically adjusting the selection of items to flip based on the remaining capacity. The operator also incorporates a memory mechanism to avoid revisiting recently explored solutions, further enhancing exploration. The function returns the new neighbor solution after validating its feasibility and updating the archive with the new solution if it is non-dominated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts and crowding distances\n    dominance_counts = [0] * len(archive)\n    crowding_distances = [0.0] * len(archive)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]:\n                    dominance_counts[i] += 1\n                if objectives[i][0] < objectives[j][0] and objectives[i][1] < objectives[j][1]:\n                    dominance_counts[i] += 1\n\n    # Sort solutions by dominance count (lower is better)\n    sorted_indices = sorted(range(len(archive)), key=lambda k: dominance_counts[k])\n    candidate_indices = sorted_indices[:max(1, len(archive) // 2)]\n\n    # Step 2: Select a base solution with weighted randomness\n    weights = [1.0 / (1.0 + dominance_counts[i]) for i in candidate_indices]\n    selected_idx = random.choices(candidate_indices, weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 3: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search operator\n    # 1. Randomly select a subset of items to flip\n    flip_indices = random.sample(range(n_items), min(3, n_items // 2))\n\n    # 2. Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # 3. Flip items while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if possible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if possible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 4. Additional perturbation: swap two items if feasible\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate weight difference\n            weight_diff = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + weight_diff <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (shouldn't be necessary but as a safeguard)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, try to remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
          "score": [
               -18.783291405738993,
               -18.18577865487048
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Create a candidate solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n\n    for idx in flip_indices:\n        # 2. Flip the item if it improves both objectives or weight allows\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's not critical for weight\n            if (current_weight - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add the item if it fits in capacity\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 3. Additional improvement: swap two items if it improves both objectives\n    if len(base_solution) >= 2:\n        i, j = np.random.choice(len(base_solution), size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Calculate potential new weight and values\n            new_weight = current_weight + (weight_lst[j] - weight_lst[i]) * (new_solution[i] - new_solution[j])\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -18.586423720786442,
               -18.76328847454988
          ]
     },
     {
          "algorithm": "{The novel local search operator, \"Dual-Objective Guided Bit Flip with Weighted Randomization,\" intelligently selects a solution from the archive by prioritizing those with high crowding distance or low dominance in the objective space, then applies a weighted random bit flip strategy that probabilistically flips bits based on their marginal contribution to both objectives, while ensuring feasibility by dynamically adjusting the flip probability to prevent exceeding capacity. The algorithm further refines the solution by iteratively flipping bits that improve the weighted sum of normalized objective values, using a simulated annealing-inspired acceptance criterion to escape local optima, and finally performs a post-optimization step to fine-tune the solution by flipping the least impactful bits to maximize one objective while minimally affecting the other.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high crowding distance or low dominance\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n        sorted_solutions = sorted(solutions, key=lambda x: x[1][0])\n        distances = [0.0] * len(solutions)\n        for m in range(2):\n            sorted_solutions.sort(key=lambda x: x[1][m])\n            distances[0] = float('inf')\n            distances[-1] = float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m]) / (sorted_solutions[-1][1][m] - sorted_solutions[0][1][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution, (obj1, obj2) = archive[selected_idx]\n\n    # Step 2: Generate a neighbor solution using weighted random bit flip\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    available_capacity = capacity - current_weight\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / np.maximum(weight_lst, 1e-6)\n    marginal2 = value2_lst / np.maximum(weight_lst, 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Probability of flipping each bit\n    flip_probs = combined_marginal * (1 - new_solution)\n    flip_probs[weight_lst > available_capacity] = 0  # Ensure feasibility\n\n    # Normalize probabilities\n    if np.sum(flip_probs) > 0:\n        flip_probs = flip_probs / np.sum(flip_probs)\n\n    # Perform flips\n    for i in range(len(new_solution)):\n        if random.random() < flip_probs[i] * 0.5:  # Lower probability to limit changes\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Simulated annealing-inspired refinement\n    temp = 1.0\n    cooling_rate = 0.99\n    for _ in range(10):\n        candidate = new_solution.copy()\n        candidate_weight = np.sum(weight_lst * candidate)\n\n        # Randomly select a bit to flip\n        idx = random.randint(0, len(candidate)-1)\n        if candidate[idx] == 0:\n            if candidate_weight + weight_lst[idx] <= capacity:\n                candidate[idx] = 1\n                candidate_weight += weight_lst[idx]\n        else:\n            candidate[idx] = 0\n            candidate_weight -= weight_lst[idx]\n\n        # Calculate new objectives\n        new_obj1 = np.sum(value1_lst * candidate)\n        new_obj2 = np.sum(value2_lst * candidate)\n\n        # Acceptance criterion\n        delta_obj1 = new_obj1 - obj1\n        delta_obj2 = new_obj2 - obj2\n        if delta_obj1 > 0 and delta_obj2 > 0:\n            new_solution = candidate\n            obj1, obj2 = new_obj1, new_obj2\n        else:\n            prob = np.exp((delta_obj1 + delta_obj2) / temp)\n            if random.random() < prob:\n                new_solution = candidate\n                obj1, obj2 = new_obj1, new_obj2\n\n        temp *= cooling_rate\n\n    # Step 4: Post-optimization step - flip least impactful bits\n    for _ in range(3):\n        # Find bits with minimal impact on objectives\n        impact1 = np.abs(value1_lst) / (1 + weight_lst)\n        impact2 = np.abs(value2_lst) / (1 + weight_lst)\n        combined_impact = impact1 + impact2\n\n        # Prefer to flip bits that are currently excluded but could improve objectives\n        flip_candidates = np.where(new_solution == 0)[0]\n        if len(flip_candidates) > 0:\n            candidate_impacts = combined_impact[flip_candidates]\n            if np.sum(candidate_impacts) > 0:\n                flip_probs = candidate_impacts / np.sum(candidate_impacts)\n                idx = np.random.choice(flip_candidates, p=flip_probs)\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
          "score": [
               -17.411685236353595,
               -17.48640227514403
          ]
     },
     {
          "algorithm": "{The algorithm first identifies promising solutions in the archive by selecting those with high objective values or those that are on the Pareto front, then intelligently samples a base solution from this subset. It then applies a hybrid local search strategy that combines a novel \"swap-and-flip\" operator with a probabilistic \"value-weighted\" perturbation to generate a neighbor solution. The swap-and-flip operator selects two items, swaps their inclusion statuses, and then flips the status of a third item based on a value-to-weight ratio heuristic, while the probabilistic perturbation introduces randomness to escape local optima. The algorithm ensures feasibility by rejecting any moves that would exceed the capacity, and it iteratively refines the solution by accepting improvements in either objective or Pareto-dominated solutions, ultimately returning a high-quality neighbor solution that balances exploration and exploitation of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify promising solutions (high objective values or on Pareto front)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1]) and (objectives[j][0] > objectives[i][0] or objectives[j][1] > objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    # If no Pareto front, select top 20% by sum of objectives\n    if not pareto_front:\n        sorted_indices = np.argsort(-objectives.sum(axis=1))\n        candidate_indices = sorted_indices[:max(1, len(archive) // 5)]\n    else:\n        candidate_indices = pareto_front\n\n    # Randomly select a base solution from candidates\n    base_idx = np.random.choice(candidate_indices)\n    base_solution = archive[base_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Swap-and-flip operator\n    if n_items >= 3:\n        # Select two items to swap\n        swap_indices = np.random.choice(n_items, size=2, replace=False)\n        # Flip a third item based on value-to-weight ratio\n        flip_idx = np.random.choice(n_items)\n        while flip_idx in swap_indices:\n            flip_idx = np.random.choice(n_items)\n\n        # Apply swap\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Apply flip with probability based on value-to-weight ratio\n        v1_ratio = value1_lst[flip_idx] / weight_lst[flip_idx] if weight_lst[flip_idx] > 0 else 0\n        v2_ratio = value2_lst[flip_idx] / weight_lst[flip_idx] if weight_lst[flip_idx] > 0 else 0\n        flip_prob = min(1.0, (v1_ratio + v2_ratio) / 10)  # Normalize\n\n        if np.random.random() < flip_prob:\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Probabilistic perturbation\n    for i in range(n_items):\n        if np.random.random() < 0.1:  # 10% chance to perturb\n            if new_solution[i] == 1:\n                # Try to remove\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random items until feasible\n        included = np.where(new_solution == 1)[0]\n        if len(included) == 0:\n            break\n        remove_idx = np.random.choice(included)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
          "score": [
               -18.525469470071368,
               -17.447019179654852
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, val1, val2))\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible solutions\n\n    # Select the solution with the highest potential for improvement\n    # Here, we use the solution with the highest sum of normalized objective values\n    selected_sol = max(candidates, key=lambda x: (x[1] + x[2]))[0]\n    base_solution = selected_sol.copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: Value-ratio swap + capacity-aware perturbation\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Value-ratio swap: Swap items based on their marginal contribution to both objectives\n        ratio1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        ratio2 = value2_lst / (weight_lst + 1e-6)\n\n        # Identify items with high ratio in one objective and low in the other\n        high_ratio1 = np.where(new_solution & (ratio1 > np.median(ratio1)))[0]\n        low_ratio2 = np.where(~new_solution & (ratio2 < np.median(ratio2)))[0]\n\n        if len(high_ratio1) > 0 and len(low_ratio2) > 0:\n            # Randomly select items to swap\n            swap1 = np.random.choice(high_ratio1)\n            swap2 = np.random.choice(low_ratio2)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[swap2] - weight_lst[swap1]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n        # Capacity-aware perturbation: Flip a small number of items near the capacity\n        if np.random.rand() < 0.3:  # 30% chance to perturb\n            # Identify items that can be flipped without violating capacity\n            current_weight = np.sum(weight_lst * new_solution)\n            feasible_flips = []\n\n            for i in range(n_items):\n                if new_solution[i] == 1:\n                    if current_weight - weight_lst[i] >= 0:\n                        feasible_flips.append(i)\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        feasible_flips.append(i)\n\n            if feasible_flips:\n                flip_idx = np.random.choice(feasible_flips)\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
          "score": [
               -17.404406389863784,
               -16.720119105446962
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating the potential for improvement in both objectives, considering the trade-off between them. It then applies a novel hybrid local search strategy that combines adaptive bit-flipping with a weighted random walk to explore the solution space. The strategy intelligently selects items to flip based on their marginal contributions to both objectives, while ensuring feasibility by dynamically adjusting the selection probability to respect the capacity constraint. The weighted random walk further diversifies the search by probabilistically including or excluding items that show high potential in either objective, guided by their normalized marginal gains. The function ensures the generated neighbor solution remains feasible by verifying the total weight and iteratively adjusting the selection if necessary.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement in either objective\n    max_potential = -1\n    base_solution = None\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        remaining_capacity = capacity - total_weight\n        potential = 0\n        for i in range(len(sol)):\n            if sol[i] == 0 and weight_lst[i] <= remaining_capacity:\n                potential += (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n        if potential > max_potential:\n            max_potential = potential\n            base_solution = sol.copy()\n\n    if base_solution is None:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - total_weight\n\n    # Adaptive bit-flipping with weighted random walk\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            # Probability of flipping based on marginal gain in both objectives\n            marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            flip_prob = min(0.5 * marginal_gain / (np.max(value1_lst) + np.max(value2_lst)), 1.0)\n            if np.random.rand() < flip_prob:\n                new_solution[i] = 1\n                total_weight += weight_lst[i]\n                remaining_capacity = capacity - total_weight\n        elif new_solution[i] == 1:\n            # Probability of removing based on marginal loss in both objectives\n            marginal_loss = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            remove_prob = min(0.3 * marginal_loss / (np.max(value1_lst) + np.max(value2_lst)), 0.5)\n            if np.random.rand() < remove_prob:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n                remaining_capacity = capacity - total_weight\n\n    # Ensure feasibility by removing items if over capacity\n    while np.sum(new_solution * weight_lst) > capacity:\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        # Remove the item with the lowest marginal gain\n        gains = (value1_lst[candidates] + value2_lst[candidates]) / weight_lst[candidates]\n        remove_idx = candidates[np.argmin(gains)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
          "score": [
               -14.86330979339682,
               -14.725023144270875
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a hybrid local search strategy that combines adaptive item swapping with a dynamic neighborhood exploration. First, it intelligently selects a solution from the archive by prioritizing those with high crowding distance in the objective space, indicating regions of the Pareto front with sparse solutions. Then, it applies an adaptive item swapping mechanism where items are probabilistically selected based on their marginal contribution to both objectives. If the swap violates the capacity constraint, it performs a guided local search by iteratively removing the least valuable item in the solution until feasibility is restored. The function also incorporates a dynamic neighborhood exploration phase, where it explores multiple neighboring solutions by flipping a subset of items, and selects the best feasible neighbor based on a weighted sum of the normalized objectives, ensuring a balanced improvement across both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n    objectives_sorted = [sorted([o[i] for o in objectives]) for i in range(2)]\n\n    for i, (sol, obj) in enumerate(archive):\n        if len(archive) <= 2:\n            crowding_distances.append(1.0)\n            continue\n\n        distance = 0.0\n        for m in range(2):\n            if objectives_sorted[m][-1] == objectives_sorted[m][0]:\n                distance += 1.0\n            else:\n                # Find the index of the current solution in the sorted list\n                idx = objectives_sorted[m].index(obj[m])\n                if idx == 0:\n                    distance += (objectives_sorted[m][1] - objectives_sorted[m][0]) / (objectives_sorted[m][-1] - objectives_sorted[m][0])\n                elif idx == len(objectives_sorted[m]) - 1:\n                    distance += (objectives_sorted[m][-2] - objectives_sorted[m][-1]) / (objectives_sorted[m][-1] - objectives_sorted[m][0])\n                else:\n                    distance += (objectives_sorted[m][idx+1] - objectives_sorted[m][idx-1]) / (objectives_sorted[m][-1] - objectives_sorted[m][0])\n        crowding_distances.append(distance)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Generate a neighbor solution using adaptive item swapping\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    marginal_value = marginal_value1 + marginal_value2\n\n    # Probabilistically select items to swap\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            swap_candidates.append((i, marginal_value[i]))\n\n    # Sort by marginal value (descending)\n    swap_candidates.sort(key=lambda x: -x[1])\n\n    # Perform swaps\n    for i, _ in swap_candidates[:max(1, len(swap_candidates) // 2)]:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n            total_weight -= weight_lst[i]\n\n            # Find an item to add that doesn't exceed capacity\n            for j in range(len(new_solution)):\n                if new_solution[j] == 0 and total_weight + weight_lst[j] <= capacity:\n                    new_solution[j] = 1\n                    total_weight += weight_lst[j]\n                    break\n\n    # Step 3: Guided local search if solution is infeasible\n    if total_weight > capacity:\n        # Remove items with least marginal value until feasible\n        while total_weight > capacity:\n            # Find the item with the smallest marginal value in the solution\n            min_marginal = float('inf')\n            min_idx = -1\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1 and marginal_value[i] < min_marginal:\n                    min_marginal = marginal_value[i]\n                    min_idx = i\n\n            if min_idx != -1:\n                new_solution[min_idx] = 0\n                total_weight -= weight_lst[min_idx]\n            else:\n                break\n\n    # Step 4: Dynamic neighborhood exploration\n    if np.random.rand() < 0.3:  # 30% chance to explore dynamic neighborhood\n        # Flip a subset of items\n        flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    return new_solution\n\n",
          "score": [
               -14.232583840247965,
               -14.040726229505509
          ]
     },
     {
          "algorithm": "{The algorithm first identifies promising solutions in the archive by evaluating their potential for improvement through a hybrid local search strategy that combines adaptive item swapping and probabilistic flipping. It intelligently selects a base solution from the archive by prioritizing those with the highest crowding distance or marginal value improvements in either objective. The neighbor solution is then generated by applying a novel \"adaptive flip-and-swap\" operator, which probabilistically flips items based on their marginal contribution to both objectives and swaps items between high-value and low-weight categories to maintain feasibility. The operator ensures feasibility by dynamically adjusting the selection probabilities to respect the capacity constraint, while also incorporating a diversity-preserving mechanism to avoid premature convergence. The resulting neighbor solution is guaranteed to be feasible and often exhibits superior trade-off improvements across both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential item swaps\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to consider for flipping\n    candidate_items = np.where((weight_lst <= remaining_capacity) | (base_solution == 1))[0]\n\n    if len(candidate_items) == 0:\n        return new_solution  # No feasible moves possible\n\n    # Adaptive flip-and-swap operator\n    for item in candidate_items:\n        # Probability of flip based on marginal contribution\n        marginal_v1 = value1_lst[item] if base_solution[item] == 0 else -value1_lst[item]\n        marginal_v2 = value2_lst[item] if base_solution[item] == 0 else -value2_lst[item]\n\n        # Calculate flip probability\n        flip_prob = 0.5 * (1 + np.tanh((marginal_v1 + marginal_v2) / (np.max([base_v1, base_v2]) + 1e-6)))\n\n        if np.random.rand() < flip_prob:\n            # Try to flip the item\n            if base_solution[item] == 0:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n            else:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Additional swap operation for diversity\n    if len(candidate_items) >= 2:\n        i, j = np.random.choice(candidate_items, 2, replace=False)\n        if (base_solution[i] != base_solution[j] and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -13.95382486090879,
               -13.725019987257948
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Check if there are items not included that can fit\n            excluded_items = np.where(sol == 0)[0]\n            if len(excluded_items) > 0:\n                candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, select a random solution\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        # Select the candidate with the most excluded items\n        base_solution = max(candidates, key=lambda x: np.sum(x == 0))\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of item addition and swap operations to explore the neighborhood\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Try adding items that can fit\n    excluded_items = np.where(new_solution == 0)[0]\n    for item in excluded_items:\n        if weight_lst[item] <= remaining_capacity:\n            new_solution[item] = 1\n            remaining_capacity -= weight_lst[item]\n            break  # Only add one item at a time to keep it simple\n\n    # Try swapping items that are currently in the knapsack with excluded items\n    included_items = np.where(new_solution == 1)[0]\n    for in_item in included_items:\n        for ex_item in excluded_items:\n            if weight_lst[ex_item] <= remaining_capacity + weight_lst[in_item]:\n                new_solution[in_item] = 0\n                new_solution[ex_item] = 1\n                break  # Only perform one swap to keep it simple\n        if new_solution[ex_item] == 1:\n            break\n\n    return new_solution\n\n",
          "score": [
               -13.940096819531755,
               -13.649590329243926
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement through a combination of crowding distance and objective space dominance, then intelligently selects one such solution. It then applies a hybrid local search operator that combines a novel 'value-driven flip' mechanism, which selectively flips item inclusion based on the marginal gains in both objectives, with a 'weight-balanced swap' operator that exchanges items while ensuring feasibility and improving both objectives. The operator also incorporates a probabilistic acceptance criterion to escape local optima, and the entire process is repeated for a fixed number of iterations to ensure thorough exploration of the neighborhood. The function always verifies the feasibility of the generated neighbor solution before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Sort objectives for each dimension\n    sorted_indices1 = np.argsort(objectives[:, 0])\n    sorted_indices2 = np.argsort(objectives[:, 1])\n\n    # Calculate crowding distance for each dimension\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] += (objectives[sorted_indices1[i+1], 0] - objectives[sorted_indices1[i-1], 0]) / (objectives[sorted_indices1[-1], 0] - objectives[sorted_indices1[0], 0] + 1e-10)\n            crowding_distances[i] += (objectives[sorted_indices2[i+1], 1] - objectives[sorted_indices2[i-1], 1]) / (objectives[sorted_indices2[-1], 1] - objectives[sorted_indices2[0], 1] + 1e-10)\n\n    # Select solutions with high crowding distance (promising for improvement)\n    max_crowding = np.max(crowding_distances)\n    candidates = [i for i, dist in enumerate(crowding_distances) if dist >= max_crowding * 0.7]\n\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Value-driven flip: flip items with high marginal gains\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for _ in range(5):  # Number of flip attempts\n        # Calculate marginal gains for each item\n        marginal_gains1 = value1_lst / (weight_lst + 1e-10)\n        marginal_gains2 = value2_lst / (weight_lst + 1e-10)\n        combined_gains = marginal_gains1 + marginal_gains2\n\n        # Select top items to flip\n        candidate_items = np.argsort(combined_gains)[-5:]  # Top 5 items with highest combined gain\n        for item in candidate_items:\n            if new_solution[item] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Weight-balanced swap: swap items to balance weights\n    for _ in range(3):  # Number of swap attempts\n        # Find items to swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random pair\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n\n            # Check if swap improves both objectives\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if current_weight + delta_weight <= capacity:\n                # Calculate marginal gains\n                gain1 = value1_lst[j] - value1_lst[i]\n                gain2 = value2_lst[j] - value2_lst[i]\n\n                # Accept if both gains are positive or with some probability\n                if (gain1 > 0 and gain2 > 0) or random.random() < 0.3:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight += delta_weight\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        # Remove heaviest item\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        heaviest = in_items[np.argmax(weight_lst[in_items])]\n        new_solution[heaviest] = 0\n        current_weight -= weight_lst[heaviest]\n\n    return new_solution\n\n",
          "score": [
               -13.748574438173542,
               -13.650259532654664
          ]
     }
]