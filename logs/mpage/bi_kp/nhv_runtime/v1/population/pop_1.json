[
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive using a hybrid approach that combines crowding distance and objective space diversity to prioritize solutions with high potential for improvement. It then applies a novel local search operator that intelligently flips items based on their marginal contributions to both objectives, ensuring feasibility by dynamically adjusting the selection to respect the capacity constraint. The operator also incorporates a probabilistic component to escape local optima, favoring flips that improve both objectives while considering trade-offs between them. The selection process is biased towards solutions with higher crowding distances or those lying on the Pareto front, ensuring a balance between exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive (prioritize solutions with high crowding distance or on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, selected_objective = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Step 2: Compute marginal contributions of each item to both objectives\n    marginal_value1 = value1_lst / weight_lst\n    marginal_value2 = value2_lst / weight_lst\n\n    # Step 3: Identify items that can be flipped to improve both objectives or trade-off between them\n    current_weight = np.sum(weight_lst * base_solution)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing item i if it doesn't significantly reduce both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1, marginal_value1[i], marginal_value2[i]))\n        else:\n            # Consider adding item i if it improves both objectives or has a good trade-off\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1, marginal_value1[i], marginal_value2[i]))\n\n    if not candidates:\n        # No feasible flips, return a random neighbor by flipping a single item\n        feasible_indices = [i for i in range(len(base_solution)) if (base_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                           (base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution = base_solution.copy()\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            return new_solution\n        else:\n            return base_solution.copy()\n\n    # Step 4: Select the best candidate based on marginal contributions and probabilistic selection\n    # Prioritize flips that improve both objectives, then those with good trade-offs\n    best_candidate = None\n    best_score = -np.inf\n    for candidate in candidates:\n        idx, flip, m_val1, m_val2 = candidate\n        if flip == 1:\n            score = m_val1 + m_val2  # Adding item: maximize both objectives\n        else:\n            score = -m_val1 - m_val2  # Removing item: minimize both objectives\n        if score > best_score:\n            best_score = score\n            best_candidate = candidate\n\n    if best_candidate is None:\n        return base_solution.copy()\n\n    # Step 5: Apply the selected flip\n    new_solution = base_solution.copy()\n    idx, flip, _, _ = best_candidate\n    new_solution[idx] = 1 if flip == 1 else 0\n\n    return new_solution\n\n",
          "score": [
               -0.9632164304649085,
               7.020322293043137
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement through a novel hybrid local search strategy. It uses a combination of crowding distance and objective-space dominance to prioritize solutions with high diversity and potential for multi-objective optimization. The selected solution undergoes a creative local search operator that dynamically adapts between item swaps, insertions, and removals based on the current solution's objective values and the archive's distribution, ensuring feasibility by always validating weight constraints. The operator explores neighboring solutions by flipping bits of items with high marginal contributions to both objectives, while also considering the impact on the solution's position in the Pareto front. The generated neighbor solution is guaranteed to be feasible and is returned as the new solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution in the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives for crowding distance calculation\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Compute crowding distance\n    crowding_dist = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(normalized_obj[:, m])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_indices[i]] += (normalized_obj[sorted_indices[i+1], m] - normalized_obj[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Determine which items to consider for modification\n    # We'll consider items that are either in the solution or have high potential\n    candidate_items = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            candidate_items.append(i)\n        else:\n            # Only consider items that can fit when added\n            if current_weight + weight_lst[i] <= capacity:\n                # Calculate marginal contribution for both objectives\n                marginal1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                marginal2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                # Add items with high marginal contribution to either objective\n                if marginal1 > 0.5 * np.max(value1_lst / weight_lst) or marginal2 > 0.5 * np.max(value2_lst / weight_lst):\n                    candidate_items.append(i)\n\n    if not candidate_items:\n        # If no candidates, randomly select an item to flip\n        candidate_items = list(range(n_items))\n\n    # Randomly select an item to modify\n    item_to_modify = np.random.choice(candidate_items)\n\n    # Perform modification based on current solution state\n    if new_solution[item_to_modify] == 1:\n        # If item is in solution, consider removing it\n        new_solution[item_to_modify] = 0\n    else:\n        # If item is not in solution, consider adding it\n        new_solution[item_to_modify] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If adding causes overflow, try to remove another item\n        # Find items to remove that would make the solution feasible\n        included_items = np.where(new_solution == 1)[0]\n        for i in included_items:\n            if total_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n                break\n\n    # If still not feasible, revert to base solution\n    if np.sum(weight_lst * new_solution) > capacity:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7887797633141523,
               3.8655914068222046
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    items = np.arange(len(new_solution))\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst - (value1_lst * new_solution)\n    marginal_gain2 = value2_lst - (value2_lst * new_solution)\n    marginal_weights = weight_lst - (weight_lst * new_solution)\n\n    # Rank items by their potential to improve both objectives\n    scores = marginal_gain1 + marginal_gain2\n    sorted_indices = np.argsort(scores)[::-1]\n\n    # Try to flip items in order of highest potential gain\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # If no improvement, try a different strategy: flip a random subset\n    if np.array_equal(new_solution, base_solution):\n        np.random.shuffle(items)\n        for idx in items:\n            if new_solution[idx] == 0:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n            else:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
          "score": [
               -0.9546836449070784,
               5.297566622495651
          ]
     },
     {
          "algorithm": "{The novel heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating both the solution's objective values and its potential for local improvement through a dynamic crowding distance metric that considers both objectives. It then applies a hybrid local search strategy that combines a greedy item swap with a probabilistic item perturbation to generate a neighbor solution. The greedy swap evaluates all possible single-item swaps (additions or removals) to maximize a weighted sum of the two objectives, while the probabilistic perturbation randomly flips a small subset of items to escape local optima. The function ensures feasibility by rejecting any swaps or perturbations that would exceed the capacity, and it intelligently selects the most promising solution for local improvement by prioritizing those with high crowding distance and low dominance.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution (high crowding distance and low dominance)\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0.0] * len(solutions)\n        distances = [0.0] * len(solutions)\n        for obj_idx in range(2):\n            sorted_idx = np.argsort([obj[obj_idx] for _, obj in solutions])\n            min_val = solutions[sorted_idx[0]][1][obj_idx]\n            max_val = solutions[sorted_idx[-1]][1][obj_idx]\n            if max_val == min_val:\n                continue\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][obj_idx] - solutions[sorted_idx[i-1]][1][obj_idx]) / (max_val - min_val)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search (greedy swap + probabilistic perturbation)\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Greedy swap: evaluate all possible single-item swaps\n    best_delta = 0\n    best_item = -1\n    best_action = None  # 'add' or 'remove'\n\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Evaluate removing item i\n            delta_weight = -weight_lst[i]\n            delta_value1 = -value1_lst[i]\n            delta_value2 = -value2_lst[i]\n            if current_weight + delta_weight <= capacity:\n                # Weighted sum of objectives (can be adjusted)\n                delta = 0.5 * delta_value1 + 0.5 * delta_value2\n                if delta < best_delta:\n                    best_delta = delta\n                    best_item = i\n                    best_action = 'remove'\n        else:\n            # Evaluate adding item i\n            delta_weight = weight_lst[i]\n            delta_value1 = value1_lst[i]\n            delta_value2 = value2_lst[i]\n            if current_weight + delta_weight <= capacity:\n                delta = 0.5 * delta_value1 + 0.5 * delta_value2\n                if delta > best_delta:\n                    best_delta = delta\n                    best_item = i\n                    best_action = 'add'\n\n    if best_item != -1:\n        if best_action == 'add':\n            new_solution[best_item] = 1\n        else:\n            new_solution[best_item] = 0\n\n    # Probabilistic perturbation: flip a small random subset of items\n    perturbation_prob = 0.1\n    for i in range(n_items):\n        if np.random.rand() < perturbation_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.8891006467033533,
               5.790628999471664
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a combination of randomness and objective-based prioritization\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either added or removed)\n    items_to_consider = np.where(new_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst[items_to_consider] / weight_lst[items_to_consider]\n    marginal_value2 = value2_lst[items_to_consider] / weight_lst[items_to_consider]\n    marginal_scores = marginal_value1 + marginal_value2  # Combined score for prioritization\n\n    # Sort items by marginal score (descending)\n    sorted_indices = np.argsort(marginal_scores)[::-1]\n    items_to_consider = items_to_consider[sorted_indices]\n\n    # Try to flip items in order of priority, ensuring feasibility\n    for item in items_to_consider:\n        if new_solution[item] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
          "score": [
               -0.8846790501092237,
               6.0916441679000854
          ]
     },
     {
          "algorithm": "{The algorithm first identifies the most promising solution in the archive by evaluating the potential for improvement in both objectives, considering the trade-off between them. It then applies a novel hybrid local search operator that combines a greedy selection of items with a probabilistic perturbation to escape local optima, ensuring feasibility by dynamically adjusting the selection based on the remaining capacity. The operator prioritizes items that offer the highest marginal gain in either objective while allowing controlled exploration of the solution space to avoid premature convergence. The selection of the base solution is biased towards those with the highest potential for further improvement, as estimated by the ratio of the current objective values to the maximum possible values in the archive. The algorithm ensures feasibility by strictly enforcing the capacity constraint during the generation of neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on potential for improvement\n    max_potential = -1\n    selected_solution = None\n    max_values = (max(obj[0] for _, obj in archive), max(obj[1] for _, obj in archive))\n\n    for sol, obj in archive:\n        potential = (1 - obj[0] / max_values[0]) + (1 - obj[1] / max_values[1])\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy selection with probabilistic perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n\n    # Combine marginal gains with a weighted sum\n    combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n\n    # Sort items by combined gain in descending order\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Try to add the best items first\n    for idx in sorted_indices:\n        if base_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-gain item\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Probabilistic perturbation: flip some items to explore\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.1:  # 10% chance to flip any item\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (should not be needed due to checks above, but just in case)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove the heaviest item\n        included_indices = np.where(new_solution == 1)[0]\n        heaviest_idx = included_indices[np.argmax(weight_lst[included_indices])]\n        new_solution[heaviest_idx] = 0\n\n    return new_solution\n\n",
          "score": [
               -0.8304689465545231,
               9.738407641649246
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement through a novel hybrid local search strategy. It intelligently selects a solution by prioritizing those with high objective values and low weight utilization, then applies a creative local search operator that combines random item swaps with objective-aware perturbations to explore the solution space efficiently. The operator dynamically adjusts the scope of perturbations based on the current solution's objective values and weight, ensuring feasibility while promoting diversity and convergence towards Pareto-optimal solutions. The process repeats iteratively, with each generated neighbor solution evaluated for dominance and added to the archive if non-dominated, until a termination condition is met.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n    max_attempts = min(10, num_items)\n\n    for _ in range(max_attempts):\n        # Randomly select an item to flip\n        item_idx = random.randint(0, num_items - 1)\n\n        # Calculate the effect of flipping this item\n        if new_solution[item_idx] == 1:\n            new_weight = current_weight - weight_lst[item_idx]\n            delta_val1 = -value1_lst[item_idx]\n            delta_val2 = -value2_lst[item_idx]\n        else:\n            new_weight = current_weight + weight_lst[item_idx]\n            delta_val1 = value1_lst[item_idx]\n            delta_val2 = value2_lst[item_idx]\n\n        # Check if the flip is feasible\n        if new_weight <= capacity:\n            # Apply the flip with a probability based on objective improvement\n            improvement_prob = 0.5 + 0.5 * (delta_val1 + delta_val2) / (np.sum(value1_lst) + np.sum(value2_lst))\n            if random.random() < improvement_prob:\n                new_solution[item_idx] = 1 - new_solution[item_idx]\n                current_weight = new_weight\n\n    # Additional perturbation: randomly swap items between objectives\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Find items that can be swapped without violating capacity\n        candidate_items = [i for i in range(num_items) if new_solution[i] == 1 and\n                          (current_weight - weight_lst[i] + weight_lst[(i+1)%num_items]) <= capacity]\n\n        if candidate_items:\n            swap_idx = random.choice(candidate_items)\n            new_solution[swap_idx] = 0\n            new_solution[(swap_idx+1)%num_items] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.3455774004565234,
               6.42365437746048
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity metrics. It then applies a hybrid local search strategy that intelligently combines path relinking with a guided random walk, where the path relinking explores high-quality regions of the solution space by interpolating between the selected solution and another elite solution, while the guided random walk ensures exploration of neighboring regions while respecting feasibility constraints. The function prioritizes solutions with the highest crowding distance or least dominated neighbors to ensure diversity and further improvement potential, and it always checks the feasibility of generated solutions by verifying that the total weight does not exceed the capacity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (highest crowding distance or least dominated)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for each objective\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search - Path Relinking with Guided Random Walk\n    new_solution = base_solution.copy()\n\n    # Path Relinking: Interpolate between base_solution and another elite solution\n    if len(archive) > 1:\n        # Select another elite solution (e.g., with high crowding distance)\n        elite_idx = np.argpartition(crowding_distances, -2)[-2]\n        elite_solution = archive[elite_idx][0].copy()\n\n        # Perform path relinking (flip bits where they differ)\n        differing_bits = np.where(base_solution != elite_solution)[0]\n        if len(differing_bits) > 0:\n            flip_idx = np.random.choice(differing_bits)\n            new_solution[flip_idx] = elite_solution[flip_idx]\n\n    # Guided Random Walk: Flip a random bit if feasible\n    if np.random.rand() < 0.5:  # 50% chance to perform random walk\n        candidate_items = np.where(base_solution == 0)[0]  # Items not in solution\n        if len(candidate_items) > 0:\n            flip_idx = np.random.choice(candidate_items)\n            if np.sum(weight_lst * new_solution) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded\n    while np.sum(weight_lst * new_solution) > capacity:\n        selected_items = np.where(new_solution == 1)[0]\n        if len(selected_items) == 0:\n            break  # No items left to remove\n        remove_idx = np.random.choice(selected_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
          "score": [
               -0.713111518804734,
               7.600472301244736
          ]
     },
     {
          "algorithm": "{The proposed algorithm, called \"Adaptive Multi-Objective Local Search with Weighted Randomization,\" operates by first identifying the most crowded regions in the Pareto front by clustering solutions based on their objective values. It then intelligently selects a base solution from the less crowded regions, prioritizing those with higher crowding distances or lower dominance counts. The algorithm employs a hybrid local search strategy that combines a novel \"weighted swap\" operator, which probabilistically swaps items based on their contribution to both objectives, with a \"multi-objective path relinking\" technique that explores intermediate solutions between the base and a randomly selected archive solution. The weighted swap operator dynamically adjusts the selection probability of items based on their marginal contributions to both objectives, while the path relinking ensures exploration of the solution space while maintaining feasibility. The algorithm also incorporates a dynamic neighborhood exploration mechanism that adaptively adjusts the size of the neighborhood based on the local search progress, allowing for both fine-grained and coarse-grained exploration. Finally, the algorithm incorporates a feasibility repair mechanism that ensures any infeasible solutions generated during the local search are repaired by iteratively removing items with the lowest weighted marginal contribution until feasibility is restored.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a base solution from the archive\n    # We select the solution with the highest crowding distance (promising for exploration)\n    crowding_distances = []\n    for i, (sol, _) in enumerate(archive):\n        left = archive[i-1] if i > 0 else None\n        right = archive[i+1] if i < len(archive)-1 else None\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(left[1][0] - right[1][0])\n            dist2 = abs(left[1][1] - right[1][1])\n            crowding_distances.append(dist1 + dist2)\n\n    max_crowding_idx = np.argmax(crowding_distances)\n    base_solution = archive[max_crowding_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Weighted swap + Path relinking\n    # First, perform a weighted swap\n    weights = np.random.rand(len(weight_lst))\n    swap_indices = np.where(weights < 0.3)[0]  # 30% chance to swap each item\n\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Then perform path relinking with another random solution\n    if len(archive) > 1:\n        other_sol = archive[np.random.choice([i for i in range(len(archive)) if i != max_crowding_idx])][0]\n        for i in range(len(new_solution)):\n            if new_solution[i] != other_sol[i]:\n                temp_sol = new_solution.copy()\n                temp_sol[i] = other_sol[i]\n                if np.sum(temp_sol * weight_lst) <= capacity:\n                    new_solution = temp_sol\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove the item with the lowest weighted marginal contribution\n        marginal_contributions = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                temp_sol = new_solution.copy()\n                temp_sol[i] = 0\n                value1 = np.sum(temp_sol * value1_lst)\n                value2 = np.sum(temp_sol * value2_lst)\n                marginal_contributions.append((value1 + value2) / weight_lst[i])\n            else:\n                marginal_contributions.append(float('inf'))\n\n        worst_item = np.argmin(marginal_contributions)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
          "score": [
               -0.531068784172877,
               10.893695622682571
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' employs a hybrid local search strategy that combines a crowding-distance-driven solution selection with a novel \"adaptive flip-and-rebalance\" operator. First, it intelligently selects a solution from the archive by prioritizing those with high crowding distances in the objective space, indicating they lie in less crowded regions and may offer greater potential for improvement. The adaptive flip-and-rebalance operator then systematically identifies a subset of items to flip (toggle inclusion/exclusion) while maintaining feasibility, using a weighted randomness that considers both objective improvements and weight constraints. The operator dynamically adjusts the flip probability based on the current solution's objective values and the archive's diversity, ensuring a balance between exploration and exploitation. After each flip, it performs a rebalancing step to maximize the total weight without exceeding capacity, further optimizing the solution. The process repeats for a fixed number of iterations or until no further improvements are found, guaranteeing feasibility at every step.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (high crowding distance)\n    def crowding_distance(solution, archive):\n        distances = []\n        for i, (sol, obj) in enumerate(archive):\n            if np.array_equal(sol, solution):\n                continue\n            dist = np.sqrt((obj[0] - archive[i][1][0])**2 + (obj[1] - archive[i][1][1])**2)\n            distances.append((dist, sol))\n        if not distances:\n            return 0\n        avg_dist = np.mean([d[0] for d in distances])\n        return avg_dist\n\n    candidates = [(sol, crowding_distance(sol, archive)) for sol, _ in archive]\n    candidates.sort(key=lambda x: -x[1])  # Sort by descending crowding distance\n    selected = candidates[0][0].copy()\n\n    # Step 2: Adaptive flip-and-rebalance operator\n    current_weight = np.sum(weight_lst * selected)\n    current_value1 = np.sum(value1_lst * selected)\n    current_value2 = np.sum(value2_lst * selected)\n\n    # Determine flip probability based on solution's position in objective space\n    max_value1 = np.sum(value1_lst * (current_weight + (capacity - current_weight) * (value1_lst > 0)))\n    max_value2 = np.sum(value2_lst * (current_weight + (capacity - current_weight) * (value2_lst > 0)))\n\n    flip_prob = 0.5 + 0.5 * (max_value1 - current_value1) / max_value1  # Higher probability for items that can improve value1\n    flip_prob = min(flip_prob, 1.0)\n\n    new_solution = selected.copy()\n    for i in range(len(selected)):\n        if np.random.rand() < flip_prob:\n            # Try flipping the item\n            if selected[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight >= 0:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Rebalance to maximize weight without exceeding capacity\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Sort items by value density (value1/weight)\n        value_density = value1_lst / weight_lst\n        sorted_indices = np.argsort(-value_density)\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
          "score": [
               -0.4597835093136943,
               8.580296874046326
          ]
     }
]