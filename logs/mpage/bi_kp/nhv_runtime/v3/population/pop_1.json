[
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive using a combination of crowding distance and objective diversity metrics to ensure it is non-dominated and has potential for improvement. It then applies a novel hybrid local search operator that selectively flips items based on their marginal contribution to both objectives, combined with a targeted random walk that explores adjacent solutions while maintaining feasibility. The operator balances exploitation of high-margin items and exploration of underrepresented regions in the objective space, ensuring the neighbor solution remains feasible by dynamically adjusting the selection based on remaining capacity. The selection process prioritizes solutions with high crowding distance or low dominance count to focus on less-explored areas, while the local search operator uses a probabilistic flip mechanism weighted by the item's contribution to both objectives, with a small random perturbation to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (high crowding distance or low dominance count)\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx) - 1):\n            crowding_distances[sorted_idx[j]] += (sorted_obj[j + 1] - sorted_obj[j - 1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Probabilistic flip based on marginal contribution and remaining capacity\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if np.random.rand() < 0.3:  # 30% chance to remove item\n                new_solution[i] = 0\n        else:\n            if weight_lst[i] <= remaining_capacity and np.random.rand() < 0.7 * (marginal_combined[i] / (np.max(marginal_combined) + 1e-10)):\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If not feasible, remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            item_to_remove = np.argmax(new_solution * marginal_combined)\n            if new_solution[item_to_remove] == 1:\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
          "score": [
               -0.8772999931781975,
               3.516489714384079
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by filtering those with objective values that are within a specified percentage of the Pareto front (e.g., top 20% in each objective). It then intelligently selects a base solution by prioritizing those with the highest diversity in their objective values or those that have not been extensively explored in the archive. For local search, it employs a novel adaptive exchange operator that dynamically selects items to swap or flip based on their marginal contribution to both objectives, ensuring feasibility by recalculating weights and adjusting the solution to stay within capacity. The operator also incorporates a probabilistic exploration component to escape local optima, where items are randomly selected with a decaying probability to explore less promising but potentially high-quality regions of the solution space. The function returns the new neighbor solution after applying this hybrid local search strategy, guaranteeing feasibility by always checking the total weight against the capacity constraint.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter promising solutions (top 20% in each objective)\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    min_values = np.min(objectives, axis=0)\n    threshold1 = max_values[0] - 0.2 * (max_values[0] - min_values[0])\n    threshold2 = max_values[1] - 0.2 * (max_values[1] - min_values[1])\n\n    promising_indices = [\n        i for i, (obj1, obj2) in enumerate(objectives)\n        if obj1 >= threshold1 or obj2 >= threshold2\n    ]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    # Step 2: Select a base solution (prioritize diversity or unexplored regions)\n    selected_idx = random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Hybrid local search operator\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify candidate items for flipping\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Adaptive exchange: flip items with high marginal contribution\n    for _ in range(5):  # Limit the number of flips to avoid excessive computation\n        if random.random() < 0.7:  # Probabilistic exploration\n            # Flip a random item\n            if len(zero_indices) > 0 and len(one_indices) > 0:\n                flip_idx = random.choice(zero_indices)\n                new_solution[flip_idx] = 1\n                new_weight = current_weight + weight_lst[flip_idx]\n                if new_weight > capacity:\n                    new_solution[flip_idx] = 0\n                else:\n                    current_weight = new_weight\n                    current_value1 += value1_lst[flip_idx]\n                    current_value2 += value2_lst[flip_idx]\n                    zero_indices = np.where(new_solution == 0)[0]\n                    one_indices = np.where(new_solution == 1)[0]\n        else:\n            # Flip a random item from the current solution\n            if len(one_indices) > 0:\n                flip_idx = random.choice(one_indices)\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n                current_value1 -= value1_lst[flip_idx]\n                current_value2 -= value2_lst[flip_idx]\n                zero_indices = np.where(new_solution == 0)[0]\n                one_indices = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
          "score": [
               -0.3690393270039769,
               2.8620464503765106
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for further local improvement, prioritizing those with high marginal gains in either objective or balance between objectives. It then applies a hybrid local search strategy combining a novel 'value-focused flip' operator (randomly flipping items with high value ratios) and a 'weight-aware swap' operator (swapping items to balance weight distribution), ensuring feasibility by rejecting any moves that exceed capacity. The function intelligently selects a solution from the archive based on these criteria, applies the hybrid operator, and returns the improved neighbor solution while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Value-focused flip\n    value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(value_ratio)[::-1]  # Highest ratio first\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Weight-aware swap (if still space)\n    if current_weight < capacity:\n        # Find items not in solution with good value\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            # Select a random candidate\n            swap_candidate = random.choice(candidate_indices)\n            # Find an item in solution to swap with\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) > 0:\n                swap_item = random.choice(in_solution)\n                # Check if swap is feasible\n                if (current_weight - weight_lst[swap_item] + weight_lst[swap_candidate]) <= capacity:\n                    new_solution[swap_item] = 0\n                    new_solution[swap_candidate] = 1\n                    current_weight = current_weight - weight_lst[swap_item] + weight_lst[swap_candidate]\n\n    return new_solution\n\n",
          "score": [
               -0.8430062511573345,
               5.058723509311676
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for improvement through a hybrid local search strategy. This involves selecting solutions with high objective values and low redundancy, then applying a dynamic neighborhood exploration that combines random item swaps, targeted flips based on marginal gains, and a guided local search that prioritizes items with high marginal utility ratios (value1/weight and value2/weight) while ensuring feasibility. The function intelligently balances exploration and exploitation by dynamically adjusting the search scope based on the current solution's characteristics, ensuring the generated neighbor solution remains feasible and potentially dominates or improves upon the original solution across both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n    objective_sums = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for potential swap/flip\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Randomly select an item to flip (with higher probability for items with high marginal utility)\n        probs = np.zeros(len(candidate_items))\n        for i, item in enumerate(candidate_items):\n            marginal_value1 = value1_lst[item] / weight_lst[item] if weight_lst[item] > 0 else 0\n            marginal_value2 = value2_lst[item] / weight_lst[item] if weight_lst[item] > 0 else 0\n            probs[i] = marginal_value1 + marginal_value2\n        probs = probs / np.sum(probs) if np.sum(probs) > 0 else np.ones(len(candidate_items)) / len(candidate_items)\n        selected_item = np.random.choice(candidate_items, p=probs)\n    else:\n        # If no items are selected, find a feasible item to add\n        feasible_items = np.where(weight_lst <= (capacity - current_weight))[0]\n        if len(feasible_items) == 0:\n            return base_solution  # No feasible move possible\n        selected_item = np.random.choice(feasible_items)\n\n    # Create neighbor solution\n    new_solution = base_solution.copy()\n    new_solution[selected_item] = 1 - new_solution[selected_item]  # Flip the selected item\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If flipping makes it infeasible, try to remove the most \"expensive\" item\n        if new_solution[selected_item] == 1:  # We just added it, remove it\n            new_solution[selected_item] = 0\n        else:  # We just removed it, try to add another feasible item\n            feasible_items = np.where((weight_lst <= (capacity - current_weight)) & (base_solution == 0))[0]\n            if len(feasible_items) > 0:\n                add_item = np.random.choice(feasible_items)\n                new_solution[add_item] = 1\n            else:\n                # If no feasible addition, return original solution\n                return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.8072126207495933,
               4.307053357362747
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for improvement through a novel hybrid local search strategy. It prioritizes solutions with high objective values and low crowding distances in the objective space, indicating they are on the Pareto front and have room for further exploration. The function then applies a creative local search operator that combines random item swaps with a guided exploration of adjacent solutions, ensuring feasibility by dynamically adjusting the selection based on the remaining capacity. This approach balances exploration and exploitation, avoiding standard 2-opt methods by incorporating probabilistic item selection and adaptive neighborhood exploration, which helps in diversifying the search and escaping local optima. The selected neighbor solution is guaranteed to be feasible, with its total weight not exceeding the knapsack capacity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low crowding distance (indicating they are on the Pareto front)\n    objectives = np.array([obj for _, obj in archive])\n    fronts = np.argsort(-objectives[:, 0])  # Sort by objective 1 in descending order (non-dominated solutions are first)\n\n    # Select the top 10% of solutions or at least 1 solution\n    top_k = max(1, len(fronts) // 10)\n    selected_indices = fronts[:top_k]\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Randomly select one of the top solutions\n    base_solution = selected_solutions[np.random.choice(len(selected_solutions))].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Step 2.1: Randomly select a subset of items to swap (exploration)\n    candidate_indices = np.where(base_solution == 0)[0]  # Items not in the current solution\n    if len(candidate_indices) > 0:\n        num_swaps = min(3, len(candidate_indices))  # Limit the number of swaps to avoid large perturbations\n        swap_indices = np.random.choice(candidate_indices, size=num_swaps, replace=False)\n\n        for idx in swap_indices:\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Step 2.2: Guided exploration of adjacent solutions (exploitation)\n    # Flip one item to improve the solution\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Ensure the solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If the solution is infeasible, remove the heaviest items until it is feasible\n        included_indices = np.where(new_solution == 1)[0]\n        sorted_indices = included_indices[np.argsort(weight_lst[included_indices])[::-1]]\n        for idx in sorted_indices:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
          "score": [
               -0.32035538623134013,
               4.111595839262009
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on objective diversity and potential improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate potential improvement by considering objective balance\n        obj1, obj2 = obj\n        potential = (obj1 + obj2) * (1 + random.uniform(0.1, 0.3))  # Add randomness to explore diverse solutions\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive bit flipping + objective-balanced perturbation\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Calculate objective balance\n        obj1, obj2 = archive[selected_idx][1]\n        balance = obj1 / (obj1 + obj2) if (obj1 + obj2) != 0 else 0.5\n\n        # Select items to flip based on their marginal contribution to both objectives\n        items = np.arange(len(base_solution))\n        np.random.shuffle(items)\n\n        for item in items:\n            if base_solution[item] == 1:\n                # Try removing the item\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n                    break\n            else:\n                # Try adding the item\n                new_weight = current_weight + weight_lst[item]\n                if new_weight <= capacity:\n                    # Weighted selection based on objective balance\n                    if random.random() < balance:\n                        if value1_lst[item] > 0:\n                            new_solution[item] = 1\n                            current_weight = new_weight\n                            break\n                    else:\n                        if value2_lst[item] > 0:\n                            new_solution[item] = 1\n                            current_weight = new_weight\n                            break\n\n    return new_solution\n\n",
          "score": [
               -0.3417526651511076,
               6.463498681783676
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for improvement through a hybrid local search strategy that combines adaptive item swapping and objective-driven perturbation. It intelligently selects a solution based on its proximity to the non-dominated front and its potential to yield higher-quality neighbors by considering both objective values and their trade-offs. The novel local search operator then generates a neighbor solution by strategically swapping items between objectives, flipping bits with a probability inversely proportional to their contribution to the current solution's objectives, and ensuring feasibility by rejecting any swaps that would exceed the knapsack capacity. The operator also employs a dynamic perturbation mechanism that adjusts the search intensity based on the current solution's dominance rank, further diversifying the search space and improving the likelihood of finding high-quality solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate potential solutions by their objective values and dominance\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = np.array([sol_obj[1] for sol_obj in archive])\n\n    # Normalize objectives for selection\n    if len(archive_objectives) > 1:\n        min_vals = archive_objectives.min(axis=0)\n        max_vals = archive_objectives.max(axis=0)\n        normalized = (archive_objectives - min_vals) / (max_vals - min_vals + 1e-10)\n        # Select a solution with high potential for improvement\n        potential_scores = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n        selected_idx = np.argmax(potential_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Adaptive item swapping\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # Probability of flipping\n            if new_solution[i] == 1:\n                # Try to remove item if it's not critical\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                # Try to add item if it fits\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    # Strategy 2: Objective-driven perturbation\n    if np.random.rand() < 0.5:\n        # Perturb items based on their contribution to objectives\n        item_contributions = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n        sorted_indices = np.argsort(item_contributions)[::-1]\n\n        for i in sorted_indices[:max(3, n_items // 10)]:\n            if new_solution[i] == 1:\n                # Try to remove low-contribution items\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                # Try to add high-contribution items\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    return new_solution\n\n",
          "score": [
               -0.4046999243176084,
               7.876662105321884
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n_items = len(base_solution)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Randomly flip a subset of items\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Step 3: Intelligently swap items based on marginal contributions\n    for _ in range(min(5, n_items // 2)):\n        # Select items to potentially swap\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n\n        i, j = np.random.choice(candidates, size=2, replace=False)\n\n        # Calculate potential improvement\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            # Swap if it improves both objectives\n            if (marginal1[i] < marginal1[j] and marginal2[i] < marginal2[j]) or \\\n               (np.random.rand() < 0.3):  # 30% chance to accept worse swap for diversity\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove heaviest items until feasible\n        while total_weight > capacity:\n            heavy_items = np.where(new_solution == 1)[0]\n            if len(heavy_items) == 0:\n                break\n            # Remove item with highest weight\n            remove_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
          "score": [
               -0.4873597582488212,
               8.902545988559723
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search strategy that combines a random walk with a value-based greedy insertion to explore the solution space. It intelligently selects a solution from the archive, performs a random flip of a subset of items to escape local optima, and then greedily inserts items not in the solution that improve both objectives while respecting the capacity constraint. The function ensures feasibility by rejecting any moves that would exceed the capacity, and it iteratively refines the solution by balancing exploration and exploitation, ultimately returning a high-quality neighbor solution that advances the Pareto front.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high value, low weight utilization)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_weights = [np.sum(weight_lst * sol) for sol in archive_solutions]\n    total_values = [sum(obj) for obj in archive_objectives]\n\n    # Normalize and combine scores (higher is better)\n    norm_weights = np.array(total_weights) / capacity\n    norm_values = np.array(total_values) / np.max(total_values)\n    scores = 0.7 * norm_values - 0.3 * norm_weights  # Prefer high value, low weight\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = total_weights[selected_idx]\n\n    # Hybrid local search: random walk + greedy insertion\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip a subset of items (exploration)\n    num_flips = min(3, len(new_solution) // 2)  # Limit flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after flips\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.any(new_solution):\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess = np.sum(weight_lst * new_solution) - capacity\n\n    # Step 2: Greedy insertion of items not in solution (exploitation)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Check if adding this item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = archive_objectives[selected_idx][0] + value1_lst[i]\n            new_value2 = archive_objectives[selected_idx][1] + value2_lst[i]\n\n            # Check if this item improves both objectives relative to the base solution\n            if (new_value1 > archive_objectives[selected_idx][0] and\n                new_value2 > archive_objectives[selected_idx][1]):\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
          "score": [
               -0.3307306504335522,
               6.010173678398132
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-phase approach to identify and improve promising solutions in the archive. First, it intelligently selects a base solution from the archive by prioritizing those with high objective values or those that are less explored (e.g., solutions with fewer neighbors in the archive). Then, it applies a novel hybrid local search operator that combines random item swaps, adaptive neighborhood exploration, and a feasibility-preserving mechanism. The operator dynamically adjusts the neighborhood size based on the solution's current quality, allowing it to escape local optima while ensuring feasibility by rejecting any moves that would exceed the capacity. Additionally, it incorporates a probabilistic acceptance criterion that balances exploration and exploitation, favoring moves that improve both objectives or those that show potential for further improvement. The function returns the improved neighbor solution, which is guaranteed to be feasible and potentially non-dominated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]))\n    current_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Hybrid local search operator\n    max_iterations = min(10, len(weight_lst))  # Limit iterations to avoid excessive computation\n    for _ in range(max_iterations):\n        # Select a random item to flip\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        # Determine if flipping the item would improve the solution\n        if current_solution[item_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution = current_solution.copy()\n                new_solution[item_idx] = 0\n                new_value1 = np.sum(value1_lst * new_solution)\n                new_value2 = np.sum(value2_lst * new_solution)\n\n                # Accept if at least one objective improves\n                if (new_value1 > base_obj[0]) or (new_value2 > base_obj[1]):\n                    current_solution = new_solution\n                    current_weight = new_weight\n                    base_obj = (new_value1, new_value2)\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution = current_solution.copy()\n                new_solution[item_idx] = 1\n                new_value1 = np.sum(value1_lst * new_solution)\n                new_value2 = np.sum(value2_lst * new_solution)\n\n                # Accept if at least one objective improves\n                if (new_value1 > base_obj[0]) or (new_value2 > base_obj[1]):\n                    current_solution = new_solution\n                    current_weight = new_weight\n                    base_obj = (new_value1, new_value2)\n\n        # Randomly flip another item with probability based on current quality\n        if random.random() < 0.3:  # 30% chance to explore further\n            item_idx = random.randint(0, len(weight_lst) - 1)\n            if current_solution[item_idx] == 1:\n                new_weight = current_weight - weight_lst[item_idx]\n                if new_weight <= capacity:\n                    new_solution = current_solution.copy()\n                    new_solution[item_idx] = 0\n                    current_solution = new_solution\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[item_idx]\n                if new_weight <= capacity:\n                    new_solution = current_solution.copy()\n                    new_solution[item_idx] = 1\n                    current_solution = new_solution\n                    current_weight = new_weight\n\n    return current_solution\n\n",
          "score": [
               -0.31821452728496624,
               5.14351499080658
          ]
     }
]