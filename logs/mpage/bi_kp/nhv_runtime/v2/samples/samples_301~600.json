[
     {
          "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Multi-Objective Value-Driven Exploration with Dynamic Cluster-Based Diversification,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative positions in the Pareto front, then applies a novel local search operator that dynamically adjusts the exploration based on the solution's position in the objective space. The operator combines cluster-based item grouping with a value-driven perturbation strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility, and incorporates a dynamic cluster-based diversification mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values. The algorithm also employs a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape, and uses a novel value-driven exploration strategy that focuses on improving both objectives simultaneously by considering their combined impact on the solution's quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good trade-off and position\n    def tradeoff_score(sol):\n        v1, v2 = sol[1]\n        return (v1 + v2) / (1 + abs(v1 - v2))  # Higher for balanced trade-off\n\n    selected = max(archive, key=lambda x: tradeoff_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Cluster items based on value-to-weight ratios and objective contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value1_ratio + value2_ratio\n    cluster_indices = np.argsort(combined_ratio)[::-1]\n\n    # Step 3: Dynamic value-driven perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine perturbation intensity based on solution's position\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_ratio = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_ratio = obj2 / total_v2 if total_v2 > 0 else 0\n    perturbation_intensity = 0.5 * (1 - obj1_ratio) + 0.5 * (1 - obj2_ratio)\n\n    # Select cluster size based on perturbation intensity\n    cluster_size = max(1, int(perturbation_intensity * len(cluster_indices)))\n    selected_cluster = cluster_indices[:cluster_size]\n\n    # Apply value-driven perturbations\n    for idx in selected_cluster:\n        if base_solution[idx] == 1:\n            # Try removing if it improves both objectives\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves both objectives\n            if weight_lst[idx] <= remaining_capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 4: Probabilistic diversification move with value-driven selection\n    if random.random() < 0.3 * perturbation_intensity:\n        # Select a random item from the cluster with higher value-to-weight ratio\n        if len(selected_cluster) > 0:\n            # Sort cluster by value-to-weight ratio\n            sorted_cluster = sorted(selected_cluster, key=lambda x: combined_ratio[x], reverse=True)\n            # Select top 30% of the cluster\n            top_cluster = sorted_cluster[:max(1, int(0.3 * len(sorted_cluster)))]\n            flip_idx = random.choice(top_cluster)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm, named \"Adaptive Multi-Objective Greedy Neighborhood Search,\" dynamically selects a solution from the archive by prioritizing those with high combined objective values and low crowding distance, then applies a hybrid local search operator that combines a greedy insertion phase with a probabilistic exchange phase. In the greedy phase, it iteratively inserts the most valuable item (based on a dynamic trade-off between the two objectives) that fits the remaining capacity, while in the exchange phase, it probabilistically swaps items between the knapsack and the remaining pool, guided by a utility function that balances the marginal gain in both objectives and the solution's current position in the Pareto front. The algorithm ensures feasibility by strictly enforcing the weight constraint and incorporates a temperature-based acceptance criterion to escape local optima, gradually reducing the probability of accepting non-improving moves as the search progresses.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective values and low crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances * (objectives[:, 0] + objectives[:, 1]))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    new_solution = base_solution.copy()\n\n    # Greedy insertion phase\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate utility for excluded items (greedy insertion)\n    utility = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-6)\n    sorted_excluded = excluded[np.argsort(-utility)]\n\n    for idx in sorted_excluded:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n            current_weight += weight_lst[idx]\n\n    # Probabilistic exchange phase\n    temperature = 0.5  # Initial temperature\n    for _ in range(10):  # Number of exchange attempts\n        if random.random() < temperature:\n            # Select a random item to swap\n            item_idx = random.choice(np.where(new_solution == 1)[0])\n            candidate_idx = random.choice(np.where(new_solution == 0)[0])\n\n            # Calculate new weight\n            new_weight = current_weight - weight_lst[item_idx] + weight_lst[candidate_idx]\n\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                new_solution[candidate_idx] = 1\n                current_weight = new_weight\n\n        temperature *= 0.9  # Cool down\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The proposed algorithm, \"Adaptive Multi-Objective Value-Weight Balance Exploration with Dynamic Objective-Driven Diversification,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative balance with respect to the total possible values, then applies a novel local search operator that dynamically adjusts the exploration based on the solution's position in the objective space. The operator combines value-weight balance clustering with an objective-driven diversification strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility, and incorporates a dynamic objective-driven diversification mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values. The algorithm also employs a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape, and uses a novel objective-driven exploration strategy that focuses on improving both objectives simultaneously by considering their combined impact on the solution's quality, while also ensuring a balanced exploration of the objective space by dynamically adjusting the exploration focus between the two objectives based on their current relative contributions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good balance and position\n    def balance_score(sol):\n        v1, v2 = sol[1]\n        total_v1 = np.sum(value1_lst)\n        total_v2 = np.sum(value2_lst)\n        if total_v1 == 0 or total_v2 == 0:\n            return 0\n        return (v1/total_v1 + v2/total_v2) / (1 + abs((v1/total_v1) - (v2/total_v2)))\n\n    selected = max(archive, key=lambda x: balance_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Cluster items based on value-weight balance and objective contributions\n    value1_balance = value1_lst / (weight_lst + 1e-6)\n    value2_balance = value2_lst / (weight_lst + 1e-6)\n    combined_balance = value1_balance + value2_balance\n    cluster_indices = np.argsort(combined_balance)[::-1]\n\n    # Step 3: Dynamic objective-driven diversification\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine diversification intensity based on objective balance\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_balance = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_balance = obj2 / total_v2 if total_v2 > 0 else 0\n    diversification_intensity = 0.5 * (1 - obj1_balance) + 0.5 * (1 - obj2_balance)\n\n    # Select cluster size based on diversification intensity\n    cluster_size = max(1, int(diversification_intensity * len(cluster_indices)))\n    selected_cluster = cluster_indices[:cluster_size]\n\n    # Apply objective-driven diversification\n    for idx in selected_cluster:\n        if base_solution[idx] == 1:\n            # Try removing if it improves the less balanced objective\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0:\n                if (obj1_balance < obj2_balance and value1_lst[idx] > 0) or (obj2_balance < obj1_balance and value2_lst[idx] > 0):\n                    new_solution[idx] = 0\n                    remaining_capacity += weight_lst[idx]\n                    current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves the more balanced objective\n            if weight_lst[idx] <= remaining_capacity:\n                if (obj1_balance > obj2_balance and value1_lst[idx] > 0) or (obj2_balance > obj1_balance and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n                    current_weight += weight_lst[idx]\n\n    # Step 4: Probabilistic diversification move with objective-driven selection\n    if random.random() < 0.3 * diversification_intensity:\n        # Select a random item from the cluster with higher value-weight balance\n        if len(selected_cluster) > 0:\n            # Sort cluster by value-weight balance\n            sorted_cluster = sorted(selected_cluster, key=lambda x: combined_balance[x], reverse=True)\n            # Select top 30% of the cluster\n            top_cluster = sorted_cluster[:max(1, int(0.3 * len(sorted_cluster)))]\n            flip_idx = random.choice(top_cluster)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.7994466366593052,
               5.177423536777496
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good balance and position\n    def balance_score(sol):\n        v1, v2 = sol[1]\n        total_v1 = np.sum(value1_lst)\n        total_v2 = np.sum(value2_lst)\n        if total_v1 == 0 or total_v2 == 0:\n            return 0\n        return (v1/total_v1 + v2/total_v2) / (1 + abs((v1/total_v1) - (v2/total_v2)))\n\n    selected = max(archive, key=lambda x: balance_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Cluster items based on value-weight balance and objective contributions\n    value1_balance = value1_lst / (weight_lst + 1e-6)\n    value2_balance = value2_lst / (weight_lst + 1e-6)\n    combined_balance = value1_balance + value2_balance\n    cluster_indices = np.argsort(combined_balance)[::-1]\n\n    # Step 3: Dynamic objective-driven diversification\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine diversification intensity based on objective balance\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_balance = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_balance = obj2 / total_v2 if total_v2 > 0 else 0\n    diversification_intensity = 0.5 * (1 - obj1_balance) + 0.5 * (1 - obj2_balance)\n\n    # Select cluster size based on diversification intensity\n    cluster_size = max(1, int(diversification_intensity * len(cluster_indices)))\n    selected_cluster = cluster_indices[:cluster_size]\n\n    # Apply objective-driven diversification\n    for idx in selected_cluster:\n        if base_solution[idx] == 1:\n            # Try removing if it improves the less balanced objective\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0:\n                if (obj1_balance < obj2_balance and value1_lst[idx] > 0) or (obj2_balance < obj1_balance and value2_lst[idx] > 0):\n                    new_solution[idx] = 0\n                    remaining_capacity += weight_lst[idx]\n                    current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves the more balanced objective\n            if weight_lst[idx] <= remaining_capacity:\n                if (obj1_balance > obj2_balance and value1_lst[idx] > 0) or (obj2_balance > obj1_balance and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n                    current_weight += weight_lst[idx]\n\n    # Step 4: Probabilistic diversification move with objective-driven selection\n    if random.random() < 0.3 * diversification_intensity:\n        # Select a random item from the cluster with higher value-weight balance\n        if len(selected_cluster) > 0:\n            # Sort cluster by value-weight balance\n            sorted_cluster = sorted(selected_cluster, key=lambda x: combined_balance[x], reverse=True)\n            # Select top 30% of the cluster\n            top_cluster = sorted_cluster[:max(1, int(0.3 * len(sorted_cluster)))]\n            flip_idx = random.choice(top_cluster)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Weighted Greedy Insertion with Dynamic Objective Expansion,\" first identifies the most promising solution in the archive by selecting the one with the highest combined objective value, then applies a novel local search operator that dynamically prioritizes items based on their adaptive objective-weighted values, uses a greedy insertion strategy that considers both objectives with adaptive weights, and incorporates a dynamic expansion mechanism that adaptively explores the solution space by selectively including or excluding items based on their relative contributions to the objectives while maintaining feasibility through a capacity-constrained insertion process that ensures the total weight does not exceed capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate adaptive objective-weighted values\n    obj1, obj2 = selected[1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    weighted_values = obj_ratio * value1_lst + (1 - obj_ratio) * value2_lst\n\n    # Sort items by weighted values in descending order\n    sorted_items = np.argsort(-weighted_values)\n\n    # Dynamic expansion mechanism\n    expansion_count = max(1, int(0.2 * len(weight_lst)))\n    for item in sorted_items[:expansion_count]:\n        if new_solution[item] == 0 and weight_lst[item] <= capacity - current_weight:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Dynamic contraction mechanism\n    contraction_count = max(1, int(0.1 * len(weight_lst)))\n    for item in sorted_items[-contraction_count:]:\n        if new_solution[item] == 1 and current_weight - weight_lst[item] >= 0:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Centric Hybridization with Dynamic Value-Weight Balance Exploration,\" first identifies the most under-represented objective direction in the archive by measuring the angular distance between each solution's objective vector and the ideal point, then applies a novel local search operator that combines value-weight balance analysis with dynamic objective-centric hybridization. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-centric and value-weight balance considerations, and incorporates a dynamic exploration mechanism that adaptively selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight balance scores\n    vw_balance1 = value1_lst / (weight_lst + 1e-10)\n    vw_balance2 = value2_lst / (weight_lst + 1e-10)\n    max_balance1, max_balance2 = np.max(vw_balance1), np.max(vw_balance2)\n    normalized_balance1 = vw_balance1 / max_balance1 if max_balance1 > 0 else vw_balance1\n    normalized_balance2 = vw_balance2 / max_balance2 if max_balance2 > 0 else vw_balance2\n\n    # Step 3: Dynamic objective-centric hybridization\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    combined_balance = obj_ratio * normalized_balance1 + (1 - obj_ratio) * normalized_balance2\n\n    # Step 4: Hybrid substitution strategy\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.3 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined balance score\n    sorted_items = np.argsort(-combined_balance)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low balance score relative to its objective\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add item if it has high balance score for the under-represented objective\n            if weight_lst[item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[item] > normalized_balance2[item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[item] > normalized_balance1[item]):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 5: Dynamic exploration mechanism\n    if random.random() < 0.4:\n        # Select item with lowest combined balance score for the under-represented objective\n        flip_item = sorted_items[-1]\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[flip_item] > normalized_balance2[flip_item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[flip_item] > normalized_balance1[flip_item]):\n                    new_solution[flip_item] = 1\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The proposed algorithm, \"Objective-Driven Dynamic Substitution with Adaptive Feasibility Preservation,\" first identifies the solution in the archive with the highest Euclidean distance from the ideal point in objective space, then applies a novel local search operator that dynamically substitutes items based on their relative contributions to both objectives, using an adaptive substitution ratio that considers the current solution's objective values and the archive's diversity, while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity, and incorporates a dynamic objective-driven exploration mechanism that selectively modifies subsets of items based on their adaptive value-weight ratios and the current objective direction, with a probabilistic acceptance criterion that balances exploration and exploitation to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the solution with highest Euclidean distance from ideal point\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-10)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Step 3: Calculate adaptive substitution ratio\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    substitution_ratio = 0.2 + 0.3 * (1 - distances[selected_idx]/np.max(distances))\n\n    # Step 4: Dynamic substitution mechanism\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(substitution_ratio * n_items))\n\n    # Calculate combined value-weight score\n    combined_score = obj_ratio * vw_ratio1 + (1 - obj_ratio) * vw_ratio2\n\n    # Sort items by combined score\n    sorted_items = np.argsort(-combined_score)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove if it has low combined score\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add if it has high combined score and fits capacity\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 5: Dynamic exploration with probabilistic acceptance\n    if random.random() < 0.5:\n        # Select random item with low combined score for potential flip\n        flip_candidates = sorted_items[-int(0.2*n_items):]\n        flip_item = random.choice(flip_candidates)\n\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.9028071607851299,
               1.0317822992801666
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the solution with highest Euclidean distance from ideal point\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-10)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Step 3: Calculate adaptive substitution ratio\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    substitution_ratio = 0.2 + 0.3 * (1 - distances[selected_idx]/np.max(distances))\n\n    # Step 4: Dynamic substitution mechanism\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(substitution_ratio * n_items))\n\n    # Calculate combined value-weight score\n    combined_score = obj_ratio * vw_ratio1 + (1 - obj_ratio) * vw_ratio2\n\n    # Sort items by combined score\n    sorted_items = np.argsort(-combined_score)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove if it has low combined score\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add if it has high combined score and fits capacity\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 5: Dynamic exploration with probabilistic acceptance\n    if random.random() < 0.5:\n        # Select random item with low combined score for potential flip\n        flip_candidates = sorted_items[-int(0.2*n_items):]\n        flip_item = random.choice(flip_candidates)\n\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Driven Diversification with Dynamic Utility-Based Substitution,\" first identifies the most diverse solution in the archive by measuring the maximum angular distance between its objective vector and the centroid of all objective vectors, then applies a novel local search operator that combines utility-based substitution with dynamic diversification pressure. The operator prioritizes items based on their normalized marginal utility for both objectives, uses a probabilistic substitution strategy that adaptsively balances exploitation and exploration based on the solution's current position relative to the Pareto front, and dynamically adjusts the substitution intensity through a utility-based diversification mechanism that encourages exploration of underrepresented objective regions while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate normalized marginal utilities\n    marginal_obj1 = value1_lst / (weight_lst + 1e-10)\n    marginal_obj2 = value2_lst / (weight_lst + 1e-10)\n    max_obj1, max_obj2 = np.max(marginal_obj1), np.max(marginal_obj2)\n    normalized_obj1 = marginal_obj1 / max_obj1 if max_obj1 > 0 else marginal_obj1\n    normalized_obj2 = marginal_obj2 / max_obj2 if max_obj2 > 0 else marginal_obj2\n    combined_utility = normalized_obj1 + normalized_obj2\n\n    # Step 3: Dynamic utility-based substitution\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.2 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined utility\n    sorted_items = np.argsort(-combined_utility)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low utility\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add item if it has high utility\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 4: Probabilistic diversification\n    if random.random() < 0.5:\n        # Select item with lowest combined utility\n        flip_item = sorted_items[-1]\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Multi-Objective Value-Driven Exploration with Dynamic Cluster-Based Diversification,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative positions in the Pareto front, then applies a novel local search operator that dynamically adjusts the exploration based on the solution's position in the objective space. The operator combines cluster-based item grouping with a value-driven perturbation strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility, and incorporates a dynamic cluster-based diversification mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values. The algorithm also employs a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape, and uses a novel value-driven exploration strategy that focuses on improving both objectives simultaneously by considering their combined impact on the solution's quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good trade-off and position\n    def tradeoff_score(sol):\n        v1, v2 = sol[1]\n        return (v1 + v2) / (1 + abs(v1 - v2))  # Higher for balanced trade-off\n\n    selected = max(archive, key=lambda x: tradeoff_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Cluster items based on value-to-weight ratios and objective contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value1_ratio + value2_ratio\n    cluster_indices = np.argsort(combined_ratio)[::-1]\n\n    # Step 3: Dynamic value-driven perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine perturbation intensity based on solution's position\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_ratio = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_ratio = obj2 / total_v2 if total_v2 > 0 else 0\n    perturbation_intensity = 0.5 * (1 - obj1_ratio) + 0.5 * (1 - obj2_ratio)\n\n    # Select cluster size based on perturbation intensity\n    cluster_size = max(1, int(perturbation_intensity * len(cluster_indices)))\n    selected_cluster = cluster_indices[:cluster_size]\n\n    # Apply value-driven perturbations\n    for idx in selected_cluster:\n        if base_solution[idx] == 1:\n            # Try removing if it improves both objectives\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves both objectives\n            if weight_lst[idx] <= remaining_capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 4: Probabilistic diversification move with value-driven selection\n    if random.random() < 0.3 * perturbation_intensity:\n        # Select a random item from the cluster with higher value-to-weight ratio\n        if len(selected_cluster) > 0:\n            # Sort cluster by value-to-weight ratio\n            sorted_cluster = sorted(selected_cluster, key=lambda x: combined_ratio[x], reverse=True)\n            # Select top 30% of the cluster\n            top_cluster = sorted_cluster[:max(1, int(0.3 * len(sorted_cluster)))]\n            flip_idx = random.choice(top_cluster)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The proposed algorithm, \"Adaptive Multi-Objective Value-Driven Exploration with Dynamic Cluster-Based Diversification,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative positions in the Pareto front, then applies a novel local search operator that dynamically adjusts the exploration based on the solution's position in the objective space. The operator combines cluster-based item grouping with a value-driven perturbation strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility, and incorporates a dynamic cluster-based diversification mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values. The algorithm also employs a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape, and uses a novel value-driven exploration strategy that focuses on improving both objectives simultaneously by considering their combined impact on the solution's quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with the highest combined value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Step 3: Sort items by combined ratio in descending order\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Step 4: Perform a series of swaps to explore the neighborhood\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    n_items = len(weight_lst)\n\n    # Try to remove the least valuable item\n    for item in sorted_items[::-1]:\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_solution[item] = 0\n                current_weight = new_weight\n                break\n\n    # Try to add the most valuable item that fits\n    remaining_capacity = capacity - current_weight\n    for item in sorted_items:\n        if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n            new_solution[item] = 1\n            break\n\n    # Step 5: Randomly flip a small number of items to maintain diversity\n    flip_count = min(2, n_items)\n    flip_indices = random.sample(range(n_items), flip_count)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.31920038025900754,
               4.578141897916794
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with the highest combined value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Step 3: Sort items by combined ratio in descending order\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Step 4: Perform a series of swaps to explore the neighborhood\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    n_items = len(weight_lst)\n\n    # Try to remove the least valuable item\n    for item in sorted_items[::-1]:\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_solution[item] = 0\n                current_weight = new_weight\n                break\n\n    # Try to add the most valuable item that fits\n    remaining_capacity = capacity - current_weight\n    for item in sorted_items:\n        if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n            new_solution[item] = 1\n            break\n\n    # Step 5: Randomly flip a small number of items to maintain diversity\n    flip_count = min(2, n_items)\n    flip_indices = random.sample(range(n_items), flip_count)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Weighted Greedy Insertion with Dynamic Objective Expansion,\" first identifies the most promising solution in the archive by selecting the one with the highest combined objective value, then applies a novel local search operator that dynamically prioritizes items based on their adaptive objective-weighted values, uses a greedy insertion strategy that considers both objectives with adaptive weights, and incorporates a dynamic expansion mechanism that adaptively explores the solution space by selectively including or excluding items based on their relative contributions to the objectives while maintaining feasibility through a capacity-constrained insertion process that ensures the total weight does not exceed capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate adaptive objective-weighted values\n    obj1, obj2 = selected[1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    weighted_values = obj_ratio * value1_lst + (1 - obj_ratio) * value2_lst\n\n    # Sort items by weighted values in descending order\n    sorted_items = np.argsort(-weighted_values)\n\n    # Dynamic expansion mechanism\n    expansion_count = max(1, int(0.2 * len(weight_lst)))\n    for item in sorted_items[:expansion_count]:\n        if new_solution[item] == 0 and weight_lst[item] <= capacity - current_weight:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Dynamic contraction mechanism\n    contraction_count = max(1, int(0.1 * len(weight_lst)))\n    for item in sorted_items[-contraction_count:]:\n        if new_solution[item] == 1 and current_weight - weight_lst[item] >= 0:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Multi-Objective Greedy Substitution with Dynamic Objective Prioritization,\" first selects the solution with the highest combined objective value as the base solution, then applies a novel local search operator that dynamically prioritizes items based on their value-to-weight ratios for both objectives, using a greedy substitution strategy that adaptively switches between objective-specific item selection based on a dynamic objective prioritization score derived from the current solution's objective values and their historical improvements, while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity. The operator also incorporates a probabilistic objective shift mechanism that randomly re-prioritizes objectives to escape local optima and explores new regions of the Pareto front, with the substitution intensity dynamically adjusted based on the current solution's position relative to the Pareto front and the diversity of the archive.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate current state\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Step 3: Dynamic objective prioritization\n    obj1, obj2 = selected[1]\n    obj_priority = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n    # Step 4: Calculate value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Step 5: Dynamic objective switching\n    if random.random() < 0.3:\n        obj_priority = 1 - obj_priority  # Randomly switch objectives\n\n    # Step 6: Sort items based on current objective priority\n    if obj_priority > 0.5:\n        sorted_items = np.argsort(-v1_ratio)\n    else:\n        sorted_items = np.argsort(-v2_ratio)\n\n    # Step 7: Greedy substitution with dynamic intensity\n    substitution_intensity = max(1, int(0.2 * len(weight_lst) * (1 - obj_priority)))\n    for item in sorted_items[:substitution_intensity]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low value-to-weight ratio\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                remaining_capacity += weight_lst[item]\n        else:\n            # Try to add item if it has high value-to-weight ratio and fits\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 8: Probabilistic objective shift\n    if random.random() < 0.1:\n        # Randomly select a different objective for next steps\n        obj_priority = random.choice([0.2, 0.8])\n\n    # Step 9: Final diversification step\n    if random.random() < 0.2:\n        # Select a random item to flip\n        flip_item = random.randint(0, len(weight_lst)-1)\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= remaining_capacity:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The proposed algorithm, \"Adaptive Multi-Objective Diversified Substitution with Dynamic Objective Fusion,\" first identifies the most promising solution in the archive by selecting the one with the highest combined objective value, then applies a novel local search operator that dynamically combines both objectives into a single fused score using a weighted sum with adaptive weights determined by the current solution's objective values and their historical improvements, using a diversified substitution strategy that adaptively switches between objective-specific item selection based on a dynamic objective fusion score derived from the current solution's objective values and their relative contributions, while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity. The operator also incorporates a probabilistic objective fusion mechanism that randomly rebalances the objective weights to escape local optima and explore new regions of the solution space, with the substitution intensity dynamically adjusted based on the current solution's position relative to the Pareto front and the diversity of the archive, and includes a novel diversification step that selectively flips items based on their contribution to both objectives and their current state in the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Dynamic objective fusion\n    obj1, obj2 = selected[1]\n    fusion_weight = obj1 / (obj1 + obj2 + 1e-6) if (obj1 + obj2) > 0 else 0.5\n\n    # Calculate fused score\n    fused_score = fusion_weight * value1_lst + (1 - fusion_weight) * value2_lst\n    fused_score /= (weight_lst + 1e-6)  # Normalize by weight\n\n    # Probabilistic fusion adjustment\n    if random.random() < 0.3:\n        fusion_weight = random.uniform(0.2, 0.8)\n\n    # Sort items based on fused score\n    sorted_items = np.argsort(-fused_score)\n\n    # Diversified substitution with dynamic intensity\n    substitution_intensity = max(1, int(0.3 * len(weight_lst) * (1 - abs(fusion_weight - 0.5))))\n\n    for item in sorted_items[:substitution_intensity]:\n        if new_solution[item] == 1:\n            # Remove item if it has low fused score\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                remaining_capacity += weight_lst[item]\n        else:\n            # Add item if it has high fused score and fits\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Novel diversification step\n    if random.random() < 0.2:\n        # Select items with high value in both objectives\n        combined_value = value1_lst + value2_lst\n        high_value_items = np.argsort(-combined_value)\n\n        for item in high_value_items[:max(1, int(0.1 * len(weight_lst)))]:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n",
          "score": [
               -0.7200873044604019,
               1.1154929995536804
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Dynamic objective fusion\n    obj1, obj2 = selected[1]\n    fusion_weight = obj1 / (obj1 + obj2 + 1e-6) if (obj1 + obj2) > 0 else 0.5\n\n    # Calculate fused score\n    fused_score = fusion_weight * value1_lst + (1 - fusion_weight) * value2_lst\n    fused_score /= (weight_lst + 1e-6)  # Normalize by weight\n\n    # Probabilistic fusion adjustment\n    if random.random() < 0.3:\n        fusion_weight = random.uniform(0.2, 0.8)\n\n    # Sort items based on fused score\n    sorted_items = np.argsort(-fused_score)\n\n    # Diversified substitution with dynamic intensity\n    substitution_intensity = max(1, int(0.3 * len(weight_lst) * (1 - abs(fusion_weight - 0.5))))\n\n    for item in sorted_items[:substitution_intensity]:\n        if new_solution[item] == 1:\n            # Remove item if it has low fused score\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                remaining_capacity += weight_lst[item]\n        else:\n            # Add item if it has high fused score and fits\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Novel diversification step\n    if random.random() < 0.2:\n        # Select items with high value in both objectives\n        combined_value = value1_lst + value2_lst\n        high_value_items = np.argsort(-combined_value)\n\n        for item in high_value_items[:max(1, int(0.1 * len(weight_lst)))]:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Aware Hybrid Substitution with Dynamic Neighborhood Expansion,\" first identifies the most under-represented objective direction in the archive by analyzing the distribution of solutions and their objective values, then applies a novel local search operator that combines dynamic objective-aware substitution with adaptive neighborhood expansion. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-aware and value-weight balance considerations, and incorporates an adaptive neighborhood expansion mechanism that dynamically selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity. Additionally, the algorithm employs a dynamic temperature-based acceptance criterion to balance exploration and exploitation, gradually reducing the probability of accepting non-improving moves as the search progresses.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight balance scores\n    vw_balance1 = value1_lst / (weight_lst + 1e-10)\n    vw_balance2 = value2_lst / (weight_lst + 1e-10)\n    max_balance1, max_balance2 = np.max(vw_balance1), np.max(vw_balance2)\n    normalized_balance1 = vw_balance1 / max_balance1 if max_balance1 > 0 else vw_balance1\n    normalized_balance2 = vw_balance2 / max_balance2 if max_balance2 > 0 else vw_balance2\n\n    # Step 3: Dynamic objective-aware substitution\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    combined_balance = obj_ratio * normalized_balance1 + (1 - obj_ratio) * normalized_balance2\n\n    # Step 4: Adaptive neighborhood expansion mechanism\n    n_items = len(weight_lst)\n    expansion_factor = 1.0 + (distances[selected_idx] / np.max(distances)) * 0.5\n    neighborhood_size = max(1, int(expansion_factor * 0.2 * n_items))\n\n    # Sort items by combined balance score\n    sorted_items = np.argsort(-combined_balance)\n\n    # Temperature-based acceptance\n    temperature = 0.7\n    for _ in range(10):\n        if random.random() < temperature:\n            # Select item with lowest combined balance score for the under-represented objective\n            flip_item = sorted_items[-1]\n            if new_solution[flip_item] == 1:\n                if current_weight - weight_lst[flip_item] >= 0:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n            else:\n                if weight_lst[flip_item] <= capacity - current_weight:\n                    if (obj_ratio > 0.5 and normalized_balance1[flip_item] > normalized_balance2[flip_item]) or \\\n                       (obj_ratio <= 0.5 and normalized_balance2[flip_item] > normalized_balance1[flip_item]):\n                        new_solution[flip_item] = 1\n                        current_weight += weight_lst[flip_item]\n        temperature *= 0.8\n\n    # Step 5: Hybrid substitution strategy with neighborhood expansion\n    for item in sorted_items[:neighborhood_size]:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            if weight_lst[item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[item] > normalized_balance2[item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[item] > normalized_balance1[item]):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Driven Diversification with Dynamic Utility-Based Substitution,\" first identifies the most diverse solution in the archive by measuring the maximum angular distance between its objective vector and the centroid of all objective vectors, then applies a novel local search operator that combines utility-based substitution with dynamic diversification pressure. The operator prioritizes items based on their normalized marginal utility for both objectives, uses a probabilistic substitution strategy that adaptsively balances exploitation and exploration based on the solution's current position relative to the Pareto front, and dynamically adjusts the substitution intensity through a utility-based diversification mechanism that encourages exploration of underrepresented objective regions while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate normalized marginal utilities\n    marginal_obj1 = value1_lst / (weight_lst + 1e-10)\n    marginal_obj2 = value2_lst / (weight_lst + 1e-10)\n    max_obj1, max_obj2 = np.max(marginal_obj1), np.max(marginal_obj2)\n    normalized_obj1 = marginal_obj1 / max_obj1 if max_obj1 > 0 else marginal_obj1\n    normalized_obj2 = marginal_obj2 / max_obj2 if max_obj2 > 0 else marginal_obj2\n    combined_utility = normalized_obj1 + normalized_obj2\n\n    # Step 3: Dynamic utility-based substitution\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.2 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined utility\n    sorted_items = np.argsort(-combined_utility)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low utility\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add item if it has high utility\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 4: Probabilistic diversification\n    if random.random() < 0.5:\n        # Select item with lowest combined utility\n        flip_item = sorted_items[-1]\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    nadir_point = np.min(objectives, axis=0)\n    range_obj = ideal_point - nadir_point + 1e-10\n    normalized_obj = (objectives - nadir_point) / range_obj\n    distances = np.linalg.norm(normalized_obj - 0.5, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate multi-criteria utility scores\n    marginal_obj1 = value1_lst / (weight_lst + 1e-10)\n    marginal_obj2 = value2_lst / (weight_lst + 1e-10)\n    max_obj1, max_obj2 = np.max(marginal_obj1), np.max(marginal_obj2)\n    normalized_obj1 = marginal_obj1 / max_obj1 if max_obj1 > 0 else marginal_obj1\n    normalized_obj2 = marginal_obj2 / max_obj2 if max_obj2 > 0 else marginal_obj2\n    combined_utility = normalized_obj1 + normalized_obj2\n\n    # Step 3: Dynamic objective-aware substitution\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    weighted_utility = obj_ratio * normalized_obj1 + (1 - obj_ratio) * normalized_obj2\n\n    # Step 4: Adaptive substitution and diversification\n    n_items = len(weight_lst)\n    substitution_size = max(1, int(0.3 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by weighted utility\n    sorted_items = np.argsort(-weighted_utility)\n\n    # Temperature-based acceptance\n    temperature = 0.5\n    for _ in range(10):\n        if random.random() < temperature:\n            # Select item with lowest weighted utility for diversification\n            flip_item = sorted_items[-1]\n            if new_solution[flip_item] == 1:\n                if current_weight - weight_lst[flip_item] >= 0:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n            else:\n                if weight_lst[flip_item] <= capacity - current_weight:\n                    new_solution[flip_item] = 1\n                    current_weight += weight_lst[flip_item]\n        temperature *= 0.9\n\n    # Step 5: Hybrid substitution with diversification\n    for item in sorted_items[:substitution_size]:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
          "score": [
               -0.8406562469994869,
               1.367310255765915
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    nadir_point = np.min(objectives, axis=0)\n    range_obj = ideal_point - nadir_point + 1e-10\n    normalized_obj = (objectives - nadir_point) / range_obj\n    distances = np.linalg.norm(normalized_obj - 0.5, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate multi-criteria utility scores\n    marginal_obj1 = value1_lst / (weight_lst + 1e-10)\n    marginal_obj2 = value2_lst / (weight_lst + 1e-10)\n    max_obj1, max_obj2 = np.max(marginal_obj1), np.max(marginal_obj2)\n    normalized_obj1 = marginal_obj1 / max_obj1 if max_obj1 > 0 else marginal_obj1\n    normalized_obj2 = marginal_obj2 / max_obj2 if max_obj2 > 0 else marginal_obj2\n    combined_utility = normalized_obj1 + normalized_obj2\n\n    # Step 3: Dynamic objective-aware substitution\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    weighted_utility = obj_ratio * normalized_obj1 + (1 - obj_ratio) * normalized_obj2\n\n    # Step 4: Adaptive substitution and diversification\n    n_items = len(weight_lst)\n    substitution_size = max(1, int(0.3 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by weighted utility\n    sorted_items = np.argsort(-weighted_utility)\n\n    # Temperature-based acceptance\n    temperature = 0.5\n    for _ in range(10):\n        if random.random() < temperature:\n            # Select item with lowest weighted utility for diversification\n            flip_item = sorted_items[-1]\n            if new_solution[flip_item] == 1:\n                if current_weight - weight_lst[flip_item] >= 0:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n            else:\n                if weight_lst[flip_item] <= capacity - current_weight:\n                    new_solution[flip_item] = 1\n                    current_weight += weight_lst[flip_item]\n        temperature *= 0.9\n\n    # Step 5: Hybrid substitution with diversification\n    for item in sorted_items[:substitution_size]:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Centric Hybridization with Dynamic Value-Weight Balance Exploration,\" first identifies the most under-represented objective direction in the archive by measuring the angular distance between each solution's objective vector and the ideal point, then applies a novel local search operator that combines value-weight balance analysis with dynamic objective-centric hybridization. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-centric and value-weight balance considerations, and incorporates a dynamic exploration mechanism that adaptively selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight balance scores\n    vw_balance1 = value1_lst / (weight_lst + 1e-10)\n    vw_balance2 = value2_lst / (weight_lst + 1e-10)\n    max_balance1, max_balance2 = np.max(vw_balance1), np.max(vw_balance2)\n    normalized_balance1 = vw_balance1 / max_balance1 if max_balance1 > 0 else vw_balance1\n    normalized_balance2 = vw_balance2 / max_balance2 if max_balance2 > 0 else vw_balance2\n\n    # Step 3: Dynamic objective-centric hybridization\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    combined_balance = obj_ratio * normalized_balance1 + (1 - obj_ratio) * normalized_balance2\n\n    # Step 4: Hybrid substitution strategy\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.3 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined balance score\n    sorted_items = np.argsort(-combined_balance)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low balance score relative to its objective\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add item if it has high balance score for the under-represented objective\n            if weight_lst[item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[item] > normalized_balance2[item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[item] > normalized_balance1[item]):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 5: Dynamic exploration mechanism\n    if random.random() < 0.4:\n        # Select item with lowest combined balance score for the under-represented objective\n        flip_item = sorted_items[-1]\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[flip_item] > normalized_balance2[flip_item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[flip_item] > normalized_balance1[flip_item]):\n                    new_solution[flip_item] = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm, \"Adaptive Objective-Driven Dynamic Substitution with Multi-Perspective Exploration,\" first identifies the most under-represented objective direction in the archive by analyzing the distribution of solutions and their objective values, then applies a novel local search operator that combines dynamic objective-centric substitution with multi-perspective exploration. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-centric and value-weight balance considerations, and incorporates a multi-perspective exploration mechanism that adaptively selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity. Additionally, the algorithm employs a dynamic temperature-based acceptance criterion to balance exploration and exploitation, gradually reducing the probability of accepting non-improving moves as the search progresses.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-6)\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Step 3: Identify items with high combined value-to-weight ratios\n    combined_ratio = ratio1 + ratio2\n    high_ratio_items = np.argsort(-combined_ratio)[:max(1, len(weight_lst)//5)]\n\n    # Step 4: Perform a dynamic substitution based on the selected items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for item in high_ratio_items:\n        if new_solution[item] == 1:\n            # Try removing the item if it has negative impact on both objectives\n            if (value1_lst[item] > 0 and value2_lst[item] > 0) or random.random() < 0.3:\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight >= 0:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n                    remaining_capacity += weight_lst[item]\n        else:\n            # Try adding the item if it fits and has positive impact\n            if weight_lst[item] <= remaining_capacity and (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 5: Perform a small random perturbation to escape local optima\n    if random.random() < 0.2:\n        random_item = random.choice(high_ratio_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] >= 0:\n                new_solution[random_item] = 0\n        else:\n            if weight_lst[random_item] <= remaining_capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": "{The proposed algorithm, \"Adaptive Objective-Driven Dynamic Substitution with Multi-Perspective Exploration,\" first identifies the most under-represented objective direction in the archive by analyzing the distribution of solutions and their objective values, then applies a novel local search operator that combines dynamic objective-centric substitution with multi-perspective exploration. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-centric and value-weight balance considerations, and incorporates a multi-perspective exploration mechanism that adaptively selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity. Additionally, the algorithm employs a dynamic temperature-based acceptance criterion to balance exploration and exploitation, gradually reducing the probability of accepting non-improving moves as the search progresses.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-6)\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Step 3: Identify items with high combined value-to-weight ratios\n    combined_ratio = ratio1 + ratio2\n    high_ratio_items = np.argsort(-combined_ratio)[:max(1, len(weight_lst)//5)]\n\n    # Step 4: Perform a dynamic substitution based on the selected items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for item in high_ratio_items:\n        if new_solution[item] == 1:\n            # Try removing the item if it has negative impact on both objectives\n            if (value1_lst[item] > 0 and value2_lst[item] > 0) or random.random() < 0.3:\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight >= 0:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n                    remaining_capacity += weight_lst[item]\n        else:\n            # Try adding the item if it fits and has positive impact\n            if weight_lst[item] <= remaining_capacity and (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 5: Perform a small random perturbation to escape local optima\n    if random.random() < 0.2:\n        random_item = random.choice(high_ratio_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] >= 0:\n                new_solution[random_item] = 0\n        else:\n            if weight_lst[random_item] <= remaining_capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.8277027858343581,
               0.7852467000484467
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-6)\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Step 3: Identify items with high combined value-to-weight ratios\n    combined_ratio = ratio1 + ratio2\n    high_ratio_items = np.argsort(-combined_ratio)[:max(1, len(weight_lst)//5)]\n\n    # Step 4: Perform a dynamic substitution based on the selected items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for item in high_ratio_items:\n        if new_solution[item] == 1:\n            # Try removing the item if it has negative impact on both objectives\n            if (value1_lst[item] > 0 and value2_lst[item] > 0) or random.random() < 0.3:\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight >= 0:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n                    remaining_capacity += weight_lst[item]\n        else:\n            # Try adding the item if it fits and has positive impact\n            if weight_lst[item] <= remaining_capacity and (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 5: Perform a small random perturbation to escape local optima\n    if random.random() < 0.2:\n        random_item = random.choice(high_ratio_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] >= 0:\n                new_solution[random_item] = 0\n        else:\n            if weight_lst[random_item] <= remaining_capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n"
     }
]