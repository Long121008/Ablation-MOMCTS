[
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement through a novel hybrid strategy that combines random walk with a dynamic neighborhood exploration. It intelligently selects a base solution by prioritizing those with high diversity in their objective values and low crowding distance in the objective space to ensure exploration of under-explored regions. Then, it applies a creative local search operator that dynamically adjusts the neighborhood size based on the solution's current position in the objective space, flipping bits in a non-uniform manner to balance exploration and exploitation. The operator ensures feasibility by only considering flips that maintain the weight constraint, and it incorporates a probabilistic acceptance criterion to escape local optima. The function returns the new neighbor solution after performing these steps, guaranteeing feasibility and promoting high-quality multi-objective improvement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high diversity in objectives and low crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for each solution\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Dynamic neighborhood size based on current solution's position\n    neighborhood_size = max(1, int(0.1 * n_items))\n\n    # Perform a dynamic number of flips\n    for _ in range(neighborhood_size):\n        # Select a random item to flip\n        item_idx = np.random.randint(0, n_items)\n\n        if new_solution[item_idx] == 1:\n            # If item is included, try removing it\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is excluded, try adding it\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
          "score": [
               -0.618314781098918,
               0.5875576436519623
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Multi-Objective Clustered Swap and Insert Local Search,\" intelligently selects a solution from the archive by prioritizing those with high objective values and low crowding distances in the Pareto front, then applies a hybrid local search operator that combines cluster-based item grouping, targeted swaps of items within clusters, and opportunistic insertions of high-value items from the cluster into the knapsack, while ensuring feasibility by dynamically adjusting the selection based on the remaining capacity and the trade-off between the two objectives. The algorithm also incorporates a probabilistic element to escape local optima by occasionally allowing non-improving moves that maintain diversity in the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values and low crowding distance\n    def crowding_distance(sol):\n        v1, v2 = sol[1]\n        # Simple crowding distance approximation (for demonstration)\n        return (v1 + v2) * (1 + random.random() * 0.1)\n\n    selected = max(archive, key=lambda x: crowding_distance(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items based on their value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    cluster_indices = np.argsort(value1_ratio + value2_ratio)[::-1]  # Highest ratio first\n\n    # Current weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Try to swap or insert items from the cluster\n    for idx in cluster_indices:\n        if base_solution[idx] == 1:\n            # Try removing this item if it's in the solution\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and remaining_capacity + weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding this item if it fits\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Probabilistic move to escape local optima\n    if random.random() < 0.3:\n        # Randomly flip one item to maintain diversity\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if weight_lst[flip_idx] <= remaining_capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.9853827396563116,
               1.2345367670059204
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Evaluate and rank solutions in the archive\n    scored_solutions = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        # Score prioritizes high objective values and low weights\n        score = (obj[0] + obj[1]) / (1 + total_weight)\n        scored_solutions.append((score, sol, obj))\n\n    if not scored_solutions:\n        raise ValueError(\"No feasible solutions in the archive.\")\n\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    # Select top 10% for probabilistic selection\n    top_solutions = scored_solutions[:max(1, len(scored_solutions) // 10)]\n    # Probabilistic selection: higher score = higher probability\n    scores = [s[0] for s in top_solutions]\n    total_score = sum(scores)\n    probabilities = [s / total_score for s in scores]\n    selected_idx = np.random.choice(len(top_solutions), p=probabilities)\n    base_solution = top_solutions[selected_idx][1].copy()\n\n    # Step 2: Multi-directional flip operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    max_flips = min(5, n_items // 2)  # Limit flips to avoid large changes\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst * base_solution) / n_items\n    marginal_value2 = value2_lst - np.sum(value2_lst * base_solution) / n_items\n    marginal_weight = weight_lst - np.sum(weight_lst * base_solution) / n_items\n\n    # Score items based on combined marginal contribution and weight\n    item_scores = (marginal_value1 + marginal_value2) / (1 + marginal_weight)\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-item_scores)\n\n    # Flip items with highest scores, ensuring feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try to remove item if it improves both objectives\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try to add item if it improves both objectives\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n        max_flips -= 1\n        if max_flips == 0:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.8343462611612769,
               3.875513046979904
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a hybrid local search strategy that combines adaptive random selection based on objective diversity with a novel \"value-weighted swap\" operator. First, it intelligently selects a base solution from the archive by prioritizing those with high objective values and low solution density, ensuring the selected solution has unexplored potential. Then, it applies a value-weighted swap where items are probabilistically selected for swapping based on their normalized contributions to both objectives, favoring items that could improve the marginal utility. The operator ensures feasibility by only swapping items when the total weight remains within capacity, and it adaptively adjusts the swap probability based on the current solution's objective values. The method avoids standard 2-opt by incorporating a multi-objective awareness and dynamic selection, promoting diverse exploration while maintaining efficient convergence.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising base solution (highest combined objective value)\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Step 3: Compute current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 4: Hybrid local search operator - Value-weighted swap\n    # Calculate normalized contributions for each item\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        return new_solution  # No possible swaps\n\n    # Normalize value contributions\n    value1_contrib = value1_lst[included_items] / np.sum(value1_lst[included_items])\n    value2_contrib = value2_lst[included_items] / np.sum(value2_lst[included_items])\n    combined_contrib = value1_contrib + value2_contrib\n\n    # Select items to swap out based on contribution\n    swap_out_probs = combined_contrib / np.sum(combined_contrib)\n    swap_out_idx = np.random.choice(included_items, p=swap_out_probs)\n\n    # Select items to swap in that would keep weight feasible\n    possible_swap_in = []\n    possible_weights = []\n\n    for item in excluded_items:\n        new_weight = current_weight - weight_lst[swap_out_idx] + weight_lst[item]\n        if new_weight <= capacity:\n            possible_swap_in.append(item)\n            possible_weights.append(weight_lst[item])\n\n    if not possible_swap_in:\n        return new_solution  # No feasible swaps\n\n    # Select swap in item with probability based on value\n    value1_swap_in = value1_lst[possible_swap_in]\n    value2_swap_in = value2_lst[possible_swap_in]\n    combined_swap_in = value1_swap_in + value2_swap_in\n    swap_in_probs = combined_swap_in / np.sum(combined_swap_in)\n    swap_in_idx = np.random.choice(possible_swap_in, p=swap_in_probs)\n\n    # Perform the swap\n    new_solution[swap_out_idx] = 0\n    new_solution[swap_in_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.42723601313776294,
               2.6828410923480988
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    max_potential = -float('inf')\n\n    for i, (solution, (v1, v2)) in enumerate(archive):\n        # Calculate potential for improvement in both objectives\n        # Potential is higher if the solution is not extreme and has room for improvement\n        potential = (v1 + v2) * (1 - 0.5 * (np.sum(solution) / len(solution)))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    # Strategy: Randomly select a subset of items and perform a \"value-aware\" flip\n    # If flipping an item improves at least one objective, keep the change\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_v1 = np.sum(value1_lst[new_solution == 1])\n    current_v2 = np.sum(value2_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    subset_size = max(1, int(0.2 * len(new_solution)))\n    subset_indices = np.random.choice(len(new_solution), size=subset_size, replace=False)\n\n    for idx in subset_indices:\n        if new_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            new_v1 = current_v1 - value1_lst[idx]\n            new_v2 = current_v2 - value2_lst[idx]\n            if new_weight <= capacity and (new_v1 >= current_v1 or new_v2 >= current_v2):\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_v1 = new_v1\n                current_v2 = new_v2\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            new_v1 = current_v1 + value1_lst[idx]\n            new_v2 = current_v2 + value2_lst[idx]\n            if new_weight <= capacity and (new_v1 >= current_v1 or new_v2 >= current_v2):\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_v1 = new_v1\n                current_v2 = new_v2\n\n    # Step 3: If no improvement, perform a random flip to ensure diversity\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip one item (ensuring feasibility)\n        feasible_indices = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
          "score": [
               -0.9185473308596813,
               3.889254480600357
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement through a novel hybrid local search strategy. It intelligently selects a base solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a creative local search operator that combines elements of variable neighborhood descent and path relinking. The operator systematically explores the solution space by dynamically adjusting the neighborhood structure based on the solution's current objective values, flipping items in a way that balances the trade-off between the two objectives. To ensure feasibility, it calculates the total weight of the new solution and reverts any changes that would exceed the capacity. The function returns the new neighbor solution after applying the local search operator, ensuring it remains non-dominated and feasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    scores = []\n    for sol, obj in archive:\n        total_value1, total_value2 = obj\n        # Calculate a score based on normalized objective values and dominance\n        normalized_value1 = total_value1 / (np.sum(value1_lst) + 1e-10)\n        normalized_value2 = total_value2 / (np.sum(value2_lst) + 1e-10)\n        dominance_score = 1.0  # Default score if no other solutions dominate it\n        for other_sol, other_obj in archive:\n            if other_obj[0] > total_value1 and other_obj[1] > total_value2:\n                dominance_score = 0.0\n                break\n        score = (normalized_value1 + normalized_value2) * dominance_score\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Dynamically adjust the neighborhood based on the current solution's objective values\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Determine which objective to prioritize for flipping\n    if total_value1 > total_value2:\n        # Prioritize value2 by potentially removing items with high value1\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            # Find item with highest value1 that can be removed without violating capacity\n            for idx in candidate_indices:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    break\n    else:\n        # Prioritize value1 by potentially removing items with high value2\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            # Find item with highest value2 that can be removed without violating capacity\n            for idx in candidate_indices:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    break\n\n    # Add an item if possible to improve the other objective\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Select item that improves the weaker objective while keeping the other relatively balanced\n        best_idx = -1\n        best_improvement = -np.inf\n        for idx in candidate_indices:\n            if total_weight + weight_lst[idx] <= capacity:\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                # Balance between the two objectives\n                if total_value1 > total_value2:\n                    score = improvement2 - 0.5 * improvement1\n                else:\n                    score = improvement1 - 0.5 * improvement2\n                if score > best_improvement:\n                    best_improvement = score\n                    best_idx = idx\n        if best_idx != -1:\n            new_solution[best_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.7662154168535015,
               2.7927763760089874
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distances for all solutions\n    solutions = [s for s, _ in archive]\n    objectives = [o for _, o in archive]\n    n = len(solutions)\n    crowding_distances = [0.0] * n\n\n    # Sort objectives by each objective\n    sorted_indices1 = np.argsort([o[0] for o in objectives])\n    sorted_indices2 = np.argsort([o[1] for o in objectives])\n\n    # Calculate crowding distances\n    for i in range(2):\n        obj_sorted = sorted_indices1 if i == 0 else sorted_indices2\n        for j in range(1, n-1):\n            crowding_distances[obj_sorted[j]] += (objectives[obj_sorted[j+1]][i] - objectives[obj_sorted[j-1]][i])\n\n    # Select solution with max crowding distance or random if all distances are zero\n    max_distance = max(crowding_distances)\n    if max_distance > 0:\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_distance]\n        selected_idx = np.random.choice(candidates)\n    else:\n        selected_idx = np.random.randint(0, n)\n\n    base_solution = solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor solution\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n\n    # Strategy selection: 60% swap, 20% perturbation, 20% hybrid\n    strategy = np.random.choice(['swap', 'perturbation', 'hybrid'], p=[0.6, 0.2, 0.2])\n\n    if strategy == 'swap':\n        # Find items with complementary marginal contributions\n        in_items = items[base_solution == 1]\n        out_items = items[base_solution == 0]\n\n        # Calculate marginal utility ratios for in_items\n        in_ratios = value1_lst[in_items] / (value2_lst[in_items] + 1e-10)\n\n        # Find item to remove (lowest ratio)\n        if len(in_items) > 0:\n            remove_idx = in_items[np.argmin(in_ratios)]\n            current_weight -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n        # Find item to add (highest ratio that fits)\n        out_ratios = value1_lst[out_items] / (value2_lst[out_items] + 1e-10)\n        valid_out = out_items[weight_lst[out_items] <= (capacity - current_weight)]\n        if len(valid_out) > 0:\n            add_idx = valid_out[np.argmax(out_ratios[out_items == valid_out[0]])]\n            new_solution[add_idx] = 1\n\n    elif strategy == 'perturbation':\n        # Randomly select a subset of items to flip\n        k = min(3, len(items))  # Perturb up to 3 items\n        selected_items = np.random.choice(items, size=k, replace=False)\n\n        for item in selected_items:\n            if base_solution[item] == 1:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    else:  # hybrid\n        # First perform swap\n        in_items = items[base_solution == 1]\n        out_items = items[base_solution == 0]\n\n        if len(in_items) > 0:\n            remove_idx = np.random.choice(in_items)\n            current_weight -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n        valid_out = out_items[weight_lst[out_items] <= (capacity - current_weight)]\n        if len(valid_out) > 0:\n            add_idx = np.random.choice(valid_out)\n            new_solution[add_idx] = 1\n\n        # Then perform perturbation on remaining items\n        remaining_items = items[base_solution != new_solution]\n        if len(remaining_items) > 0:\n            k = min(2, len(remaining_items))\n            perturb_items = np.random.choice(remaining_items, size=k, replace=False)\n            for item in perturb_items:\n                if new_solution[item] == 1:\n                    if current_weight - weight_lst[item] >= 0:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    return new_solution\n\n",
          "score": [
               -0.7899846541054563,
               2.939237117767334
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high marginal gains in either objective\n    def marginal_gain(solution, obj_idx):\n        included = solution == 1\n        excluded = solution == 0\n        if obj_idx == 0:\n            gains = value1_lst[excluded] / weight_lst[excluded]\n        else:\n            gains = value2_lst[excluded] / weight_lst[excluded]\n        return np.max(gains) if len(gains) > 0 else 0\n\n    # Evaluate each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight >= capacity:\n            continue  # Skip infeasible solutions\n        gain1 = marginal_gain(sol, 0)\n        gain2 = marginal_gain(sol, 1)\n        score = gain1 + gain2  # Combined potential for improvement\n        scores.append(score)\n\n    if not scores:\n        # Fallback: select a random solution if no promising candidates\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        # Select the solution with the highest combined marginal gain\n        best_idx = np.argmax(scores)\n        base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Strategy: Greedy addition of items with high marginal gains, followed by probabilistic swaps\n    included = new_solution == 1\n    excluded = new_solution == 0\n    total_weight = np.sum(weight_lst[included])\n\n    # Greedy addition of items with high marginal gains\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        # Calculate marginal gains for excluded items\n        gains1 = value1_lst[excluded] / weight_lst[excluded]\n        gains2 = value2_lst[excluded] / weight_lst[excluded]\n        combined_gains = gains1 + gains2\n\n        if len(combined_gains) == 0:\n            break\n\n        best_item = np.argmax(combined_gains)\n        item_idx = np.where(excluded)[0][best_item]\n        if total_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            total_weight += weight_lst[item_idx]\n            included = new_solution == 1\n            excluded = new_solution == 0\n\n    # Probabilistic swap to explore diverse neighborhoods\n    if np.random.random() < 0.5:  # 50% chance to perform a swap\n        swap_candidates = np.where(included)[0]\n        if len(swap_candidates) > 0:\n            swap_item = np.random.choice(swap_candidates)\n            new_solution[swap_item] = 0\n            total_weight -= weight_lst[swap_item]\n            excluded = new_solution == 0\n\n            # Try to add a new item that fits the remaining capacity\n            feasible_items = np.where((excluded) & (weight_lst <= (capacity - total_weight)))[0]\n            if len(feasible_items) > 0:\n                new_item = np.random.choice(feasible_items)\n                new_solution[new_item] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.8772360217109856,
               11.183965891599655
          ]
     },
     {
          "algorithm": "{The proposed heuristic function, 'select_neighbor', employs a hybrid local search strategy combining adaptive neighborhood exploration with value-driven perturbation to generate high-quality neighbor solutions. It first identifies the most promising solution in the archive by evaluating a composite score that balances objective values and solution sparsity, then performs a novel 'value-aware swap' operator that selectively replaces low-value items with high-value alternatives while ensuring feasibility via a dynamic capacity adjustment mechanism. The method also incorporates a probabilistic restart mechanism to escape local optima, dynamically adjusting the perturbation intensity based on the archive's diversity and the current solution's position in the Pareto front.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a composite score\n    def composite_score(solution, objective):\n        v1, v2 = objective\n        density = (v1 + v2) / (np.sum(weight_lst[solution == 1]) + 1e-6)\n        sparsity = np.sum(solution) / len(solution)\n        return density * (1 - sparsity)\n\n    scored_solutions = [(solution, objective, composite_score(solution, objective))\n                        for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: -x[2])\n    base_solution, _, _ = scored_solutions[0]\n\n    # Create a neighbor using a hybrid local search approach\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items to potentially remove (low value, high weight)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0:\n        # Calculate value ratios for included items\n        value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        remove_candidates = included_items[np.argsort(value_ratios)[:max(1, len(included_items)//4)]]\n\n        # Remove some low-value items\n        for item in remove_candidates:\n            if np.random.rand() < 0.7:  # 70% chance to remove\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Add high-value items that fit\n    if len(excluded_items) > 0:\n        # Calculate value ratios for excluded items\n        value_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        add_candidates = excluded_items[np.argsort(value_ratios)[-max(1, len(excluded_items)//4):][::-1]]\n\n        for item in add_candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Small probability to perform a random swap if no improvement\n    if np.random.rand() < 0.2:\n        candidate_items = np.where(new_solution != base_solution)[0]\n        if len(candidate_items) > 0:\n            swap_item = np.random.choice(candidate_items)\n            new_solution[swap_item] = 1 - new_solution[swap_item]\n\n    return new_solution\n\n",
          "score": [
               -0.3438892601846167,
               3.5549173653125763
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # We prioritize solutions that are not fully packed (i.e., have some items not included)\n    # and are not on the extreme fronts (to avoid local optima)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity and np.sum(sol) < len(sol):  # Not fully packed and not extreme\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates, select the solution with the highest total value1 + value2\n        candidates = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        base_solution = candidates[0][0].copy()\n    else:\n        # Randomly select a candidate with higher probability for those with higher combined values\n        values = [obj[0] + obj[1] for _, obj in candidates]\n        probs = np.array(values) / np.sum(values)\n        idx = np.random.choice(len(candidates), p=probs)\n        base_solution = candidates[idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    # The strategy combines:\n    # 1. Randomly flip a subset of items (similar to mutation)\n    # 2. Apply a greedy improvement step to ensure feasibility and quality\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly flip a subset of items (1-3 items)\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility and apply greedy improvement\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        # Sort items by value1 + value2 in descending order\n        sorted_indices = np.argsort(-(value1_lst + value2_lst))\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n                if excess <= 0:\n                    break\n\n    # Greedy improvement: add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Sort items by value1 + value2 in descending order\n        sorted_indices = np.argsort(-(value1_lst + value2_lst))\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
          "score": [
               -0.3597548407136213,
               11.201912701129913
          ]
     }
]