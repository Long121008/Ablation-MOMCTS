[
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement through a novel hybrid strategy that combines random walk with a dynamic neighborhood exploration. It intelligently selects a base solution by prioritizing those with high diversity in their objective values and low crowding distance in the objective space to ensure exploration of under-explored regions. Then, it applies a creative local search operator that dynamically adjusts the neighborhood size based on the solution's current position in the objective space, flipping bits in a non-uniform manner to balance exploration and exploitation. The operator ensures feasibility by only considering flips that maintain the weight constraint, and it incorporates a probabilistic acceptance criterion to escape local optima. The function returns the new neighbor solution after performing these steps, guaranteeing feasibility and promoting high-quality multi-objective improvement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high diversity in objectives and low crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for each solution\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Dynamic neighborhood size based on current solution's position\n    neighborhood_size = max(1, int(0.1 * n_items))\n\n    # Perform a dynamic number of flips\n    for _ in range(neighborhood_size):\n        # Select a random item to flip\n        item_idx = np.random.randint(0, n_items)\n\n        if new_solution[item_idx] == 1:\n            # If item is included, try removing it\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is excluded, try adding it\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
          "score": [
               -0.618314781098918,
               0.5875576436519623
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Multi-Objective Clustered Swap and Insert Local Search,\" intelligently selects a solution from the archive by prioritizing those with high objective values and low crowding distances in the Pareto front, then applies a hybrid local search operator that combines cluster-based item grouping, targeted swaps of items within clusters, and opportunistic insertions of high-value items from the cluster into the knapsack, while ensuring feasibility by dynamically adjusting the selection based on the remaining capacity and the trade-off between the two objectives. The algorithm also incorporates a probabilistic element to escape local optima by occasionally allowing non-improving moves that maintain diversity in the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values and low crowding distance\n    def crowding_distance(sol):\n        v1, v2 = sol[1]\n        # Simple crowding distance approximation (for demonstration)\n        return (v1 + v2) * (1 + random.random() * 0.1)\n\n    selected = max(archive, key=lambda x: crowding_distance(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items based on their value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    cluster_indices = np.argsort(value1_ratio + value2_ratio)[::-1]  # Highest ratio first\n\n    # Current weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Try to swap or insert items from the cluster\n    for idx in cluster_indices:\n        if base_solution[idx] == 1:\n            # Try removing this item if it's in the solution\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and remaining_capacity + weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding this item if it fits\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Probabilistic move to escape local optima\n    if random.random() < 0.3:\n        # Randomly flip one item to maintain diversity\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if weight_lst[flip_idx] <= remaining_capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.9853827396563116,
               1.2345367670059204
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Multi-Objective Greedy Neighborhood Search,\" dynamically selects a solution from the archive by prioritizing those with high combined objective values and low crowding distance, then applies a hybrid local search operator that combines a greedy insertion phase with a probabilistic exchange phase. In the greedy phase, it iteratively inserts the most valuable item (based on a dynamic trade-off between the two objectives) that fits the remaining capacity, while in the exchange phase, it probabilistically swaps items between the knapsack and the remaining pool, guided by a utility function that balances the marginal gain in both objectives and the solution's current position in the Pareto front. The algorithm ensures feasibility by strictly enforcing the weight constraint and incorporates a temperature-based acceptance criterion to escape local optima, gradually reducing the probability of accepting non-improving moves as the search progresses.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective values and low crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances * (objectives[:, 0] + objectives[:, 1]))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    new_solution = base_solution.copy()\n\n    # Greedy insertion phase\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate utility for excluded items (greedy insertion)\n    utility = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-6)\n    sorted_excluded = excluded[np.argsort(-utility)]\n\n    for idx in sorted_excluded:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n            current_weight += weight_lst[idx]\n\n    # Probabilistic exchange phase\n    temperature = 0.5  # Initial temperature\n    for _ in range(10):  # Number of exchange attempts\n        if random.random() < temperature:\n            # Select a random item to swap\n            item_idx = random.choice(np.where(new_solution == 1)[0])\n            candidate_idx = random.choice(np.where(new_solution == 0)[0])\n\n            # Calculate new weight\n            new_weight = current_weight - weight_lst[item_idx] + weight_lst[candidate_idx]\n\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                new_solution[candidate_idx] = 1\n                current_weight = new_weight\n\n        temperature *= 0.9  # Cool down\n\n    return new_solution\n\n",
          "score": [
               -0.9955216318108593,
               2.837202548980713
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Objective-Driven Dynamic Subset Replacement with Adaptive Trade-off Exploration,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative positions in the Pareto front, then applies a novel local search operator that dynamically selects and replaces subsets of items based on their marginal contributions to both objectives, while maintaining feasibility. The operator employs a hybrid flip strategy that considers both objective-specific item prioritization and a dynamic trade-off adjustment mechanism that balances the exploration of both objectives, and incorporates a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape. The algorithm also includes a novel subset replacement mechanism that adaptively selects and replaces subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values, ensuring that the generated neighbor solution remains feasible and potentially improves both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good trade-off and position\n    def tradeoff_score(sol):\n        v1, v2 = sol[1]\n        return (v1 + v2) / (1 + abs(v1 - v2))  # Higher for balanced trade-off\n\n    selected = max(archive, key=lambda x: tradeoff_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate current state\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Step 3: Dynamic trade-off adjustment\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_ratio = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_ratio = obj2 / total_v2 if total_v2 > 0 else 0\n    tradeoff_balance = 0.5 * (1 - obj1_ratio) + 0.5 * (1 - obj2_ratio)\n\n    # Step 4: Calculate marginal contributions\n    marginal_v1 = value1_lst / (weight_lst + 1e-6)\n    marginal_v2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = tradeoff_balance * marginal_v1 + (1 - tradeoff_balance) * marginal_v2\n\n    # Step 5: Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Step 6: Dynamic subset replacement\n    subset_size = max(1, int(0.3 * len(weight_lst) * tradeoff_balance))\n    selected_subset = sorted_items[:subset_size]\n\n    # Step 7: Hybrid flip strategy\n    for item in selected_subset:\n        if new_solution[item] == 1:\n            # Try to remove if it improves both objectives\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                remaining_capacity += weight_lst[item]\n        else:\n            # Try to add if it fits and improves both objectives\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 8: Probabilistic diversification move\n    if random.random() < 0.2 * tradeoff_balance:\n        # Select a random item from the subset\n        if len(selected_subset) > 0:\n            flip_item = random.choice(selected_subset)\n            if new_solution[flip_item] == 1:\n                if current_weight - weight_lst[flip_item] >= 0:\n                    new_solution[flip_item] = 0\n            else:\n                if weight_lst[flip_item] <= remaining_capacity:\n                    new_solution[flip_item] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.9020213406155315,
               0.9840697646141052
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Multi-Objective Value-Driven Exploration with Dynamic Cluster-Based Diversification,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative positions in the Pareto front, then applies a novel local search operator that dynamically adjusts the exploration based on the solution's position in the objective space. The operator combines cluster-based item grouping with a value-driven perturbation strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility, and incorporates a dynamic cluster-based diversification mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values. The algorithm also employs a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape, and uses a novel value-driven exploration strategy that focuses on improving both objectives simultaneously by considering their combined impact on the solution's quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good trade-off and position\n    def tradeoff_score(sol):\n        v1, v2 = sol[1]\n        return (v1 + v2) / (1 + abs(v1 - v2))  # Higher for balanced trade-off\n\n    selected = max(archive, key=lambda x: tradeoff_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Cluster items based on value-to-weight ratios and objective contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value1_ratio + value2_ratio\n    cluster_indices = np.argsort(combined_ratio)[::-1]\n\n    # Step 3: Dynamic value-driven perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine perturbation intensity based on solution's position\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_ratio = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_ratio = obj2 / total_v2 if total_v2 > 0 else 0\n    perturbation_intensity = 0.5 * (1 - obj1_ratio) + 0.5 * (1 - obj2_ratio)\n\n    # Select cluster size based on perturbation intensity\n    cluster_size = max(1, int(perturbation_intensity * len(cluster_indices)))\n    selected_cluster = cluster_indices[:cluster_size]\n\n    # Apply value-driven perturbations\n    for idx in selected_cluster:\n        if base_solution[idx] == 1:\n            # Try removing if it improves both objectives\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves both objectives\n            if weight_lst[idx] <= remaining_capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 4: Probabilistic diversification move with value-driven selection\n    if random.random() < 0.3 * perturbation_intensity:\n        # Select a random item from the cluster with higher value-to-weight ratio\n        if len(selected_cluster) > 0:\n            # Sort cluster by value-to-weight ratio\n            sorted_cluster = sorted(selected_cluster, key=lambda x: combined_ratio[x], reverse=True)\n            # Select top 30% of the cluster\n            top_cluster = sorted_cluster[:max(1, int(0.3 * len(sorted_cluster)))]\n            flip_idx = random.choice(top_cluster)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -1.0203507685259985,
               2.9317766726017
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Objective-Driven Diversification with Dynamic Utility-Based Substitution,\" first identifies the most diverse solution in the archive by measuring the maximum angular distance between its objective vector and the centroid of all objective vectors, then applies a novel local search operator that combines utility-based substitution with dynamic diversification pressure. The operator prioritizes items based on their normalized marginal utility for both objectives, uses a probabilistic substitution strategy that adaptsively balances exploitation and exploration based on the solution's current position relative to the Pareto front, and dynamically adjusts the substitution intensity through a utility-based diversification mechanism that encourages exploration of underrepresented objective regions while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate normalized marginal utilities\n    marginal_obj1 = value1_lst / (weight_lst + 1e-10)\n    marginal_obj2 = value2_lst / (weight_lst + 1e-10)\n    max_obj1, max_obj2 = np.max(marginal_obj1), np.max(marginal_obj2)\n    normalized_obj1 = marginal_obj1 / max_obj1 if max_obj1 > 0 else marginal_obj1\n    normalized_obj2 = marginal_obj2 / max_obj2 if max_obj2 > 0 else marginal_obj2\n    combined_utility = normalized_obj1 + normalized_obj2\n\n    # Step 3: Dynamic utility-based substitution\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.2 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined utility\n    sorted_items = np.argsort(-combined_utility)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low utility\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add item if it has high utility\n            if weight_lst[item] <= capacity - current_weight:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 4: Probabilistic diversification\n    if random.random() < 0.5:\n        # Select item with lowest combined utility\n        flip_item = sorted_items[-1]\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.9896971574599591,
               1.7536233961582184
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Objective-Centric Hybridization with Dynamic Value-Weight Balance Exploration,\" first identifies the most under-represented objective direction in the archive by measuring the angular distance between each solution's objective vector and the ideal point, then applies a novel local search operator that combines value-weight balance analysis with dynamic objective-centric hybridization. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-centric and value-weight balance considerations, and incorporates a dynamic exploration mechanism that adaptively selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight balance scores\n    vw_balance1 = value1_lst / (weight_lst + 1e-10)\n    vw_balance2 = value2_lst / (weight_lst + 1e-10)\n    max_balance1, max_balance2 = np.max(vw_balance1), np.max(vw_balance2)\n    normalized_balance1 = vw_balance1 / max_balance1 if max_balance1 > 0 else vw_balance1\n    normalized_balance2 = vw_balance2 / max_balance2 if max_balance2 > 0 else vw_balance2\n\n    # Step 3: Dynamic objective-centric hybridization\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    combined_balance = obj_ratio * normalized_balance1 + (1 - obj_ratio) * normalized_balance2\n\n    # Step 4: Hybrid substitution strategy\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.3 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined balance score\n    sorted_items = np.argsort(-combined_balance)\n\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            # Try to remove item if it has low balance score relative to its objective\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try to add item if it has high balance score for the under-represented objective\n            if weight_lst[item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[item] > normalized_balance2[item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[item] > normalized_balance1[item]):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 5: Dynamic exploration mechanism\n    if random.random() < 0.4:\n        # Select item with lowest combined balance score for the under-represented objective\n        flip_item = sorted_items[-1]\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] >= 0:\n                new_solution[flip_item] = 0\n        else:\n            if weight_lst[flip_item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[flip_item] > normalized_balance2[flip_item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[flip_item] > normalized_balance1[flip_item]):\n                    new_solution[flip_item] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.9374470386456604,
               1.743850290775299
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Objective-Driven Dynamic Substitution with Multi-Perspective Exploration,\" first identifies the most under-represented objective direction in the archive by analyzing the distribution of solutions and their objective values, then applies a novel local search operator that combines dynamic objective-centric substitution with multi-perspective exploration. The operator prioritizes items based on their adaptive value-weight balance scores that dynamically adjust based on the current objective direction, uses a hybrid substitution strategy that combines both objective-centric and value-weight balance considerations, and incorporates a multi-perspective exploration mechanism that adaptively selects and modifies subsets of items based on their relative contributions to the under-represented objective direction while maintaining feasibility through a capacity-aware substitution process that ensures the total weight does not exceed capacity. Additionally, the algorithm employs a dynamic temperature-based acceptance criterion to balance exploration and exploitation, gradually reducing the probability of accepting non-improving moves as the search progresses.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most under-represented objective direction\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate adaptive value-weight balance scores\n    vw_balance1 = value1_lst / (weight_lst + 1e-10)\n    vw_balance2 = value2_lst / (weight_lst + 1e-10)\n    max_balance1, max_balance2 = np.max(vw_balance1), np.max(vw_balance2)\n    normalized_balance1 = vw_balance1 / max_balance1 if max_balance1 > 0 else vw_balance1\n    normalized_balance2 = vw_balance2 / max_balance2 if max_balance2 > 0 else vw_balance2\n\n    # Step 3: Dynamic objective-centric substitution\n    obj1, obj2 = archive[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2 + 1e-10) if (obj1 + obj2) > 0 else 0.5\n    combined_balance = obj_ratio * normalized_balance1 + (1 - obj_ratio) * normalized_balance2\n\n    # Step 4: Multi-perspective exploration mechanism\n    n_items = len(weight_lst)\n    substitution_count = max(1, int(0.2 * n_items * (1 - distances[selected_idx]/np.max(distances))))\n\n    # Sort items by combined balance score\n    sorted_items = np.argsort(-combined_balance)\n\n    # Temperature-based acceptance\n    temperature = 0.7\n    for _ in range(10):\n        if random.random() < temperature:\n            # Select item with lowest combined balance score for the under-represented objective\n            flip_item = sorted_items[-1]\n            if new_solution[flip_item] == 1:\n                if current_weight - weight_lst[flip_item] >= 0:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n            else:\n                if weight_lst[flip_item] <= capacity - current_weight:\n                    if (obj_ratio > 0.5 and normalized_balance1[flip_item] > normalized_balance2[flip_item]) or \\\n                       (obj_ratio <= 0.5 and normalized_balance2[flip_item] > normalized_balance1[flip_item]):\n                        new_solution[flip_item] = 1\n                        current_weight += weight_lst[flip_item]\n        temperature *= 0.8\n\n    # Step 5: Hybrid substitution strategy\n    for item in sorted_items[:substitution_count]:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            if weight_lst[item] <= capacity - current_weight:\n                if (obj_ratio > 0.5 and normalized_balance1[item] > normalized_balance2[item]) or \\\n                   (obj_ratio <= 0.5 and normalized_balance2[item] > normalized_balance1[item]):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
          "score": [
               -0.7764706644433461,
               1.0548008382320404
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Objective-Space Trajectory Exploration with Dynamic Cluster-Based Perturbation,\" first identifies the most promising solution in the archive by analyzing the trade-off between objectives and their relative positions in the Pareto front, then applies a novel local search operator that dynamically adjusts the exploration trajectory based on the solution's position in the objective space. The operator combines cluster-based item grouping with a trajectory-aware perturbation strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility, and incorporates a dynamic cluster-based perturbation mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their proximity to the current solution's objective values. The algorithm also employs a probabilistic acceptance criterion that balances improvement and diversity, while dynamically adjusting the exploration parameters to adapt to the current search landscape.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with good trade-off and position\n    def tradeoff_score(sol):\n        v1, v2 = sol[1]\n        return (v1 + v2) / (1 + abs(v1 - v2))  # Higher for balanced trade-off\n\n    selected = max(archive, key=lambda x: tradeoff_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Cluster items based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    cluster_indices = np.argsort(value1_ratio + value2_ratio)[::-1]\n\n    # Step 3: Dynamic trajectory-based perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine perturbation intensity based on solution's position\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_ratio = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_ratio = obj2 / total_v2 if total_v2 > 0 else 0\n    perturbation_intensity = 0.5 * (1 - obj1_ratio) + 0.5 * (1 - obj2_ratio)\n\n    # Select cluster size based on perturbation intensity\n    cluster_size = max(1, int(perturbation_intensity * len(cluster_indices)))\n    selected_cluster = cluster_indices[:cluster_size]\n\n    # Apply trajectory-aware perturbations\n    for idx in selected_cluster:\n        if base_solution[idx] == 1:\n            # Try removing if it improves both objectives\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves both objectives\n            if weight_lst[idx] <= remaining_capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 4: Probabilistic diversification move\n    if random.random() < 0.3 * perturbation_intensity:\n        # Select a random item from the cluster\n        if len(selected_cluster) > 0:\n            flip_idx = random.choice(selected_cluster)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -0.8863352738929804,
               1.4475612342357635
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Multi-Objective Solution Path Exploration with Dynamic Objective-Driven Item Grouping,\" first identifies the most promising solution in the archive by analyzing the Pareto front dominance relationships and objective space distribution, then applies a novel local search operator that dynamically adjusts the exploration path based on the solution's objective dominance and diversity, combining objective-driven item grouping with a path-aware perturbation strategy that prioritizes items with high marginal contributions to both objectives while maintaining feasibility. The operator incorporates a dynamic objective-driven grouping mechanism that adaptively selects and modifies subsets of items based on their value-to-weight ratios and their relative positions in the Pareto front, and employs a probabilistic acceptance criterion that balances improvement and diversity while dynamically adjusting the exploration parameters to adapt to the current search landscape. The algorithm also includes a novel path exploration mechanism that traces the solution's trajectory in the objective space to identify under-explored regions and prioritize perturbations that lead to these regions, ensuring comprehensive exploration of the Pareto front.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    def dominance_score(sol):\n        v1, v2 = sol[1]\n        non_dominated = True\n        for other_sol in archive:\n            ov1, ov2 = other_sol[1]\n            if (ov1 >= v1 and ov2 > v2) or (ov1 > v1 and ov2 >= v2):\n                non_dominated = False\n                break\n        if not non_dominated:\n            return -float('inf')\n        # Calculate diversity score\n        distances = []\n        for other_sol in archive:\n            ov1, ov2 = other_sol[1]\n            distances.append(np.sqrt((v1 - ov1)**2 + (v2 - ov2)**2))\n        diversity_score = np.mean(distances)\n        return diversity_score\n\n    selected = max(archive, key=lambda x: dominance_score(x))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Objective-driven item grouping\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n    obj1_group = np.argsort(value1_ratio)[::-1]\n    obj2_group = np.argsort(value2_ratio)[::-1]\n\n    # Step 3: Path-aware perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Determine perturbation direction based on objective space\n    obj1, obj2 = selected[1]\n    total_v1 = np.sum(value1_lst)\n    total_v2 = np.sum(value2_lst)\n    obj1_ratio = obj1 / total_v1 if total_v1 > 0 else 0\n    obj2_ratio = obj2 / total_v2 if total_v2 > 0 else 0\n\n    # Select group based on which objective is under-represented\n    if obj1_ratio < obj2_ratio:\n        selected_group = obj1_group\n    else:\n        selected_group = obj2_group\n\n    # Apply path-aware perturbations\n    for idx in selected_group:\n        if base_solution[idx] == 1:\n            # Try removing if it doesn't dominate in both objectives\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight >= 0 and (value1_lst[idx] < value1_ratio[idx] or value2_lst[idx] < value2_ratio[idx]):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n                current_weight = temp_weight\n        else:\n            # Try adding if it fits and improves at least one objective\n            if weight_lst[idx] <= remaining_capacity and (value1_lst[idx] > value1_ratio[idx] or value2_lst[idx] > value2_ratio[idx]):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 4: Path exploration move\n    if random.random() < 0.4:\n        # Select a random item from the selected group\n        if len(selected_group) > 0:\n            flip_idx = random.choice(selected_group)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] >= 0:\n                    new_solution[flip_idx] = 0\n            else:\n                if weight_lst[flip_idx] <= remaining_capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -1.017605254193353,
               3.3538430631160736
          ]
     }
]