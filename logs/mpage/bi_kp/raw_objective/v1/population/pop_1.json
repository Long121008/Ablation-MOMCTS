[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest variance in objectives)\n    solutions = [s[0] for s in archive]\n    objectives = np.array([s[1] for s in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate a neighbor by randomly swapping items\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    swap_count = min(3, n_items)  # Limit the number of swaps to avoid excessive perturbation\n\n    # Randomly select items to swap\n    swap_indices = np.random.choice(n_items, size=swap_count, replace=False)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Check feasibility and repair if necessary\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Greedy repair: remove items until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0:\n            # Find the item with the smallest ratio of weight to value (sum of both objectives)\n            item_weights = weight_lst[new_solution == 1]\n            item_values = value1_lst[new_solution == 1] + value2_lst[new_solution == 1]\n            if len(item_weights) == 0:\n                break  # No items left to remove\n            ratios = item_values / item_weights\n            worst_item_idx = np.argmin(ratios)\n            actual_idx = np.where(new_solution == 1)[0][worst_item_idx]\n            new_solution[actual_idx] = 0\n            excess_weight -= weight_lst[actual_idx]\n\n    # Greedy improvement: add items that improve both objectives without exceeding capacity\n    remaining_weight = capacity - np.sum(new_solution * weight_lst)\n    if remaining_weight > 0:\n        # Find items not in the solution that can be added without exceeding capacity\n        candidate_items = np.where(new_solution == 0)[0]\n        candidate_weights = weight_lst[candidate_items]\n        candidate_values = value1_lst[candidate_items] + value2_lst[candidate_items]\n        feasible_items = candidate_weights <= remaining_weight\n\n        if np.any(feasible_items):\n            best_item_idx = np.argmax(candidate_values[feasible_items])\n            actual_idx = candidate_items[feasible_items][best_item_idx]\n            new_solution[actual_idx] = 1\n\n    return new_solution\n\n",
          "score": [
               -18.909604645239646,
               -18.814088175738103
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating the potential for improvement using a hybrid metric that combines the solution's current objective values with their spread across the Pareto front. It then applies a novel local search operator that intelligently combines three strategies: (1) a probabilistic swap of items based on their marginal contribution to both objectives, (2) a guided perturbation that selectively includes/excludes items near the Pareto front's knee point, and (3) a capacity-aware random walk that ensures feasibility by only considering moves that maintain or slightly reduce the total weight. The function dynamically balances exploration and exploitation by adjusting the selection probability of these strategies based on the archive's diversity, ensuring high-quality neighbors that efficiently navigate the trade-off space while always respecting the capacity constraint.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (highest combined objective value)\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    best_idx = np.argmax(combined_values)\n    base_solution = archive[best_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Probabilistic swap based on marginal contribution\n    for _ in range(min(3, n_items // 2)):\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        i = np.random.choice(candidates)\n        if new_solution[i] == 1 and np.random.rand() < 0.7:  # Higher probability to remove\n            new_solution[i] = 0\n            # Try to add a new item that improves both objectives\n            remaining_items = np.where(new_solution == 0)[0]\n            if len(remaining_items) > 0:\n                potential_adds = []\n                for j in remaining_items:\n                    if (weight_lst[j] <= capacity - np.sum(weight_lst[new_solution == 1])):\n                        potential_adds.append(j)\n                if potential_adds:\n                    j = np.random.choice(potential_adds)\n                    new_solution[j] = 1\n\n    # Strategy 2: Guided perturbation near knee point (approximate)\n    if len(archive) > 1:\n        # Approximate knee point as solution with max (v1 - v2)\n        knee_idx = np.argmax(objectives[:, 0] - objectives[:, 1])\n        knee_solution = archive[knee_idx][0]\n        # Perturb around knee items\n        for i in range(n_items):\n            if knee_solution[i] != new_solution[i] and np.random.rand() < 0.3:\n                if knee_solution[i] == 1 and (weight_lst[i] <= capacity - np.sum(weight_lst[new_solution == 1])):\n                    new_solution[i] = 1\n                elif new_solution[i] == 1:\n                    new_solution[i] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Strategy 3: Capacity-aware random walk\n        excess = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for i in excess_items:\n            if weight_lst[i] <= excess:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
          "score": [
               -19.18646270182542,
               -18.508972406433266
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high marginal gains or close to the Pareto front\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Apply the guided flip and swap operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Perform targeted swap between two items\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = np.random.choice(swap_candidates, size=2, replace=False)\n        # Check if swapping improves the solution\n        delta_weight = weight_lst[j] - weight_lst[i]\n        delta_value1 = value1_lst[j] - value1_lst[i]\n        delta_value2 = value2_lst[j] - value2_lst[i]\n\n        if (delta_weight <= 0 or current_weight + delta_weight <= capacity) and \\\n           (delta_value1 >= 0 or delta_value2 >= 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n            current_value1 += delta_value1\n            current_value2 += delta_value2\n\n    return new_solution\n\n",
          "score": [
               -18.68004542521698,
               -18.028382666602297
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on marginal improvement potential\n    max_potential = -1\n    selected_solution = None\n    selected_obj = None\n\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] / (current_weight + 1e-6) + obj[1] / (current_weight + 1e-6)) / 2\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n            selected_obj = obj\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n        selected_obj = archive[0][1]\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Guided flip operator\n    for i in range(len(new_solution)):\n        # Calculate potential improvement if we flip this item\n        delta_weight = weight_lst[i] * (1 - 2 * new_solution[i])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Calculate marginal improvement for both objectives\n            delta_value1 = value1_lst[i] * (1 - 2 * new_solution[i])\n            delta_value2 = value2_lst[i] * (1 - 2 * new_solution[i])\n\n            # Calculate normalized improvement\n            norm_improvement = (delta_value1 / (selected_obj[0] + 1e-6) + delta_value2 / (selected_obj[1] + 1e-6)) / 2\n\n            # Flip with probability based on improvement and a small random factor\n            flip_prob = min(1.0, 0.1 + 0.9 * norm_improvement + 0.1 * np.random.random())\n\n            if np.random.random() < flip_prob:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight = new_weight\n\n    return new_solution\n\n",
          "score": [
               -18.46494248406106,
               -18.273839065231257
          ]
     },
     {
          "algorithm": "{The proposed algorithm for the Bi-objective Knapsack Problem (BI-KP) employs a hybrid local search strategy that combines adaptive item swapping with a novel \"value-driven perturbation\" mechanism. First, it intelligently selects a solution from the archive by prioritizing those with high \"crowding distance\" in the objective space, indicating they lie in sparse regions and may benefit from further exploration. Then, it applies a sequence of operations: 1) a \"value-aware swap\" where items are exchanged between the selected solution and a randomly chosen archive solution, prioritizing swaps that improve the objective values while maintaining feasibility; 2) a \"diversity-boosting perturbation\" that probabilistically flips items based on their contribution to both objectives, favoring items with high marginal gains; and 3) a \"capacity-adaptive adjustment\" that ensures feasibility by iteratively removing the least valuable item (based on a weighted sum of objectives) until the weight constraint is satisfied. The algorithm dynamically balances exploration and exploitation by adjusting the perturbation probability based on the current solution's proximity to the Pareto front, using a novel \"objective-space entropy\" metric to guide the search toward under-explored regions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for exploration)\n    def crowding_distance(sol):\n        objectives = [obj for (_, obj) in archive]\n        v1 = sol[1][0]\n        v2 = sol[1][1]\n        left = next((obj for obj in objectives if obj[0] < v1 and obj[1] > v2), None)\n        right = next((obj for obj in objectives if obj[0] > v1 and obj[1] < v2), None)\n        if left is None or right is None:\n            return float('inf')\n        return (right[0] - left[0]) + (right[1] - left[1])\n\n    archive_sorted = sorted(archive, key=crowding_distance, reverse=True)\n    selected = archive_sorted[0][0].copy()\n\n    # Hybrid local search: value-aware swap + perturbation\n    new_solution = selected.copy()\n\n    # Value-aware swap with another solution\n    if len(archive) > 1:\n        other_sol = archive[np.random.randint(1, len(archive))][0]\n        diff = new_solution ^ other_sol\n        candidates = np.where(diff == 1)[0]\n\n        if len(candidates) > 0:\n            # Prioritize items that improve both objectives\n            total_weight = np.sum(weight_lst * new_solution)\n            for idx in candidates:\n                if new_solution[idx] == 1:\n                    if total_weight - weight_lst[idx] + weight_lst[other_sol == 1][0] <= capacity:\n                        new_solution[idx] = 0\n                        new_solution[other_sol == 1][0] = 1\n                        break\n                else:\n                    if total_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        break\n\n    # Diversity-boosting perturbation\n    perturbation_prob = 0.3\n    for i in range(len(new_solution)):\n        if np.random.random() < perturbation_prob:\n            # Flip based on value contribution\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    # Prefer items with high marginal value\n                    marginal_value = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    if marginal_value > np.median((value1_lst + value2_lst) / weight_lst):\n                        new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        # Remove least valuable item (weighted sum of objectives)\n        values = (value1_lst + value2_lst) / weight_lst\n        values[new_solution == 0] = np.inf\n        idx = np.argmin(values)\n        new_solution[idx] = 0\n        total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
          "score": [
               -15.832423517734163,
               -15.524799988858781
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first intelligently selects a promising solution from the archive by prioritizing those with high objective values and low crowding distances (indicating under-explored regions), then applies a hybrid local search operator that combines a novel 'value-aware swap' (selecting items to swap based on their marginal improvement potential in both objectives) with a 'weight-balanced perturbation' (randomly flipping items while ensuring feasibility by dynamically adjusting the selection probability based on remaining capacity and item weights). This ensures the neighbor solution maintains feasibility and explores diverse trade-offs between the two objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low crowding distances\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives for distance calculation\n    if len(objectives) > 1:\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distances\n        distances = np.zeros(len(solutions))\n        for i in range(2):\n            sorted_indices = np.argsort(normalized_obj[:, i])\n            distances[sorted_indices[0]] = np.inf\n            distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(solutions) - 1):\n                distances[sorted_indices[j]] += (normalized_obj[sorted_indices[j+1], i] - normalized_obj[sorted_indices[j-1], i])\n\n        # Select solution with highest crowding distance (most under-explored)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Value-aware swap: identify items with high marginal improvement potential\n    marginal_gain1 = value1_lst - np.sum(value1_lst * base_solution) / len(base_solution)\n    marginal_gain2 = value2_lst - np.sum(value2_lst * base_solution) / len(base_solution)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Select top k items to consider for swap\n    k = max(1, len(base_solution) // 10)\n    top_indices = np.argsort(combined_gain)[-k:]\n\n    # Perform swap if feasible\n    for idx in top_indices:\n        if base_solution[idx] == 1:\n            # Try removing this item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n        else:\n            # Try adding this item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n    # Weight-balanced perturbation: randomly flip items with probability based on weight\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
          "score": [
               -15.916755895342042,
               -15.158676397957834
          ]
     },
     {
          "algorithm": "{The proposed algorithm, called \"Adaptive Multi-Objective Local Search with Dynamic Neighborhood Exploration,\" intelligently selects a solution from the archive by prioritizing those with high crowding distances in the objective space, indicating they lie in less explored regions. It then applies a hybrid local search operator that combines a novel \"value-weighted random walk\" with a \"critical item perturbation\" step. The random walk probabilistically flips items based on their marginal contribution to both objectives, while the perturbation step identifies and flips items that are critical for feasibility or objective improvement, ensuring the neighbor solution remains feasible and potentially dominates the original. The algorithm dynamically adjusts the exploration/exploitation balance by scaling the random walk's step size based on the solution's proximity to the archive's Pareto front, thereby balancing diversification and intensification for higher-quality multi-objective solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return np.ones(len(solutions)) * float('inf')\n\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution, _ = archive[selected_idx]\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Value-weighted random walk\n    for _ in range(min(5, len(new_solution))):\n        # Calculate marginal contributions\n        marginal1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n        marginal2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n        marginal_weight = weight_lst * (1 - new_solution) - weight_lst * new_solution\n\n        # Probability based on normalized marginal contributions\n        prob = np.abs(marginal1) + np.abs(marginal2)\n        prob = prob / (np.sum(prob) + 1e-10)\n\n        # Select item to flip\n        item = np.random.choice(len(new_solution), p=prob)\n\n        # Check feasibility\n        if (new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity) or \\\n           (new_solution[item] == 1 and current_weight - weight_lst[item] <= capacity):\n            new_solution[item] = 1 - new_solution[item]\n            current_weight += marginal_weight[item]\n\n    # Critical item perturbation\n    for item in np.where(new_solution == 1)[0]:\n        if current_weight - weight_lst[item] > capacity:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
          "score": [
               -14.681409134742065,
               -14.472153754907481
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (promising for improvement)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either 0->1 or 1->0) while keeping the solution feasible\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return new_solution  # No feasible moves\n\n    # Select a candidate item to flip, prioritizing those with high marginal contribution\n    # Marginal contribution is defined as the sum of normalized improvements in both objectives\n    marginal_contributions = []\n    for i, flip in candidate_items:\n        if flip == 1:\n            marginal = (value1_lst[i] / np.sum(value1_lst), value2_lst[i] / np.sum(value2_lst))\n        else:\n            marginal = (-value1_lst[i] / np.sum(value1_lst), -value2_lst[i] / np.sum(value2_lst))\n        marginal_contributions.append((np.sum(marginal), i, flip))\n\n    # Sort candidates by marginal contribution (descending) and select the top one\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n    if not marginal_contributions:\n        return new_solution\n\n    _, best_i, best_flip = marginal_contributions[0]\n    new_solution[best_i] = best_flip if best_flip == 1 else 0\n\n    return new_solution\n\n",
          "score": [
               -13.949268949197737,
               -13.87715273652985
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating the potential for further improvement in both objectives, considering both the current objective values and the remaining capacity. It then applies a hybrid local search strategy that combines random item swaps with a biased selection of items based on their marginal contributions to both objectives, ensuring feasibility by always checking the weight constraint. The function intelligently balances exploration and exploitation by prioritizing items that offer the highest marginal gains in either objective, while also occasionally exploring less obvious swaps to avoid local optima. The new neighbor solution is generated by iteratively flipping the inclusion status of selected items, with each flip ensuring the solution remains feasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    objectives_sum = np.array([sum(obj) for obj in archive_objectives])\n    best_idx = np.argmax(objectives_sum)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added (not in solution and within capacity)\n    not_in_solution = np.where(base_solution == 0)[0]\n    feasible_add = [i for i in not_in_solution if weight_lst[i] <= remaining_capacity]\n\n    # Identify items that can be removed (in solution)\n    in_solution = np.where(base_solution == 1)[0]\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Option 1: Randomly swap an item in with one out\n    if len(feasible_add) > 0 and len(in_solution) > 0:\n        # Select item to add based on marginal contribution to both objectives\n        add_candidates = np.array(feasible_add)\n        add_marginal1 = value1_lst[add_candidates]\n        add_marginal2 = value2_lst[add_candidates]\n        add_scores = add_marginal1 + add_marginal2\n        add_idx = np.random.choice(add_candidates, p=add_scores/np.sum(add_scores))\n\n        # Select item to remove based on marginal contribution (negative)\n        remove_candidates = np.array(in_solution)\n        remove_marginal1 = -value1_lst[remove_candidates]\n        remove_marginal2 = -value2_lst[remove_candidates]\n        remove_scores = remove_marginal1 + remove_marginal2\n        remove_idx = np.random.choice(remove_candidates, p=remove_scores/np.sum(remove_scores))\n\n        new_solution[add_idx] = 1\n        new_solution[remove_idx] = 0\n\n        # Verify feasibility\n        new_weight = np.sum(weight_lst[new_solution == 1])\n        if new_weight > capacity:\n            # Revert if not feasible\n            new_solution[add_idx] = 0\n            new_solution[remove_idx] = 1\n\n    # Option 2: If no swap possible, try to add a single item\n    elif len(feasible_add) > 0:\n        add_candidates = np.array(feasible_add)\n        add_marginal1 = value1_lst[add_candidates]\n        add_marginal2 = value2_lst[add_candidates]\n        add_scores = add_marginal1 + add_marginal2\n        add_idx = np.random.choice(add_candidates, p=add_scores/np.sum(add_scores))\n        new_solution[add_idx] = 1\n\n    # Option 3: If no add possible, try to remove a single item\n    elif len(in_solution) > 0:\n        remove_candidates = np.array(in_solution)\n        remove_marginal1 = -value1_lst[remove_candidates]\n        remove_marginal2 = -value2_lst[remove_candidates]\n        remove_scores = remove_marginal1 + remove_marginal2\n        remove_idx = np.random.choice(remove_candidates, p=remove_scores/np.sum(remove_scores))\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
          "score": [
               -13.870888195586055,
               -13.808378453569997
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to compare across different scales\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Select top 20% of solutions by combined normalized objective value\n    combined_scores = np.sum(normalized_obj, axis=1)\n    top_indices = np.argsort(combined_scores)[-max(1, len(archive) // 5):]\n    selected_solutions = [archive[i][0] for i in top_indices]\n\n    # Randomly select one solution from the top candidates\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal improvements for each item\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Calculate potential improvements for each objective\n    def calculate_improvement(item, action):\n        if action == 'add':\n            new_weight = current_weight + weight_lst[item]\n            if new_weight > capacity:\n                return -np.inf, -np.inf\n            return value1_lst[item], value2_lst[item]\n        else:  # remove\n            return -value1_lst[item], -value2_lst[item]\n\n    # Evaluate all possible single flips\n    flip_candidates = []\n    for item in included_items:\n        imp1, imp2 = calculate_improvement(item, 'remove')\n        flip_candidates.append((item, imp1, imp2, 'remove'))\n    for item in excluded_items:\n        imp1, imp2 = calculate_improvement(item, 'add')\n        if imp1 > 0 or imp2 > 0:  # Only consider feasible additions\n            flip_candidates.append((item, imp1, imp2, 'add'))\n\n    if not flip_candidates:\n        return new_solution\n\n    # Select top 10% of flips by combined improvement\n    flip_scores = np.array([imp1 + imp2 for (_, imp1, imp2, _) in flip_candidates])\n    top_flip_indices = np.argsort(flip_scores)[-max(1, len(flip_candidates) // 10):]\n\n    # Randomly select one flip from top candidates\n    selected_flip = flip_candidates[random.choice(top_flip_indices)]\n    item, _, _, action = selected_flip\n\n    # Apply the flip\n    if action == 'add':\n        new_solution[item] = 1\n    else:\n        new_solution[item] = 0\n\n    # Additional dynamic flip based on objective balance\n    current_obj1 = np.sum(value1_lst * new_solution)\n    current_obj2 = np.sum(value2_lst * new_solution)\n    obj_ratio = current_obj1 / (current_obj2 + 1e-10)\n\n    # If objectives are imbalanced, try to improve the weaker one\n    if obj_ratio > 1.5:  # Objective 2 is weaker\n        candidates = excluded_items if np.sum(new_solution) < len(new_solution) // 2 else included_items\n        for item in candidates:\n            if action == 'add' and new_solution[item] == 0:\n                imp1, imp2 = calculate_improvement(item, 'add')\n                if imp2 > imp1 * 0.5:  # Prefer items that improve obj2 more\n                    new_solution[item] = 1\n                    break\n            elif action == 'remove' and new_solution[item] == 1:\n                imp1, imp2 = calculate_improvement(item, 'remove')\n                if imp2 < imp1 * 0.5 and imp1 < 0:  # Remove items that hurt obj1 more\n                    new_solution[item] = 0\n                    break\n    elif obj_ratio < 0.66:  # Objective 1 is weaker\n        candidates = excluded_items if np.sum(new_solution) < len(new_solution) // 2 else included_items\n        for item in candidates:\n            if action == 'add' and new_solution[item] == 0:\n                imp1, imp2 = calculate_improvement(item, 'add')\n                if imp1 > imp2 * 0.5:  # Prefer items that improve obj1 more\n                    new_solution[item] = 1\n                    break\n            elif action == 'remove' and new_solution[item] == 1:\n                imp1, imp2 = calculate_improvement(item, 'remove')\n                if imp1 < imp2 * 0.5 and imp2 < 0:  # Remove items that hurt obj2 more\n                    new_solution[item] = 0\n                    break\n\n    return new_solution\n\n",
          "score": [
               -13.834274565463533,
               -13.60916964691096
          ]
     }
]