[
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Route Segmentation with Spatial and Demand-Aware Clustering,\" first selects a high-quality solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically partitions the solution into segments based on spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by greedily merging segments that optimize both objectives, using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware segment swapping\" mechanism that exchanges segments between routes while preserving capacity feasibility and potentially improving both objectives. The method combines adaptive segmentation, spatial-demand clustering, and hybrid objective-driven reconstruction to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Adaptive route segmentation\n    segments = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Split route into segments of approximately equal length\n            n_segments = max(2, len(route) // 4)\n            segment_length = len(route) // n_segments\n            for i in range(n_segments):\n                start = 1 + i * segment_length\n                end = min(start + segment_length, len(route) - 1)\n                segment = route[start:end]\n                segments.append(segment)\n\n    # Spatial and demand-aware clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    for segment in segments:\n        if len(segment) == 0:\n            continue\n\n        # Find segment center\n        segment_coords = coords[segment]\n        center = np.mean(segment_coords, axis=0)\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find closest cluster with available capacity\n        best_cluster = -1\n        min_dist = float('inf')\n        for i, (cluster_center, cluster_d) in enumerate(zip(cluster_centers, cluster_demands)):\n            if cluster_d + segment_demand <= capacity:\n                dist = np.linalg.norm(center - cluster_center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(segment)\n            cluster_demands[best_cluster] += segment_demand\n        else:\n            # Create new cluster\n            clusters.append([segment])\n            cluster_centers.append(center)\n            cluster_demands.append(segment_demand)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Combine all segments in cluster\n        all_nodes = []\n        for segment in cluster:\n            all_nodes.extend(segment)\n        remaining = set(all_nodes)\n\n        # Dynamic weight adjustment for hybrid objective\n        total_dist, makespan = archive_sorted[0][1]\n        weight_dist = 0.7 if makespan > 1.2 * total_dist else 0.3\n\n        # Greedy route construction\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Calculate hybrid cost\n                    last_node = current_route[-1]\n                    dist_cost = distance_matrix[last_node][node]\n                    span_cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n                    total_cost = weight_dist * dist_cost + (1 - weight_dist) * span_cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n    # Demand-aware segment swapping\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform a few swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find segments to swap\n            route1_nodes = set(route1[1:-1])\n            route2_nodes = set(route2[1:-1])\n\n            # Find compatible segments\n            for segment1 in [route1[1:-1], route1[1:-2], route1[2:-1]]:\n                segment1_demand = sum(demand[node] for node in segment1)\n                for segment2 in [route2[1:-1], route2[1:-2], route2[2:-1]]:\n                    segment2_demand = sum(demand[node] for node in segment2)\n\n                    # Check capacity constraints\n                    route1_demand = sum(demand[node] for node in route1[1:-1])\n                    route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                    if (route1_demand - segment1_demand + segment2_demand <= capacity and\n                        route2_demand - segment2_demand + segment1_demand <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], segment1), segment2, [0]])\n                        new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], segment2), segment1, [0]])\n\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, called \"Adaptive Multi-Objective Route Transformation with Spatial-Demand Harmony,\" prioritizes solutions with high makespan and moderate total distance from the archive, then applies a sequence of adaptive transformations that dynamically balance spatial clustering and demand distribution. It first performs a \"route harmonization\" step where routes are partitioned into segments based on both spatial proximity and demand thresholds, with each segment's demand dynamically adjusted to maintain feasibility. Next, it employs a \"spatial-demand centroid alignment\" step where customers are reordered within segments based on their proximity to the segment's spatial centroid, while also considering demand compatibility. The algorithm then applies a probabilistic \"route fusion and decomposition\" step where adjacent segments are merged or split based on their spatial coherence and demand balance, with fusion probabilities adjusted based on the current solution's quality. Finally, it includes a \"demand-spatial workload redistribution\" step where customers are redistributed across routes to balance workload while maintaining spatial coherence, with acceptance probabilities dynamically adjusted to balance exploration and exploitation. The method ensures all transformations maintain feasibility and potentially improve both objectives through adaptive parameter tuning and spatial-aware demand management.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] * 0.7))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Route harmonization with spatial-demand partitioning\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_nodes = route[1:-1]\n        route_coords = coords[route_nodes]\n        centroid = np.mean(route_coords, axis=0)\n\n        # Calculate spatial-demand harmony score\n        spatial_scores = np.linalg.norm(route_coords - centroid, axis=1)\n        demand_scores = demand[route_nodes] / capacity\n        harmony_scores = spatial_scores * 0.6 + demand_scores * 0.4\n\n        # Partition route into segments\n        sorted_indices = np.argsort(harmony_scores)\n        segment_size = max(2, len(route_nodes) // 3)\n        segments = []\n        current_segment = []\n\n        for idx in sorted_indices:\n            current_segment.append(route_nodes[idx])\n            if len(current_segment) >= segment_size or idx == sorted_indices[-1]:\n                segments.append(np.array([0] + current_segment + [0]))\n                current_segment = []\n\n        if len(segments) > 1:\n            new_solution[route_idx] = segments[0]\n            for seg in segments[1:]:\n                new_solution.append(seg)\n\n    # Spatial-demand centroid alignment\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_nodes = route[1:-1]\n        centroid = np.mean(coords[route_nodes], axis=0)\n        distances = np.linalg.norm(coords[route_nodes] - centroid, axis=1)\n        sorted_indices = np.argsort(distances)\n\n        # Reorder nodes based on spatial proximity\n        new_order = route_nodes[sorted_indices]\n        new_route = np.array([0] + list(new_order) + [0])\n\n        if np.sum(demand[new_order]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Probabilistic route fusion and decomposition\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate fusion probability based on spatial and demand compatibility\n        centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n        centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n        spatial_dist = np.linalg.norm(centroid1 - centroid2)\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        fusion_prob = max(0.1, 0.8 * (1 - spatial_dist / np.max(distance_matrix)) * (1 - abs(demand1 - demand2) / capacity))\n\n        if random.random() < fusion_prob:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Try decomposition if fusion fails\n                split_pos = random.randint(2, len(merged_route) - 3)\n                segment1 = merged_route[:split_pos + 1]\n                segment2 = merged_route[split_pos:]\n                if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                    new_solution[i] = segment1\n                    new_solution.insert(j, segment2)\n\n    # Demand-spatial workload redistribution\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_nodes = route[1:-1]\n        route_centroid = np.mean(coords[route_nodes], axis=0)\n\n        # Find customer with highest spatial-demand imbalance\n        spatial_scores = np.linalg.norm(coords[route_nodes] - route_centroid, axis=1)\n        demand_scores = demand[route_nodes] / capacity\n        imbalance_scores = spatial_scores * 0.7 - demand_scores * 0.3\n        customer = route_nodes[np.argmax(imbalance_scores)]\n\n        # Find best target route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, other_route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n\n            current_demand = np.sum(demand[other_route[1:-1]])\n            if current_demand + demand[customer] > capacity:\n                continue\n\n            other_centroid = np.mean(coords[other_route[1:-1]], axis=0)\n            spatial_gain = np.linalg.norm(coords[customer] - other_centroid) - np.linalg.norm(coords[customer] - route_centroid)\n\n            for pos in range(1, len(other_route)):\n                cost = (distance_matrix[other_route[pos-1]][customer] +\n                       distance_matrix[customer][other_route[pos]] -\n                       distance_matrix[other_route[pos-1]][other_route[pos]]) * 0.7 - spatial_gain * 0.3\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [customer],\n                new_solution[best_route_idx][best_pos:]\n            ])\n            new_solution[route_idx] = np.concatenate([\n                route[:np.where(route == customer)[0][0]],\n                route[np.where(route == customer)[0][0]+1:]\n            ])\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The novel algorithm, called \"Adaptive Multi-Objective Route Fusion with Demand-Driven Spatial Clustering,\" first selects a solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically identifies high-demand clusters based on spatial proximity and demand density, while maintaining vehicle capacity constraints. It then fuses these clusters into composite segments while ensuring demand feasibility, followed by a demand-driven spatial reordering step that optimizes the sequence of customers within each segment based on their proximity to the segment's demand-weighted centroid. The algorithm then applies a probabilistic route merging step where adjacent segments are merged based on their demand compatibility and spatial coherence, with merge probabilities adjusted based on the demand balance and spatial proximity of the segments. Finally, it includes a \"demand-driven spatial workload redistribution\" step where customers are redistributed across routes to balance workload while maintaining spatial coherence, with acceptance probabilities dynamically adjusted to balance exploration and exploitation. The method ensures all transformations maintain feasibility and potentially improve both objectives through adaptive parameter tuning and demand-driven spatial management.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Identify high-demand clusters\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return new_solution\n\n    # Calculate demand density and spatial clusters\n    demand_density = demand[all_customers] / capacity\n    customer_coords = coords[all_customers]\n\n    # DBSCAN clustering based on demand and spatial proximity\n    from sklearn.cluster import DBSCAN\n    clustering = DBSCAN(eps=0.5, min_samples=2).fit(customer_coords)\n    labels = clustering.labels_\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    # Create demand-driven clusters\n    demand_clusters = []\n    for cluster_id in range(n_clusters):\n        cluster_indices = np.where(labels == cluster_id)[0]\n        cluster_customers = all_customers[cluster_indices]\n        cluster_demand = np.sum(demand[cluster_customers])\n\n        if cluster_demand > 0.6 * capacity:\n            demand_clusters.append(cluster_customers)\n\n    # Fusion of demand clusters into composite segments\n    for cluster in demand_clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with the most overlap with this cluster\n        best_route_idx = -1\n        max_overlap = 0\n        for i, route in enumerate(new_solution):\n            route_customers = set(route[1:-1])\n            overlap = len(set(cluster) & route_customers)\n            if overlap > max_overlap:\n                max_overlap = overlap\n                best_route_idx = i\n\n        if best_route_idx != -1:\n            # Create a new segment with the cluster\n            new_segment = np.array([0] + list(cluster) + [0])\n            if np.sum(demand[cluster]) <= capacity:\n                new_solution[best_route_idx] = new_segment\n\n    # Demand-driven spatial reordering\n    for route in new_solution:\n        if len(route) < 4:\n            continue\n\n        route_customers = route[1:-1]\n        if len(route_customers) == 0:\n            continue\n\n        # Calculate demand-weighted centroid\n        customer_weights = demand[route_customers] / np.sum(demand[route_customers])\n        centroid = np.average(coords[route_customers], axis=0, weights=customer_weights)\n\n        # Sort customers by distance to centroid\n        distances = np.linalg.norm(coords[route_customers] - centroid, axis=1)\n        sorted_indices = np.argsort(distances)\n        new_order = route_customers[sorted_indices]\n\n        # Rebuild route with new order\n        new_route = np.array([0] + list(new_order) + [0])\n        if np.sum(demand[new_order]) <= capacity:\n            route[:] = new_route\n\n    # Probabilistic route merging based on demand and spatial compatibility\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate demand and spatial compatibility\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n        demand_diff = abs(demand1 - demand2) / capacity\n\n        centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n        centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n        spatial_dist = np.linalg.norm(centroid1 - centroid2)\n\n        merge_prob = max(0.1, 0.9 * (1 - demand_diff) * (1 - spatial_dist / np.max(distance_matrix)))\n\n        if random.random() < merge_prob:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    # Demand-driven spatial workload redistribution\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_customers = route[1:-1]\n        route_centroid = np.mean(coords[route_customers], axis=0)\n\n        # Find customer with highest demand and spatial imbalance\n        demand_scores = demand[route_customers] / capacity\n        spatial_scores = np.linalg.norm(coords[route_customers] - route_centroid, axis=1)\n        imbalance_scores = demand_scores * 0.7 + spatial_scores * 0.3\n        customer = route_customers[np.argmax(imbalance_scores)]\n\n        # Find best target route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, other_route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n\n            current_demand = np.sum(demand[other_route[1:-1]])\n            if current_demand + demand[customer] > capacity:\n                continue\n\n            other_centroid = np.mean(coords[other_route[1:-1]], axis=0)\n            spatial_gain = np.linalg.norm(coords[customer] - other_centroid) - np.linalg.norm(coords[customer] - route_centroid)\n\n            for pos in range(1, len(other_route)):\n                cost = (distance_matrix[other_route[pos-1]][customer] +\n                       distance_matrix[customer][other_route[pos]] -\n                       distance_matrix[other_route[pos-1]][other_route[pos]]) * 0.6 + spatial_gain * 0.4\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [customer],\n                new_solution[best_route_idx][best_pos:]\n            ])\n            new_solution[route_idx] = np.concatenate([\n                route[:np.where(route == customer)[0][0]],\n                route[np.where(route == customer)[0][0]+1:]\n            ])\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7029851027986385,
               2.237561523914337
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Identify high-demand clusters\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return new_solution\n\n    # Calculate demand density and spatial clusters\n    demand_density = demand[all_customers] / capacity\n    customer_coords = coords[all_customers]\n\n    # DBSCAN clustering based on demand and spatial proximity\n    from sklearn.cluster import DBSCAN\n    clustering = DBSCAN(eps=0.5, min_samples=2).fit(customer_coords)\n    labels = clustering.labels_\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    # Create demand-driven clusters\n    demand_clusters = []\n    for cluster_id in range(n_clusters):\n        cluster_indices = np.where(labels == cluster_id)[0]\n        cluster_customers = all_customers[cluster_indices]\n        cluster_demand = np.sum(demand[cluster_customers])\n\n        if cluster_demand > 0.6 * capacity:\n            demand_clusters.append(cluster_customers)\n\n    # Fusion of demand clusters into composite segments\n    for cluster in demand_clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with the most overlap with this cluster\n        best_route_idx = -1\n        max_overlap = 0\n        for i, route in enumerate(new_solution):\n            route_customers = set(route[1:-1])\n            overlap = len(set(cluster) & route_customers)\n            if overlap > max_overlap:\n                max_overlap = overlap\n                best_route_idx = i\n\n        if best_route_idx != -1:\n            # Create a new segment with the cluster\n            new_segment = np.array([0] + list(cluster) + [0])\n            if np.sum(demand[cluster]) <= capacity:\n                new_solution[best_route_idx] = new_segment\n\n    # Demand-driven spatial reordering\n    for route in new_solution:\n        if len(route) < 4:\n            continue\n\n        route_customers = route[1:-1]\n        if len(route_customers) == 0:\n            continue\n\n        # Calculate demand-weighted centroid\n        customer_weights = demand[route_customers] / np.sum(demand[route_customers])\n        centroid = np.average(coords[route_customers], axis=0, weights=customer_weights)\n\n        # Sort customers by distance to centroid\n        distances = np.linalg.norm(coords[route_customers] - centroid, axis=1)\n        sorted_indices = np.argsort(distances)\n        new_order = route_customers[sorted_indices]\n\n        # Rebuild route with new order\n        new_route = np.array([0] + list(new_order) + [0])\n        if np.sum(demand[new_order]) <= capacity:\n            route[:] = new_route\n\n    # Probabilistic route merging based on demand and spatial compatibility\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate demand and spatial compatibility\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n        demand_diff = abs(demand1 - demand2) / capacity\n\n        centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n        centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n        spatial_dist = np.linalg.norm(centroid1 - centroid2)\n\n        merge_prob = max(0.1, 0.9 * (1 - demand_diff) * (1 - spatial_dist / np.max(distance_matrix)))\n\n        if random.random() < merge_prob:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    # Demand-driven spatial workload redistribution\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_customers = route[1:-1]\n        route_centroid = np.mean(coords[route_customers], axis=0)\n\n        # Find customer with highest demand and spatial imbalance\n        demand_scores = demand[route_customers] / capacity\n        spatial_scores = np.linalg.norm(coords[route_customers] - route_centroid, axis=1)\n        imbalance_scores = demand_scores * 0.7 + spatial_scores * 0.3\n        customer = route_customers[np.argmax(imbalance_scores)]\n\n        # Find best target route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, other_route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n\n            current_demand = np.sum(demand[other_route[1:-1]])\n            if current_demand + demand[customer] > capacity:\n                continue\n\n            other_centroid = np.mean(coords[other_route[1:-1]], axis=0)\n            spatial_gain = np.linalg.norm(coords[customer] - other_centroid) - np.linalg.norm(coords[customer] - route_centroid)\n\n            for pos in range(1, len(other_route)):\n                cost = (distance_matrix[other_route[pos-1]][customer] +\n                       distance_matrix[customer][other_route[pos]] -\n                       distance_matrix[other_route[pos-1]][other_route[pos]]) * 0.6 + spatial_gain * 0.4\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [customer],\n                new_solution[best_route_idx][best_pos:]\n            ])\n            new_solution[route_idx] = np.concatenate([\n                route[:np.where(route == customer)[0][0]],\n                route[np.where(route == customer)[0][0]+1:]\n            ])\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Route Segmentation with Spatial and Demand-Aware Clustering,\" first selects a high-quality solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically partitions the solution into segments based on spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by greedily merging segments that optimize both objectives, using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware segment swapping\" mechanism that exchanges segments between routes while preserving capacity feasibility and potentially improving both objectives. The method combines adaptive segmentation, spatial-demand clustering, and hybrid objective-driven reconstruction to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Adaptive route segmentation\n    segments = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Split route into segments of approximately equal length\n            n_segments = max(2, len(route) // 4)\n            segment_length = len(route) // n_segments\n            for i in range(n_segments):\n                start = 1 + i * segment_length\n                end = min(start + segment_length, len(route) - 1)\n                segment = route[start:end]\n                segments.append(segment)\n\n    # Spatial and demand-aware clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    for segment in segments:\n        if len(segment) == 0:\n            continue\n\n        # Find segment center\n        segment_coords = coords[segment]\n        center = np.mean(segment_coords, axis=0)\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find closest cluster with available capacity\n        best_cluster = -1\n        min_dist = float('inf')\n        for i, (cluster_center, cluster_d) in enumerate(zip(cluster_centers, cluster_demands)):\n            if cluster_d + segment_demand <= capacity:\n                dist = np.linalg.norm(center - cluster_center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(segment)\n            cluster_demands[best_cluster] += segment_demand\n        else:\n            # Create new cluster\n            clusters.append([segment])\n            cluster_centers.append(center)\n            cluster_demands.append(segment_demand)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Combine all segments in cluster\n        all_nodes = []\n        for segment in cluster:\n            all_nodes.extend(segment)\n        remaining = set(all_nodes)\n\n        # Dynamic weight adjustment for hybrid objective\n        total_dist, makespan = archive_sorted[0][1]\n        weight_dist = 0.7 if makespan > 1.2 * total_dist else 0.3\n\n        # Greedy route construction\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Calculate hybrid cost\n                    last_node = current_route[-1]\n                    dist_cost = distance_matrix[last_node][node]\n                    span_cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n                    total_cost = weight_dist * dist_cost + (1 - weight_dist) * span_cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n    # Demand-aware segment swapping\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform a few swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find segments to swap\n            route1_nodes = set(route1[1:-1])\n            route2_nodes = set(route2[1:-1])\n\n            # Find compatible segments\n            for segment1 in [route1[1:-1], route1[1:-2], route1[2:-1]]:\n                segment1_demand = sum(demand[node] for node in segment1)\n                for segment2 in [route2[1:-1], route2[1:-2], route2[2:-1]]:\n                    segment2_demand = sum(demand[node] for node in segment2)\n\n                    # Check capacity constraints\n                    route1_demand = sum(demand[node] for node in route1[1:-1])\n                    route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                    if (route1_demand - segment1_demand + segment2_demand <= capacity and\n                        route2_demand - segment2_demand + segment1_demand <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], segment1), segment2, [0]])\n                        new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], segment2), segment1, [0]])\n\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, called \"Adaptive Spatial-Demand Harmony Hybridization,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-demand harmony mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment harmonization step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and harmonization probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-spatial synergy insertion\" step where customers are inserted into routes based on their demand and proximity to route centroids, and a \"route harmonization\" step where routes are adjusted to balance the workload across vehicles while maintaining spatial coherence.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 4), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.4, 0.7)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.4, 0.7)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.15) or (total_dist <= original_dist * 1.15 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        closest_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[closest_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                           distance_matrix[closest_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                        route[np.where(route == closest_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The new algorithm, called \"Adaptive Multi-Objective Route Fusion with Spatial-Demand Synergy,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-demand synergy mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment fusion step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and fusion probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-spatial synergy insertion\" step where customers are inserted into routes based on their demand and proximity to route centroids, and a \"route harmonization\" step where routes are adjusted to balance the workload across vehicles while maintaining spatial coherence.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 4), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.5, 0.8)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.5, 0.8)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        closest_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[closest_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                           distance_matrix[closest_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                        route[np.where(route == closest_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.79363487930532,
               0.1087062656879425
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 4), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.5, 0.8)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.5, 0.8)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        closest_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[closest_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                           distance_matrix[closest_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                        route[np.where(route == closest_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Route Segmentation with Spatial and Demand-Aware Clustering,\" first selects a high-quality solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically partitions the solution into segments based on spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by greedily merging segments that optimize both objectives, using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware segment swapping\" mechanism that exchanges segments between routes while preserving capacity feasibility and potentially improving both objectives. The method combines adaptive segmentation, spatial-demand clustering, and hybrid objective-driven reconstruction to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Adaptive route segmentation\n    segments = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Split route into segments of approximately equal length\n            n_segments = max(2, len(route) // 4)\n            segment_length = len(route) // n_segments\n            for i in range(n_segments):\n                start = 1 + i * segment_length\n                end = min(start + segment_length, len(route) - 1)\n                segment = route[start:end]\n                segments.append(segment)\n\n    # Spatial and demand-aware clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    for segment in segments:\n        if len(segment) == 0:\n            continue\n\n        # Find segment center\n        segment_coords = coords[segment]\n        center = np.mean(segment_coords, axis=0)\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find closest cluster with available capacity\n        best_cluster = -1\n        min_dist = float('inf')\n        for i, (cluster_center, cluster_d) in enumerate(zip(cluster_centers, cluster_demands)):\n            if cluster_d + segment_demand <= capacity:\n                dist = np.linalg.norm(center - cluster_center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(segment)\n            cluster_demands[best_cluster] += segment_demand\n        else:\n            # Create new cluster\n            clusters.append([segment])\n            cluster_centers.append(center)\n            cluster_demands.append(segment_demand)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Combine all segments in cluster\n        all_nodes = []\n        for segment in cluster:\n            all_nodes.extend(segment)\n        remaining = set(all_nodes)\n\n        # Dynamic weight adjustment for hybrid objective\n        total_dist, makespan = archive_sorted[0][1]\n        weight_dist = 0.7 if makespan > 1.2 * total_dist else 0.3\n\n        # Greedy route construction\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Calculate hybrid cost\n                    last_node = current_route[-1]\n                    dist_cost = distance_matrix[last_node][node]\n                    span_cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n                    total_cost = weight_dist * dist_cost + (1 - weight_dist) * span_cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n    # Demand-aware segment swapping\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform a few swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find segments to swap\n            route1_nodes = set(route1[1:-1])\n            route2_nodes = set(route2[1:-1])\n\n            # Find compatible segments\n            for segment1 in [route1[1:-1], route1[1:-2], route1[2:-1]]:\n                segment1_demand = sum(demand[node] for node in segment1)\n                for segment2 in [route2[1:-1], route2[1:-2], route2[2:-1]]:\n                    segment2_demand = sum(demand[node] for node in segment2)\n\n                    # Check capacity constraints\n                    route1_demand = sum(demand[node] for node in route1[1:-1])\n                    route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                    if (route1_demand - segment1_demand + segment2_demand <= capacity and\n                        route2_demand - segment2_demand + segment1_demand <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], segment1), segment2, [0]])\n                        new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], segment2), segment1, [0]])\n\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Multi-Objective Route Balancing with Spatial-Demand Synergy,\" first selects a solution from the archive by prioritizing those with high total distance but moderate makespan, indicating potential for improvement in both objectives, then dynamically partitions the solution into segments based on both spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by iteratively balancing the workload across vehicles using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"spatial-demand aware route splitting\" mechanism that splits routes when their spatial or demand imbalance exceeds predefined thresholds, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the splitting thresholds and acceptance probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-aware route merging\" step where compatible routes are merged if it reduces the makespan without violating capacity constraints, and a \"route optimization\" step where routes are optimized using a greedy insertion heuristic that considers both spatial proximity and demand compatibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    new_solution = []\n    route_indices = list(range(len(base_solution)))\n\n    while route_indices:\n        current_route_idx = random.choice(route_indices)\n        current_route = base_solution[current_route_idx]\n        route_indices.remove(current_route_idx)\n\n        if len(current_route) < 3:\n            new_solution.append(current_route)\n            continue\n\n        # Calculate spatial and demand metrics\n        route_customers = current_route[1:-1]\n        route_coords = coords[route_customers]\n        route_centroid = np.mean(route_coords, axis=0)\n        route_demand = sum(demand[node] for node in route_customers)\n\n        # Check for spatial imbalance\n        max_distance = max(np.linalg.norm(route_coords - route_centroid, axis=1))\n        avg_distance = np.mean(np.linalg.norm(route_coords - route_centroid, axis=1))\n        spatial_imbalance = max_distance / avg_distance if avg_distance > 0 else 0\n\n        # Check for demand imbalance\n        demand_imbalance = max(demand[node] for node in route_customers) / route_demand if route_demand > 0 else 0\n\n        # Decide whether to split or not\n        split_threshold = random.uniform(1.2, 1.5)\n        if spatial_imbalance > split_threshold or demand_imbalance > split_threshold:\n            # Split the route\n            split_pos = len(current_route) // 2\n            new_route1 = np.concatenate([current_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], current_route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(current_route)\n        else:\n            new_solution.append(current_route)\n\n    # Try to merge compatible routes\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate potential merged demand\n        merged_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if merged_demand <= capacity:\n            # Calculate spatial compatibility\n            route1_coords = coords[route1[1:-1]]\n            route2_coords = coords[route2[1:-1]]\n            route1_centroid = np.mean(route1_coords, axis=0)\n            route2_centroid = np.mean(route2_coords, axis=0)\n            centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n            # Calculate demand compatibility\n            route1_demand = sum(demand[node] for node in route1[1:-1])\n            route2_demand = sum(demand[node] for node in route2[1:-1])\n            demand_ratio = max(route1_demand, route2_demand) / min(route1_demand, route2_demand) if min(route1_demand, route2_demand) > 0 else 1\n\n            # Decide whether to merge\n            merge_probability = 0.7 if centroid_distance < np.mean(distance_matrix) and demand_ratio < 1.5 else 0.3\n\n            if random.random() < merge_probability:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                new_solution.append(merged_route)\n\n    # Optimize routes with greedy insertion\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        # Find the most remote customer\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        remote_customer_pos = np.argmax(distances) + 1  # +1 because we skip depot\n        remote_customer = route[remote_customer_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            if other_demand + demand[remote_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][remote_customer] +\n                           distance_matrix[remote_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Calculate current and potential makespan\n                current_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in new_solution\n                )\n\n                new_route = np.concatenate([other_route[:best_pos], [remote_customer], other_route[best_pos:]])\n                new_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in [new_route] + [r for idx, r in enumerate(new_solution) if idx != other_route_idx]\n                )\n\n                if new_makespan <= current_makespan * 1.1:  # Allow slight increase in makespan for better distance\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:remote_customer_pos], route[remote_customer_pos+1:]])\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The novel algorithm, called \"Dynamic Cluster-Based Route Evolution with Adaptive Objective Fusion,\" first selects a solution from the archive by prioritizing those with moderate makespan and total distance, then dynamically clusters routes based on both spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then evolves routes by iteratively merging and splitting clusters using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"cluster-based route evolution\" mechanism that allows for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the cluster formation thresholds and acceptance probabilities based on the current solution quality, and incorporates spatial-demand awareness to create more balanced routes. Additionally, it includes an \"adaptive objective fusion\" step where the hybrid cost function is refined based on the current Pareto front characteristics, and a \"route optimization\" step where routes are optimized using a greedy insertion heuristic that considers both spatial proximity and demand compatibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    new_solution = []\n    route_indices = list(range(len(base_solution)))\n\n    while route_indices:\n        current_route_idx = random.choice(route_indices)\n        current_route = base_solution[current_route_idx]\n        route_indices.remove(current_route_idx)\n\n        if len(current_route) < 3:\n            new_solution.append(current_route)\n            continue\n\n        route_customers = current_route[1:-1]\n        route_coords = coords[route_customers]\n        route_centroid = np.mean(route_coords, axis=0)\n        route_demand = sum(demand[node] for node in route_customers)\n\n        max_distance = max(np.linalg.norm(route_coords - route_centroid, axis=1))\n        avg_distance = np.mean(np.linalg.norm(route_coords - route_centroid, axis=1))\n        spatial_imbalance = max_distance / avg_distance if avg_distance > 0 else 0\n\n        demand_imbalance = max(demand[node] for node in route_customers) / route_demand if route_demand > 0 else 0\n\n        cluster_threshold = random.uniform(1.1, 1.4)\n        if spatial_imbalance > cluster_threshold or demand_imbalance > cluster_threshold:\n            split_pos = len(current_route) // 2\n            new_route1 = np.concatenate([current_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], current_route[split_pos:-1], [0]])\n\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(current_route)\n        else:\n            new_solution.append(current_route)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if merged_demand <= capacity:\n            route1_coords = coords[route1[1:-1]]\n            route2_coords = coords[route2[1:-1]]\n            route1_centroid = np.mean(route1_coords, axis=0)\n            route2_centroid = np.mean(route2_coords, axis=0)\n            centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n            route1_demand = sum(demand[node] for node in route1[1:-1])\n            route2_demand = sum(demand[node] for node in route2[1:-1])\n            demand_ratio = max(route1_demand, route2_demand) / min(route1_demand, route2_demand) if min(route1_demand, route2_demand) > 0 else 1\n\n            merge_probability = 0.6 if centroid_distance < np.mean(distance_matrix) and demand_ratio < 1.3 else 0.2\n\n            if random.random() < merge_probability:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                new_solution.append(merged_route)\n\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        remote_customer_pos = np.argmax(distances) + 1\n        remote_customer = route[remote_customer_pos]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            if other_demand + demand[remote_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][remote_customer] +\n                           distance_matrix[remote_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                current_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in new_solution\n                )\n\n                new_route = np.concatenate([other_route[:best_pos], [remote_customer], other_route[best_pos:]])\n                new_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in [new_route] + [r for idx, r in enumerate(new_solution) if idx != other_route_idx]\n                )\n\n                if new_makespan <= current_makespan * 1.1:\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:remote_customer_pos], route[remote_customer_pos+1:]])\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7956563306248772,
               3.200564682483673
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    new_solution = []\n    route_indices = list(range(len(base_solution)))\n\n    while route_indices:\n        current_route_idx = random.choice(route_indices)\n        current_route = base_solution[current_route_idx]\n        route_indices.remove(current_route_idx)\n\n        if len(current_route) < 3:\n            new_solution.append(current_route)\n            continue\n\n        route_customers = current_route[1:-1]\n        route_coords = coords[route_customers]\n        route_centroid = np.mean(route_coords, axis=0)\n        route_demand = sum(demand[node] for node in route_customers)\n\n        max_distance = max(np.linalg.norm(route_coords - route_centroid, axis=1))\n        avg_distance = np.mean(np.linalg.norm(route_coords - route_centroid, axis=1))\n        spatial_imbalance = max_distance / avg_distance if avg_distance > 0 else 0\n\n        demand_imbalance = max(demand[node] for node in route_customers) / route_demand if route_demand > 0 else 0\n\n        cluster_threshold = random.uniform(1.1, 1.4)\n        if spatial_imbalance > cluster_threshold or demand_imbalance > cluster_threshold:\n            split_pos = len(current_route) // 2\n            new_route1 = np.concatenate([current_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], current_route[split_pos:-1], [0]])\n\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(current_route)\n        else:\n            new_solution.append(current_route)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if merged_demand <= capacity:\n            route1_coords = coords[route1[1:-1]]\n            route2_coords = coords[route2[1:-1]]\n            route1_centroid = np.mean(route1_coords, axis=0)\n            route2_centroid = np.mean(route2_coords, axis=0)\n            centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n            route1_demand = sum(demand[node] for node in route1[1:-1])\n            route2_demand = sum(demand[node] for node in route2[1:-1])\n            demand_ratio = max(route1_demand, route2_demand) / min(route1_demand, route2_demand) if min(route1_demand, route2_demand) > 0 else 1\n\n            merge_probability = 0.6 if centroid_distance < np.mean(distance_matrix) and demand_ratio < 1.3 else 0.2\n\n            if random.random() < merge_probability:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                new_solution.append(merged_route)\n\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        remote_customer_pos = np.argmax(distances) + 1\n        remote_customer = route[remote_customer_pos]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            if other_demand + demand[remote_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][remote_customer] +\n                           distance_matrix[remote_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                current_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in new_solution\n                )\n\n                new_route = np.concatenate([other_route[:best_pos], [remote_customer], other_route[best_pos:]])\n                new_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in [new_route] + [r for idx, r in enumerate(new_solution) if idx != other_route_idx]\n                )\n\n                if new_makespan <= current_makespan * 1.1:\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:remote_customer_pos], route[remote_customer_pos+1:]])\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, called \"Adaptive Demand-Adjusted Route Fusion and Spatial-Constrained Splitting\" (ADARFS), first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, then applies a hybrid approach that first fuses routes with complementary demand patterns while respecting spatial constraints, followed by a demand-adjusted splitting phase that divides overloaded routes into segments with balanced demands and optimized spatial configurations, ensuring capacity constraints are met and both objectives are improved through a two-phase transformation process where demand-adjustment identifies optimal route groupings and spatial-constrained splitting ensures feasible and efficient route configurations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in base_solution]\n\n    demand_threshold = capacity * 0.6\n    complement_pairs = []\n\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            combined_demand = route_demands[i] + route_demands[j]\n            if combined_demand <= capacity * 1.2 and combined_demand >= demand_threshold:\n                complement_pairs.append((i, j))\n\n    if complement_pairs:\n        pair = random.choice(complement_pairs)\n        route1, route2 = base_solution[pair[0]], base_solution[pair[1]]\n\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [route for idx, route in enumerate(base_solution) if idx not in pair]\n            new_solution.append(merged_route)\n            base_solution = new_solution\n\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d > capacity * 0.8]\n\n    if overloaded_routes:\n        route_idx = random.choice(overloaded_routes)\n        route = base_solution[route_idx]\n        nodes = route[1:-1]\n\n        if len(nodes) > 2:\n            demand_sorted = sorted(nodes, key=lambda x: demand[x], reverse=True)\n            split_pos = len(nodes) // 2\n\n            segment1 = np.concatenate(([0], nodes[:split_pos], [0]))\n            segment2 = np.concatenate(([0], nodes[split_pos:], [0]))\n\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution = [route for idx, route in enumerate(base_solution) if idx != route_idx]\n                new_solution.extend([segment1, segment2])\n                base_solution = new_solution\n\n    return base_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Route Partitioning with Spatial-Demand Clustering and Multi-Objective Balancing,\" first selects a solution from the archive by prioritizing those with balanced objectives, then partitions the solution into spatial-demand clusters using a k-means++ inspired approach that considers both geographic proximity and demand compatibility, while maintaining capacity constraints. It then reconstructs routes by iteratively merging clusters that optimize a hybrid objective function, which dynamically balances distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware route inversion\" mechanism that reverses segments of routes when it improves both objectives, while preserving capacity feasibility. The method combines adaptive partitioning, spatial-demand clustering, hybrid objective-driven reconstruction, and intelligent route inversion to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Spatial-demand clustering using k-means++\n    def kmeans_plus_plus(coords, demand, k, capacity):\n        centers = []\n        demands = []\n        remaining = set(all_customers)\n\n        # Initialize first center\n        first_center = random.choice(all_customers)\n        centers.append(first_center)\n        demands.append(demand[first_center])\n        remaining.remove(first_center)\n\n        # Initialize remaining centers\n        for _ in range(1, k):\n            max_dist = -1\n            best_node = None\n\n            for node in remaining:\n                min_dist = min(distance_matrix[node][center] for center in centers)\n                if min_dist > max_dist:\n                    max_dist = min_dist\n                    best_node = node\n\n            if best_node is not None:\n                centers.append(best_node)\n                demands.append(demand[best_node])\n                remaining.remove(best_node)\n            else:\n                break\n\n        # Assign nodes to clusters\n        clusters = [[] for _ in range(len(centers))]\n        cluster_demands = demands.copy()\n\n        for node in all_customers:\n            if node in centers:\n                idx = centers.index(node)\n                clusters[idx].append(node)\n            else:\n                best_cluster = -1\n                min_dist = float('inf')\n\n                for i, center in enumerate(centers):\n                    if cluster_demands[i] + demand[node] <= capacity:\n                        dist = distance_matrix[node][center]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_cluster = i\n\n                if best_cluster != -1:\n                    clusters[best_cluster].append(node)\n                    cluster_demands[best_cluster] += demand[node]\n\n        return clusters\n\n    # Determine number of clusters (between 2 and 4)\n    k = min(max(2, len(base_solution) // 2), 4)\n    clusters = kmeans_plus_plus(coords, demand, k, capacity)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Sort nodes in cluster by distance to depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Greedy route construction\n        current_route = [0]\n        current_demand = 0.0\n        remaining = cluster_sorted.copy()\n\n        while remaining:\n            best_node = None\n            best_cost = float('inf')\n\n            for node in remaining:\n                if current_demand + demand[node] > capacity:\n                    continue\n\n                # Calculate hybrid cost (balance between distance and makespan)\n                last_node = current_route[-1]\n                dist_cost = distance_matrix[last_node][node]\n                span_cost = distance_matrix[node][0]  # Return to depot\n                total_cost = 0.5 * dist_cost + 0.5 * span_cost\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_node = node\n\n            if best_node is not None:\n                current_route.append(best_node)\n                current_demand += demand[best_node]\n                remaining.remove(best_node)\n            else:\n                break\n\n        current_route.append(0)\n        if len(current_route) > 2:\n            new_solution.append(np.array(current_route))\n\n    # Demand-aware route inversion\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if inversion improves both objectives\n                original_dist = (distance_matrix[route[i-1]][route[i]] +\n                                distance_matrix[route[j]][route[j+1]])\n                inverted_dist = (distance_matrix[route[i-1]][route[j]] +\n                                distance_matrix[route[i]][route[j+1]])\n\n                if inverted_dist < original_dist:\n                    # Check capacity constraints\n                    segment_demand = sum(demand[node] for node in route[i:j+1])\n                    if segment_demand <= capacity:\n                        # Perform inversion\n                        route[i:j+1] = route[j:i-1:-1]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The new algorithm, called \"Adaptive Multi-Objective Route Balancing with Spatial-Demand Adaptive Clustering and Dynamic Route Realignment,\" first selects a solution from the archive by prioritizing those with high makespan and low total distance, then partitions the solution into adaptive spatial-demand clusters using a novel demand-weighted k-means approach that considers both geographic proximity and demand compatibility, while maintaining capacity constraints. It then reconstructs routes by iteratively merging clusters that optimize a multi-objective balancing function, which dynamically adjusts the weight between distance and makespan based on the current solution's characteristics. The method incorporates a dynamic route realignment mechanism that adaptively reorders nodes within routes to improve both objectives, while preserving capacity feasibility, and uses a novel \"demand-aware segment inversion\" technique that inverts segments of routes when it improves both objectives. The algorithm combines adaptive clustering, demand-weighted partitioning, multi-objective balancing, dynamic realignment, and demand-aware inversion to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    def demand_weighted_kmeans(coords, demand, k, capacity):\n        centers = []\n        demands = []\n        remaining = set(all_customers)\n\n        first_center = random.choice(all_customers)\n        centers.append(first_center)\n        demands.append(demand[first_center])\n        remaining.remove(first_center)\n\n        for _ in range(1, k):\n            max_score = -1\n            best_node = None\n\n            for node in remaining:\n                min_dist = min(distance_matrix[node][center] for center in centers)\n                demand_weight = demand[node] / capacity\n                score = min_dist * (1 + demand_weight)\n\n                if score > max_score:\n                    max_score = score\n                    best_node = node\n\n            if best_node is not None:\n                centers.append(best_node)\n                demands.append(demand[best_node])\n                remaining.remove(best_node)\n            else:\n                break\n\n        clusters = [[] for _ in range(len(centers))]\n        cluster_demands = demands.copy()\n\n        for node in all_customers:\n            if node in centers:\n                idx = centers.index(node)\n                clusters[idx].append(node)\n            else:\n                best_cluster = -1\n                best_score = float('inf')\n\n                for i, center in enumerate(centers):\n                    if cluster_demands[i] + demand[node] <= capacity:\n                        dist = distance_matrix[node][center]\n                        demand_weight = (cluster_demands[i] + demand[node]) / capacity\n                        score = dist * (1 + demand_weight)\n\n                        if score < best_score:\n                            best_score = score\n                            best_cluster = i\n\n                if best_cluster != -1:\n                    clusters[best_cluster].append(node)\n                    cluster_demands[best_cluster] += demand[node]\n\n        return clusters\n\n    k = min(max(2, len(base_solution) // 2), 4)\n    clusters = demand_weighted_kmeans(coords, demand, k, capacity)\n\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        current_route = [0]\n        current_demand = 0.0\n        remaining = cluster_sorted.copy()\n\n        while remaining:\n            best_node = None\n            best_score = float('inf')\n\n            for node in remaining:\n                if current_demand + demand[node] > capacity:\n                    continue\n\n                last_node = current_route[-1]\n                dist_cost = distance_matrix[last_node][node]\n                span_cost = distance_matrix[node][0]\n                demand_weight = (current_demand + demand[node]) / capacity\n\n                total_score = 0.6 * dist_cost + 0.4 * span_cost + 0.2 * demand_weight\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_node = node\n\n            if best_node is not None:\n                current_route.append(best_node)\n                current_demand += demand[best_node]\n                remaining.remove(best_node)\n            else:\n                break\n\n        current_route.append(0)\n        if len(current_route) > 2:\n            new_solution.append(np.array(current_route))\n\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                original_dist = (distance_matrix[route[i-1]][route[i]] +\n                                distance_matrix[route[j]][route[j+1]])\n                inverted_dist = (distance_matrix[route[i-1]][route[j]] +\n                                distance_matrix[route[i]][route[j+1]])\n\n                if inverted_dist < original_dist:\n                    segment_demand = sum(demand[node] for node in route[i:j+1])\n                    if segment_demand <= capacity:\n                        route[i:j+1] = route[j:i-1:-1]\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7605821276018702,
               1.6484400033950806
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    def demand_weighted_kmeans(coords, demand, k, capacity):\n        centers = []\n        demands = []\n        remaining = set(all_customers)\n\n        first_center = random.choice(all_customers)\n        centers.append(first_center)\n        demands.append(demand[first_center])\n        remaining.remove(first_center)\n\n        for _ in range(1, k):\n            max_score = -1\n            best_node = None\n\n            for node in remaining:\n                min_dist = min(distance_matrix[node][center] for center in centers)\n                demand_weight = demand[node] / capacity\n                score = min_dist * (1 + demand_weight)\n\n                if score > max_score:\n                    max_score = score\n                    best_node = node\n\n            if best_node is not None:\n                centers.append(best_node)\n                demands.append(demand[best_node])\n                remaining.remove(best_node)\n            else:\n                break\n\n        clusters = [[] for _ in range(len(centers))]\n        cluster_demands = demands.copy()\n\n        for node in all_customers:\n            if node in centers:\n                idx = centers.index(node)\n                clusters[idx].append(node)\n            else:\n                best_cluster = -1\n                best_score = float('inf')\n\n                for i, center in enumerate(centers):\n                    if cluster_demands[i] + demand[node] <= capacity:\n                        dist = distance_matrix[node][center]\n                        demand_weight = (cluster_demands[i] + demand[node]) / capacity\n                        score = dist * (1 + demand_weight)\n\n                        if score < best_score:\n                            best_score = score\n                            best_cluster = i\n\n                if best_cluster != -1:\n                    clusters[best_cluster].append(node)\n                    cluster_demands[best_cluster] += demand[node]\n\n        return clusters\n\n    k = min(max(2, len(base_solution) // 2), 4)\n    clusters = demand_weighted_kmeans(coords, demand, k, capacity)\n\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        current_route = [0]\n        current_demand = 0.0\n        remaining = cluster_sorted.copy()\n\n        while remaining:\n            best_node = None\n            best_score = float('inf')\n\n            for node in remaining:\n                if current_demand + demand[node] > capacity:\n                    continue\n\n                last_node = current_route[-1]\n                dist_cost = distance_matrix[last_node][node]\n                span_cost = distance_matrix[node][0]\n                demand_weight = (current_demand + demand[node]) / capacity\n\n                total_score = 0.6 * dist_cost + 0.4 * span_cost + 0.2 * demand_weight\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_node = node\n\n            if best_node is not None:\n                current_route.append(best_node)\n                current_demand += demand[best_node]\n                remaining.remove(best_node)\n            else:\n                break\n\n        current_route.append(0)\n        if len(current_route) > 2:\n            new_solution.append(np.array(current_route))\n\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                original_dist = (distance_matrix[route[i-1]][route[i]] +\n                                distance_matrix[route[j]][route[j+1]])\n                inverted_dist = (distance_matrix[route[i-1]][route[j]] +\n                                distance_matrix[route[i]][route[j+1]])\n\n                if inverted_dist < original_dist:\n                    segment_demand = sum(demand[node] for node in route[i:j+1])\n                    if segment_demand <= capacity:\n                        route[i:j+1] = route[j:i-1:-1]\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, called \"Adaptive Demand Cluster Fusion and Spatial-Aware Splitting,\" first selects a solution from the archive by prioritizing those with high total distance and relatively balanced makespan, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-aware splitting mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and merging probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1] / x[1][0]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.5, 0.8)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n                current_demand = 0\n                demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n                for k in range(1, len(merged_segment) - 1):\n                    current_segment.append(merged_segment[k])\n                    current_demand += demand[merged_segment[k]]\n\n                    if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                        if current_demand <= capacity:\n                            segment_coords = coords[current_segment[1:-1]]\n                            segment_centroid = np.mean(segment_coords, axis=0)\n                            distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                            if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                                new_segments.append(np.array(current_segment + [0]))\n                                current_segment = [0]\n                                current_demand = 0\n                                demand_threshold = capacity * random.uniform(0.5, 0.8)\n                        else:\n                            last_node = current_segment.pop()\n                            current_demand -= demand[last_node]\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0, last_node]\n                            current_demand = demand[last_node]\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy, called \"Adaptive Route Merging with Demand-Balanced Splitting,\" first selects a solution from the archive based on a multi-criteria ranking that considers both objective values and solution structure, then adaptively merges multiple routes into a single path while maintaining capacity constraints, and strategically splits this merged route into multiple segments using a demand-balanced approach that minimizes both the total distance increase and the variance in route lengths, followed by an optional demand-aware relocation step that intelligently redistributes high-demand nodes across routes to further balance the solution's objectives without violating capacity constraints. This hybrid approach combines adaptive merging, demand-balanced splitting, and intelligent relocation to explore the solution space more effectively than standard methods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / (x[1][1] + 1), -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Adaptive route merging\n    merge_indices = random.sample(range(len(selected_solution)), min(3, len(selected_solution)))\n    merged_routes = selected_solution[merge_indices[0]].copy()\n\n    for idx in merge_indices[1:]:\n        merged_routes = np.concatenate((merged_routes[:-1], selected_solution[idx][1:]))\n\n    total_demand = sum(demand[node] for node in merged_routes[1:-1])\n    if total_demand > capacity:\n        return selected_solution\n\n    # Demand-balanced splitting\n    split_points = []\n    current_demand = 0\n    target_load = total_demand / (len(merge_indices) + 1)\n\n    for i in range(1, len(merged_routes)-1):\n        current_demand += demand[merged_routes[i]]\n        if abs(current_demand - target_load) < target_load * 0.2:\n            split_points.append(i)\n            current_demand = 0\n\n    if not split_points:\n        return selected_solution\n\n    # Create new routes from splits\n    new_routes = []\n    prev = 0\n    for point in split_points:\n        new_route = np.concatenate(([0], merged_routes[prev+1:point+1], [0]))\n        if len(new_route) > 2:\n            new_routes.append(new_route)\n        prev = point\n\n    if len(merged_routes) > prev + 1:\n        new_route = np.concatenate(([0], merged_routes[prev+1:-1], [0]))\n        if len(new_route) > 2:\n            new_routes.append(new_route)\n\n    # Remove original merged routes\n    new_solution = [route for i, route in enumerate(selected_solution) if i not in merge_indices]\n    new_solution.extend(new_routes)\n\n    # Demand-aware relocation\n    for route in new_solution:\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if demand[node] > capacity * 0.25:  # Relocate high-demand nodes\n                for other_route in new_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    current_demand = sum(demand[n] for n in other_route[1:-1])\n                    if current_demand + demand[node] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[j-1]][node] +\n                                   distance_matrix[node][other_route[j]] -\n                                   distance_matrix[other_route[j-1]][other_route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        if best_cost < 0:  # Only relocate if improves distance\n                            new_route = np.insert(other_route, best_pos, node)\n                            other_route[:] = new_route\n                            route = np.delete(route, i)\n                            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": "{The new algorithm, called \"Spatial-Clustered Demand-Aware Route Fusion and Balanced Splitting,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, indicating potential for improvement in both objectives, then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-clustering-based splitting mechanism that partitions the fused route into segments based on both demand thresholds and spatial proximity, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold, followed by an optional demand-aware relocation step that intelligently redistributes high-demand nodes across routes to further balance the solution's objectives without violating capacity constraints, while also incorporating a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the total distance without violating capacity constraints.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    from sklearn.cluster import KMeans\n\n    route_points = coords[fused_route[1:-1]]\n    k = min(3, len(route_points) // 2)\n    if k < 2:\n        return base_solution\n\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(route_points)\n    clusters = kmeans.labels_\n\n    segments = []\n    for cluster_id in range(k):\n        cluster_nodes = fused_route[1:-1][clusters == cluster_id]\n        if len(cluster_nodes) == 0:\n            continue\n\n        current_segment = [0]\n        current_demand = 0\n        demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n        for node in cluster_nodes:\n            current_segment.append(node)\n            current_demand += demand[node]\n\n            if current_demand > demand_threshold:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n                demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n        if len(current_segment) > 1:\n            segments.append(np.array(current_segment + [0]))\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n                current_demand = 0\n                demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n                for node in merged_segment[1:-1]:\n                    current_segment.append(node)\n                    current_demand += demand[node]\n\n                    if current_demand > demand_threshold:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n                        demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n                if len(current_segment) > 1:\n                    new_segments.append(np.array(current_segment + [0]))\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist * 0.95 and makespan <= original_makespan * 1.05) or (total_dist <= original_dist * 1.05 and makespan < original_makespan * 0.95):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n                    break\n\n    for route in new_solution:\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if demand[node] > capacity * 0.3:\n                for other_route in new_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    current_demand = sum(demand[n] for n in other_route[1:-1])\n                    if current_demand + demand[node] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[j-1]][node] +\n                                   distance_matrix[node][other_route[j]] -\n                                   distance_matrix[other_route[j-1]][other_route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        if best_cost < 0:\n                            new_route = np.insert(other_route, best_pos, node)\n                            other_route[:] = new_route\n                            route = np.delete(route, i)\n                            break\n\n    return new_solution\n\n",
          "score": [
               -0.8104112811508555,
               0.10684847831726074
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    from sklearn.cluster import KMeans\n\n    route_points = coords[fused_route[1:-1]]\n    k = min(3, len(route_points) // 2)\n    if k < 2:\n        return base_solution\n\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(route_points)\n    clusters = kmeans.labels_\n\n    segments = []\n    for cluster_id in range(k):\n        cluster_nodes = fused_route[1:-1][clusters == cluster_id]\n        if len(cluster_nodes) == 0:\n            continue\n\n        current_segment = [0]\n        current_demand = 0\n        demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n        for node in cluster_nodes:\n            current_segment.append(node)\n            current_demand += demand[node]\n\n            if current_demand > demand_threshold:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n                demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n        if len(current_segment) > 1:\n            segments.append(np.array(current_segment + [0]))\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n                current_demand = 0\n                demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n                for node in merged_segment[1:-1]:\n                    current_segment.append(node)\n                    current_demand += demand[node]\n\n                    if current_demand > demand_threshold:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n                        demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n                if len(current_segment) > 1:\n                    new_segments.append(np.array(current_segment + [0]))\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist * 0.95 and makespan <= original_makespan * 1.05) or (total_dist <= original_dist * 1.05 and makespan < original_makespan * 0.95):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n                    break\n\n    for route in new_solution:\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if demand[node] > capacity * 0.3:\n                for other_route in new_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    current_demand = sum(demand[n] for n in other_route[1:-1])\n                    if current_demand + demand[node] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[j-1]][node] +\n                                   distance_matrix[node][other_route[j]] -\n                                   distance_matrix[other_route[j-1]][other_route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        if best_cost < 0:\n                            new_route = np.insert(other_route, best_pos, node)\n                            other_route[:] = new_route\n                            route = np.delete(route, i)\n                            break\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, called \"Adaptive Demand Cluster Fusion and Spatial-Aware Splitting,\" first selects a solution from the archive by prioritizing those with high total distance and relatively balanced makespan, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-aware splitting mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and merging probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1] / x[1][0]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.5, 0.8)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n                current_demand = 0\n                demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n                for k in range(1, len(merged_segment) - 1):\n                    current_segment.append(merged_segment[k])\n                    current_demand += demand[merged_segment[k]]\n\n                    if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                        if current_demand <= capacity:\n                            segment_coords = coords[current_segment[1:-1]]\n                            segment_centroid = np.mean(segment_coords, axis=0)\n                            distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                            if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                                new_segments.append(np.array(current_segment + [0]))\n                                current_segment = [0]\n                                current_demand = 0\n                                demand_threshold = capacity * random.uniform(0.5, 0.8)\n                        else:\n                            last_node = current_segment.pop()\n                            current_demand -= demand[last_node]\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0, last_node]\n                            current_demand = demand[last_node]\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, called \"Adaptive Demand-Adjusted Route Fusion and Spatial-Constrained Splitting\" (ADARFS), first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, then applies a hybrid approach that first fuses routes with complementary demand patterns while respecting spatial constraints, followed by a demand-adjusted splitting phase that divides overloaded routes into segments with balanced demands and optimized spatial configurations, ensuring capacity constraints are met and both objectives are improved through a two-phase transformation process where demand-adjustment identifies optimal route groupings and spatial-constrained splitting ensures feasible and efficient route configurations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in base_solution]\n\n    demand_threshold = capacity * 0.6\n    complement_pairs = []\n\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            combined_demand = route_demands[i] + route_demands[j]\n            if combined_demand <= capacity * 1.2 and combined_demand >= demand_threshold:\n                complement_pairs.append((i, j))\n\n    if complement_pairs:\n        pair = random.choice(complement_pairs)\n        route1, route2 = base_solution[pair[0]], base_solution[pair[1]]\n\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [route for idx, route in enumerate(base_solution) if idx not in pair]\n            new_solution.append(merged_route)\n            base_solution = new_solution\n\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d > capacity * 0.8]\n\n    if overloaded_routes:\n        route_idx = random.choice(overloaded_routes)\n        route = base_solution[route_idx]\n        nodes = route[1:-1]\n\n        if len(nodes) > 2:\n            demand_sorted = sorted(nodes, key=lambda x: demand[x], reverse=True)\n            split_pos = len(nodes) // 2\n\n            segment1 = np.concatenate(([0], nodes[:split_pos], [0]))\n            segment2 = np.concatenate(([0], nodes[split_pos:], [0]))\n\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution = [route for idx, route in enumerate(base_solution) if idx != route_idx]\n                new_solution.extend([segment1, segment2])\n                base_solution = new_solution\n\n    return base_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": "{The new algorithm, called \"Dynamic Demand-Clustered Route Evolution with Spatial-Aware Balancing,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, then applies a novel hybrid approach that dynamically clusters routes based on demand patterns and spatial proximity, followed by an evolutionary process that evolves these clusters through adaptive merging, splitting, and rebalancing operations while respecting capacity constraints, and ensuring both objectives are improved through spatial-aware balancing that optimizes the distribution of customers across routes to create more compact and efficient configurations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    route_centroids = []\n    for route in base_solution:\n        route_nodes = route[1:-1]\n        if len(route_nodes) > 0:\n            route_coords = coords[route_nodes]\n            centroid = np.mean(route_coords, axis=0)\n            route_centroids.append(centroid)\n        else:\n            route_centroids.append(coords[0])\n\n    clusters = []\n    for i in range(len(base_solution)):\n        cluster = [i]\n        for j in range(len(base_solution)):\n            if i != j:\n                dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                if dist < np.mean([np.linalg.norm(c - route_centroids[i]) for c in route_centroids]) * 1.5:\n                    cluster.append(j)\n        clusters.append(cluster)\n\n    unique_clusters = []\n    for cluster in clusters:\n        cluster = list(set(cluster))\n        if cluster not in unique_clusters:\n            unique_clusters.append(cluster)\n\n    if len(unique_clusters) > 1:\n        selected_cluster = random.choice(unique_clusters)\n        if len(selected_cluster) > 1:\n            selected_routes = [base_solution[i] for i in selected_cluster]\n\n            merged_nodes = []\n            for route in selected_routes:\n                merged_nodes.extend(route[1:-1])\n            merged_nodes = list(set(merged_nodes))\n\n            if len(merged_nodes) > 0:\n                merged_route = np.concatenate(([0], merged_nodes, [0]))\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_cluster]\n                    new_solution.append(merged_route)\n\n                    split_pos = len(merged_nodes) // 2\n                    segment1 = np.concatenate(([0], merged_nodes[:split_pos], [0]))\n                    segment2 = np.concatenate(([0], merged_nodes[split_pos:], [0]))\n\n                    if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                        new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n                        new_solution.extend([segment1, segment2])\n\n                    return new_solution\n\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        nodes = route[1:-1]\n        if len(nodes) > 2:\n            demand_sorted = sorted(nodes, key=lambda x: demand[x], reverse=True)\n            split_pos = len(nodes) // 2\n\n            segment1 = np.concatenate(([0], nodes[:split_pos], [0]))\n            segment2 = np.concatenate(([0], nodes[split_pos:], [0]))\n\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution = [route for idx, route in enumerate(base_solution) if idx != i]\n                new_solution.extend([segment1, segment2])\n                return new_solution\n\n    return base_solution\n\n",
          "score": [
               -0.7413076909050318,
               4.889994233846664
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    route_centroids = []\n    for route in base_solution:\n        route_nodes = route[1:-1]\n        if len(route_nodes) > 0:\n            route_coords = coords[route_nodes]\n            centroid = np.mean(route_coords, axis=0)\n            route_centroids.append(centroid)\n        else:\n            route_centroids.append(coords[0])\n\n    clusters = []\n    for i in range(len(base_solution)):\n        cluster = [i]\n        for j in range(len(base_solution)):\n            if i != j:\n                dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                if dist < np.mean([np.linalg.norm(c - route_centroids[i]) for c in route_centroids]) * 1.5:\n                    cluster.append(j)\n        clusters.append(cluster)\n\n    unique_clusters = []\n    for cluster in clusters:\n        cluster = list(set(cluster))\n        if cluster not in unique_clusters:\n            unique_clusters.append(cluster)\n\n    if len(unique_clusters) > 1:\n        selected_cluster = random.choice(unique_clusters)\n        if len(selected_cluster) > 1:\n            selected_routes = [base_solution[i] for i in selected_cluster]\n\n            merged_nodes = []\n            for route in selected_routes:\n                merged_nodes.extend(route[1:-1])\n            merged_nodes = list(set(merged_nodes))\n\n            if len(merged_nodes) > 0:\n                merged_route = np.concatenate(([0], merged_nodes, [0]))\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_cluster]\n                    new_solution.append(merged_route)\n\n                    split_pos = len(merged_nodes) // 2\n                    segment1 = np.concatenate(([0], merged_nodes[:split_pos], [0]))\n                    segment2 = np.concatenate(([0], merged_nodes[split_pos:], [0]))\n\n                    if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                        new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n                        new_solution.extend([segment1, segment2])\n\n                    return new_solution\n\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        nodes = route[1:-1]\n        if len(nodes) > 2:\n            demand_sorted = sorted(nodes, key=lambda x: demand[x], reverse=True)\n            split_pos = len(nodes) // 2\n\n            segment1 = np.concatenate(([0], nodes[:split_pos], [0]))\n            segment2 = np.concatenate(([0], nodes[split_pos:], [0]))\n\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution = [route for idx, route in enumerate(base_solution) if idx != i]\n                new_solution.extend([segment1, segment2])\n                return new_solution\n\n    return base_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Multi-Objective Route Balancing with Spatial-Demand Synergy,\" first selects a solution from the archive by prioritizing those with high total distance but moderate makespan, indicating potential for improvement in both objectives, then dynamically partitions the solution into segments based on both spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by iteratively balancing the workload across vehicles using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"spatial-demand aware route splitting\" mechanism that splits routes when their spatial or demand imbalance exceeds predefined thresholds, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the splitting thresholds and acceptance probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-aware route merging\" step where compatible routes are merged if it reduces the makespan without violating capacity constraints, and a \"route optimization\" step where routes are optimized using a greedy insertion heuristic that considers both spatial proximity and demand compatibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    new_solution = []\n    route_indices = list(range(len(base_solution)))\n\n    while route_indices:\n        current_route_idx = random.choice(route_indices)\n        current_route = base_solution[current_route_idx]\n        route_indices.remove(current_route_idx)\n\n        if len(current_route) < 3:\n            new_solution.append(current_route)\n            continue\n\n        # Calculate spatial and demand metrics\n        route_customers = current_route[1:-1]\n        route_coords = coords[route_customers]\n        route_centroid = np.mean(route_coords, axis=0)\n        route_demand = sum(demand[node] for node in route_customers)\n\n        # Check for spatial imbalance\n        max_distance = max(np.linalg.norm(route_coords - route_centroid, axis=1))\n        avg_distance = np.mean(np.linalg.norm(route_coords - route_centroid, axis=1))\n        spatial_imbalance = max_distance / avg_distance if avg_distance > 0 else 0\n\n        # Check for demand imbalance\n        demand_imbalance = max(demand[node] for node in route_customers) / route_demand if route_demand > 0 else 0\n\n        # Decide whether to split or not\n        split_threshold = random.uniform(1.2, 1.5)\n        if spatial_imbalance > split_threshold or demand_imbalance > split_threshold:\n            # Split the route\n            split_pos = len(current_route) // 2\n            new_route1 = np.concatenate([current_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], current_route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(current_route)\n        else:\n            new_solution.append(current_route)\n\n    # Try to merge compatible routes\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate potential merged demand\n        merged_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if merged_demand <= capacity:\n            # Calculate spatial compatibility\n            route1_coords = coords[route1[1:-1]]\n            route2_coords = coords[route2[1:-1]]\n            route1_centroid = np.mean(route1_coords, axis=0)\n            route2_centroid = np.mean(route2_coords, axis=0)\n            centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n            # Calculate demand compatibility\n            route1_demand = sum(demand[node] for node in route1[1:-1])\n            route2_demand = sum(demand[node] for node in route2[1:-1])\n            demand_ratio = max(route1_demand, route2_demand) / min(route1_demand, route2_demand) if min(route1_demand, route2_demand) > 0 else 1\n\n            # Decide whether to merge\n            merge_probability = 0.7 if centroid_distance < np.mean(distance_matrix) and demand_ratio < 1.5 else 0.3\n\n            if random.random() < merge_probability:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                new_solution.append(merged_route)\n\n    # Optimize routes with greedy insertion\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        # Find the most remote customer\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        remote_customer_pos = np.argmax(distances) + 1  # +1 because we skip depot\n        remote_customer = route[remote_customer_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            if other_demand + demand[remote_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][remote_customer] +\n                           distance_matrix[remote_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Calculate current and potential makespan\n                current_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in new_solution\n                )\n\n                new_route = np.concatenate([other_route[:best_pos], [remote_customer], other_route[best_pos:]])\n                new_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in [new_route] + [r for idx, r in enumerate(new_solution) if idx != other_route_idx]\n                )\n\n                if new_makespan <= current_makespan * 1.1:  # Allow slight increase in makespan for better distance\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:remote_customer_pos], route[remote_customer_pos+1:]])\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel algorithm, called \"Adaptive Route Segmentation with Spatial and Demand-Aware Clustering,\" first selects a high-quality solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically partitions the solution into segments based on spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by greedily merging segments that optimize both objectives, using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware segment swapping\" mechanism that exchanges segments between routes while preserving capacity feasibility and potentially improving both objectives. The method combines adaptive segmentation, spatial-demand clustering, and hybrid objective-driven reconstruction to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Adaptive route segmentation\n    segments = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Split route into segments of approximately equal length\n            n_segments = max(2, len(route) // 4)\n            segment_length = len(route) // n_segments\n            for i in range(n_segments):\n                start = 1 + i * segment_length\n                end = min(start + segment_length, len(route) - 1)\n                segment = route[start:end]\n                segments.append(segment)\n\n    # Spatial and demand-aware clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    for segment in segments:\n        if len(segment) == 0:\n            continue\n\n        # Find segment center\n        segment_coords = coords[segment]\n        center = np.mean(segment_coords, axis=0)\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find closest cluster with available capacity\n        best_cluster = -1\n        min_dist = float('inf')\n        for i, (cluster_center, cluster_d) in enumerate(zip(cluster_centers, cluster_demands)):\n            if cluster_d + segment_demand <= capacity:\n                dist = np.linalg.norm(center - cluster_center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(segment)\n            cluster_demands[best_cluster] += segment_demand\n        else:\n            # Create new cluster\n            clusters.append([segment])\n            cluster_centers.append(center)\n            cluster_demands.append(segment_demand)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Combine all segments in cluster\n        all_nodes = []\n        for segment in cluster:\n            all_nodes.extend(segment)\n        remaining = set(all_nodes)\n\n        # Dynamic weight adjustment for hybrid objective\n        total_dist, makespan = archive_sorted[0][1]\n        weight_dist = 0.7 if makespan > 1.2 * total_dist else 0.3\n\n        # Greedy route construction\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Calculate hybrid cost\n                    last_node = current_route[-1]\n                    dist_cost = distance_matrix[last_node][node]\n                    span_cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n                    total_cost = weight_dist * dist_cost + (1 - weight_dist) * span_cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n    # Demand-aware segment swapping\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform a few swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find segments to swap\n            route1_nodes = set(route1[1:-1])\n            route2_nodes = set(route2[1:-1])\n\n            # Find compatible segments\n            for segment1 in [route1[1:-1], route1[1:-2], route1[2:-1]]:\n                segment1_demand = sum(demand[node] for node in segment1)\n                for segment2 in [route2[1:-1], route2[1:-2], route2[2:-1]]:\n                    segment2_demand = sum(demand[node] for node in segment2)\n\n                    # Check capacity constraints\n                    route1_demand = sum(demand[node] for node in route1[1:-1])\n                    route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                    if (route1_demand - segment1_demand + segment2_demand <= capacity and\n                        route2_demand - segment2_demand + segment1_demand <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], segment1), segment2, [0]])\n                        new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], segment2), segment1, [0]])\n\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 307,
          "algorithm": "{The novel algorithm, called \"Multi-Objective Route Evolution with Adaptive Spatial-Temporal Clustering,\" first selects a solution from the archive by prioritizing those with high makespan but moderate total distance, indicating potential for significant improvement in both objectives, then dynamically clusters customers based on both spatial proximity and temporal (demand-based) compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by iteratively evolving the solution through a combination of spatial-temporal clustering, adaptive route splitting based on both spatial dispersion and demand imbalance, and demand-aware route merging that considers both capacity and spatial proximity, while incorporating a novel \"objective-aware route evolution\" mechanism that alternates between improving distance and makespan objectives based on the current solution's characteristics. The method balances exploration and exploitation by dynamically adjusting the clustering parameters and evolution strategies based on the current solution quality, and incorporates a \"route diversification\" step where incompatible routes are intentionally split to escape local optima, followed by a \"route intensification\" step where compatible routes are aggressively merged to improve both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Spatial-temporal clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    # Initial clustering based on spatial proximity and demand compatibility\n    for customer in all_customers:\n        customer_coords = coords[customer]\n        customer_demand = demand[customer]\n\n        best_cluster = -1\n        min_dist = float('inf')\n\n        for i, (center, total_demand) in enumerate(zip(cluster_centers, cluster_demands)):\n            if total_demand + customer_demand <= capacity:\n                dist = np.linalg.norm(customer_coords - center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(customer)\n            cluster_centers[best_cluster] = (cluster_centers[best_cluster] * len(clusters[best_cluster]) + customer_coords) / (len(clusters[best_cluster]) + 1)\n            cluster_demands[best_cluster] += customer_demand\n        else:\n            clusters.append([customer])\n            cluster_centers.append(customer_coords)\n            cluster_demands.append(customer_demand)\n\n    # Route reconstruction with objective-aware evolution\n    new_solution = []\n    current_objective = 0  # 0 for distance, 1 for makespan\n\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        cluster_demand = sum(demand[node] for node in cluster)\n        remaining = set(cluster)\n\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    last_node = current_route[-1]\n\n                    if current_objective == 0:  # Focus on distance\n                        cost = distance_matrix[last_node][node]\n                    else:  # Focus on makespan\n                        cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n            current_objective = 1 - current_objective  # Alternate objectives\n\n    # Adaptive route splitting based on spatial dispersion and demand imbalance\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        max_distance = np.max(distances)\n        avg_distance = np.mean(distances)\n\n        route_demand = sum(demand[node] for node in route[1:-1])\n        max_demand = max(demand[node] for node in route[1:-1])\n\n        spatial_threshold = random.uniform(1.3, 1.7)\n        demand_threshold = random.uniform(1.5, 2.0)\n\n        if (max_distance > spatial_threshold * avg_distance or\n            max_demand > demand_threshold * (route_demand / len(route[1:-1]))):\n\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Demand-aware route merging with spatial proximity consideration\n    for _ in range(5):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        route1_demand = sum(demand[node] for node in route1[1:-1])\n        route2_demand = sum(demand[node] for node in route2[1:-1])\n\n        if route1_demand + route2_demand > capacity:\n            continue\n\n        route1_coords = coords[route1[1:-1]]\n        route2_coords = coords[route2[1:-1]]\n        route1_centroid = np.mean(route1_coords, axis=0)\n        route2_centroid = np.mean(route2_coords, axis=0)\n        centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n        avg_distance = np.mean(distance_matrix)\n\n        if centroid_distance < 1.5 * avg_distance:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Route diversification\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 5:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n        demand1 = sum(demand[node] for node in new_route1[1:-1])\n        demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7886284663979874,
               2.2560901641845703
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Spatial-temporal clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    # Initial clustering based on spatial proximity and demand compatibility\n    for customer in all_customers:\n        customer_coords = coords[customer]\n        customer_demand = demand[customer]\n\n        best_cluster = -1\n        min_dist = float('inf')\n\n        for i, (center, total_demand) in enumerate(zip(cluster_centers, cluster_demands)):\n            if total_demand + customer_demand <= capacity:\n                dist = np.linalg.norm(customer_coords - center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(customer)\n            cluster_centers[best_cluster] = (cluster_centers[best_cluster] * len(clusters[best_cluster]) + customer_coords) / (len(clusters[best_cluster]) + 1)\n            cluster_demands[best_cluster] += customer_demand\n        else:\n            clusters.append([customer])\n            cluster_centers.append(customer_coords)\n            cluster_demands.append(customer_demand)\n\n    # Route reconstruction with objective-aware evolution\n    new_solution = []\n    current_objective = 0  # 0 for distance, 1 for makespan\n\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        cluster_demand = sum(demand[node] for node in cluster)\n        remaining = set(cluster)\n\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    last_node = current_route[-1]\n\n                    if current_objective == 0:  # Focus on distance\n                        cost = distance_matrix[last_node][node]\n                    else:  # Focus on makespan\n                        cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n            current_objective = 1 - current_objective  # Alternate objectives\n\n    # Adaptive route splitting based on spatial dispersion and demand imbalance\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        max_distance = np.max(distances)\n        avg_distance = np.mean(distances)\n\n        route_demand = sum(demand[node] for node in route[1:-1])\n        max_demand = max(demand[node] for node in route[1:-1])\n\n        spatial_threshold = random.uniform(1.3, 1.7)\n        demand_threshold = random.uniform(1.5, 2.0)\n\n        if (max_distance > spatial_threshold * avg_distance or\n            max_demand > demand_threshold * (route_demand / len(route[1:-1]))):\n\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Demand-aware route merging with spatial proximity consideration\n    for _ in range(5):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        route1_demand = sum(demand[node] for node in route1[1:-1])\n        route2_demand = sum(demand[node] for node in route2[1:-1])\n\n        if route1_demand + route2_demand > capacity:\n            continue\n\n        route1_coords = coords[route1[1:-1]]\n        route2_coords = coords[route2[1:-1]]\n        route1_centroid = np.mean(route1_coords, axis=0)\n        route2_centroid = np.mean(route2_coords, axis=0)\n        centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n        avg_distance = np.mean(distance_matrix)\n\n        if centroid_distance < 1.5 * avg_distance:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Route diversification\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 5:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n        demand1 = sum(demand[node] for node in new_route1[1:-1])\n        demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n"
     }
]