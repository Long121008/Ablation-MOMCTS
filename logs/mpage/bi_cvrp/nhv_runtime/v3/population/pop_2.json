[
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Splitting with Demand-Aware Relocation,\" first selects a promising solution from the archive by prioritizing those with high total distance and relatively low makespan, indicating potential for improvement in balancing route lengths. It then randomly selects two routes from the solution, fuses them into a single path while ensuring capacity constraints are met, and strategically splits the fused route back into two segments by identifying a demand-aware split point that minimizes the increase in total distance while balancing route lengths. The method also incorporates a probabilistic demand-aware relocation step where high-demand nodes are relocated to different routes if it reduces the makespan without violating capacity constraints. This hybrid approach combines path fusion, demand-aware splitting, and relocation to explore the solution space more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select two routes to fuse\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = random.sample(range(len(selected_solution)), 2)\n    route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n    # Fuse the two routes\n    fused_route = np.concatenate((route1[:-1], route2[1:]))\n\n    # Check capacity constraint for the fused route\n    total_demand = np.sum(demand[fused_route[1:-1]])\n    if total_demand > capacity:\n        return selected_solution  # Return original if fusion is infeasible\n\n    # Find a demand-aware split point\n    best_split = None\n    min_increase = float('inf')\n\n    for i in range(1, len(fused_route) - 1):\n        # Split into two segments\n        segment1 = fused_route[:i+1]\n        segment2 = np.concatenate(([0], fused_route[i+1:]))\n\n        # Check capacity for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Calculate total distance increase\n            dist1 = np.sum(distance_matrix[segment1[:-1], segment1[1:]])\n            dist2 = np.sum(distance_matrix[segment2[:-1], segment2[1:]])\n            total_dist = dist1 + dist2\n\n            # Calculate original distance\n            original_dist = np.sum(distance_matrix[route1[:-1], route1[1:]]) + np.sum(distance_matrix[route2[:-1], route2[1:]])\n\n            increase = total_dist - original_dist\n            if increase < min_increase:\n                min_increase = increase\n                best_split = (segment1, segment2)\n\n    if best_split is not None:\n        # Replace the original routes with the split segments\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n        new_solution.extend(best_split)\n\n        # Optional: Demand-aware relocation step\n        for route in new_solution:\n            for i in range(1, len(route)-1):\n                node = route[i]\n                if demand[node] > capacity * 0.3:  # High demand node\n                    for other_route in new_solution:\n                        if np.array_equal(other_route, route):\n                            continue\n                        # Try inserting the node into another route\n                        for j in range(1, len(other_route)):\n                            # Check capacity\n                            if np.sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                                # Calculate new makespan\n                                new_route = np.insert(other_route, j, node)\n                                new_makespan = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                                original_makespan = np.sum(distance_matrix[other_route[:-1], other_route[1:]])\n\n                                if new_makespan < original_makespan:\n                                    # Perform the relocation\n                                    other_route[:] = new_route\n                                    route = np.delete(route, i)\n                                    break\n\n        return new_solution\n    else:\n        return selected_solution\n\n",
          "score": [
               -0.8441379680955634,
               0.12357181310653687
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Route Consolidation and Dispersal\" (ARCD), selects a solution from the archive by prioritizing those with high total distance and makespan, then applies a hybrid approach that first identifies the most capacity-critical routes and consolidates them by merging with nearby routes based on spatial proximity, followed by dispersing nodes from overloaded routes to underutilized routes using a demand-aware insertion strategy that minimizes the increase in total distance while balancing the makespan. This method differs from standard approaches by dynamically adapting to route characteristics and leveraging spatial and demand information to improve both objectives simultaneously through a two-phase transformation process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Identify capacity-critical routes (those closest to capacity)\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    critical_routes = [i for i, d in enumerate(route_demands) if d > 0.8 * capacity]\n\n    if not critical_routes:\n        return base_solution\n\n    # Select a critical route to consolidate\n    critical_idx = random.choice(critical_routes)\n    critical_route = base_solution[critical_idx]\n\n    # Find the nearest route to merge with\n    nearest_route_idx = None\n    min_distance = float('inf')\n    for i, route in enumerate(base_solution):\n        if i == critical_idx:\n            continue\n        # Calculate distance between last node of critical route and first node of other route\n        dist = distance_matrix[critical_route[-2]][route[1]]\n        if dist < min_distance:\n            min_distance = dist\n            nearest_route_idx = i\n\n    if nearest_route_idx is None:\n        return base_solution\n\n    # Merge critical route with nearest route\n    merged_route = np.concatenate((critical_route[:-1], base_solution[nearest_route_idx][1:]))\n\n    # Check if merged route exceeds capacity\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        # If it does, try to disperse nodes instead\n        # Find the most overloaded node in critical route\n        critical_nodes = critical_route[1:-1]\n        overloaded_nodes = [node for node in critical_nodes if demand[node] > 0.3 * capacity]\n\n        if overloaded_nodes:\n            # Try to insert into other routes\n            for node in overloaded_nodes:\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for i, route in enumerate(base_solution):\n                    if i == critical_idx:\n                        continue\n\n                    for pos in range(1, len(route)):\n                        temp_route = np.insert(route, pos, node)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = (distance_matrix[temp_route[pos-1]][node] +\n                                    distance_matrix[node][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = i\n                                best_pos = pos\n\n                if best_route is not None:\n                    # Perform the insertion\n                    new_route = np.insert(base_solution[best_route], best_pos, node)\n                    base_solution[best_route] = new_route\n                    # Remove the node from critical route\n                    critical_route = np.delete(critical_route, np.where(critical_route == node)[0][0])\n                    base_solution[critical_idx] = critical_route\n\n    else:\n        # Update the solution with the merged route\n        new_solution = [route for i, route in enumerate(base_solution)\n                       if i != critical_idx and i != nearest_route_idx]\n        new_solution.append(merged_route)\n        base_solution = new_solution\n\n    return base_solution\n\n",
          "score": [
               -0.8593646646770561,
               0.20235806703567505
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Route Merging and Segmented Reinsertion,\" first selects a solution from the archive by prioritizing those with high makespan and total distance, then randomly merges two routes into a single path while ensuring capacity constraints are met. It then strategically segments the merged route into multiple smaller segments using a demand-aware clustering approach that groups nodes based on spatial proximity and demand similarity, and reinserts these segments back into the solution as new routes. This method avoids standard 2-opt by incorporating a more holistic transformation of the solution structure, where the segmentation and reinsertion steps are guided by both spatial and demand-based criteria to balance route lengths and total distance more effectively. The algorithm also includes a probabilistic segment merging step where adjacent segments with similar demand patterns are merged if it reduces the makespan without violating capacity constraints, further enhancing the exploration of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_indices = random.sample(range(len(base_solution)), 2)\n    route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n    merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n\n    for i in range(1, len(merged_route) - 1):\n        current_segment.append(merged_route[i])\n        segment_demand = np.sum(demand[current_segment[1:]])\n        if segment_demand > capacity * 0.8 or i == len(merged_route) - 2:\n            if segment_demand <= capacity:\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0]\n            else:\n                last_node = current_segment.pop()\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in route_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n\n                for k in range(1, len(merged_segment) - 1):\n                    current_segment.append(merged_segment[k])\n                    segment_demand = np.sum(demand[current_segment[1:]])\n                    if segment_demand > capacity * 0.8 or k == len(merged_segment) - 2:\n                        if segment_demand <= capacity:\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                        else:\n                            last_node = current_segment.pop()\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0, last_node]\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan) or (total_dist <= original_dist and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    return new_solution\n\n",
          "score": [
               -0.7467283543413393,
               0.10716685652732849
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer relocation with capacity check\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to split or relocate\n        split_pos = random.randint(1, len(route)-2)\n        segment = route[split_pos:-1]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to relocate the segment to another route or create a new route\n        for j, other_route in enumerate(new_solution):\n            if i == j:\n                continue\n\n            # Check if relocating the segment to this route is feasible\n            other_route_demand = sum(demand[node] for node in other_route[1:-1])\n            if other_route_demand + segment_demand <= capacity:\n                # Find the best insertion position in the other route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[other_route[pos-1]][segment[0]] +\n                           distance_matrix[segment[-1]][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform relocation\n                new_solution[i] = np.concatenate([route[:split_pos], [0]])\n                new_solution[j] = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 2]\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.8441024349834282,
               0.7101049423217773
          ]
     },
     {
          "algorithm": "{The described algorithm, named \"Multi-Objective Route Fusion and Segment Reallocation (MRFSR)\", operates by first selecting a solution from the archive based on a weighted combination of its objectives, favoring those with lower makespan but also considering total distance to avoid premature convergence. It then applies a hybrid local search that combines three novel operators: 1) \"Route Fusion\" merges two routes by inserting a segment from one into another, ensuring capacity constraints are met, 2) \"Segment Reallocation\" moves a high-demand segment between routes to balance makespan, and 3) \"Cross-Route 2-opt*\" extends 2-opt by considering multiple nodes in a cross-route context to reduce total distance while maintaining feasibility. The algorithm intelligently selects the operator based on the current solution's characteristics, such as route imbalance or high total distance, and uses a feasibility-preserving mechanism for demand checks during segment moves.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.4, 0.6])  # More weight on makespan\n    normalized_scores = np.array([weights * np.array(obj) for _, obj in archive])\n    normalized_scores = normalized_scores / normalized_scores.max(axis=0)\n    scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Choose a local search operator based on solution characteristics\n    max_makespan = max([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    total_distance = sum([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n\n    # Operator selection probabilities\n    if max_makespan > total_distance * 0.6:  # If makespan is significantly larger than distance\n        operator = \"route_fusion\"\n    elif len(new_solution) > 3:  # If many routes exist\n        operator = \"segment_reallocation\"\n    else:\n        operator = \"cross_route_2opt\"\n\n    # Apply the selected operator\n    if operator == \"route_fusion\":\n        # Merge two routes by inserting a segment from one into another\n        if len(new_solution) >= 2:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route2) > 3:  # Ensure there's a segment to move\n                # Select a random segment from route2\n                start, end = sorted(random.sample(range(1, len(route2)-1), 2))\n                segment = route2[start:end+1]\n                segment_demand = sum(demand[node] for node in segment)\n\n                # Find insertion points in route1\n                for i in range(1, len(route1)):\n                    if sum(demand[node] for node in route1[1:i]) + segment_demand <= capacity:\n                        new_route = np.concatenate((route1[:i], segment, route1[i:]))\n                        new_solution[route1_idx] = new_route\n                        new_solution[route2_idx] = np.concatenate((route2[:start], route2[end+1:]))\n                        break\n\n    elif operator == \"segment_reallocation\":\n        # Move a high-demand segment between routes to balance makespan\n        if len(new_solution) >= 2:\n            # Find the route with the highest makespan\n            makespans = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            source_idx = np.argmax(makespans)\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            if len(source_route) > 3:\n                # Select a high-demand segment\n                segment_length = min(3, len(source_route)-2)\n                start = random.randint(1, len(source_route)-segment_length-1)\n                segment = source_route[start:start+segment_length]\n                segment_demand = sum(demand[node] for node in segment)\n\n                # Find insertion points in target route\n                target_route = new_solution[target_idx]\n                for i in range(1, len(target_route)):\n                    if sum(demand[node] for node in target_route[1:i]) + segment_demand <= capacity:\n                        new_target = np.concatenate((target_route[:i], segment, target_route[i:]))\n                        new_source = np.concatenate((source_route[:start], source_route[start+segment_length:]))\n                        new_solution[target_idx] = new_target\n                        new_solution[source_idx] = new_source\n                        break\n\n    elif operator == \"cross_route_2opt\":\n        # Extended 2-opt that considers multiple nodes in cross-route context\n        if len(new_solution) >= 2:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select two nodes from each route (excluding depots)\n                node1 = random.randint(1, len(route1)-2)\n                node2 = random.randint(1, len(route2)-2)\n\n                # Check capacity constraints\n                segment1 = route1[node1:]\n                segment2 = route2[node2:]\n                new_route1 = np.concatenate((route1[:node1], segment2))\n                new_route2 = np.concatenate((route2[:node2], segment1))\n\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure no empty routes are left\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8037892194016065,
               0.24140217900276184
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a solution from the archive based on a novel diversity-aware metric that combines objective values with spatial distribution of customers, then applying a hybrid local search operator that combines route merging with capacity-constrained node migration. The selection process prioritizes solutions that show good balance between objectives while considering spatial diversity, and the local search operator identifies the most promising route pairs for merging, then strategically migrates nodes between routes while respecting capacity constraints, with special attention to geographic proximity to minimize additional travel distance. The operator also includes a novel \"demand-balancing\" step that redistributes customers between routes to improve makespan while considering the spatial distribution of demands. The function returns the new feasible neighbor solution after applying these transformations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def diversity_metric(sol):\n        total_dist, makespan = sol[1]\n        # Calculate spatial diversity (average distance from depot)\n        diversity = 0\n        for route in sol[0]:\n            route_nodes = route[1:-1]  # exclude depots\n            if len(route_nodes) > 0:\n                avg_dist = np.mean([np.linalg.norm(coords[node] - coords[0]) for node in route_nodes])\n                diversity += avg_dist\n        diversity /= len(sol[0])\n        # Combine objectives with spatial diversity\n        return total_dist * 0.4 + makespan * 0.4 + diversity * 0.2\n\n    selected_solution = min(archive, key=diversity_metric)[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging with demand balancing\n    if len(new_solution) > 1:\n        # Select routes with the most similar makespans\n        makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        route1_idx = np.argmin(makespans)\n        route2_idx = np.argmax(makespans)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate current demands\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        # Find nodes to migrate to balance demands\n        target_demand = (demand1 + demand2) / 2\n        nodes_to_migrate = []\n        current_demand = demand1 if demand1 < target_demand else demand2\n\n        # Collect candidate nodes for migration\n        source_route = route1 if demand1 < target_demand else route2\n        for node in source_route[1:-1]:\n            if current_demand + demand[node] <= capacity:\n                nodes_to_migrate.append(node)\n                current_demand += demand[node]\n\n        # Migrate nodes to the other route\n        target_route = route2 if demand1 < target_demand else route1\n        migrated_nodes = []\n        for node in nodes_to_migrate:\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(target_route)):\n                cost = (distance_matrix[target_route[i-1]][node] +\n                        distance_matrix[node][target_route[i]] -\n                        distance_matrix[target_route[i-1]][target_route[i]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Insert node\n            target_route = np.insert(target_route, best_pos, node)\n            migrated_nodes.append(node)\n\n        # Remove migrated nodes from source route\n        source_route = source_route[1:-1]\n        source_route = source_route[~np.isin(source_route, migrated_nodes)]\n        source_route = np.concatenate([[0], source_route, [0]])\n\n        # Update solution\n        new_solution[route1_idx] = source_route if demand1 < target_demand else target_route\n        new_solution[route2_idx] = target_route if demand1 < target_demand else source_route\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8455701807191196,
               4.533470541238785
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a promising solution from the archive by prioritizing those with lower total distance and makespan, then applying a hybrid local search strategy that combines route fragmentation and reinsertion with a novel \"capacity-aware route merging\" step. This involves randomly selecting a subset of routes from the selected solution, breaking them into segments, and reinserting these segments into other routes while ensuring capacity constraints are met, followed by merging routes that share common customers to reduce the number of vehicles and improve makespan. The algorithm also includes a probabilistic acceptance criterion based on the solution's objective values to balance exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation and reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Ensure we can split the route\n            split_pos = random.randint(1, len(route) - 2)\n            segment = route[split_pos:-1]  # Exclude the depot at the end\n            remaining_route = np.concatenate([route[:split_pos], [0]])\n\n            # Update the original route\n            new_solution[route_idx] = remaining_route\n\n            # Try to reinsert the segment into another route\n            for i in range(len(new_solution)):\n                if i != route_idx:\n                    test_route = np.concatenate([new_solution[i][:-1], segment, [0]])\n                    if np.sum(demand[test_route[1:-1]]) <= capacity:\n                        new_solution[i] = test_route\n                        break\n\n        # Step 2: Capacity-aware route merging\n        if len(new_solution) > 1:\n            # Randomly select two routes for potential merging\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Create new solution with merged route\n                temp_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                temp_solution.append(merged_route)\n\n                # Check if the merged solution is better (simplified criterion)\n                if len(temp_solution) < len(new_solution):\n                    new_solution = temp_solution\n\n    # Ensure the solution is feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.4467128582861687,
               0.11891692876815796
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves a hybrid local search strategy that combines a novel \"route-splitting and merging\" operator with a demand-aware insertion heuristic. First, it intelligently selects a solution from the archive by prioritizing those with high total distance but relatively low makespan, as these often contain long routes that can be improved by splitting into shorter, more balanced ones. The algorithm then identifies the longest route in the selected solution and attempts to split it into two feasible sub-routes by finding a high-demand node that can serve as a split point, ensuring neither sub-route exceeds vehicle capacity. If splitting fails due to capacity constraints, it applies a demand-aware insertion heuristic to redistribute nodes between routes by considering both demand and distance, prioritizing nodes with high demand to prevent future capacity violations. The neighbor solution is then constructed by either the split routes or the reinserted nodes, ensuring feasibility and potentially improving both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Find the longest route in the selected solution\n    longest_route = max(selected, key=lambda route: distance_matrix[route[:-1], route[1:]].sum())\n\n    # Try to split the longest route\n    new_solution = selected.copy()\n    split_success = False\n\n    # Find a candidate split point (high demand node that can split the route)\n    for i in range(1, len(longest_route) - 1):\n        node = longest_route[i]\n        if demand[node] > capacity / 2:  # High demand node\n            # Check if splitting at this node is feasible\n            route1 = longest_route[:i+1]\n            route2 = longest_route[i:]\n            if (demand[route1[1:-1]].sum() <= capacity and\n                demand[route2[1:-1]].sum() <= capacity):\n                # Replace the original route with the two new routes\n                new_solution = [r for r in new_solution if not np.array_equal(r, longest_route)]\n                new_solution.extend([route1, route2])\n                split_success = True\n                break\n\n    # If splitting failed, try demand-aware insertion\n    if not split_success:\n        # Find the route with the most excess capacity\n        routes_with_capacity = [(route, capacity - demand[route[1:-1]].sum())\n                               for route in new_solution]\n        routes_with_capacity.sort(key=lambda x: x[1], reverse=True)\n\n        # Try to move nodes from the longest route to other routes\n        for node in longest_route[1:-1]:\n            for route, excess in routes_with_capacity:\n                if excess >= demand[node]:\n                    # Find the best insertion position in the target route\n                    min_insert_cost = float('inf')\n                    best_pos = -1\n                    for i in range(1, len(route)):\n                        cost = (distance_matrix[route[i-1], node] +\n                               distance_matrix[node, route[i]] -\n                               distance_matrix[route[i-1], route[i]])\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_pos = i\n                    if best_pos != -1:\n                        # Insert the node and update the route\n                        new_route = np.insert(route, best_pos, node)\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                        new_solution.append(new_route)\n                        # Remove the node from the original route\n                        original_route = [r for r in selected if np.array_equal(r, longest_route)][0]\n                        new_solution = [r for r in new_solution if not np.array_equal(r, original_route)]\n                        new_solution.append(np.delete(original_route, np.where(original_route == node)))\n                        break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.6774461242311831,
               0.2328459918498993
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution first selects a solution from the archive by prioritizing those with lower makespan and then applies a novel \"route reshuffling and insertion\" strategy. This involves randomly selecting a customer from one route and temporarily removing it, followed by an intelligent insertion into another route while considering both capacity constraints and the potential to balance route lengths. The algorithm also includes a \"route reversal\" step where entire routes are reversed to explore different customer sequences, and a \"customer swapping\" step where customers between routes are swapped if it reduces the total distance and maintains feasibility. The method balances exploration and exploitation by probabilistically accepting moves that improve the makespan or total distance, while ensuring all generated solutions remain feasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route reshuffling and insertion\n    if len(new_solution) > 1:\n        # Select a random customer from a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can remove a customer\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove the customer from the route\n            new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Try to insert the customer into another route\n            for i in range(len(new_solution)):\n                if i != route_idx:\n                    other_route = new_solution[i]\n                    current_demand = sum(demand[node] for node in other_route[1:-1])\n                    if current_demand + demand[customer] <= capacity:\n                        # Find the best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1]][customer] +\n                                   distance_matrix[customer][other_route[pos]] -\n                                   distance_matrix[other_route[pos-1]][other_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Insert the customer\n                        new_solution[i] = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                        break\n\n    # Route reversal\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            reversed_route = np.concatenate([[0], route[-2:0:-1], [0]])\n            new_solution[route_idx] = reversed_route\n\n    # Customer swapping between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            # Check capacity constraints\n            route1_demand = sum(demand[node] for node in route1[1:-1])\n            route2_demand = sum(demand[node] for node in route2[1:-1])\n\n            if (route1_demand - demand[cust1] + demand[cust2] <= capacity and\n                route2_demand - demand[cust2] + demand[cust1] <= capacity):\n\n                # Calculate cost difference\n                original_cost = (distance_matrix[route1[cust1_pos-1]][cust1] +\n                                distance_matrix[cust1][route1[cust1_pos+1]] +\n                                distance_matrix[route2[cust2_pos-1]][cust2] +\n                                distance_matrix[cust2][route2[cust2_pos+1]])\n\n                new_cost = (distance_matrix[route1[cust1_pos-1]][cust2] +\n                            distance_matrix[cust2][route1[cust1_pos+1]] +\n                            distance_matrix[route2[cust2_pos-1]][cust1] +\n                            distance_matrix[cust1][route2[cust2_pos+1]])\n\n                if new_cost < original_cost:\n                    # Perform swap\n                    route1[cust1_pos] = cust2\n                    route2[cust2_pos] = cust1\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.618175997110275,
               0.14754429459571838
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a promising solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route segment reversal and customer insertion, where it randomly selects a segment from a route, reverses it to potentially reduce distance or makespan, and inserts a randomly chosen customer into the most feasible position while ensuring capacity constraints are met. The algorithm also considers partial route swaps between different vehicles to further optimize both objectives, ensuring feasibility by validating demand constraints after each modification.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = random.choice(archive[:max(1, len(archive) // 3)])  # Prefer top 1/3 solutions\n    base_solution = [route.copy() for route in selected_solution[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment reversal and customer insertion\n    if len(new_solution) >= 2:  # Need at least two routes to perform swaps\n        # Randomly select a route and a segment to reverse\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot + 2 customers + depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n            # Check if the reversed segment is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    # Randomly select a customer to insert into another route\n    if len(new_solution) >= 2:\n        # Select a random route and a random customer from it\n        src_route_idx = random.randint(0, len(new_solution) - 1)\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 2:  # At least one customer\n            customer_pos = random.randint(1, len(src_route) - 2)\n            customer = src_route[customer_pos]\n\n            # Try to insert into another route\n            for _ in range(5):  # Try up to 5 times to find a feasible insertion\n                dest_route_idx = random.randint(0, len(new_solution) - 1)\n                if dest_route_idx == src_route_idx:\n                    continue\n\n                dest_route = new_solution[dest_route_idx]\n                if np.sum(demand[dest_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position in the destination route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(dest_route)):\n                    # Calculate the increase in distance\n                    prev_node = dest_route[pos - 1]\n                    next_node = dest_route[pos]\n                    increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Insert the customer\n                new_dest_route = np.concatenate([dest_route[:best_pos], [customer], dest_route[best_pos:]])\n                new_solution[dest_route_idx] = new_dest_route\n                new_src_route = np.concatenate([src_route[:customer_pos], src_route[customer_pos + 1:]])\n                new_solution[src_route_idx] = new_src_route\n                break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If a route is infeasible, revert to the original solution\n            return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.609204529898868,
               0.17037931084632874
          ]
     }
]