[
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution first selects a solution from the archive by prioritizing those with lower total distance, then applies a novel \"route merging and segment relocation\" strategy. This involves randomly selecting two routes, merging them into a single route while respecting capacity constraints, and then intelligently relocating segments between routes to balance the makespan and total distance. The algorithm also includes a \"route decomposition\" step where long routes are split into smaller segments that are redistributed to other routes, and a \"customer redistribution\" step where customers are redistributed across routes based on their spatial proximity to route centers, all while ensuring feasibility and potentially improving both objectives. The method balances exploration and exploitation by probabilistically accepting moves that improve either objective, while ensuring all generated solutions remain feasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging and segment relocation\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging routes is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Relocate segments to balance routes\n            if len(merged_route) > 5:  # Only relocate if route is long enough\n                for _ in range(2):  # Try a few segment relocations\n                    split_pos = random.randint(2, len(merged_route)-3)\n                    segment = merged_route[split_pos:-1]\n                    segment_demand = sum(demand[node] for node in segment)\n\n                    # Create a new route with the segment\n                    new_route = np.concatenate([[0], segment, [0]])\n                    if segment_demand <= capacity:\n                        new_solution.append(new_route)\n                        new_solution[route1_idx] = np.concatenate([merged_route[:split_pos], [0]])\n\n                        # Remove empty routes\n                        new_solution = [r for r in new_solution if len(r) > 2]\n                        break\n\n    # Route decomposition\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 6:  # Only decompose long routes\n            split_pos1 = random.randint(2, len(route)-4)\n            split_pos2 = random.randint(split_pos1+1, len(route)-2)\n\n            segment1 = route[:split_pos1+1]\n            segment2 = route[split_pos1:split_pos2+1]\n            segment3 = route[split_pos2:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in segment1[1:-1])\n            demand2 = sum(demand[node] for node in segment2[1:-1])\n            demand3 = sum(demand[node] for node in segment3[1:-1])\n\n            if all(d <= capacity for d in [demand1, demand2, demand3]):\n                # Replace original route with three new routes\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                new_solution.insert(route_idx+2, segment3)\n\n    # Customer redistribution based on spatial proximity\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find route center\n            route_nodes = route[1:-1]\n            route_center = np.mean(coords[route_nodes], axis=0)\n\n            # Find closest customer to route center\n            distances_to_center = np.linalg.norm(coords[route_nodes] - route_center, axis=1)\n            closest_customer = route_nodes[np.argmin(distances_to_center)]\n\n            # Try to relocate closest customer to another route\n            for i, other_route in enumerate(new_solution):\n                if i != route_idx:\n                    current_demand = sum(demand[node] for node in other_route[1:-1])\n                    if current_demand + demand[closest_customer] <= capacity:\n                        # Find best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                                   distance_matrix[closest_customer][other_route[pos]] -\n                                   distance_matrix[other_route[pos-1]][other_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform relocation\n                        new_solution[i] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                        new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                                route[np.where(route == closest_customer)[0][0]+1:]])\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7503442659201316,
               0.090950608253479
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Adaptive Route Segmentation with Spatial and Demand-Aware Clustering,\" first selects a high-quality solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically partitions the solution into segments based on spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by greedily merging segments that optimize both objectives, using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware segment swapping\" mechanism that exchanges segments between routes while preserving capacity feasibility and potentially improving both objectives. The method combines adaptive segmentation, spatial-demand clustering, and hybrid objective-driven reconstruction to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Adaptive route segmentation\n    segments = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Split route into segments of approximately equal length\n            n_segments = max(2, len(route) // 4)\n            segment_length = len(route) // n_segments\n            for i in range(n_segments):\n                start = 1 + i * segment_length\n                end = min(start + segment_length, len(route) - 1)\n                segment = route[start:end]\n                segments.append(segment)\n\n    # Spatial and demand-aware clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    for segment in segments:\n        if len(segment) == 0:\n            continue\n\n        # Find segment center\n        segment_coords = coords[segment]\n        center = np.mean(segment_coords, axis=0)\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find closest cluster with available capacity\n        best_cluster = -1\n        min_dist = float('inf')\n        for i, (cluster_center, cluster_d) in enumerate(zip(cluster_centers, cluster_demands)):\n            if cluster_d + segment_demand <= capacity:\n                dist = np.linalg.norm(center - cluster_center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(segment)\n            cluster_demands[best_cluster] += segment_demand\n        else:\n            # Create new cluster\n            clusters.append([segment])\n            cluster_centers.append(center)\n            cluster_demands.append(segment_demand)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Combine all segments in cluster\n        all_nodes = []\n        for segment in cluster:\n            all_nodes.extend(segment)\n        remaining = set(all_nodes)\n\n        # Dynamic weight adjustment for hybrid objective\n        total_dist, makespan = archive_sorted[0][1]\n        weight_dist = 0.7 if makespan > 1.2 * total_dist else 0.3\n\n        # Greedy route construction\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Calculate hybrid cost\n                    last_node = current_route[-1]\n                    dist_cost = distance_matrix[last_node][node]\n                    span_cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n                    total_cost = weight_dist * dist_cost + (1 - weight_dist) * span_cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n    # Demand-aware segment swapping\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform a few swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find segments to swap\n            route1_nodes = set(route1[1:-1])\n            route2_nodes = set(route2[1:-1])\n\n            # Find compatible segments\n            for segment1 in [route1[1:-1], route1[1:-2], route1[2:-1]]:\n                segment1_demand = sum(demand[node] for node in segment1)\n                for segment2 in [route2[1:-1], route2[1:-2], route2[2:-1]]:\n                    segment2_demand = sum(demand[node] for node in segment2)\n\n                    # Check capacity constraints\n                    route1_demand = sum(demand[node] for node in route1[1:-1])\n                    route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                    if (route1_demand - segment1_demand + segment2_demand <= capacity and\n                        route2_demand - segment2_demand + segment1_demand <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], segment1), segment2, [0]])\n                        new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], segment2), segment1, [0]])\n\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.9054799063755163,
               2.908462554216385
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Demand Cluster Fusion and Spatial-Aware Splitting,\" first selects a solution from the archive by prioritizing those with high total distance and relatively balanced makespan, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-aware splitting mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and merging probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1] / x[1][0]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.5, 0.8)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n                current_demand = 0\n                demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n                for k in range(1, len(merged_segment) - 1):\n                    current_segment.append(merged_segment[k])\n                    current_demand += demand[merged_segment[k]]\n\n                    if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                        if current_demand <= capacity:\n                            segment_coords = coords[current_segment[1:-1]]\n                            segment_centroid = np.mean(segment_coords, axis=0)\n                            distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                            if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                                new_segments.append(np.array(current_segment + [0]))\n                                current_segment = [0]\n                                current_demand = 0\n                                demand_threshold = capacity * random.uniform(0.5, 0.8)\n                        else:\n                            last_node = current_segment.pop()\n                            current_demand -= demand[last_node]\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0, last_node]\n                            current_demand = demand[last_node]\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8590109894069807,
               0.10349655151367188
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Route Merging with Demand-Balanced Splitting,\" first selects a solution from the archive based on a multi-criteria ranking that considers both objective values and solution structure, then adaptively merges multiple routes into a single path while maintaining capacity constraints, and strategically splits this merged route into multiple segments using a demand-balanced approach that minimizes both the total distance increase and the variance in route lengths, followed by an optional demand-aware relocation step that intelligently redistributes high-demand nodes across routes to further balance the solution's objectives without violating capacity constraints. This hybrid approach combines adaptive merging, demand-balanced splitting, and intelligent relocation to explore the solution space more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / (x[1][1] + 1), -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Adaptive route merging\n    merge_indices = random.sample(range(len(selected_solution)), min(3, len(selected_solution)))\n    merged_routes = selected_solution[merge_indices[0]].copy()\n\n    for idx in merge_indices[1:]:\n        merged_routes = np.concatenate((merged_routes[:-1], selected_solution[idx][1:]))\n\n    total_demand = sum(demand[node] for node in merged_routes[1:-1])\n    if total_demand > capacity:\n        return selected_solution\n\n    # Demand-balanced splitting\n    split_points = []\n    current_demand = 0\n    target_load = total_demand / (len(merge_indices) + 1)\n\n    for i in range(1, len(merged_routes)-1):\n        current_demand += demand[merged_routes[i]]\n        if abs(current_demand - target_load) < target_load * 0.2:\n            split_points.append(i)\n            current_demand = 0\n\n    if not split_points:\n        return selected_solution\n\n    # Create new routes from splits\n    new_routes = []\n    prev = 0\n    for point in split_points:\n        new_route = np.concatenate(([0], merged_routes[prev+1:point+1], [0]))\n        if len(new_route) > 2:\n            new_routes.append(new_route)\n        prev = point\n\n    if len(merged_routes) > prev + 1:\n        new_route = np.concatenate(([0], merged_routes[prev+1:-1], [0]))\n        if len(new_route) > 2:\n            new_routes.append(new_route)\n\n    # Remove original merged routes\n    new_solution = [route for i, route in enumerate(selected_solution) if i not in merge_indices]\n    new_solution.extend(new_routes)\n\n    # Demand-aware relocation\n    for route in new_solution:\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if demand[node] > capacity * 0.25:  # Relocate high-demand nodes\n                for other_route in new_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    current_demand = sum(demand[n] for n in other_route[1:-1])\n                    if current_demand + demand[node] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[j-1]][node] +\n                                   distance_matrix[node][other_route[j]] -\n                                   distance_matrix[other_route[j-1]][other_route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        if best_cost < 0:  # Only relocate if improves distance\n                            new_route = np.insert(other_route, best_pos, node)\n                            other_route[:] = new_route\n                            route = np.delete(route, i)\n                            break\n\n    return new_solution\n\n",
          "score": [
               -0.8648558587369714,
               0.10906502604484558
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Adaptive Route Partitioning with Spatial-Demand Clustering and Multi-Objective Balancing,\" first selects a solution from the archive by prioritizing those with balanced objectives, then partitions the solution into spatial-demand clusters using a k-means++ inspired approach that considers both geographic proximity and demand compatibility, while maintaining capacity constraints. It then reconstructs routes by iteratively merging clusters that optimize a hybrid objective function, which dynamically balances distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware route inversion\" mechanism that reverses segments of routes when it improves both objectives, while preserving capacity feasibility. The method combines adaptive partitioning, spatial-demand clustering, hybrid objective-driven reconstruction, and intelligent route inversion to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Spatial-demand clustering using k-means++\n    def kmeans_plus_plus(coords, demand, k, capacity):\n        centers = []\n        demands = []\n        remaining = set(all_customers)\n\n        # Initialize first center\n        first_center = random.choice(all_customers)\n        centers.append(first_center)\n        demands.append(demand[first_center])\n        remaining.remove(first_center)\n\n        # Initialize remaining centers\n        for _ in range(1, k):\n            max_dist = -1\n            best_node = None\n\n            for node in remaining:\n                min_dist = min(distance_matrix[node][center] for center in centers)\n                if min_dist > max_dist:\n                    max_dist = min_dist\n                    best_node = node\n\n            if best_node is not None:\n                centers.append(best_node)\n                demands.append(demand[best_node])\n                remaining.remove(best_node)\n            else:\n                break\n\n        # Assign nodes to clusters\n        clusters = [[] for _ in range(len(centers))]\n        cluster_demands = demands.copy()\n\n        for node in all_customers:\n            if node in centers:\n                idx = centers.index(node)\n                clusters[idx].append(node)\n            else:\n                best_cluster = -1\n                min_dist = float('inf')\n\n                for i, center in enumerate(centers):\n                    if cluster_demands[i] + demand[node] <= capacity:\n                        dist = distance_matrix[node][center]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_cluster = i\n\n                if best_cluster != -1:\n                    clusters[best_cluster].append(node)\n                    cluster_demands[best_cluster] += demand[node]\n\n        return clusters\n\n    # Determine number of clusters (between 2 and 4)\n    k = min(max(2, len(base_solution) // 2), 4)\n    clusters = kmeans_plus_plus(coords, demand, k, capacity)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Sort nodes in cluster by distance to depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Greedy route construction\n        current_route = [0]\n        current_demand = 0.0\n        remaining = cluster_sorted.copy()\n\n        while remaining:\n            best_node = None\n            best_cost = float('inf')\n\n            for node in remaining:\n                if current_demand + demand[node] > capacity:\n                    continue\n\n                # Calculate hybrid cost (balance between distance and makespan)\n                last_node = current_route[-1]\n                dist_cost = distance_matrix[last_node][node]\n                span_cost = distance_matrix[node][0]  # Return to depot\n                total_cost = 0.5 * dist_cost + 0.5 * span_cost\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_node = node\n\n            if best_node is not None:\n                current_route.append(best_node)\n                current_demand += demand[best_node]\n                remaining.remove(best_node)\n            else:\n                break\n\n        current_route.append(0)\n        if len(current_route) > 2:\n            new_solution.append(np.array(current_route))\n\n    # Demand-aware route inversion\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if inversion improves both objectives\n                original_dist = (distance_matrix[route[i-1]][route[i]] +\n                                distance_matrix[route[j]][route[j+1]])\n                inverted_dist = (distance_matrix[route[i-1]][route[j]] +\n                                distance_matrix[route[i]][route[j+1]])\n\n                if inverted_dist < original_dist:\n                    # Check capacity constraints\n                    segment_demand = sum(demand[node] for node in route[i:j+1])\n                    if segment_demand <= capacity:\n                        # Perform inversion\n                        route[i:j+1] = route[j:i-1:-1]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.873617345618189,
               1.4678039252758026
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Demand-Adjusted Route Fusion and Spatial-Constrained Splitting\" (ADARFS), first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, then applies a hybrid approach that first fuses routes with complementary demand patterns while respecting spatial constraints, followed by a demand-adjusted splitting phase that divides overloaded routes into segments with balanced demands and optimized spatial configurations, ensuring capacity constraints are met and both objectives are improved through a two-phase transformation process where demand-adjustment identifies optimal route groupings and spatial-constrained splitting ensures feasible and efficient route configurations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in base_solution]\n\n    demand_threshold = capacity * 0.6\n    complement_pairs = []\n\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            combined_demand = route_demands[i] + route_demands[j]\n            if combined_demand <= capacity * 1.2 and combined_demand >= demand_threshold:\n                complement_pairs.append((i, j))\n\n    if complement_pairs:\n        pair = random.choice(complement_pairs)\n        route1, route2 = base_solution[pair[0]], base_solution[pair[1]]\n\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [route for idx, route in enumerate(base_solution) if idx not in pair]\n            new_solution.append(merged_route)\n            base_solution = new_solution\n\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d > capacity * 0.8]\n\n    if overloaded_routes:\n        route_idx = random.choice(overloaded_routes)\n        route = base_solution[route_idx]\n        nodes = route[1:-1]\n\n        if len(nodes) > 2:\n            demand_sorted = sorted(nodes, key=lambda x: demand[x], reverse=True)\n            split_pos = len(nodes) // 2\n\n            segment1 = np.concatenate(([0], nodes[:split_pos], [0]))\n            segment2 = np.concatenate(([0], nodes[split_pos:], [0]))\n\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution = [route for idx, route in enumerate(base_solution) if idx != route_idx]\n                new_solution.extend([segment1, segment2])\n                base_solution = new_solution\n\n    return base_solution\n\n",
          "score": [
               -0.8681747393147738,
               0.3164099454879761
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Dynamic Route Fusion with Adaptive Demand Clustering and Spatial-Weighted Insertion,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a demand-aware clustering mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a spatial-weighted insertion step where customers are inserted into routes based on their demand and proximity to route centroids, weighted by their spatial distribution, and a \"route balancing\" step where routes are adjusted to balance the workload across vehicles while maintaining spatial coherence. Additionally, it includes a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and merging probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.4, 0.7)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.4, 0.7)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        spatial_weights = 1 / (1 + distances_to_centroid)\n        demand_weights = 1 / (1 + demand[customers])\n        combined_weights = spatial_weights * demand_weights\n        sorted_indices = np.argsort(-combined_weights)\n        selected_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[selected_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][selected_customer] +\n                           distance_matrix[selected_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [selected_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == selected_customer)[0][0]],\n                                                        route[np.where(route == selected_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7286947835915425,
               0.10348764061927795
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Route Partitioning and Demand-Balanced Insertion,\" first selects a solution from the archive by prioritizing those with high total distance and moderate makespan, then partitions the longest route into smaller segments using a demand-balanced clustering approach that groups nodes based on both spatial proximity and demand similarity, while ensuring capacity constraints are met. It then strategically reinserts these segments into the solution as new routes, using a probabilistic insertion mechanism that considers both the spatial distribution and demand distribution of the nodes, to optimize both the total distance and makespan. The algorithm also includes an adaptive segment merging step where adjacent segments with complementary demand patterns are merged if it improves both objectives, further enhancing the exploration of the solution space while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 1:\n        return base_solution\n\n    longest_route = max(base_solution, key=lambda r: len(r))\n    route_nodes = longest_route[1:-1]\n\n    if len(route_nodes) < 2:\n        return base_solution\n\n    demand_threshold = capacity * 0.7\n    high_demand_nodes = [node for node in route_nodes if demand[node] > demand_threshold]\n    low_demand_nodes = [node for node in route_nodes if demand[node] <= demand_threshold]\n\n    segments = []\n    current_segment = [0]\n\n    for node in route_nodes:\n        current_segment.append(node)\n        if len(current_segment) > 1 and (node in high_demand_nodes or random.random() < 0.3):\n            segment_demand = np.sum(demand[current_segment[1:]])\n            if segment_demand <= capacity:\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0]\n            else:\n                last_node = current_segment.pop()\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n\n    if len(current_segment) > 1:\n        segments.append(np.array(current_segment + [0]))\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for route in base_solution if not np.array_equal(route, longest_route)]\n\n    for segment in segments:\n        if len(segment) > 2:\n            segment_demand = np.sum(demand[segment[1:-1]])\n            if segment_demand <= capacity:\n                new_solution.append(segment)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity * 0.9:\n                temp_segments = []\n                current_temp = [0]\n\n                for node in merged_segment[1:-1]:\n                    current_temp.append(node)\n                    if random.random() < 0.4:\n                        temp_demand = np.sum(demand[current_temp[1:]])\n                        if temp_demand <= capacity:\n                            temp_segments.append(np.array(current_temp + [0]))\n                            current_temp = [0]\n                        else:\n                            last_node = current_temp.pop()\n                            temp_segments.append(np.array(current_temp + [0]))\n                            current_temp = [0, last_node]\n\n                if len(current_temp) > 1:\n                    temp_segments.append(np.array(current_temp + [0]))\n\n                if len(temp_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in temp_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan) or (total_dist <= original_dist and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(temp_segments)\n\n    return new_solution\n\n",
          "score": [
               -0.8679364343806394,
               3.8128295242786407
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Spatial-Demand Hybrid Clustering and Rebalancing\" (SDHCR), selects a solution from the archive by prioritizing those with high total distance and makespan, then applies a hybrid approach that first clusters routes based on both spatial proximity and demand similarity, followed by a rebalancing phase that redistributes nodes between clusters to minimize the makespan while ensuring capacity constraints are met. This method differs from standard approaches by dynamically adapting to route characteristics and leveraging both spatial and demand information to improve both objectives simultaneously through a two-phase transformation process, where spatial clustering identifies natural groupings of routes and demand-aware rebalancing ensures load balance across the solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Spatial-Demand Hybrid Clustering\n    route_centroids = []\n    route_demands = []\n\n    for route in base_solution:\n        nodes = route[1:-1]\n        if len(nodes) == 0:\n            continue\n        centroid = np.mean(coords[nodes], axis=0)\n        total_demand = np.sum(demand[nodes])\n        route_centroids.append(centroid)\n        route_demands.append(total_demand)\n\n    if len(route_centroids) < 2:\n        return base_solution\n\n    # Find two most dissimilar routes (spatial + demand)\n    max_dissimilarity = -1\n    pair = (0, 1)\n\n    for i in range(len(route_centroids)):\n        for j in range(i+1, len(route_centroids)):\n            spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n            demand_diff = abs(route_demands[i] - route_demands[j])\n            dissimilarity = spatial_dist * demand_diff\n            if dissimilarity > max_dissimilarity:\n                max_dissimilarity = dissimilarity\n                pair = (i, j)\n\n    route1_idx, route2_idx = pair\n    route1 = base_solution[route1_idx]\n    route2 = base_solution[route2_idx]\n\n    # Attempt to merge the two most dissimilar routes\n    merged_route = np.concatenate((route1[:-1], route2[1:]))\n    if np.sum(demand[merged_route[1:-1]]) <= capacity:\n        new_solution = [route for i, route in enumerate(base_solution) if i != route1_idx and i != route2_idx]\n        new_solution.append(merged_route)\n        base_solution = new_solution\n\n    # Demand-Aware Rebalancing\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in base_solution]\n    avg_length = np.mean(route_lengths)\n    long_routes = [i for i, length in enumerate(route_lengths) if length > avg_length * 1.2]\n    short_routes = [i for i, length in enumerate(route_lengths) if length < avg_length * 0.8]\n\n    if long_routes and short_routes:\n        long_route = base_solution[random.choice(long_routes)]\n        short_route = base_solution[random.choice(short_routes)]\n\n        # Find the most distant node in long route from short route centroid\n        short_centroid = np.mean(coords[short_route[1:-1]], axis=0)\n        max_dist = -1\n        node_to_move = None\n\n        for node in long_route[1:-1]:\n            dist = np.linalg.norm(coords[node] - short_centroid)\n            if dist > max_dist:\n                max_dist = dist\n                node_to_move = node\n\n        if node_to_move is not None:\n            # Try to insert into short route\n            best_pos = None\n            best_cost = float('inf')\n\n            for pos in range(1, len(short_route)):\n                temp_route = np.insert(short_route, pos, node_to_move)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[temp_route[pos-1]][node_to_move] +\n                            distance_matrix[node_to_move][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            if best_pos is not None:\n                # Perform the insertion\n                new_short_route = np.insert(short_route, best_pos, node_to_move)\n                new_long_route = np.delete(long_route, np.where(long_route == node_to_move)[0][0])\n\n                # Update the solution\n                for i, route in enumerate(base_solution):\n                    if np.array_equal(route, long_route):\n                        base_solution[i] = new_long_route\n                    if np.array_equal(route, short_route):\n                        base_solution[i] = new_short_route\n\n    return base_solution\n\n",
          "score": [
               -0.8624680151583892,
               0.6620391309261322
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Adaptive Route Fusion with Spatial-Demand Balancing,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-demand balancing mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and merging probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-aware insertion\" step where customers are inserted into routes based on their demand and proximity to route centroids, and a \"route balancing\" step where routes are adjusted to balance the workload across vehicles while maintaining spatial coherence.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.4, 0.7)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.4, 0.7)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        closest_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[closest_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                           distance_matrix[closest_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                        route[np.where(route == closest_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.806596622773768,
               0.1227213442325592
          ]
     }
]