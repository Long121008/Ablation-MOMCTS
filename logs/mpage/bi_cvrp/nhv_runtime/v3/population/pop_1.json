[
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Splitting with Demand-Aware Relocation,\" first selects a promising solution from the archive by prioritizing those with high total distance and relatively low makespan, indicating potential for improvement in balancing route lengths. It then randomly selects two routes from the solution, fuses them into a single path while ensuring capacity constraints are met, and strategically splits the fused route back into two segments by identifying a demand-aware split point that minimizes the increase in total distance while balancing route lengths. The method also incorporates a probabilistic demand-aware relocation step where high-demand nodes are relocated to different routes if it reduces the makespan without violating capacity constraints. This hybrid approach combines path fusion, demand-aware splitting, and relocation to explore the solution space more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select two routes to fuse\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = random.sample(range(len(selected_solution)), 2)\n    route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n    # Fuse the two routes\n    fused_route = np.concatenate((route1[:-1], route2[1:]))\n\n    # Check capacity constraint for the fused route\n    total_demand = np.sum(demand[fused_route[1:-1]])\n    if total_demand > capacity:\n        return selected_solution  # Return original if fusion is infeasible\n\n    # Find a demand-aware split point\n    best_split = None\n    min_increase = float('inf')\n\n    for i in range(1, len(fused_route) - 1):\n        # Split into two segments\n        segment1 = fused_route[:i+1]\n        segment2 = np.concatenate(([0], fused_route[i+1:]))\n\n        # Check capacity for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Calculate total distance increase\n            dist1 = np.sum(distance_matrix[segment1[:-1], segment1[1:]])\n            dist2 = np.sum(distance_matrix[segment2[:-1], segment2[1:]])\n            total_dist = dist1 + dist2\n\n            # Calculate original distance\n            original_dist = np.sum(distance_matrix[route1[:-1], route1[1:]]) + np.sum(distance_matrix[route2[:-1], route2[1:]])\n\n            increase = total_dist - original_dist\n            if increase < min_increase:\n                min_increase = increase\n                best_split = (segment1, segment2)\n\n    if best_split is not None:\n        # Replace the original routes with the split segments\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n        new_solution.extend(best_split)\n\n        # Optional: Demand-aware relocation step\n        for route in new_solution:\n            for i in range(1, len(route)-1):\n                node = route[i]\n                if demand[node] > capacity * 0.3:  # High demand node\n                    for other_route in new_solution:\n                        if np.array_equal(other_route, route):\n                            continue\n                        # Try inserting the node into another route\n                        for j in range(1, len(other_route)):\n                            # Check capacity\n                            if np.sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                                # Calculate new makespan\n                                new_route = np.insert(other_route, j, node)\n                                new_makespan = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                                original_makespan = np.sum(distance_matrix[other_route[:-1], other_route[1:]])\n\n                                if new_makespan < original_makespan:\n                                    # Perform the relocation\n                                    other_route[:] = new_route\n                                    route = np.delete(route, i)\n                                    break\n\n        return new_solution\n    else:\n        return selected_solution\n\n",
          "score": [
               -0.8441379680955634,
               0.12357181310653687
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a promising solution from the archive by prioritizing those with lower total distance and makespan, then applying a hybrid local search strategy that combines route fragmentation and reinsertion with a novel \"capacity-aware route merging\" step. This involves randomly selecting a subset of routes from the selected solution, breaking them into segments, and reinserting these segments into other routes while ensuring capacity constraints are met, followed by merging routes that share common customers to reduce the number of vehicles and improve makespan. The algorithm also includes a probabilistic acceptance criterion based on the solution's objective values to balance exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation and reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Ensure we can split the route\n            split_pos = random.randint(1, len(route) - 2)\n            segment = route[split_pos:-1]  # Exclude the depot at the end\n            remaining_route = np.concatenate([route[:split_pos], [0]])\n\n            # Update the original route\n            new_solution[route_idx] = remaining_route\n\n            # Try to reinsert the segment into another route\n            for i in range(len(new_solution)):\n                if i != route_idx:\n                    test_route = np.concatenate([new_solution[i][:-1], segment, [0]])\n                    if np.sum(demand[test_route[1:-1]]) <= capacity:\n                        new_solution[i] = test_route\n                        break\n\n        # Step 2: Capacity-aware route merging\n        if len(new_solution) > 1:\n            # Randomly select two routes for potential merging\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Create new solution with merged route\n                temp_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                temp_solution.append(merged_route)\n\n                # Check if the merged solution is better (simplified criterion)\n                if len(temp_solution) < len(new_solution):\n                    new_solution = temp_solution\n\n    # Ensure the solution is feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.4467128582861687,
               0.11891692876815796
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer relocation with capacity check\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to split or relocate\n        split_pos = random.randint(1, len(route)-2)\n        segment = route[split_pos:-1]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to relocate the segment to another route or create a new route\n        for j, other_route in enumerate(new_solution):\n            if i == j:\n                continue\n\n            # Check if relocating the segment to this route is feasible\n            other_route_demand = sum(demand[node] for node in other_route[1:-1])\n            if other_route_demand + segment_demand <= capacity:\n                # Find the best insertion position in the other route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[other_route[pos-1]][segment[0]] +\n                           distance_matrix[segment[-1]][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform relocation\n                new_solution[i] = np.concatenate([route[:split_pos], [0]])\n                new_solution[j] = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 2]\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.8441024349834282,
               0.7101049423217773
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a promising solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route segment reversal and customer insertion, where it randomly selects a segment from a route, reverses it to potentially reduce distance or makespan, and inserts a randomly chosen customer into the most feasible position while ensuring capacity constraints are met. The algorithm also considers partial route swaps between different vehicles to further optimize both objectives, ensuring feasibility by validating demand constraints after each modification.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = random.choice(archive[:max(1, len(archive) // 3)])  # Prefer top 1/3 solutions\n    base_solution = [route.copy() for route in selected_solution[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment reversal and customer insertion\n    if len(new_solution) >= 2:  # Need at least two routes to perform swaps\n        # Randomly select a route and a segment to reverse\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot + 2 customers + depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n            # Check if the reversed segment is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    # Randomly select a customer to insert into another route\n    if len(new_solution) >= 2:\n        # Select a random route and a random customer from it\n        src_route_idx = random.randint(0, len(new_solution) - 1)\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 2:  # At least one customer\n            customer_pos = random.randint(1, len(src_route) - 2)\n            customer = src_route[customer_pos]\n\n            # Try to insert into another route\n            for _ in range(5):  # Try up to 5 times to find a feasible insertion\n                dest_route_idx = random.randint(0, len(new_solution) - 1)\n                if dest_route_idx == src_route_idx:\n                    continue\n\n                dest_route = new_solution[dest_route_idx]\n                if np.sum(demand[dest_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position in the destination route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(dest_route)):\n                    # Calculate the increase in distance\n                    prev_node = dest_route[pos - 1]\n                    next_node = dest_route[pos]\n                    increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Insert the customer\n                new_dest_route = np.concatenate([dest_route[:best_pos], [customer], dest_route[best_pos:]])\n                new_solution[dest_route_idx] = new_dest_route\n                new_src_route = np.concatenate([src_route[:customer_pos], src_route[customer_pos + 1:]])\n                new_solution[src_route_idx] = new_src_route\n                break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If a route is infeasible, revert to the original solution\n            return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.609204529898868,
               0.17037931084632874
          ]
     },
     {
          "algorithm": "{The described algorithm, named \"Multi-Objective Route Fusion and Segment Reallocation (MRFSR)\", operates by first selecting a solution from the archive based on a weighted combination of its objectives, favoring those with lower makespan but also considering total distance to avoid premature convergence. It then applies a hybrid local search that combines three novel operators: 1) \"Route Fusion\" merges two routes by inserting a segment from one into another, ensuring capacity constraints are met, 2) \"Segment Reallocation\" moves a high-demand segment between routes to balance makespan, and 3) \"Cross-Route 2-opt*\" extends 2-opt by considering multiple nodes in a cross-route context to reduce total distance while maintaining feasibility. The algorithm intelligently selects the operator based on the current solution's characteristics, such as route imbalance or high total distance, and uses a feasibility-preserving mechanism for demand checks during segment moves.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.4, 0.6])  # More weight on makespan\n    normalized_scores = np.array([weights * np.array(obj) for _, obj in archive])\n    normalized_scores = normalized_scores / normalized_scores.max(axis=0)\n    scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Choose a local search operator based on solution characteristics\n    max_makespan = max([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    total_distance = sum([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n\n    # Operator selection probabilities\n    if max_makespan > total_distance * 0.6:  # If makespan is significantly larger than distance\n        operator = \"route_fusion\"\n    elif len(new_solution) > 3:  # If many routes exist\n        operator = \"segment_reallocation\"\n    else:\n        operator = \"cross_route_2opt\"\n\n    # Apply the selected operator\n    if operator == \"route_fusion\":\n        # Merge two routes by inserting a segment from one into another\n        if len(new_solution) >= 2:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route2) > 3:  # Ensure there's a segment to move\n                # Select a random segment from route2\n                start, end = sorted(random.sample(range(1, len(route2)-1), 2))\n                segment = route2[start:end+1]\n                segment_demand = sum(demand[node] for node in segment)\n\n                # Find insertion points in route1\n                for i in range(1, len(route1)):\n                    if sum(demand[node] for node in route1[1:i]) + segment_demand <= capacity:\n                        new_route = np.concatenate((route1[:i], segment, route1[i:]))\n                        new_solution[route1_idx] = new_route\n                        new_solution[route2_idx] = np.concatenate((route2[:start], route2[end+1:]))\n                        break\n\n    elif operator == \"segment_reallocation\":\n        # Move a high-demand segment between routes to balance makespan\n        if len(new_solution) >= 2:\n            # Find the route with the highest makespan\n            makespans = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            source_idx = np.argmax(makespans)\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            if len(source_route) > 3:\n                # Select a high-demand segment\n                segment_length = min(3, len(source_route)-2)\n                start = random.randint(1, len(source_route)-segment_length-1)\n                segment = source_route[start:start+segment_length]\n                segment_demand = sum(demand[node] for node in segment)\n\n                # Find insertion points in target route\n                target_route = new_solution[target_idx]\n                for i in range(1, len(target_route)):\n                    if sum(demand[node] for node in target_route[1:i]) + segment_demand <= capacity:\n                        new_target = np.concatenate((target_route[:i], segment, target_route[i:]))\n                        new_source = np.concatenate((source_route[:start], source_route[start+segment_length:]))\n                        new_solution[target_idx] = new_target\n                        new_solution[source_idx] = new_source\n                        break\n\n    elif operator == \"cross_route_2opt\":\n        # Extended 2-opt that considers multiple nodes in cross-route context\n        if len(new_solution) >= 2:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select two nodes from each route (excluding depots)\n                node1 = random.randint(1, len(route1)-2)\n                node2 = random.randint(1, len(route2)-2)\n\n                # Check capacity constraints\n                segment1 = route1[node1:]\n                segment2 = route2[node2:]\n                new_route1 = np.concatenate((route1[:node1], segment2))\n                new_route2 = np.concatenate((route2[:node2], segment1))\n\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure no empty routes are left\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8037892194016065,
               0.24140217900276184
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves a hybrid local search strategy that combines a novel \"route-splitting and merging\" operator with a demand-aware insertion heuristic. First, it intelligently selects a solution from the archive by prioritizing those with high total distance but relatively low makespan, as these often contain long routes that can be improved by splitting into shorter, more balanced ones. The algorithm then identifies the longest route in the selected solution and attempts to split it into two feasible sub-routes by finding a high-demand node that can serve as a split point, ensuring neither sub-route exceeds vehicle capacity. If splitting fails due to capacity constraints, it applies a demand-aware insertion heuristic to redistribute nodes between routes by considering both demand and distance, prioritizing nodes with high demand to prevent future capacity violations. The neighbor solution is then constructed by either the split routes or the reinserted nodes, ensuring feasibility and potentially improving both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Find the longest route in the selected solution\n    longest_route = max(selected, key=lambda route: distance_matrix[route[:-1], route[1:]].sum())\n\n    # Try to split the longest route\n    new_solution = selected.copy()\n    split_success = False\n\n    # Find a candidate split point (high demand node that can split the route)\n    for i in range(1, len(longest_route) - 1):\n        node = longest_route[i]\n        if demand[node] > capacity / 2:  # High demand node\n            # Check if splitting at this node is feasible\n            route1 = longest_route[:i+1]\n            route2 = longest_route[i:]\n            if (demand[route1[1:-1]].sum() <= capacity and\n                demand[route2[1:-1]].sum() <= capacity):\n                # Replace the original route with the two new routes\n                new_solution = [r for r in new_solution if not np.array_equal(r, longest_route)]\n                new_solution.extend([route1, route2])\n                split_success = True\n                break\n\n    # If splitting failed, try demand-aware insertion\n    if not split_success:\n        # Find the route with the most excess capacity\n        routes_with_capacity = [(route, capacity - demand[route[1:-1]].sum())\n                               for route in new_solution]\n        routes_with_capacity.sort(key=lambda x: x[1], reverse=True)\n\n        # Try to move nodes from the longest route to other routes\n        for node in longest_route[1:-1]:\n            for route, excess in routes_with_capacity:\n                if excess >= demand[node]:\n                    # Find the best insertion position in the target route\n                    min_insert_cost = float('inf')\n                    best_pos = -1\n                    for i in range(1, len(route)):\n                        cost = (distance_matrix[route[i-1], node] +\n                               distance_matrix[node, route[i]] -\n                               distance_matrix[route[i-1], route[i]])\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_pos = i\n                    if best_pos != -1:\n                        # Insert the node and update the route\n                        new_route = np.insert(route, best_pos, node)\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                        new_solution.append(new_route)\n                        # Remove the node from the original route\n                        original_route = [r for r in selected if np.array_equal(r, longest_route)][0]\n                        new_solution = [r for r in new_solution if not np.array_equal(r, original_route)]\n                        new_solution.append(np.delete(original_route, np.where(original_route == node)))\n                        break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.6774461242311831,
               0.2328459918498993
          ]
     },
     {
          "algorithm": "{The novel local search operator, \"Route Fusion and Split\" (RFS), intelligently selects a solution from the archive by prioritizing those with high makespan and total distance, then applies a hybrid approach that first fuses two randomly selected routes into a single super-route, identifies the most promising split point using a combination of demand balance and distance minimization, and finally splits the fused route into two new routes while ensuring capacity constraints are met. This method exploits the trade-off between objectives by balancing route lengths while optimizing total distance, and it avoids standard 2-opt by incorporating demand-aware splitting and route fusion, ensuring both objectives are improved through a more holistic transformation of the solution structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Choose two distinct routes to fuse\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_indices = list(range(len(base_solution)))\n    i, j = random.sample(route_indices, 2)\n    route1, route2 = base_solution[i], base_solution[j]\n\n    # Fuse the two routes (excluding depots)\n    fused_route = np.concatenate((route1[:-1], route2[1:]))\n\n    # Find the best split point considering demand balance and distance\n    best_split = None\n    min_cost = float('inf')\n\n    for k in range(1, len(fused_route) - 1):\n        # Split into two new routes\n        new_route1 = np.concatenate(([0], fused_route[1:k+1], [0]))\n        new_route2 = np.concatenate(([0], fused_route[k+1:], [0]))\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n\n        if demand1 > capacity or demand2 > capacity:\n            continue\n\n        # Calculate cost: weighted sum of distance and makespan\n        dist1 = np.sum(distance_matrix[np.roll(new_route1, 1)[:-1], new_route1[:-1]])\n        dist2 = np.sum(distance_matrix[np.roll(new_route2, 1)[:-1], new_route2[:-1]])\n        total_dist = dist1 + dist2\n        makespan = max(dist1, dist2)\n\n        # Balance between distance and makespan\n        cost = 0.7 * total_dist + 0.3 * makespan\n\n        if cost < min_cost:\n            min_cost = cost\n            best_split = (new_route1, new_route2)\n\n    if best_split is None:\n        return base_solution\n\n    # Replace the original routes with the new ones\n    new_solution = [route for idx, route in enumerate(base_solution) if idx not in {i, j}]\n    new_solution.extend(best_split)\n\n    return new_solution\n\n",
          "score": [
               -0.6904685829211545,
               0.34322670102119446
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Route Segment Swap with Capacity-Aware Rebalancing,\" begins by intelligently selecting a solution from the archive based on a weighted combination of objective values, favoring those with lower total distance but also considering makespan diversity to avoid premature convergence. It then identifies high-demand customers and clusters them into segments, prioritizing those with the highest demand-to-distance ratios. The algorithm performs a novel local search by swapping these high-demand segments between routes while ensuring capacity constraints are met, using a greedy insertion heuristic to rebalance loads. Additionally, it employs a \"route merging\" step to combine short routes with sufficient remaining capacity, followed by a \"route splitting\" step to address overloaded routes by strategically inserting depot visits. The algorithm also includes a \"demand-based node relocation\" phase to optimize the placement of high-demand nodes within their respective routes, and finally applies a \"distance-aware route reversal\" to improve individual route efficiency. All steps are designed to maintain feasibility while exploring the solution space more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + 0.1 * obj[1]) for (_, obj) in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Identify high-demand customers and cluster them into segments\n    high_demand_nodes = np.where(demand > capacity * 0.3)[0]  # Nodes with demand > 30% of capacity\n    segments = []\n\n    for route in new_solution:\n        route_demands = demand[route[1:-1]]  # Exclude depot\n        route_high_demand = high_demand_nodes[np.isin(high_demand_nodes, route[1:-1])]\n\n        if len(route_high_demand) >= 2:\n            # Cluster consecutive high-demand nodes\n            clusters = []\n            current_cluster = [route_high_demand[0]]\n            for i in range(1, len(route_high_demand)):\n                if distance_matrix[route_high_demand[i-1], route_high_demand[i]] < 2 * np.mean(distance_matrix):\n                    current_cluster.append(route_high_demand[i])\n                else:\n                    if len(current_cluster) >= 2:\n                        clusters.append(current_cluster)\n                    current_cluster = [route_high_demand[i]]\n            if len(current_cluster) >= 2:\n                clusters.append(current_cluster)\n\n            for cluster in clusters:\n                segments.append((cluster, route))\n\n    # Step 2: Swap high-demand segments between routes\n    if len(segments) >= 2:\n        # Select two random segments\n        seg1, route1 = random.choice(segments)\n        seg2, route2 = random.choice([s for s in segments if s[1] != route1])\n\n        # Check if swapping is feasible\n        total_demand1 = sum(demand[seg1])\n        total_demand2 = sum(demand[seg2])\n\n        # Calculate remaining capacities\n        def route_capacity(route):\n            return capacity - sum(demand[route[1:-1]])\n\n        cap1_after = route_capacity(route1) + total_demand1 - total_demand2\n        cap2_after = route_capacity(route2) + total_demand2 - total_demand1\n\n        if cap1_after >= 0 and cap2_after >= 0:\n            # Perform the swap\n            idx1 = [np.where(route1 == node)[0][0] for node in seg1]\n            idx2 = [np.where(route2 == node)[0][0] for node in seg2]\n\n            # Remove segments\n            for i in sorted(idx1, reverse=True):\n                route1 = np.delete(route1, i)\n            for i in sorted(idx2, reverse=True):\n                route2 = np.delete(route2, i)\n\n            # Insert segments\n            insert_pos1 = np.random.randint(1, len(route1))\n            insert_pos2 = np.random.randint(1, len(route2))\n\n            route1 = np.insert(route1, insert_pos1, seg2)\n            route2 = np.insert(route2, insert_pos2, seg1)\n\n            # Update the solution\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route1):\n                    new_solution[i] = route1\n                elif np.array_equal(new_solution[i], route2):\n                    new_solution[i] = route2\n\n    # Step 3: Route merging (combine short routes)\n    if len(new_solution) > 1:\n        short_routes = [i for i, route in enumerate(new_solution) if len(route) <= 5]  # Very short routes\n        if len(short_routes) >= 2:\n            route1_idx = random.choice(short_routes)\n            route2_idx = random.choice([i for i in short_routes if i != route1_idx])\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            if route_capacity(route1) + route_capacity(route2) >= sum(demand[route2[1:-1]]):\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Step 4: Route splitting (split overloaded routes)\n    for i, route in enumerate(new_solution):\n        if sum(demand[route[1:-1]]) > capacity:\n            # Find the best split point\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_pos = np.where(cumulative_demand > capacity)[0][0] + 1  # +1 to account for depot\n\n            # Create two new routes\n            route1 = np.concatenate([route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Update the solution\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n\n    # Step 5: Demand-based node relocation\n    for route in new_solution:\n        route_nodes = route[1:-1]\n        if len(route_nodes) > 1:\n            # Find the most demanding node in this route\n            most_demanding = route_nodes[np.argmax(demand[route_nodes])]\n\n            # Find the best position to move it\n            best_pos = 1\n            best_cost = float('inf')\n\n            for pos in range(1, len(route)):\n                if pos == np.where(route == most_demanding)[0][0]:\n                    continue\n\n                # Try inserting at position pos\n                temp_route = np.insert(route, pos, most_demanding)\n                temp_route = np.delete(temp_route, np.where(temp_route == most_demanding)[0][0])\n\n                # Check capacity\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Calculate cost of the new route\n                    cost = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Perform the move if it improves the route\n            if best_pos != np.where(route == most_demanding)[0][0]:\n                original_pos = np.where(route == most_demanding)[0][0]\n                route[best_pos] = most_demanding\n                route[original_pos] = route[best_pos]\n\n    # Step 6: Distance-aware route reversal\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Calculate current distance\n            current_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n\n            # Reverse the route (excluding depots)\n            reversed_route = np.concatenate([[0], route[-2:0:-1], [0]])\n            reversed_dist = sum(distance_matrix[reversed_route[i], reversed_route[i+1]] for i in range(len(reversed_route)-1))\n\n            # Keep the better one\n            if reversed_dist < current_dist:\n                route[:] = reversed_route\n\n    return new_solution\n\n",
          "score": [
               -0.6905325641911968,
               3.6216825246810913
          ]
     },
     {
          "algorithm": "{The algorithm first identifies the most promising solution in the archive by selecting those with the lowest total distance and makespan, then applies a hybrid local search combining route splitting and merging with a capacity-aware insertion heuristic. It randomly splits a long route into two by selecting a split point that balances demand and minimizes the increase in total distance, then merges the two resulting routes into the best feasible position while ensuring vehicle capacity constraints are not violated. The new neighbor solution is constructed by replacing the original route with the merged result, and the process is repeated iteratively to explore diverse improvements while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n\n    # Find the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = longest_route[split_point:]\n\n    # Check if the split is feasible\n    if demand[first_part[1:-1]].sum() > capacity or demand[second_part[1:-1]].sum() > capacity:\n        return selected_solution\n\n    # Merge the two parts into the solution\n    new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n    new_solution.append(first_part)\n    new_solution.append(second_part)\n\n    # Try to merge the two new routes into one if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            if demand[route1[1:-1]].sum() + demand[route2[1:-1]].sum() <= capacity:\n                # Try to merge route1 and route2\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for k, route in enumerate(new_solution) if k != i and k != j]\n                new_solution.append(merged_route)\n                return new_solution\n\n    return new_solution\n\n",
          "score": [
               -0.6418009442014783,
               0.2624903917312622
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a promising solution from the archive by considering both objective values (total distance and makespan) and their trade-offs, then applying a hybrid local search operator that combines route segment swapping with capacity-aware node insertion to balance the objectives. The selection process prioritizes solutions with lower total distance and makespan, while the local search operator identifies critical segments (longest or capacity-critical) in routes, swaps them with other segments from different routes, and inserts nodes from the swapped segments into the new routes while ensuring capacity constraints are respected. The operator also considers the spatial proximity of nodes to minimize additional travel distance, thus improving both objectives simultaneously. The function returns the new feasible neighbor solution after applying the transformation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment swap with capacity-aware insertion\n    if len(new_solution) > 1:\n        # Select two routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find critical segments (longest or capacity-critical)\n        def get_critical_segment(route):\n            max_segment_length = 0\n            critical_segment = None\n            for i in range(1, len(route) - 1):\n                for j in range(i + 1, len(route) - 1):\n                    segment_length = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                    if segment_length > max_segment_length:\n                        max_segment_length = segment_length\n                        critical_segment = (i, j)\n            return critical_segment if critical_segment else (1, len(route) - 2)\n\n        seg1_start, seg1_end = get_critical_segment(route1)\n        seg2_start, seg2_end = get_critical_segment(route2)\n\n        # Swap segments\n        new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end], route1[seg1_end:]])\n        new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end], route2[seg2_end:]])\n\n        # Insert nodes from swapped segments into new routes (capacity-aware)\n        def insert_nodes(route, nodes):\n            new_route = route.copy()\n            for node in nodes:\n                best_pos = 1\n                min_cost = float('inf')\n                for i in range(1, len(new_route)):\n                    temp_route = np.insert(new_route, i, node)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1]][node] + distance_matrix[node][temp_route[i+1]] - distance_matrix[temp_route[i-1]][temp_route[i+1]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = i\n                if min_cost < float('inf'):\n                    new_route = np.insert(new_route, best_pos, node)\n            return new_route\n\n        # Get nodes from swapped segments\n        nodes_from_seg1 = route1[seg1_start:seg1_end]\n        nodes_from_seg2 = route2[seg2_start:seg2_end]\n\n        # Insert nodes into new routes\n        new_route1 = insert_nodes(new_route1, nodes_from_seg2)\n        new_route2 = insert_nodes(new_route2, nodes_from_seg1)\n\n        # Update solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
          "score": [
               -0.6620130014725638,
               2.7181800305843353
          ]
     }
]