[
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Splitting with Demand-Aware Relocation,\" first selects a promising solution from the archive by prioritizing those with high total distance and relatively low makespan, indicating potential for improvement in balancing route lengths. It then randomly selects two routes from the solution, fuses them into a single path while ensuring capacity constraints are met, and strategically splits the fused route back into two segments by identifying a demand-aware split point that minimizes the increase in total distance while balancing route lengths. The method also incorporates a probabilistic demand-aware relocation step where high-demand nodes are relocated to different routes if it reduces the makespan without violating capacity constraints. This hybrid approach combines path fusion, demand-aware splitting, and relocation to explore the solution space more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select two routes to fuse\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = random.sample(range(len(selected_solution)), 2)\n    route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n    # Fuse the two routes\n    fused_route = np.concatenate((route1[:-1], route2[1:]))\n\n    # Check capacity constraint for the fused route\n    total_demand = np.sum(demand[fused_route[1:-1]])\n    if total_demand > capacity:\n        return selected_solution  # Return original if fusion is infeasible\n\n    # Find a demand-aware split point\n    best_split = None\n    min_increase = float('inf')\n\n    for i in range(1, len(fused_route) - 1):\n        # Split into two segments\n        segment1 = fused_route[:i+1]\n        segment2 = np.concatenate(([0], fused_route[i+1:]))\n\n        # Check capacity for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Calculate total distance increase\n            dist1 = np.sum(distance_matrix[segment1[:-1], segment1[1:]])\n            dist2 = np.sum(distance_matrix[segment2[:-1], segment2[1:]])\n            total_dist = dist1 + dist2\n\n            # Calculate original distance\n            original_dist = np.sum(distance_matrix[route1[:-1], route1[1:]]) + np.sum(distance_matrix[route2[:-1], route2[1:]])\n\n            increase = total_dist - original_dist\n            if increase < min_increase:\n                min_increase = increase\n                best_split = (segment1, segment2)\n\n    if best_split is not None:\n        # Replace the original routes with the split segments\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n        new_solution.extend(best_split)\n\n        # Optional: Demand-aware relocation step\n        for route in new_solution:\n            for i in range(1, len(route)-1):\n                node = route[i]\n                if demand[node] > capacity * 0.3:  # High demand node\n                    for other_route in new_solution:\n                        if np.array_equal(other_route, route):\n                            continue\n                        # Try inserting the node into another route\n                        for j in range(1, len(other_route)):\n                            # Check capacity\n                            if np.sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                                # Calculate new makespan\n                                new_route = np.insert(other_route, j, node)\n                                new_makespan = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                                original_makespan = np.sum(distance_matrix[other_route[:-1], other_route[1:]])\n\n                                if new_makespan < original_makespan:\n                                    # Perform the relocation\n                                    other_route[:] = new_route\n                                    route = np.delete(route, i)\n                                    break\n\n        return new_solution\n    else:\n        return selected_solution\n\n",
          "score": [
               -0.8441379680955634,
               0.12357181310653687
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Route Consolidation and Dispersal\" (ARCD), selects a solution from the archive by prioritizing those with high total distance and makespan, then applies a hybrid approach that first identifies the most capacity-critical routes and consolidates them by merging with nearby routes based on spatial proximity, followed by dispersing nodes from overloaded routes to underutilized routes using a demand-aware insertion strategy that minimizes the increase in total distance while balancing the makespan. This method differs from standard approaches by dynamically adapting to route characteristics and leveraging spatial and demand information to improve both objectives simultaneously through a two-phase transformation process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Identify capacity-critical routes (those closest to capacity)\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    critical_routes = [i for i, d in enumerate(route_demands) if d > 0.8 * capacity]\n\n    if not critical_routes:\n        return base_solution\n\n    # Select a critical route to consolidate\n    critical_idx = random.choice(critical_routes)\n    critical_route = base_solution[critical_idx]\n\n    # Find the nearest route to merge with\n    nearest_route_idx = None\n    min_distance = float('inf')\n    for i, route in enumerate(base_solution):\n        if i == critical_idx:\n            continue\n        # Calculate distance between last node of critical route and first node of other route\n        dist = distance_matrix[critical_route[-2]][route[1]]\n        if dist < min_distance:\n            min_distance = dist\n            nearest_route_idx = i\n\n    if nearest_route_idx is None:\n        return base_solution\n\n    # Merge critical route with nearest route\n    merged_route = np.concatenate((critical_route[:-1], base_solution[nearest_route_idx][1:]))\n\n    # Check if merged route exceeds capacity\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        # If it does, try to disperse nodes instead\n        # Find the most overloaded node in critical route\n        critical_nodes = critical_route[1:-1]\n        overloaded_nodes = [node for node in critical_nodes if demand[node] > 0.3 * capacity]\n\n        if overloaded_nodes:\n            # Try to insert into other routes\n            for node in overloaded_nodes:\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for i, route in enumerate(base_solution):\n                    if i == critical_idx:\n                        continue\n\n                    for pos in range(1, len(route)):\n                        temp_route = np.insert(route, pos, node)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = (distance_matrix[temp_route[pos-1]][node] +\n                                    distance_matrix[node][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = i\n                                best_pos = pos\n\n                if best_route is not None:\n                    # Perform the insertion\n                    new_route = np.insert(base_solution[best_route], best_pos, node)\n                    base_solution[best_route] = new_route\n                    # Remove the node from critical route\n                    critical_route = np.delete(critical_route, np.where(critical_route == node)[0][0])\n                    base_solution[critical_idx] = critical_route\n\n    else:\n        # Update the solution with the merged route\n        new_solution = [route for i, route in enumerate(base_solution)\n                       if i != critical_idx and i != nearest_route_idx]\n        new_solution.append(merged_route)\n        base_solution = new_solution\n\n    return base_solution\n\n",
          "score": [
               -0.8593646646770561,
               0.20235806703567505
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution first selects a solution from the archive by prioritizing those with lower total distance, then applies a novel \"route merging and segment relocation\" strategy. This involves randomly selecting two routes, merging them into a single route while respecting capacity constraints, and then intelligently relocating segments between routes to balance the makespan and total distance. The algorithm also includes a \"route decomposition\" step where long routes are split into smaller segments that are redistributed to other routes, and a \"customer redistribution\" step where customers are redistributed across routes based on their spatial proximity to route centers, all while ensuring feasibility and potentially improving both objectives. The method balances exploration and exploitation by probabilistically accepting moves that improve either objective, while ensuring all generated solutions remain feasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging and segment relocation\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging routes is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Relocate segments to balance routes\n            if len(merged_route) > 5:  # Only relocate if route is long enough\n                for _ in range(2):  # Try a few segment relocations\n                    split_pos = random.randint(2, len(merged_route)-3)\n                    segment = merged_route[split_pos:-1]\n                    segment_demand = sum(demand[node] for node in segment)\n\n                    # Create a new route with the segment\n                    new_route = np.concatenate([[0], segment, [0]])\n                    if segment_demand <= capacity:\n                        new_solution.append(new_route)\n                        new_solution[route1_idx] = np.concatenate([merged_route[:split_pos], [0]])\n\n                        # Remove empty routes\n                        new_solution = [r for r in new_solution if len(r) > 2]\n                        break\n\n    # Route decomposition\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 6:  # Only decompose long routes\n            split_pos1 = random.randint(2, len(route)-4)\n            split_pos2 = random.randint(split_pos1+1, len(route)-2)\n\n            segment1 = route[:split_pos1+1]\n            segment2 = route[split_pos1:split_pos2+1]\n            segment3 = route[split_pos2:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in segment1[1:-1])\n            demand2 = sum(demand[node] for node in segment2[1:-1])\n            demand3 = sum(demand[node] for node in segment3[1:-1])\n\n            if all(d <= capacity for d in [demand1, demand2, demand3]):\n                # Replace original route with three new routes\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                new_solution.insert(route_idx+2, segment3)\n\n    # Customer redistribution based on spatial proximity\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find route center\n            route_nodes = route[1:-1]\n            route_center = np.mean(coords[route_nodes], axis=0)\n\n            # Find closest customer to route center\n            distances_to_center = np.linalg.norm(coords[route_nodes] - route_center, axis=1)\n            closest_customer = route_nodes[np.argmin(distances_to_center)]\n\n            # Try to relocate closest customer to another route\n            for i, other_route in enumerate(new_solution):\n                if i != route_idx:\n                    current_demand = sum(demand[node] for node in other_route[1:-1])\n                    if current_demand + demand[closest_customer] <= capacity:\n                        # Find best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                                   distance_matrix[closest_customer][other_route[pos]] -\n                                   distance_matrix[other_route[pos-1]][other_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform relocation\n                        new_solution[i] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                        new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                                route[np.where(route == closest_customer)[0][0]+1:]])\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7503442659201316,
               0.090950608253479
          ]
     },
     {
          "algorithm": "{The proposed algorithm combines the strengths of the given approaches by first selecting a solution from the archive that balances both objectives, then applying a novel \"route-fusion and disaggregation\" operator. This operator intelligently merges two short routes into one if their combined demand is feasible, potentially reducing makespan, while simultaneously disaggregating long routes by strategically splitting them at low-demand nodes to balance route lengths and improve total distance. The algorithm also incorporates a demand-aware relocation heuristic that moves high-demand nodes between routes to optimize both objectives, ensuring feasibility by validating capacity constraints after each modification. The neighbor solution is constructed by either the fused, split, or relocated routes, providing a comprehensive local search that addresses both objectives while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_solution = random.choice(archive[:max(1, len(archive) // 2)])  # Prefer middle solutions\n    base_solution = [route.copy() for route in selected_solution[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route fusion: merge two short routes if possible\n    if len(new_solution) >= 2:\n        # Find the two shortest routes\n        routes_sorted = sorted(new_solution, key=lambda r: len(r))\n        route1, route2 = routes_sorted[0], routes_sorted[1]\n\n        # Check if merging is feasible\n        if demand[route1[1:-1]].sum() + demand[route2[1:-1]].sum() <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n            new_solution.append(merged_route)\n\n    # Route disaggregation: split long routes at low-demand nodes\n    if len(new_solution) >= 1:\n        # Find the longest route\n        longest_route = max(new_solution, key=lambda r: len(r))\n\n        # Find the lowest demand node in the middle of the route\n        candidates = [(i, demand[node]) for i, node in enumerate(longest_route[1:-1]) if demand[node] < capacity / 4]\n        if candidates:\n            # Sort by demand (lowest first) and select the first candidate\n            candidates.sort(key=lambda x: x[1])\n            split_pos, _ = candidates[0]\n\n            # Split the route\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:]\n            if demand[route1[1:-1]].sum() <= capacity and demand[route2[1:-1]].sum() <= capacity:\n                new_solution = [r for r in new_solution if not np.array_equal(r, longest_route)]\n                new_solution.extend([route1, route2])\n\n    # Demand-aware relocation: move high-demand nodes between routes\n    if len(new_solution) >= 2:\n        # Find the route with the highest average demand\n        routes_with_avg_demand = [(route, demand[route[1:-1]].sum() / len(route[1:-1]) if len(route) > 2 else 0)\n                                 for route in new_solution]\n        routes_with_avg_demand.sort(key=lambda x: x[1], reverse=True)\n        source_route, _ = routes_with_avg_demand[0]\n\n        # Find high-demand nodes in the source route\n        high_demand_nodes = [node for node in source_route[1:-1] if demand[node] > capacity / 3]\n\n        for node in high_demand_nodes:\n            # Find the best target route (with enough capacity)\n            for target_route in new_solution:\n                if target_route is source_route:\n                    continue\n                if demand[target_route[1:-1]].sum() + demand[node] <= capacity:\n                    # Find the best insertion position in the target route\n                    min_insert_cost = float('inf')\n                    best_pos = -1\n                    for i in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[i-1], node] +\n                               distance_matrix[node, target_route[i]] -\n                               distance_matrix[target_route[i-1], target_route[i]])\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_pos = i\n                    if best_pos != -1:\n                        # Insert the node into the target route\n                        new_target_route = np.insert(target_route, best_pos, node)\n                        new_solution = [r for r in new_solution if not np.array_equal(r, target_route)]\n                        new_solution.append(new_target_route)\n                        # Remove the node from the source route\n                        new_source_route = np.delete(source_route, np.where(source_route == node))\n                        new_solution = [r for r in new_solution if not np.array_equal(r, source_route)]\n                        new_solution.append(new_source_route)\n                        break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If a route is infeasible, revert to the original solution\n            return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.8333791547468146,
               0.17536872625350952
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer relocation with capacity check\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to split or relocate\n        split_pos = random.randint(1, len(route)-2)\n        segment = route[split_pos:-1]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to relocate the segment to another route or create a new route\n        for j, other_route in enumerate(new_solution):\n            if i == j:\n                continue\n\n            # Check if relocating the segment to this route is feasible\n            other_route_demand = sum(demand[node] for node in other_route[1:-1])\n            if other_route_demand + segment_demand <= capacity:\n                # Find the best insertion position in the other route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[other_route[pos-1]][segment[0]] +\n                           distance_matrix[segment[-1]][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform relocation\n                new_solution[i] = np.concatenate([route[:split_pos], [0]])\n                new_solution[j] = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 2]\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.8441024349834282,
               0.7101049423217773
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a solution from the archive based on a novel diversity-aware metric that combines objective values with spatial distribution of customers, then applying a hybrid local search operator that combines route merging with capacity-constrained node migration. The selection process prioritizes solutions that show good balance between objectives while considering spatial diversity, and the local search operator identifies the most promising route pairs for merging, then strategically migrates nodes between routes while respecting capacity constraints, with special attention to geographic proximity to minimize additional travel distance. The operator also includes a novel \"demand-balancing\" step that redistributes customers between routes to improve makespan while considering the spatial distribution of demands. The function returns the new feasible neighbor solution after applying these transformations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def diversity_metric(sol):\n        total_dist, makespan = sol[1]\n        # Calculate spatial diversity (average distance from depot)\n        diversity = 0\n        for route in sol[0]:\n            route_nodes = route[1:-1]  # exclude depots\n            if len(route_nodes) > 0:\n                avg_dist = np.mean([np.linalg.norm(coords[node] - coords[0]) for node in route_nodes])\n                diversity += avg_dist\n        diversity /= len(sol[0])\n        # Combine objectives with spatial diversity\n        return total_dist * 0.4 + makespan * 0.4 + diversity * 0.2\n\n    selected_solution = min(archive, key=diversity_metric)[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging with demand balancing\n    if len(new_solution) > 1:\n        # Select routes with the most similar makespans\n        makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        route1_idx = np.argmin(makespans)\n        route2_idx = np.argmax(makespans)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate current demands\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        # Find nodes to migrate to balance demands\n        target_demand = (demand1 + demand2) / 2\n        nodes_to_migrate = []\n        current_demand = demand1 if demand1 < target_demand else demand2\n\n        # Collect candidate nodes for migration\n        source_route = route1 if demand1 < target_demand else route2\n        for node in source_route[1:-1]:\n            if current_demand + demand[node] <= capacity:\n                nodes_to_migrate.append(node)\n                current_demand += demand[node]\n\n        # Migrate nodes to the other route\n        target_route = route2 if demand1 < target_demand else route1\n        migrated_nodes = []\n        for node in nodes_to_migrate:\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(target_route)):\n                cost = (distance_matrix[target_route[i-1]][node] +\n                        distance_matrix[node][target_route[i]] -\n                        distance_matrix[target_route[i-1]][target_route[i]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Insert node\n            target_route = np.insert(target_route, best_pos, node)\n            migrated_nodes.append(node)\n\n        # Remove migrated nodes from source route\n        source_route = source_route[1:-1]\n        source_route = source_route[~np.isin(source_route, migrated_nodes)]\n        source_route = np.concatenate([[0], source_route, [0]])\n\n        # Update solution\n        new_solution[route1_idx] = source_route if demand1 < target_demand else target_route\n        new_solution[route2_idx] = target_route if demand1 < target_demand else source_route\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8455701807191196,
               4.533470541238785
          ]
     },
     {
          "algorithm": "{The proposed algorithm, \"Adaptive Route Balancing and Demand Redistribution\" (ARBR), selects a solution from the archive by prioritizing those with high makespan and moderate total distance, then applies a hybrid approach that first identifies the most imbalanced routes (those with significantly longer makespan than average) and redistributes their nodes to other routes using a demand-aware clustering strategy, followed by balancing the makespan by selectively merging or splitting routes based on spatial proximity and demand distribution, while ensuring capacity constraints are met throughout the process. This method differs from standard approaches by dynamically adapting to route characteristics and leveraging spatial and demand information to improve both objectives simultaneously through a two-phase transformation process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in base_solution]\n    route_demands = [demand[route[1:-1]].sum() for route in base_solution]\n    avg_length = np.mean(route_lengths)\n\n    # Identify imbalanced routes (longer than average)\n    imbalanced_routes = [i for i, length in enumerate(route_lengths) if length > 1.2 * avg_length]\n\n    if not imbalanced_routes:\n        return base_solution\n\n    # Select an imbalanced route to process\n    selected_route_idx = random.choice(imbalanced_routes)\n    selected_route = base_solution[selected_route_idx]\n\n    # Cluster nodes in the selected route based on spatial proximity and demand\n    nodes = selected_route[1:-1]\n    clusters = []\n    current_cluster = [nodes[0]]\n\n    for node in nodes[1:]:\n        # Check if adding this node to current cluster maintains capacity\n        if demand[current_cluster].sum() + demand[node] <= capacity:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Try to redistribute clusters to other routes\n    new_solution = base_solution.copy()\n    for cluster in clusters:\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        # Find the best route and position to insert the cluster\n        for route_idx, route in enumerate(new_solution):\n            if route_idx == selected_route_idx:\n                continue\n\n            # Check if adding the cluster to this route exceeds capacity\n            if demand[route[1:-1]].sum() + demand[cluster].sum() > capacity:\n                continue\n\n            # Find the best insertion position in the route\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[route[pos-1]][cluster[0]] +\n                        distance_matrix[cluster[-1]][route[pos]] -\n                        distance_matrix[route[pos-1]][route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route = route_idx\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            target_route = new_solution[best_route]\n            new_route = np.insert(target_route, best_pos, cluster)\n            new_solution[best_route] = new_route\n\n            # Remove the cluster from the original route\n            original_route = new_solution[selected_route_idx]\n            mask = np.isin(original_route, cluster, invert=True)\n            new_solution[selected_route_idx] = original_route[mask]\n\n    # After redistribution, balance makespan by merging or splitting routes\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n    sorted_routes = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])\n\n    for i in range(len(sorted_routes)):\n        if route_lengths[sorted_routes[i]] > 1.1 * avg_length:\n            # Try to merge with the shortest route\n            shortest_route = sorted_routes[0]\n            if (demand[new_solution[sorted_routes[i]][1:-1]].sum() +\n                demand[new_solution[shortest_route][1:-1]].sum() <= capacity):\n\n                # Merge the routes\n                merged_route = np.concatenate((new_solution[sorted_routes[i]][:-1],\n                                              new_solution[shortest_route][1:]))\n                new_solution[sorted_routes[i]] = merged_route\n                new_solution.pop(shortest_route)\n\n    return new_solution\n\n",
          "score": [
               -0.8366578409591027,
               0.2931278944015503
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Route Merging and Segmented Reinsertion,\" first selects a solution from the archive by prioritizing those with high makespan and total distance, then randomly merges two routes into a single path while ensuring capacity constraints are met. It then strategically segments the merged route into multiple smaller segments using a demand-aware clustering approach that groups nodes based on spatial proximity and demand similarity, and reinserts these segments back into the solution as new routes. This method avoids standard 2-opt by incorporating a more holistic transformation of the solution structure, where the segmentation and reinsertion steps are guided by both spatial and demand-based criteria to balance route lengths and total distance more effectively. The algorithm also includes a probabilistic segment merging step where adjacent segments with similar demand patterns are merged if it reduces the makespan without violating capacity constraints, further enhancing the exploration of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_indices = random.sample(range(len(base_solution)), 2)\n    route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n    merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n\n    for i in range(1, len(merged_route) - 1):\n        current_segment.append(merged_route[i])\n        segment_demand = np.sum(demand[current_segment[1:]])\n        if segment_demand > capacity * 0.8 or i == len(merged_route) - 2:\n            if segment_demand <= capacity:\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0]\n            else:\n                last_node = current_segment.pop()\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in route_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n\n                for k in range(1, len(merged_segment) - 1):\n                    current_segment.append(merged_segment[k])\n                    segment_demand = np.sum(demand[current_segment[1:]])\n                    if segment_demand > capacity * 0.8 or k == len(merged_segment) - 2:\n                        if segment_demand <= capacity:\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                        else:\n                            last_node = current_segment.pop()\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0, last_node]\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan) or (total_dist <= original_dist and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    return new_solution\n\n",
          "score": [
               -0.7467283543413393,
               0.10716685652732849
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a promising solution from the archive by prioritizing those with lower total distance and makespan, then applying a hybrid local search strategy that combines route fragmentation and reinsertion with a novel \"capacity-aware route merging\" step. This involves randomly selecting a subset of routes from the selected solution, breaking them into segments, and reinserting these segments into other routes while ensuring capacity constraints are met, followed by merging routes that share common customers to reduce the number of vehicles and improve makespan. The algorithm also includes a probabilistic acceptance criterion based on the solution's objective values to balance exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation and reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Ensure we can split the route\n            split_pos = random.randint(1, len(route) - 2)\n            segment = route[split_pos:-1]  # Exclude the depot at the end\n            remaining_route = np.concatenate([route[:split_pos], [0]])\n\n            # Update the original route\n            new_solution[route_idx] = remaining_route\n\n            # Try to reinsert the segment into another route\n            for i in range(len(new_solution)):\n                if i != route_idx:\n                    test_route = np.concatenate([new_solution[i][:-1], segment, [0]])\n                    if np.sum(demand[test_route[1:-1]]) <= capacity:\n                        new_solution[i] = test_route\n                        break\n\n        # Step 2: Capacity-aware route merging\n        if len(new_solution) > 1:\n            # Randomly select two routes for potential merging\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Create new solution with merged route\n                temp_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                temp_solution.append(merged_route)\n\n                # Check if the merged solution is better (simplified criterion)\n                if len(temp_solution) < len(new_solution):\n                    new_solution = temp_solution\n\n    # Ensure the solution is feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.4467128582861687,
               0.11891692876815796
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Cluster-Based Route Optimization with Dynamic Capacity Balancing,\" first selects a promising solution from the archive by prioritizing those with low total distance and relatively high makespan, indicating potential for improvement in both route efficiency and load balancing. It then dynamically partitions the customer nodes into clusters using a k-means-like approach that considers both spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. The method then optimizes each cluster by reconstructing routes through a greedy insertion heuristic that alternates between minimizing travel distance and balancing route lengths, with a dynamic capacity threshold that adjusts based on the current load distribution across routes. This hybrid approach combines cluster-based decomposition, dynamic capacity balancing, and greedy route reconstruction to explore the solution space more effectively than standard methods, particularly for problems with high spatial variability in customer locations and demands.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract customer nodes from all routes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Determine number of clusters (min between 2 and number of routes)\n    n_clusters = min(2, len(base_solution))\n\n    # Initialize clusters with random centroids from customer coordinates\n    centroids = random.sample(list(all_customers), n_clusters)\n    centroid_coords = coords[centroids]\n\n    # Cluster assignment with capacity constraint\n    clusters = [[] for _ in range(n_clusters)]\n    cluster_demands = [0.0] * n_clusters\n\n    for customer in all_customers:\n        # Find nearest centroid with available capacity\n        min_dist = float('inf')\n        best_cluster = -1\n        for i in range(n_clusters):\n            if cluster_demands[i] + demand[customer] <= capacity:\n                dist = np.linalg.norm(coords[customer] - centroid_coords[i])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(customer)\n            cluster_demands[best_cluster] += demand[customer]\n\n    # Reconstruct routes for each cluster\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Greedy route construction with alternating objectives\n        remaining = set(cluster)\n        routes = []\n\n        while remaining:\n            # Alternate between minimizing distance and balancing routes\n            if random.random() < 0.5:\n                # Distance-minimizing route\n                current_route = [0]\n                current_demand = 0.0\n                while remaining and current_demand + min(demand[list(remaining)]) <= capacity:\n                    # Find nearest customer\n                    last = current_route[-1]\n                    nearest = None\n                    min_dist = float('inf')\n                    for customer in remaining:\n                        if demand[customer] + current_demand <= capacity:\n                            dist = distance_matrix[last][customer]\n                            if dist < min_dist:\n                                min_dist = dist\n                                nearest = customer\n                    if nearest is not None:\n                        current_route.append(nearest)\n                        current_demand += demand[nearest]\n                        remaining.remove(nearest)\n                    else:\n                        break\n                current_route.append(0)\n                if len(current_route) > 2:\n                    routes.append(np.array(current_route))\n            else:\n                # Route balancing step\n                current_route = [0]\n                current_demand = 0.0\n                while remaining and current_demand + min(demand[list(remaining)]) <= capacity:\n                    # Find customer that best balances route length\n                    last = current_route[-1]\n                    best_customer = None\n                    best_balance = float('inf')\n                    for customer in remaining:\n                        if demand[customer] + current_demand <= capacity:\n                            # Calculate potential route length increase\n                            new_length = distance_matrix[last][customer] + distance_matrix[customer][0]\n                            balance = abs(new_length - np.mean([len(r) for r in routes]) if routes else 0)\n                            if balance < best_balance:\n                                best_balance = balance\n                                best_customer = customer\n                    if best_customer is not None:\n                        current_route.append(best_customer)\n                        current_demand += demand[best_customer]\n                        remaining.remove(best_customer)\n                    else:\n                        break\n                current_route.append(0)\n                if len(current_route) > 2:\n                    routes.append(np.array(current_route))\n\n        new_solution.extend(routes)\n\n    # If no routes were created, return original solution\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.8309350768592649,
               0.5364269018173218
          ]
     }
]