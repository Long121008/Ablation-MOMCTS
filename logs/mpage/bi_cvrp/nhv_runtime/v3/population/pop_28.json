[
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution first selects a solution from the archive by prioritizing those with lower total distance, then applies a novel \"route merging and segment relocation\" strategy. This involves randomly selecting two routes, merging them into a single route while respecting capacity constraints, and then intelligently relocating segments between routes to balance the makespan and total distance. The algorithm also includes a \"route decomposition\" step where long routes are split into smaller segments that are redistributed to other routes, and a \"customer redistribution\" step where customers are redistributed across routes based on their spatial proximity to route centers, all while ensuring feasibility and potentially improving both objectives. The method balances exploration and exploitation by probabilistically accepting moves that improve either objective, while ensuring all generated solutions remain feasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging and segment relocation\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging routes is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Relocate segments to balance routes\n            if len(merged_route) > 5:  # Only relocate if route is long enough\n                for _ in range(2):  # Try a few segment relocations\n                    split_pos = random.randint(2, len(merged_route)-3)\n                    segment = merged_route[split_pos:-1]\n                    segment_demand = sum(demand[node] for node in segment)\n\n                    # Create a new route with the segment\n                    new_route = np.concatenate([[0], segment, [0]])\n                    if segment_demand <= capacity:\n                        new_solution.append(new_route)\n                        new_solution[route1_idx] = np.concatenate([merged_route[:split_pos], [0]])\n\n                        # Remove empty routes\n                        new_solution = [r for r in new_solution if len(r) > 2]\n                        break\n\n    # Route decomposition\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 6:  # Only decompose long routes\n            split_pos1 = random.randint(2, len(route)-4)\n            split_pos2 = random.randint(split_pos1+1, len(route)-2)\n\n            segment1 = route[:split_pos1+1]\n            segment2 = route[split_pos1:split_pos2+1]\n            segment3 = route[split_pos2:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in segment1[1:-1])\n            demand2 = sum(demand[node] for node in segment2[1:-1])\n            demand3 = sum(demand[node] for node in segment3[1:-1])\n\n            if all(d <= capacity for d in [demand1, demand2, demand3]):\n                # Replace original route with three new routes\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                new_solution.insert(route_idx+2, segment3)\n\n    # Customer redistribution based on spatial proximity\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find route center\n            route_nodes = route[1:-1]\n            route_center = np.mean(coords[route_nodes], axis=0)\n\n            # Find closest customer to route center\n            distances_to_center = np.linalg.norm(coords[route_nodes] - route_center, axis=1)\n            closest_customer = route_nodes[np.argmin(distances_to_center)]\n\n            # Try to relocate closest customer to another route\n            for i, other_route in enumerate(new_solution):\n                if i != route_idx:\n                    current_demand = sum(demand[node] for node in other_route[1:-1])\n                    if current_demand + demand[closest_customer] <= capacity:\n                        # Find best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                                   distance_matrix[closest_customer][other_route[pos]] -\n                                   distance_matrix[other_route[pos-1]][other_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform relocation\n                        new_solution[i] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                        new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                                route[np.where(route == closest_customer)[0][0]+1:]])\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7503442659201316,
               0.090950608253479
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Adaptive Route Segmentation with Spatial and Demand-Aware Clustering,\" first selects a high-quality solution from the archive by prioritizing those with balanced makespan and total distance, then dynamically partitions the solution into segments based on spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by greedily merging segments that optimize both objectives, using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware segment swapping\" mechanism that exchanges segments between routes while preserving capacity feasibility and potentially improving both objectives. The method combines adaptive segmentation, spatial-demand clustering, and hybrid objective-driven reconstruction to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Adaptive route segmentation\n    segments = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Split route into segments of approximately equal length\n            n_segments = max(2, len(route) // 4)\n            segment_length = len(route) // n_segments\n            for i in range(n_segments):\n                start = 1 + i * segment_length\n                end = min(start + segment_length, len(route) - 1)\n                segment = route[start:end]\n                segments.append(segment)\n\n    # Spatial and demand-aware clustering\n    clusters = []\n    cluster_centers = []\n    cluster_demands = []\n\n    for segment in segments:\n        if len(segment) == 0:\n            continue\n\n        # Find segment center\n        segment_coords = coords[segment]\n        center = np.mean(segment_coords, axis=0)\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find closest cluster with available capacity\n        best_cluster = -1\n        min_dist = float('inf')\n        for i, (cluster_center, cluster_d) in enumerate(zip(cluster_centers, cluster_demands)):\n            if cluster_d + segment_demand <= capacity:\n                dist = np.linalg.norm(center - cluster_center)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cluster = i\n\n        if best_cluster != -1:\n            clusters[best_cluster].append(segment)\n            cluster_demands[best_cluster] += segment_demand\n        else:\n            # Create new cluster\n            clusters.append([segment])\n            cluster_centers.append(center)\n            cluster_demands.append(segment_demand)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Combine all segments in cluster\n        all_nodes = []\n        for segment in cluster:\n            all_nodes.extend(segment)\n        remaining = set(all_nodes)\n\n        # Dynamic weight adjustment for hybrid objective\n        total_dist, makespan = archive_sorted[0][1]\n        weight_dist = 0.7 if makespan > 1.2 * total_dist else 0.3\n\n        # Greedy route construction\n        while remaining:\n            current_route = [0]\n            current_demand = 0.0\n\n            while remaining:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in remaining:\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Calculate hybrid cost\n                    last_node = current_route[-1]\n                    dist_cost = distance_matrix[last_node][node]\n                    span_cost = distance_matrix[node][0] + sum(distance_matrix[node][n] for n in current_route[1:])\n                    total_cost = weight_dist * dist_cost + (1 - weight_dist) * span_cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n\n                if best_node is not None:\n                    current_route.append(best_node)\n                    current_demand += demand[best_node]\n                    remaining.remove(best_node)\n                else:\n                    break\n\n            current_route.append(0)\n            if len(current_route) > 2:\n                new_solution.append(np.array(current_route))\n\n    # Demand-aware segment swapping\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform a few swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find segments to swap\n            route1_nodes = set(route1[1:-1])\n            route2_nodes = set(route2[1:-1])\n\n            # Find compatible segments\n            for segment1 in [route1[1:-1], route1[1:-2], route1[2:-1]]:\n                segment1_demand = sum(demand[node] for node in segment1)\n                for segment2 in [route2[1:-1], route2[1:-2], route2[2:-1]]:\n                    segment2_demand = sum(demand[node] for node in segment2)\n\n                    # Check capacity constraints\n                    route1_demand = sum(demand[node] for node in route1[1:-1])\n                    route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                    if (route1_demand - segment1_demand + segment2_demand <= capacity and\n                        route2_demand - segment2_demand + segment1_demand <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], segment1), segment2, [0]])\n                        new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], segment2), segment1, [0]])\n\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.9054799063755163,
               2.908462554216385
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Demand Cluster Fusion and Spatial-Aware Splitting,\" first selects a solution from the archive by prioritizing those with high total distance and relatively balanced makespan, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-aware splitting mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment merging step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and merging probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1] / x[1][0]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 3), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.5, 0.8)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n\n            merged_segment = np.concatenate((route1[:-1], route2[1:]))\n            merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n            if merged_demand <= capacity:\n                new_segments = []\n                current_segment = [0]\n                current_demand = 0\n                demand_threshold = capacity * random.uniform(0.5, 0.8)\n\n                for k in range(1, len(merged_segment) - 1):\n                    current_segment.append(merged_segment[k])\n                    current_demand += demand[merged_segment[k]]\n\n                    if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                        if current_demand <= capacity:\n                            segment_coords = coords[current_segment[1:-1]]\n                            segment_centroid = np.mean(segment_coords, axis=0)\n                            distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                            if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                                new_segments.append(np.array(current_segment + [0]))\n                                current_segment = [0]\n                                current_demand = 0\n                                demand_threshold = capacity * random.uniform(0.5, 0.8)\n                        else:\n                            last_node = current_segment.pop()\n                            current_demand -= demand[last_node]\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0, last_node]\n                            current_demand = demand[last_node]\n\n                if len(new_segments) < 2:\n                    continue\n\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.1) or (total_dist <= original_dist * 1.1 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8590109894069807,
               0.10349655151367188
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Route Merging with Demand-Balanced Splitting,\" first selects a solution from the archive based on a multi-criteria ranking that considers both objective values and solution structure, then adaptively merges multiple routes into a single path while maintaining capacity constraints, and strategically splits this merged route into multiple segments using a demand-balanced approach that minimizes both the total distance increase and the variance in route lengths, followed by an optional demand-aware relocation step that intelligently redistributes high-demand nodes across routes to further balance the solution's objectives without violating capacity constraints. This hybrid approach combines adaptive merging, demand-balanced splitting, and intelligent relocation to explore the solution space more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / (x[1][1] + 1), -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Adaptive route merging\n    merge_indices = random.sample(range(len(selected_solution)), min(3, len(selected_solution)))\n    merged_routes = selected_solution[merge_indices[0]].copy()\n\n    for idx in merge_indices[1:]:\n        merged_routes = np.concatenate((merged_routes[:-1], selected_solution[idx][1:]))\n\n    total_demand = sum(demand[node] for node in merged_routes[1:-1])\n    if total_demand > capacity:\n        return selected_solution\n\n    # Demand-balanced splitting\n    split_points = []\n    current_demand = 0\n    target_load = total_demand / (len(merge_indices) + 1)\n\n    for i in range(1, len(merged_routes)-1):\n        current_demand += demand[merged_routes[i]]\n        if abs(current_demand - target_load) < target_load * 0.2:\n            split_points.append(i)\n            current_demand = 0\n\n    if not split_points:\n        return selected_solution\n\n    # Create new routes from splits\n    new_routes = []\n    prev = 0\n    for point in split_points:\n        new_route = np.concatenate(([0], merged_routes[prev+1:point+1], [0]))\n        if len(new_route) > 2:\n            new_routes.append(new_route)\n        prev = point\n\n    if len(merged_routes) > prev + 1:\n        new_route = np.concatenate(([0], merged_routes[prev+1:-1], [0]))\n        if len(new_route) > 2:\n            new_routes.append(new_route)\n\n    # Remove original merged routes\n    new_solution = [route for i, route in enumerate(selected_solution) if i not in merge_indices]\n    new_solution.extend(new_routes)\n\n    # Demand-aware relocation\n    for route in new_solution:\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if demand[node] > capacity * 0.25:  # Relocate high-demand nodes\n                for other_route in new_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    current_demand = sum(demand[n] for n in other_route[1:-1])\n                    if current_demand + demand[node] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[j-1]][node] +\n                                   distance_matrix[node][other_route[j]] -\n                                   distance_matrix[other_route[j-1]][other_route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        if best_cost < 0:  # Only relocate if improves distance\n                            new_route = np.insert(other_route, best_pos, node)\n                            other_route[:] = new_route\n                            route = np.delete(route, i)\n                            break\n\n    return new_solution\n\n",
          "score": [
               -0.8648558587369714,
               0.10906502604484558
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Adaptive Route Partitioning with Spatial-Demand Clustering and Multi-Objective Balancing,\" first selects a solution from the archive by prioritizing those with balanced objectives, then partitions the solution into spatial-demand clusters using a k-means++ inspired approach that considers both geographic proximity and demand compatibility, while maintaining capacity constraints. It then reconstructs routes by iteratively merging clusters that optimize a hybrid objective function, which dynamically balances distance and makespan based on the current solution's characteristics, and incorporates a novel \"demand-aware route inversion\" mechanism that reverses segments of routes when it improves both objectives, while preserving capacity feasibility. The method combines adaptive partitioning, spatial-demand clustering, hybrid objective-driven reconstruction, and intelligent route inversion to explore the solution space more effectively than standard approaches, particularly for problems with heterogeneous customer distributions and varying demand patterns.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Extract all customer nodes\n    all_customers = []\n    for route in base_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.array(all_customers)\n\n    if len(all_customers) == 0:\n        return base_solution\n\n    # Spatial-demand clustering using k-means++\n    def kmeans_plus_plus(coords, demand, k, capacity):\n        centers = []\n        demands = []\n        remaining = set(all_customers)\n\n        # Initialize first center\n        first_center = random.choice(all_customers)\n        centers.append(first_center)\n        demands.append(demand[first_center])\n        remaining.remove(first_center)\n\n        # Initialize remaining centers\n        for _ in range(1, k):\n            max_dist = -1\n            best_node = None\n\n            for node in remaining:\n                min_dist = min(distance_matrix[node][center] for center in centers)\n                if min_dist > max_dist:\n                    max_dist = min_dist\n                    best_node = node\n\n            if best_node is not None:\n                centers.append(best_node)\n                demands.append(demand[best_node])\n                remaining.remove(best_node)\n            else:\n                break\n\n        # Assign nodes to clusters\n        clusters = [[] for _ in range(len(centers))]\n        cluster_demands = demands.copy()\n\n        for node in all_customers:\n            if node in centers:\n                idx = centers.index(node)\n                clusters[idx].append(node)\n            else:\n                best_cluster = -1\n                min_dist = float('inf')\n\n                for i, center in enumerate(centers):\n                    if cluster_demands[i] + demand[node] <= capacity:\n                        dist = distance_matrix[node][center]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_cluster = i\n\n                if best_cluster != -1:\n                    clusters[best_cluster].append(node)\n                    cluster_demands[best_cluster] += demand[node]\n\n        return clusters\n\n    # Determine number of clusters (between 2 and 4)\n    k = min(max(2, len(base_solution) // 2), 4)\n    clusters = kmeans_plus_plus(coords, demand, k, capacity)\n\n    # Route reconstruction with hybrid objective function\n    new_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n\n        # Sort nodes in cluster by distance to depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Greedy route construction\n        current_route = [0]\n        current_demand = 0.0\n        remaining = cluster_sorted.copy()\n\n        while remaining:\n            best_node = None\n            best_cost = float('inf')\n\n            for node in remaining:\n                if current_demand + demand[node] > capacity:\n                    continue\n\n                # Calculate hybrid cost (balance between distance and makespan)\n                last_node = current_route[-1]\n                dist_cost = distance_matrix[last_node][node]\n                span_cost = distance_matrix[node][0]  # Return to depot\n                total_cost = 0.5 * dist_cost + 0.5 * span_cost\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_node = node\n\n            if best_node is not None:\n                current_route.append(best_node)\n                current_demand += demand[best_node]\n                remaining.remove(best_node)\n            else:\n                break\n\n        current_route.append(0)\n        if len(current_route) > 2:\n            new_solution.append(np.array(current_route))\n\n    # Demand-aware route inversion\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if inversion improves both objectives\n                original_dist = (distance_matrix[route[i-1]][route[i]] +\n                                distance_matrix[route[j]][route[j+1]])\n                inverted_dist = (distance_matrix[route[i-1]][route[j]] +\n                                distance_matrix[route[i]][route[j+1]])\n\n                if inverted_dist < original_dist:\n                    # Check capacity constraints\n                    segment_demand = sum(demand[node] for node in route[i:j+1])\n                    if segment_demand <= capacity:\n                        # Perform inversion\n                        route[i:j+1] = route[j:i-1:-1]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    if not new_solution:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.873617345618189,
               1.4678039252758026
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Demand-Adjusted Route Fusion and Spatial-Constrained Splitting\" (ADARFS), first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, then applies a hybrid approach that first fuses routes with complementary demand patterns while respecting spatial constraints, followed by a demand-adjusted splitting phase that divides overloaded routes into segments with balanced demands and optimized spatial configurations, ensuring capacity constraints are met and both objectives are improved through a two-phase transformation process where demand-adjustment identifies optimal route groupings and spatial-constrained splitting ensures feasible and efficient route configurations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in base_solution]\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in base_solution]\n\n    demand_threshold = capacity * 0.6\n    complement_pairs = []\n\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            combined_demand = route_demands[i] + route_demands[j]\n            if combined_demand <= capacity * 1.2 and combined_demand >= demand_threshold:\n                complement_pairs.append((i, j))\n\n    if complement_pairs:\n        pair = random.choice(complement_pairs)\n        route1, route2 = base_solution[pair[0]], base_solution[pair[1]]\n\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [route for idx, route in enumerate(base_solution) if idx not in pair]\n            new_solution.append(merged_route)\n            base_solution = new_solution\n\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d > capacity * 0.8]\n\n    if overloaded_routes:\n        route_idx = random.choice(overloaded_routes)\n        route = base_solution[route_idx]\n        nodes = route[1:-1]\n\n        if len(nodes) > 2:\n            demand_sorted = sorted(nodes, key=lambda x: demand[x], reverse=True)\n            split_pos = len(nodes) // 2\n\n            segment1 = np.concatenate(([0], nodes[:split_pos], [0]))\n            segment2 = np.concatenate(([0], nodes[split_pos:], [0]))\n\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution = [route for idx, route in enumerate(base_solution) if idx != route_idx]\n                new_solution.extend([segment1, segment2])\n                base_solution = new_solution\n\n    return base_solution\n\n",
          "score": [
               -0.8681747393147738,
               0.3164099454879761
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Spatial-Demand Harmony Hybridization,\" first selects a solution from the archive by prioritizing those with high makespan and relatively balanced total distance, indicating potential for improvement in both objectives. It then adaptively fuses multiple routes into a single path while respecting capacity constraints, and employs a spatial-demand harmony mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment harmonization step where adjacent segments with compatible spatial patterns are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the capacity thresholds and harmonization probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-spatial synergy insertion\" step where customers are inserted into routes based on their demand and proximity to route centroids, and a \"route harmonization\" step where routes are adjusted to balance the workload across vehicles while maintaining spatial coherence.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] / x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 4), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.4, 0.7)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.4, 0.7)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.15) or (total_dist <= original_dist * 1.15 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        closest_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[closest_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                           distance_matrix[closest_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                        route[np.where(route == closest_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.6696718300008245,
               0.10217472910881042
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Adaptive Multi-Objective Route Balancing with Spatial-Demand Synergy,\" first selects a solution from the archive by prioritizing those with high total distance but moderate makespan, indicating potential for improvement in both objectives, then dynamically partitions the solution into segments based on both spatial proximity and demand compatibility, while maintaining vehicle capacity constraints. It then reconstructs routes by iteratively balancing the workload across vehicles using a hybrid cost function that dynamically adjusts weights between distance and makespan based on the current solution's characteristics, and incorporates a novel \"spatial-demand aware route splitting\" mechanism that splits routes when their spatial or demand imbalance exceeds predefined thresholds, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the splitting thresholds and acceptance probabilities based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-aware route merging\" step where compatible routes are merged if it reduces the makespan without violating capacity constraints, and a \"route optimization\" step where routes are optimized using a greedy insertion heuristic that considers both spatial proximity and demand compatibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    new_solution = []\n    route_indices = list(range(len(base_solution)))\n\n    while route_indices:\n        current_route_idx = random.choice(route_indices)\n        current_route = base_solution[current_route_idx]\n        route_indices.remove(current_route_idx)\n\n        if len(current_route) < 3:\n            new_solution.append(current_route)\n            continue\n\n        # Calculate spatial and demand metrics\n        route_customers = current_route[1:-1]\n        route_coords = coords[route_customers]\n        route_centroid = np.mean(route_coords, axis=0)\n        route_demand = sum(demand[node] for node in route_customers)\n\n        # Check for spatial imbalance\n        max_distance = max(np.linalg.norm(route_coords - route_centroid, axis=1))\n        avg_distance = np.mean(np.linalg.norm(route_coords - route_centroid, axis=1))\n        spatial_imbalance = max_distance / avg_distance if avg_distance > 0 else 0\n\n        # Check for demand imbalance\n        demand_imbalance = max(demand[node] for node in route_customers) / route_demand if route_demand > 0 else 0\n\n        # Decide whether to split or not\n        split_threshold = random.uniform(1.2, 1.5)\n        if spatial_imbalance > split_threshold or demand_imbalance > split_threshold:\n            # Split the route\n            split_pos = len(current_route) // 2\n            new_route1 = np.concatenate([current_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], current_route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(current_route)\n        else:\n            new_solution.append(current_route)\n\n    # Try to merge compatible routes\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate potential merged demand\n        merged_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if merged_demand <= capacity:\n            # Calculate spatial compatibility\n            route1_coords = coords[route1[1:-1]]\n            route2_coords = coords[route2[1:-1]]\n            route1_centroid = np.mean(route1_coords, axis=0)\n            route2_centroid = np.mean(route2_coords, axis=0)\n            centroid_distance = np.linalg.norm(route1_centroid - route2_centroid)\n\n            # Calculate demand compatibility\n            route1_demand = sum(demand[node] for node in route1[1:-1])\n            route2_demand = sum(demand[node] for node in route2[1:-1])\n            demand_ratio = max(route1_demand, route2_demand) / min(route1_demand, route2_demand) if min(route1_demand, route2_demand) > 0 else 1\n\n            # Decide whether to merge\n            merge_probability = 0.7 if centroid_distance < np.mean(distance_matrix) and demand_ratio < 1.5 else 0.3\n\n            if random.random() < merge_probability:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                new_solution.append(merged_route)\n\n    # Optimize routes with greedy insertion\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        # Find the most remote customer\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n        distances = np.linalg.norm(route_coords - route_centroid, axis=1)\n        remote_customer_pos = np.argmax(distances) + 1  # +1 because we skip depot\n        remote_customer = route[remote_customer_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            if other_demand + demand[remote_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][remote_customer] +\n                           distance_matrix[remote_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Calculate current and potential makespan\n                current_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in new_solution\n                )\n\n                new_route = np.concatenate([other_route[:best_pos], [remote_customer], other_route[best_pos:]])\n                new_makespan = max(\n                    sum(distance_matrix[np.roll(r, 1)[:-1], r[:-1]]) for r in [new_route] + [r for idx, r in enumerate(new_solution) if idx != other_route_idx]\n                )\n\n                if new_makespan <= current_makespan * 1.1:  # Allow slight increase in makespan for better distance\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:remote_customer_pos], route[remote_customer_pos+1:]])\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8764415990061454,
               3.859888881444931
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Dynamic Multi-Objective Route Fusion with Adaptive Demand-Spatial Synergy,\" first selects a solution from the archive by prioritizing those with high makespan and relatively low total distance, indicating potential for improvement in both objectives, then dynamically fuses multiple routes into a single path while respecting capacity constraints, and employs an adaptive demand-spatial synergy mechanism that partitions the fused route into segments based on both demand thresholds and spatial clustering, ensuring each segment's demand does not exceed a dynamically adjusted capacity threshold. The algorithm incorporates a probabilistic segment fusion step where adjacent segments with compatible demand patterns and spatial proximity are merged if it reduces the makespan without violating capacity constraints, while also allowing for controlled exploration by occasionally accepting non-improving moves to escape local optima. The method balances exploration and exploitation by dynamically adjusting the fusion probabilities and demand thresholds based on the current solution quality, and incorporates spatial awareness to create more balanced routes. Additionally, it includes a \"demand-spatial centroid alignment\" step where customers are reordered within segments based on their proximity to the segment's spatial centroid, and a \"route harmonization\" step where routes are adjusted to balance the workload across vehicles while maintaining spatial coherence.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    num_routes_to_fuse = min(random.randint(2, 4), len(base_solution))\n    selected_indices = random.sample(range(len(base_solution)), num_routes_to_fuse)\n    selected_routes = [base_solution[i] for i in selected_indices]\n\n    fused_route = np.concatenate([route[:-1] for route in selected_routes] + [[0]])\n\n    if np.sum(demand[fused_route[1:-1]]) > capacity:\n        return base_solution\n\n    segments = []\n    current_segment = [0]\n    current_demand = 0\n    demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n    centroids = []\n    for route in selected_routes:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    overall_centroid = np.mean(centroids, axis=0)\n\n    for i in range(1, len(fused_route) - 1):\n        current_segment.append(fused_route[i])\n        current_demand += demand[fused_route[i]]\n\n        if current_demand > demand_threshold or i == len(fused_route) - 2:\n            if current_demand <= capacity:\n                segment_coords = coords[current_segment[1:-1]]\n                segment_centroid = np.mean(segment_coords, axis=0)\n                distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                    segments.append(np.array(current_segment + [0]))\n                    current_segment = [0]\n                    current_demand = 0\n                    demand_threshold = capacity * random.uniform(0.4, 0.7)\n            else:\n                last_node = current_segment.pop()\n                current_demand -= demand[last_node]\n                segments.append(np.array(current_segment + [0]))\n                current_segment = [0, last_node]\n                current_demand = demand[last_node]\n\n    if len(segments) < 2:\n        return base_solution\n\n    new_solution = [route for i, route in enumerate(base_solution) if i not in selected_indices]\n    new_solution.extend(segments)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        merged_segment = np.concatenate((route1[:-1], route2[1:]))\n        merged_demand = np.sum(demand[merged_segment[1:-1]])\n\n        if merged_demand <= capacity:\n            new_segments = []\n            current_segment = [0]\n            current_demand = 0\n            demand_threshold = capacity * random.uniform(0.4, 0.7)\n\n            for k in range(1, len(merged_segment) - 1):\n                current_segment.append(merged_segment[k])\n                current_demand += demand[merged_segment[k]]\n\n                if current_demand > demand_threshold or k == len(merged_segment) - 2:\n                    if current_demand <= capacity:\n                        segment_coords = coords[current_segment[1:-1]]\n                        segment_centroid = np.mean(segment_coords, axis=0)\n                        distance_to_center = np.linalg.norm(segment_centroid - overall_centroid)\n\n                        if distance_to_center < np.mean([np.linalg.norm(c - overall_centroid) for c in centroids]):\n                            new_segments.append(np.array(current_segment + [0]))\n                            current_segment = [0]\n                            current_demand = 0\n                            demand_threshold = capacity * random.uniform(0.4, 0.7)\n                    else:\n                        last_node = current_segment.pop()\n                        current_demand -= demand[last_node]\n                        new_segments.append(np.array(current_segment + [0]))\n                        current_segment = [0, last_node]\n                        current_demand = demand[last_node]\n\n            if len(new_segments) >= 2:\n                total_dist = 0\n                makespan = 0\n                for seg in new_segments:\n                    seg_dist = np.sum(distance_matrix[np.roll(seg, 1)[:-1], seg[:-1]])\n                    total_dist += seg_dist\n                    makespan = max(makespan, seg_dist)\n\n                original_dist = np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]) + np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]])\n                original_makespan = max(np.sum(distance_matrix[np.roll(route1, 1)[:-1], route1[:-1]]), np.sum(distance_matrix[np.roll(route2, 1)[:-1], route2[:-1]]))\n\n                if (total_dist < original_dist and makespan <= original_makespan * 1.15) or (total_dist <= original_dist * 1.15 and makespan < original_makespan):\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.extend(new_segments)\n\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) < 4:\n            continue\n\n        route_coords = coords[route[1:-1]]\n        route_centroid = np.mean(route_coords, axis=0)\n\n        customers = route[1:-1]\n        distances_to_centroid = np.linalg.norm(coords[customers] - route_centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        closest_customer = customers[sorted_indices[0]]\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            if other_demand + demand[closest_customer] <= capacity:\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1]][closest_customer] +\n                           distance_matrix[closest_customer][other_route[pos]] -\n                           distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [closest_customer], other_route[best_pos:]])\n                new_solution[route_idx] = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                                        route[np.where(route == closest_customer)[0][0]+1:]])\n                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8341644049554928,
               0.10499840974807739
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Adaptive Multi-Objective Route Transformation with Spatial-Demand Harmony,\" prioritizes solutions with high makespan and moderate total distance from the archive, then applies a sequence of adaptive transformations that dynamically balance spatial clustering and demand distribution. It first performs a \"route harmonization\" step where routes are partitioned into segments based on both spatial proximity and demand thresholds, with each segment's demand dynamically adjusted to maintain feasibility. Next, it employs a \"spatial-demand centroid alignment\" step where customers are reordered within segments based on their proximity to the segment's spatial centroid, while also considering demand compatibility. The algorithm then applies a probabilistic \"route fusion and decomposition\" step where adjacent segments are merged or split based on their spatial coherence and demand balance, with fusion probabilities adjusted based on the current solution's quality. Finally, it includes a \"demand-spatial workload redistribution\" step where customers are redistributed across routes to balance workload while maintaining spatial coherence, with acceptance probabilities dynamically adjusted to balance exploration and exploitation. The method ensures all transformations maintain feasibility and potentially improve both objectives through adaptive parameter tuning and spatial-aware demand management.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0] * 0.7))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Route harmonization with spatial-demand partitioning\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_nodes = route[1:-1]\n        route_coords = coords[route_nodes]\n        centroid = np.mean(route_coords, axis=0)\n\n        # Calculate spatial-demand harmony score\n        spatial_scores = np.linalg.norm(route_coords - centroid, axis=1)\n        demand_scores = demand[route_nodes] / capacity\n        harmony_scores = spatial_scores * 0.6 + demand_scores * 0.4\n\n        # Partition route into segments\n        sorted_indices = np.argsort(harmony_scores)\n        segment_size = max(2, len(route_nodes) // 3)\n        segments = []\n        current_segment = []\n\n        for idx in sorted_indices:\n            current_segment.append(route_nodes[idx])\n            if len(current_segment) >= segment_size or idx == sorted_indices[-1]:\n                segments.append(np.array([0] + current_segment + [0]))\n                current_segment = []\n\n        if len(segments) > 1:\n            new_solution[route_idx] = segments[0]\n            for seg in segments[1:]:\n                new_solution.append(seg)\n\n    # Spatial-demand centroid alignment\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_nodes = route[1:-1]\n        centroid = np.mean(coords[route_nodes], axis=0)\n        distances = np.linalg.norm(coords[route_nodes] - centroid, axis=1)\n        sorted_indices = np.argsort(distances)\n\n        # Reorder nodes based on spatial proximity\n        new_order = route_nodes[sorted_indices]\n        new_route = np.array([0] + list(new_order) + [0])\n\n        if np.sum(demand[new_order]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Probabilistic route fusion and decomposition\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Calculate fusion probability based on spatial and demand compatibility\n        centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n        centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n        spatial_dist = np.linalg.norm(centroid1 - centroid2)\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        fusion_prob = max(0.1, 0.8 * (1 - spatial_dist / np.max(distance_matrix)) * (1 - abs(demand1 - demand2) / capacity))\n\n        if random.random() < fusion_prob:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Try decomposition if fusion fails\n                split_pos = random.randint(2, len(merged_route) - 3)\n                segment1 = merged_route[:split_pos + 1]\n                segment2 = merged_route[split_pos:]\n                if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                    new_solution[i] = segment1\n                    new_solution.insert(j, segment2)\n\n    # Demand-spatial workload redistribution\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) < 4:\n            continue\n\n        route_nodes = route[1:-1]\n        route_centroid = np.mean(coords[route_nodes], axis=0)\n\n        # Find customer with highest spatial-demand imbalance\n        spatial_scores = np.linalg.norm(coords[route_nodes] - route_centroid, axis=1)\n        demand_scores = demand[route_nodes] / capacity\n        imbalance_scores = spatial_scores * 0.7 - demand_scores * 0.3\n        customer = route_nodes[np.argmax(imbalance_scores)]\n\n        # Find best target route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, other_route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n\n            current_demand = np.sum(demand[other_route[1:-1]])\n            if current_demand + demand[customer] > capacity:\n                continue\n\n            other_centroid = np.mean(coords[other_route[1:-1]], axis=0)\n            spatial_gain = np.linalg.norm(coords[customer] - other_centroid) - np.linalg.norm(coords[customer] - route_centroid)\n\n            for pos in range(1, len(other_route)):\n                cost = (distance_matrix[other_route[pos-1]][customer] +\n                       distance_matrix[customer][other_route[pos]] -\n                       distance_matrix[other_route[pos-1]][other_route[pos]]) * 0.7 - spatial_gain * 0.3\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [customer],\n                new_solution[best_route_idx][best_pos:]\n            ])\n            new_solution[route_idx] = np.concatenate([\n                route[:np.where(route == customer)[0][0]],\n                route[np.where(route == customer)[0][0]+1:]\n            ])\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.865338666996793,
               2.704514801502228
          ]
     }
]