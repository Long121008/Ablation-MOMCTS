[
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route splitting and customer reinsertion with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and attempts to split it into two routes by relocating a segment of customers to a new route, ensuring capacity constraints are met. If splitting is infeasible, it performs a customer reinsertion by removing a customer from the shortest route and inserting it into another route, choosing the insertion position that minimizes the increase in total distance while maintaining the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try to split the shortest route into two\n    for i in range(1, len(shortest_route) - 1):\n        first_part = shortest_route[:i+1]\n        second_part = np.concatenate([[0], shortest_route[i+1:]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[shortest_route_idx] = first_part\n            new_solution.append(second_part)\n\n            # Check if this improves the makespan\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) <= max(route_lengths):\n                return new_solution\n\n    # If splitting didn't work, try reinserting a customer from the shortest route\n    if len(selected_solution) > 1:\n        # Find another route to insert into\n        for target_route_idx in range(len(selected_solution)):\n            if target_route_idx == shortest_route_idx:\n                continue\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Try moving each customer from shortest route to target route\n            for customer in shortest_route[1:-1]:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_increase = float('inf')\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_pos = pos\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_shortest_route = np.delete(shortest_route, np.where(shortest_route == customer)[0][0])\n                    new_target_route = np.insert(target_route, best_pos, customer)\n\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    new_solution[target_route_idx] = new_target_route\n\n                    # Check if this improves the makespan\n                    new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                    if max(new_route_lengths) <= max(route_lengths):\n                        return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8236050826838496,
               0.12729865312576294
          ]
     },
     {
          "algorithm": "{The novel \"Route Reconstruction and Demand Harmonization\" algorithm first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, indicating potential for route optimization. It then reconstructs routes by iteratively removing the longest route and redistributing its customers to other routes using a \"demand-aware\" insertion heuristic that minimizes both the increase in total distance and the deviation from an ideal load balance. The algorithm dynamically adjusts the insertion points based on demand proximity and spatial clustering to create balanced routes, while ensuring feasibility through strict capacity checks. If redistribution fails, it attempts to create new routes by grouping spatially close, low-demand customers. The method combines these steps in a probabilistic framework to explore diverse neighborhoods while maintaining solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers_to_reinsert = longest_route[1:-1]\n\n    # Remove the longest route\n    del new_solution[longest_route_idx]\n\n    # Sort customers by demand (ascending) to prioritize smaller customers\n    customers_to_reinsert = sorted(customers_to_reinsert, key=lambda x: demand[x])\n\n    # Calculate ideal load per route (excluding the longest route)\n    remaining_capacity = capacity * len(new_solution)\n    ideal_load = remaining_capacity / len(new_solution)\n\n    # Reinsert customers into existing routes\n    for customer in customers_to_reinsert:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        for i, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                insertion_cost = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                # Calculate load deviation from ideal\n                current_load = sum(demand[route[1:-1]])\n                new_load = current_load + demand[customer]\n                load_dev = abs(new_load - ideal_load)\n\n                # Combine cost and load deviation\n                total_cost = insertion_cost + 0.1 * load_dev\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            # Insert the customer\n            route = new_solution[best_route_idx]\n            new_route = np.insert(route, best_position, customer)\n            new_solution[best_route_idx] = new_route\n\n    # If some customers couldn't be reinserted, create new routes\n    remaining_customers = [c for c in customers_to_reinsert if c not in [node for route in new_solution for node in route[1:-1]]]\n    if remaining_customers:\n        # Group remaining customers by spatial proximity and low demand\n        remaining_customers = sorted(remaining_customers, key=lambda x: demand[x])\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            for i, customer in enumerate(remaining_customers):\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    break\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
          "score": [
               -0.9619479325462242,
               1.234698325395584
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Adaptive Route Clustering with Demand-Based Merging,\" first selects the solution with the highest makespan from the archive to identify the most imbalanced route, then dynamically clusters customers into new routes based on their demand profiles, ensuring capacity constraints are maintained through a novel demand-aware merging process that prioritizes spatial proximity and demand compatibility, while adaptively adjusting cluster boundaries to balance route lengths and minimize total distance, resulting in a feasible neighbor solution that significantly reduces makespan while improving overall route efficiency.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    # Sort unassigned customers by demand (descending) and then by distance to depot\n    unassigned_customers.sort(key=lambda x: (-demand[x], distance_matrix[0][x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            if len(current_route) > 1:  # Avoid adding empty routes\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    # Combine with existing routes\n    new_solution = selected_solution + new_routes\n\n    return new_solution\n\n",
          "score": [
               -0.7911038221089215,
               0.11675745248794556
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Spatial Cluster Refinement and Demand-Adaptive Routing,\" first selects a solution from the archive by prioritizing those with the highest total distance and highest makespan, indicating potential for significant improvement in both objectives. It then identifies spatial clusters of customers in the solution by grouping nearby customers based on a dynamic threshold that balances spatial proximity and demand feasibility. The algorithm then attempts to reassign customers from these clusters to new routes or existing routes by strategically inserting them at positions that minimize both the increase in total distance and the makespan, while ensuring vehicle capacity constraints are met. If direct reassignment is infeasible, it creates new routes by extracting compact spatial clusters that can be served by a single vehicle, ensuring the new routes' makespan is below the current average. The operator dynamically adjusts the cluster threshold and insertion criteria based on demand patterns and spatial distribution to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives through careful spatial analysis and demand-aware routing adjustments.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and makespan\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    makespan = max(route_lengths)\n\n    # Find spatial clusters of customers\n    all_customers = []\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.unique(all_customers)\n\n    clusters = []\n    visited = set()\n\n    for customer in all_customers:\n        if customer in visited:\n            continue\n        cluster = [customer]\n        visited.add(customer)\n\n        # Find all customers within a dynamic threshold distance\n        threshold = 1.5 * np.mean(distance_matrix[customer][all_customers])\n        for other in all_customers:\n            if other not in visited and distance_matrix[customer][other] <= threshold:\n                cluster.append(other)\n                visited.add(other)\n\n        clusters.append(cluster)\n\n    # Try to reassign clusters to existing routes or create new routes\n    for cluster in clusters:\n        cluster_demand = sum(demand[cluster])\n        if cluster_demand > capacity:\n            continue\n\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        # Try to insert the cluster into existing routes\n        for i, route in enumerate(selected_solution):\n            current_demand = sum(demand[route[1:-1]])\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                # Calculate cost of inserting cluster at this position\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                cost_increase = (distance_matrix[prev_node][first_node] +\n                                distance_matrix[last_node][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                if cost_increase < best_cost:\n                    best_cost = cost_increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = selected_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            selected_solution[best_route] = new_route\n            continue\n\n        # If no good insertion found, create a new route\n        new_route = np.concatenate([[0], cluster, [0]])\n        selected_solution.append(new_route)\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    # Check if any route exceeds capacity\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to original solution\n            return archive_sorted[0][0].copy()\n\n    return selected_solution\n\n",
          "score": [
               -0.8698950547833597,
               0.28535816073417664
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Dynamic Demand-Adaptive Route Clustering and Relocation,\" first selects a solution from the archive by prioritizing those with the highest makespan and highest total distance, indicating significant potential for improvement in both objectives. It then clusters customers based on both spatial proximity and demand similarity, creating demand-adaptive clusters that can be efficiently relocated or merged. The operator dynamically identifies the most promising clusters by analyzing demand profiles and spatial compactness, then evaluates multiple relocation strategies that prioritize reducing the makespan while maintaining or improving the total distance. If no beneficial relocation is found, it attempts to merge clusters from different routes when their combined demand is within capacity limits, creating more balanced and efficient route configurations. The operator dynamically adjusts its clustering and relocation strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of demand-adaptive clustering and spatial analysis to generate high-quality neighbor solutions that improve both objectives while maintaining feasibility through careful capacity checks and spatial considerations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Create demand-adaptive clusters\n    all_customers = np.concatenate([route[1:-1] for route in selected_solution])\n    cluster_centers = []\n    cluster_members = []\n\n    for customer in all_customers:\n        # Find the nearest cluster center with similar demand\n        best_cluster = None\n        best_distance = float('inf')\n\n        for i, center in enumerate(cluster_centers):\n            dist = distance_matrix[customer][center]\n            demand_diff = abs(demand[customer] - demand[center])\n\n            if demand_diff <= capacity * 0.2 and dist < best_distance:\n                best_distance = dist\n                best_cluster = i\n\n        if best_cluster is not None:\n            cluster_members[best_cluster].append(customer)\n        else:\n            cluster_centers.append(customer)\n            cluster_members.append([customer])\n\n    # Try to relocate clusters to balance makespan\n    for i, cluster in enumerate(cluster_members):\n        cluster_demand = sum(demand[cluster])\n\n        # Find best route to insert this cluster\n        best_route = None\n        best_position = None\n        best_improvement = 0\n\n        for route_idx in range(len(selected_solution)):\n            route = selected_solution[route_idx]\n            if sum(demand[route[1:-1]]) + cluster_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for pos in range(1, len(route)):\n                # Calculate potential improvement\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                distance_increase = (distance_matrix[prev_node][first_node] +\n                                   distance_matrix[last_node][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                # Calculate new makespan\n                current_length = route_lengths[route_idx]\n                new_length = current_length + distance_increase\n                new_makespan = max(max(route_lengths), new_length)\n\n                improvement = (max(route_lengths) - new_makespan) * 0.7 + (sum(route_lengths) - (sum(route_lengths) + distance_increase)) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = route_idx\n                    best_position = pos\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the relocation\n            new_route = np.concatenate([selected_solution[best_route][:best_position],\n                                      np.array(cluster),\n                                      selected_solution[best_route][best_position:]])\n\n            new_solution = selected_solution.copy()\n            new_solution[best_route] = new_route\n\n            # Remove relocated customers from their original routes\n            for customer in cluster:\n                for route_idx in range(len(new_solution)):\n                    if customer in new_solution[route_idx][1:-1]:\n                        mask = new_solution[route_idx] != customer\n                        new_solution[route_idx] = new_solution[route_idx][mask]\n                        if len(new_solution[route_idx]) == 2:  # Only depot left\n                            new_solution.pop(route_idx)\n                        break\n\n            return new_solution\n\n    # If relocation didn't work, try merging clusters from different routes\n    for i in range(len(cluster_members)):\n        for j in range(i+1, len(cluster_members)):\n            combined_demand = sum(demand[cluster_members[i]]) + sum(demand[cluster_members[j]])\n\n            if combined_demand <= capacity:\n                # Find best pair of routes to merge these clusters\n                best_pair = None\n                best_improvement = 0\n\n                for route1_idx in range(len(selected_solution)):\n                    for route2_idx in range(route1_idx+1, len(selected_solution)):\n                        if (sum(demand[selected_solution[route1_idx][1:-1]]) +\n                            sum(demand[selected_solution[route2_idx][1:-1]])) + combined_demand <= capacity:\n\n                            # Calculate potential improvement\n                            original_length = sum(distance_matrix[selected_solution[route1_idx][:-1], selected_solution[route1_idx][1:]]) + \\\n                                             sum(distance_matrix[selected_solution[route2_idx][:-1], selected_solution[route2_idx][1:]])\n\n                            # Create merged route\n                            merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                          cluster_members[i],\n                                                          selected_solution[route2_idx][1:]])\n\n                            new_length = sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n                            improvement = original_length - new_length\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_pair = (route1_idx, route2_idx)\n\n                if best_pair is not None and best_improvement > 0:\n                    route1_idx, route2_idx = best_pair\n                    merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                  cluster_members[i],\n                                                  selected_solution[route2_idx][1:]])\n\n                    new_solution = [route for idx, route in enumerate(selected_solution)\n                                  if idx not in [route1_idx, route2_idx]]\n                    new_solution.append(merged_route)\n\n                    # Remove merged clusters from their original positions\n                    for customer in cluster_members[i] + cluster_members[j]:\n                        for route_idx in range(len(new_solution)):\n                            if customer in new_solution[route_idx][1:-1]:\n                                mask = new_solution[route_idx] != customer\n                                new_solution[route_idx] = new_solution[route_idx][mask]\n                                if len(new_solution[route_idx]) == 2:  # Only depot left\n                                    new_solution.pop(route_idx)\n                                break\n\n                    return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.9304719574529826,
               0.4577655494213104
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Demand-Driven Route Harmonization,\" first selects a solution from the archive by prioritizing those with the highest makespan and highest total distance, indicating significant potential for improvement in both objectives. It then analyzes the demand distribution across routes to identify underutilized routes (with low demand) and overloaded routes (with high demand), strategically reallocating customers from underutilized routes to overloaded routes by inserting them at positions that minimize the increase in total distance while ensuring vehicle capacity constraints are met. If no beneficial reallocation is found, it creates new routes by extracting clusters of customers with complementary demand patterns that can be served together efficiently, ensuring the new routes' makespan is below the current average. The operator dynamically adjusts its reallocation strategy based on demand imbalances and spatial distribution to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives through careful demand analysis and spatial-aware routing adjustments.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and lengths\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n\n    # Identify underutilized (low demand) and overloaded (high demand) routes\n    underutilized_threshold = 0.3 * capacity\n    overloaded_threshold = 0.8 * capacity\n\n    underutilized_routes = [i for i, d in enumerate(route_demands) if d <= underutilized_threshold and len(selected_solution[i]) > 2]\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d >= overloaded_threshold]\n\n    if not underutilized_routes or not overloaded_routes:\n        return selected_solution.copy()\n\n    # Try to reallocate customers from underutilized to overloaded routes\n    for under_idx in underutilized_routes:\n        under_route = selected_solution[under_idx]\n        customers = under_route[1:-1]\n\n        for customer in customers:\n            best_route = None\n            best_pos = None\n            best_cost = float('inf')\n\n            for over_idx in overloaded_routes:\n                over_route = selected_solution[over_idx]\n                current_demand = route_demands[over_idx]\n\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for pos in range(1, len(over_route)):\n                    prev_node = over_route[pos-1]\n                    next_node = over_route[pos]\n\n                    cost_increase = (distance_matrix[prev_node][customer] +\n                                   distance_matrix[customer][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                    if cost_increase < best_cost:\n                        best_cost = cost_increase\n                        best_route = over_idx\n                        best_pos = pos\n\n            if best_route is not None:\n                # Reallocate customer\n                over_route = selected_solution[best_route]\n                new_over_route = np.concatenate([over_route[:best_pos], [customer], over_route[best_pos:]])\n                selected_solution[best_route] = new_over_route\n\n                # Remove customer from underutilized route\n                new_under_route = np.array([0] + [c for c in under_route[1:-1] if c != customer] + [0])\n                selected_solution[under_idx] = new_under_route\n\n                # Update demands\n                route_demands[best_route] += demand[customer]\n                route_demands[under_idx] -= demand[customer]\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    # Check capacity constraints\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return archive_sorted[0][0].copy()\n\n    return selected_solution\n\n",
          "score": [
               -0.8150995873411835,
               0.2339048683643341
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive and applying route modifications, but introduces a novel approach called \"Adaptive Route Rebalancing\" that dynamically identifies overloaded and underloaded routes, then redistributes customers between them by solving a constrained optimization problem that simultaneously minimizes distance increase while maximizing load balance, using a hybrid of greedy and simulated annealing techniques to explore the solution space while ensuring feasibility through capacity-aware perturbations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest makespan (potential for rebalancing)\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def route_load(route):\n        return np.sum(demand[route[1:-1]])\n\n    def route_distance(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    # Identify overloaded and underloaded routes\n    loads = [route_load(route) for route in new_solution]\n    avg_load = np.mean(loads)\n    overloaded = [i for i, load in enumerate(loads) if load > avg_load * 1.2]\n    underloaded = [i for i, load in enumerate(loads) if load < avg_load * 0.8]\n\n    if not overloaded or not underloaded:\n        return new_solution\n\n    # Try to redistribute customers between routes\n    for src_idx in overloaded:\n        src_route = new_solution[src_idx]\n        customers = src_route[1:-1]\n\n        # Find best customer to move\n        best_customer = None\n        best_dest = None\n        best_improvement = 0\n\n        for customer in customers:\n            for dest_idx in underloaded:\n                dest_route = new_solution[dest_idx]\n                if route_load(dest_route) + demand[customer] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                original_dist = route_distance(src_route) + route_distance(dest_route)\n\n                # Simulate move\n                temp_src = np.concatenate([src_route[:np.where(src_route == customer)[0][0]],\n                                         src_route[np.where(src_route == customer)[0][0]+1:]])\n                temp_dest = np.concatenate([dest_route[:-1], [customer], [0]])\n\n                new_dist = route_distance(temp_src) + route_distance(temp_dest)\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_customer = customer\n                    best_dest = dest_idx\n\n        if best_customer is not None:\n            # Perform the move\n            src_route = new_solution[src_idx]\n            dest_route = new_solution[best_dest]\n\n            # Remove customer from source route\n            mask = src_route != best_customer\n            new_solution[src_idx] = src_route[mask]\n\n            # Add customer to destination route\n            new_solution[best_dest] = np.concatenate([dest_route[:-1], [best_customer], [0]])\n\n            # Update loads and break after first improvement\n            loads = [route_load(route) for route in new_solution]\n            overloaded = [i for i, load in enumerate(loads) if load > avg_load * 1.2]\n            underloaded = [i for i, load in enumerate(loads) if load < avg_load * 0.8]\n            break\n\n    # Additional local improvements with simulated annealing\n    current_temp = 100\n    cooling_rate = 0.99\n    min_temp = 1\n\n    while current_temp > min_temp:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Try to swap two customers between routes\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random customers (excluding depot)\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Check capacity constraints\n            load_i = route_load(route_i) - demand[cust_i] + demand[cust_j]\n            load_j = route_load(route_j) - demand[cust_j] + demand[cust_i]\n\n            if load_i <= capacity and load_j <= capacity:\n                # Calculate potential improvement\n                original_dist = route_distance(route_i) + route_distance(route_j)\n\n                # Create new routes\n                new_route_i = route_i.copy()\n                new_route_i[np.where(new_route_i == cust_i)[0][0]] = cust_j\n\n                new_route_j = route_j.copy()\n                new_route_j[np.where(new_route_j == cust_j)[0][0]] = cust_i\n\n                new_dist = route_distance(new_route_i) + route_distance(new_route_j)\n                delta = new_dist - original_dist\n\n                # Accept if improvement or with probability\n                if delta < 0 or np.random.random() < np.exp(-delta / current_temp):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n        current_temp *= cooling_rate\n\n    return new_solution\n\n",
          "score": [
               -0.789865212513206,
               0.1571863293647766
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Demand-Driven Route Segmentation,\" first selects a solution from the archive by prioritizing those with the highest total distance and highest makespan, indicating potential for significant improvement in both objectives. It then analyzes the demand patterns across all routes and identifies segments of customers with similar demand profiles that can be strategically relocated or merged. The operator dynamically segments routes based on cumulative demand thresholds, creating new routes by extracting segments that form compact spatial clusters while ensuring capacity constraints are met. It then evaluates multiple insertion points across all existing routes, selecting the combination that maximizes the reduction in total distance while maintaining or improving the makespan. If no beneficial relocation is found, it attempts to merge two shortest routes if their combined demand is within capacity limits, creating a more efficient route configuration. The operator dynamically adjusts its segmentation strategy based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis and demand-driven segmentation to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and lengths\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n\n    # Find routes with similar demand patterns\n    demand_threshold = capacity * 0.3\n    similar_routes = []\n    for i in range(len(selected_solution)):\n        for j in range(i+1, len(selected_solution)):\n            if abs(route_demands[i] - route_demands[j]) <= demand_threshold:\n                similar_routes.append((i, j))\n\n    # Try merging similar routes if possible\n    for i, j in similar_routes:\n        if route_demands[i] + route_demands[j] <= capacity:\n            route1 = selected_solution[i]\n            route2 = selected_solution[j]\n\n            # Create merged route by combining both routes\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Create new solution\n            new_solution = [route for idx, route in enumerate(selected_solution) if idx not in [i, j]]\n            new_solution.append(new_route)\n\n            # Check if this improves both objectives\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            total_distance = sum(new_route_lengths)\n            makespan = max(new_route_lengths)\n\n            if total_distance < archive_sorted[0][1][0] or makespan < archive_sorted[0][1][1]:\n                return new_solution\n\n    # If merging didn't work, try demand-driven segmentation\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        customers = route[1:-1]\n\n        # Sort customers by demand\n        sorted_indices = np.argsort(demand[customers])\n        sorted_customers = customers[sorted_indices]\n\n        # Find segments with similar demand\n        segment_size = max(2, len(sorted_customers) // 3)\n        for i in range(len(sorted_customers) - segment_size + 1):\n            segment = sorted_customers[i:i+segment_size]\n            segment_demand = sum(demand[segment])\n\n            if segment_demand > capacity:\n                continue\n\n            # Find best insertion point in other routes\n            best_insertion = None\n            best_improvement = 0\n\n            for target_idx in range(len(selected_solution)):\n                if target_idx == route_idx:\n                    continue\n                target_route = selected_solution[target_idx]\n\n                if sum(demand[target_route[1:-1]]) + segment_demand > capacity:\n                    continue\n\n                # Calculate potential improvement\n                original_length = sum(distance_matrix[route[:-1], route[1:]])\n                new_route = np.concatenate([route[:i+1], route[i+segment_size+1:]])\n                new_length = sum(distance_matrix[new_route[:-1], new_route[1:]])\n\n                improvement = original_length - new_length\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insertion = (target_idx, segment)\n\n            if best_insertion is not None:\n                target_idx, segment = best_insertion\n                new_route = selected_solution[route_idx].copy()\n                new_route = np.concatenate([new_route[:i+1], new_route[i+segment_size+1:]])\n\n                new_target_route = np.concatenate([selected_solution[target_idx][:-1], segment, [0]])\n\n                new_solution = selected_solution.copy()\n                new_solution[route_idx] = new_route\n                new_solution[target_idx] = new_target_route\n\n                # Check if this improves both objectives\n                new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                total_distance = sum(new_route_lengths)\n                makespan = max(new_route_lengths)\n\n                if total_distance < archive_sorted[0][1][0] or makespan < archive_sorted[0][1][1]:\n                    return new_solution\n\n    # If no improvement found, try creating new route from compact cluster\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        customers = route[1:-1]\n\n        # Find most compact cluster of customers\n        min_spread = float('inf')\n        best_cluster = None\n\n        for i in range(len(customers)):\n            for j in range(i+1, len(customers)):\n                cluster = customers[i:j+1]\n                cluster_demand = sum(demand[cluster])\n\n                if cluster_demand > capacity:\n                    continue\n\n                # Calculate spatial spread\n                max_dist = 0\n                for node1 in cluster:\n                    for node2 in cluster:\n                        if node1 != node2:\n                            dist = distance_matrix[node1][node2]\n                            if dist > max_dist:\n                                max_dist = dist\n\n                if max_dist < min_spread:\n                    min_spread = max_dist\n                    best_cluster = cluster\n\n        if best_cluster is not None:\n            new_route = np.concatenate([[0], best_cluster, [0]])\n            new_solution = selected_solution.copy()\n            new_route_idx = np.where(np.array(selected_solution) == route)[0][0]\n            new_solution[new_route_idx] = np.array([0] + [c for c in route[1:-1] if c not in best_cluster] + [0])\n            new_solution.append(new_route)\n\n            # Check if this improves both objectives\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            total_distance = sum(new_route_lengths)\n            makespan = max(new_route_lengths)\n\n            if total_distance < archive_sorted[0][1][0] or makespan < archive_sorted[0][1][1]:\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8397238862188635,
               0.31893083453178406
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive but introduces a novel approach that combines route fragmentation and adaptive segment reassembly. It first identifies the most diverse solutions in the archive based on both objective values and spatial distribution of routes, then applies a fragmentation-based local search where long routes are systematically broken into smaller segments, each evaluated for potential reassembly with other segments or routes to form more balanced configurations. The reassembly process prioritizes spatial proximity and demand complementarity, while maintaining feasibility, to create solutions that simultaneously reduce total distance through route consolidation and improve makespan through better load balancing. The algorithm dynamically adjusts the fragmentation granularity based on the current solution's characteristics, allowing it to adaptively explore both local and global improvements.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse characteristics\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    diversity_scores = (total_distances - np.mean(total_distances))**2 + (makespans - np.mean(makespans))**2\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def fragment_route(route, min_fragment_size=3):\n        fragments = []\n        current_fragment = [route[0]]\n        current_load = 0\n\n        for node in route[1:-1]:\n            current_load += demand[node]\n            current_fragment.append(node)\n\n            if len(current_fragment) >= min_fragment_size and current_load <= capacity:\n                if np.random.random() < 0.7 or current_load > 0.8 * capacity:\n                    fragments.append(np.array(current_fragment + [0]))\n                    current_fragment = [0]\n                    current_load = 0\n\n        if len(current_fragment) > 1:\n            fragments.append(np.array(current_fragment + [0]))\n\n        return fragments if len(fragments) > 1 else [route]\n\n    def reassemble_fragments(fragments):\n        reassembled = []\n        remaining = [frag for frag in fragments]\n\n        while remaining:\n            current_route = [0]\n            current_load = 0\n            added = False\n\n            for i, frag in enumerate(remaining):\n                frag_load = np.sum(demand[frag[1:-1]])\n                if current_load + frag_load <= capacity:\n                    current_route.extend(frag[1:-1])\n                    current_load += frag_load\n                    remaining.pop(i)\n                    added = True\n                    break\n\n            if not added:\n                if len(current_route) > 1:\n                    reassembled.append(np.array(current_route + [0]))\n                remaining.pop(0)\n\n            if len(current_route) > 1:\n                reassembled.append(np.array(current_route + [0]))\n\n        return reassembled if reassembled else fragments\n\n    # Perform fragmentation and reassembly\n    all_fragments = []\n    for route in new_solution:\n        fragments = fragment_route(route)\n        all_fragments.extend(fragments)\n\n    new_solution = reassemble_fragments(all_fragments)\n\n    # Additional local improvements\n    improved = True\n    max_iter = 50\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Try to merge adjacent fragments\n        if len(new_solution) > 1:\n            i = np.random.randint(0, len(new_solution))\n            j = (i + 1) % len(new_solution)\n\n            merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if is_feasible(merged):\n                new_route_length = route_length(merged)\n                original_length = route_length(new_solution[i]) + route_length(new_solution[j])\n\n                if new_route_length < original_length * 0.95:\n                    new_solution[i] = merged\n                    del new_solution[j]\n                    improved = True\n\n        # Try to move a customer between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if len(new_solution[i]) > 3 and len(new_solution[j]) > 2:\n                customer_idx = np.random.randint(1, len(new_solution[i]) - 1)\n                customer = new_solution[i][customer_idx]\n\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_dist = route_length(new_solution[i]) + route_length(new_solution[j])\n                    new_i = np.concatenate([new_solution[i][:customer_idx], new_solution[i][customer_idx+1:]])\n                    new_j = np.concatenate([new_solution[j][:-1], [customer], [0]])\n\n                    new_dist = route_length(new_i) + route_length(new_j)\n\n                    if new_dist < original_dist * 0.98:\n                        new_solution[i] = new_i\n                        new_solution[j] = new_j\n                        improved = True\n\n    return new_solution\n\n",
          "score": [
               -0.9048805479347265,
               1.5466918349266052
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Demand-Aware Route Segmentation with Spatial Rebalancing,\" first selects a solution with the highest total distance from the archive to identify routes with spatial inefficiency, then segments long routes at strategic demand-based breakpoints while simultaneously rebalancing shorter routes by strategically inserting high-demand nodes from other routes, ensuring capacity constraints are maintained through a novel spatial-demand trade-off mechanism that prioritizes both route length reduction and demand distribution improvement, resulting in a feasible neighbor solution that significantly reduces total distance while maintaining balanced makespan.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Find the longest route in the solution\n    longest_route = max(selected_solution, key=lambda x: len(x))\n\n    if len(longest_route) <= 3:  # Route is just [0, customer, 0]\n        return selected_solution\n\n    # Find the best segmentation point based on demand and spatial balance\n    customers = longest_route[1:-1]\n    best_split_idx = -1\n    best_split_score = float('inf')\n\n    # Calculate total demand and spatial center\n    total_demand = sum(demand[customers])\n    center_x = np.mean(coords[customers, 0])\n    center_y = np.mean(coords[customers, 1])\n\n    for i in range(1, len(customers)):\n        first_part = customers[:i]\n        second_part = customers[i:]\n\n        # Calculate demand balance\n        demand_diff = abs(sum(demand[first_part]) - sum(demand[second_part]))\n\n        # Calculate spatial balance\n        first_center_x = np.mean(coords[first_part, 0])\n        first_center_y = np.mean(coords[first_part, 1])\n        second_center_x = np.mean(coords[second_part, 0])\n        second_center_y = np.mean(coords[second_part, 1])\n\n        spatial_diff = np.sqrt((first_center_x - center_x)**2 + (first_center_y - center_y)**2) + \\\n                      np.sqrt((second_center_x - center_x)**2 + (second_center_y - center_y)**2)\n\n        # Combine scores (lower is better)\n        current_score = demand_diff + spatial_diff\n\n        if current_score < best_split_score:\n            best_split_score = current_score\n            best_split_idx = i\n\n    if best_split_score == float('inf'):\n        return selected_solution\n\n    # Split the longest route at the best point\n    first_part = np.concatenate([[0], customers[:best_split_idx], [0]])\n    second_part = np.concatenate([[0], customers[best_split_idx:], [0]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return selected_solution\n\n    # Create new solution with the split routes\n    new_solution = [route for route in selected_solution if not np.array_equal(route, longest_route)]\n    new_solution.extend([first_part, second_part])\n\n    # Rebalance routes by moving high-demand nodes between routes\n    high_demand_nodes = [node for node in customers if demand[node] > capacity * 0.3]\n\n    for node in high_demand_nodes:\n        # Find the route containing this node\n        source_route_idx = next(i for i, route in enumerate(new_solution) if node in route[1:-1])\n        source_route = new_solution[source_route_idx]\n\n        # Try to move this node to another route\n        for target_route in new_solution:\n            if np.array_equal(target_route, source_route):\n                continue\n\n            # Check if adding the node to target route is feasible\n            if sum(demand[target_route[1:-1]]) + demand[node] <= capacity:\n                # Remove node from source route\n                new_source = np.array([x for x in source_route if x != node])\n                if len(new_source) == 2:  # Only [0, 0] left\n                    new_solution.remove(source_route)\n                else:\n                    new_solution[new_solution.index(source_route)] = new_source\n\n                # Add node to target route (insert at position that minimizes distance increase)\n                target_customers = target_route[1:-1]\n                best_insert_pos = 1\n                best_insert_cost = float('inf')\n\n                for i in range(len(target_customers) + 1):\n                    # Calculate insertion cost\n                    if i == 0:\n                        cost = distance_matrix[0][node] + distance_matrix[node][target_customers[0]] - distance_matrix[0][target_customers[0]]\n                    elif i == len(target_customers):\n                        cost = distance_matrix[target_customers[-1]][node] + distance_matrix[node][0] - distance_matrix[target_customers[-1]][0]\n                    else:\n                        cost = distance_matrix[target_customers[i-1]][node] + distance_matrix[node][target_customers[i]] - distance_matrix[target_customers[i-1]][target_customers[i]]\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = i\n\n                # Insert the node\n                new_target = np.concatenate([\n                    target_route[:best_insert_pos+1],\n                    [node],\n                    target_route[best_insert_pos+1:]\n                ])\n                new_solution[new_solution.index(target_route)] = new_target\n\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.8623756269075378,
               0.5302450060844421
          ]
     }
]