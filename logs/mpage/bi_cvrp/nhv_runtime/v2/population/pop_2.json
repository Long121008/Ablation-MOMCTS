[
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route splitting and customer reinsertion with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and attempts to split it into two routes by relocating a segment of customers to a new route, ensuring capacity constraints are met. If splitting is infeasible, it performs a customer reinsertion by removing a customer from the shortest route and inserting it into another route, choosing the insertion position that minimizes the increase in total distance while maintaining the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try to split the shortest route into two\n    for i in range(1, len(shortest_route) - 1):\n        first_part = shortest_route[:i+1]\n        second_part = np.concatenate([[0], shortest_route[i+1:]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[shortest_route_idx] = first_part\n            new_solution.append(second_part)\n\n            # Check if this improves the makespan\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) <= max(route_lengths):\n                return new_solution\n\n    # If splitting didn't work, try reinserting a customer from the shortest route\n    if len(selected_solution) > 1:\n        # Find another route to insert into\n        for target_route_idx in range(len(selected_solution)):\n            if target_route_idx == shortest_route_idx:\n                continue\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Try moving each customer from shortest route to target route\n            for customer in shortest_route[1:-1]:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_increase = float('inf')\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_pos = pos\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_shortest_route = np.delete(shortest_route, np.where(shortest_route == customer)[0][0])\n                    new_target_route = np.insert(target_route, best_pos, customer)\n\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    new_solution[target_route_idx] = new_target_route\n\n                    # Check if this improves the makespan\n                    new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                    if max(new_route_lengths) <= max(route_lengths):\n                        return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8236050826838496,
               0.12729865312576294
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive but introduces a novel approach that combines route fragmentation and adaptive segment reassembly. It first identifies the most diverse solutions in the archive based on both objective values and spatial distribution of routes, then applies a fragmentation-based local search where long routes are systematically broken into smaller segments, each evaluated for potential reassembly with other segments or routes to form more balanced configurations. The reassembly process prioritizes spatial proximity and demand complementarity, while maintaining feasibility, to create solutions that simultaneously reduce total distance through route consolidation and improve makespan through better load balancing. The algorithm dynamically adjusts the fragmentation granularity based on the current solution's characteristics, allowing it to adaptively explore both local and global improvements.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse characteristics\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    diversity_scores = (total_distances - np.mean(total_distances))**2 + (makespans - np.mean(makespans))**2\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def fragment_route(route, min_fragment_size=3):\n        fragments = []\n        current_fragment = [route[0]]\n        current_load = 0\n\n        for node in route[1:-1]:\n            current_load += demand[node]\n            current_fragment.append(node)\n\n            if len(current_fragment) >= min_fragment_size and current_load <= capacity:\n                if np.random.random() < 0.7 or current_load > 0.8 * capacity:\n                    fragments.append(np.array(current_fragment + [0]))\n                    current_fragment = [0]\n                    current_load = 0\n\n        if len(current_fragment) > 1:\n            fragments.append(np.array(current_fragment + [0]))\n\n        return fragments if len(fragments) > 1 else [route]\n\n    def reassemble_fragments(fragments):\n        reassembled = []\n        remaining = [frag for frag in fragments]\n\n        while remaining:\n            current_route = [0]\n            current_load = 0\n            added = False\n\n            for i, frag in enumerate(remaining):\n                frag_load = np.sum(demand[frag[1:-1]])\n                if current_load + frag_load <= capacity:\n                    current_route.extend(frag[1:-1])\n                    current_load += frag_load\n                    remaining.pop(i)\n                    added = True\n                    break\n\n            if not added:\n                if len(current_route) > 1:\n                    reassembled.append(np.array(current_route + [0]))\n                remaining.pop(0)\n\n            if len(current_route) > 1:\n                reassembled.append(np.array(current_route + [0]))\n\n        return reassembled if reassembled else fragments\n\n    # Perform fragmentation and reassembly\n    all_fragments = []\n    for route in new_solution:\n        fragments = fragment_route(route)\n        all_fragments.extend(fragments)\n\n    new_solution = reassemble_fragments(all_fragments)\n\n    # Additional local improvements\n    improved = True\n    max_iter = 50\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Try to merge adjacent fragments\n        if len(new_solution) > 1:\n            i = np.random.randint(0, len(new_solution))\n            j = (i + 1) % len(new_solution)\n\n            merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if is_feasible(merged):\n                new_route_length = route_length(merged)\n                original_length = route_length(new_solution[i]) + route_length(new_solution[j])\n\n                if new_route_length < original_length * 0.95:\n                    new_solution[i] = merged\n                    del new_solution[j]\n                    improved = True\n\n        # Try to move a customer between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if len(new_solution[i]) > 3 and len(new_solution[j]) > 2:\n                customer_idx = np.random.randint(1, len(new_solution[i]) - 1)\n                customer = new_solution[i][customer_idx]\n\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_dist = route_length(new_solution[i]) + route_length(new_solution[j])\n                    new_i = np.concatenate([new_solution[i][:customer_idx], new_solution[i][customer_idx+1:]])\n                    new_j = np.concatenate([new_solution[j][:-1], [customer], [0]])\n\n                    new_dist = route_length(new_i) + route_length(new_j)\n\n                    if new_dist < original_dist * 0.98:\n                        new_solution[i] = new_i\n                        new_solution[j] = new_j\n                        improved = True\n\n    return new_solution\n\n",
          "score": [
               -0.9048805479347265,
               1.5466918349266052
          ]
     },
     {
          "algorithm": "{The algorithm first intelligently selects a promising solution from the archive by identifying those with low total distance and makespan, then applies a hybrid local search operator that combines route merging, customer reallocation, and a novel \"route balancing\" step to reduce both objectives. Route merging combines short routes to save distance, while customer reallocation redistributes demand to balance loads, and route balancing adjusts route lengths by iteratively moving customers between routes to minimize the maximum route length. The method ensures feasibility by checking capacity constraints at each step and uses a probabilistic acceptance criterion to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with low total distance and makespan\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route merging (combine short routes to reduce total distance)\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) + len(new_solution[j]) - 2 <= 10:  # Limit route length\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    # Check if merging improves total distance\n                    original_dist = distance_matrix[new_solution[i][-2], 0] + distance_matrix[new_solution[j][1], 0]\n                    merged_dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]\n                    if merged_dist < original_dist:\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    # Step 2: Customer reallocation (redistribute customers to balance loads)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        current_load = np.sum(demand[route[1:-1]])\n        if current_load < capacity * 0.7:  # If route is underutilized\n            for other_route in new_solution:\n                if len(other_route) <= 3 or other_route is route:\n                    continue\n                # Try to move a customer from other_route to this route\n                for i in range(1, len(other_route) - 1):\n                    customer = other_route[i]\n                    new_load = current_load + demand[customer]\n                    if new_load <= capacity:\n                        # Check if moving improves makespan\n                        original_dist = distance_matrix[other_route[i-1], other_route[i]] + distance_matrix[other_route[i], other_route[i+1]]\n                        new_dist = distance_matrix[other_route[i-1], other_route[i+1]] + distance_matrix[route[-2], customer] + distance_matrix[customer, 0]\n                        if new_dist < original_dist:\n                            # Perform the move\n                            route[-1] = customer\n                            route = np.append(route, 0)\n                            other_route = np.delete(other_route, i)\n                            current_load = new_load\n                            break\n\n    # Step 3: Route balancing (adjust route lengths to minimize makespan)\n    if len(new_solution) > 1:\n        max_route = max(new_solution, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n        min_route = min(new_solution, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n        if max_route is not min_route:\n            # Try to move a customer from max_route to min_route\n            for i in range(1, len(max_route) - 1):\n                customer = max_route[i]\n                if np.sum(demand[min_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_max_dist = np.sum(distance_matrix[max_route[:-1], max_route[1:]])\n                    new_max_dist = original_max_dist - distance_matrix[max_route[i-1], max_route[i]] - distance_matrix[max_route[i], max_route[i+1]] + distance_matrix[max_route[i-1], max_route[i+1]]\n                    new_min_dist = np.sum(distance_matrix[min_route[:-1], min_route[1:]]) + distance_matrix[min_route[-2], customer] + distance_matrix[customer, 0]\n                    if new_max_dist < original_max_dist and new_min_dist < np.sum(distance_matrix[max_route[:-1], max_route[1:]]):\n                        # Perform the move\n                        min_route[-1] = customer\n                        min_route = np.append(min_route, 0)\n                        max_route = np.delete(max_route, i)\n                        break\n\n    # Ensure solution is feasible and non-empty\n    if not new_solution:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7722103387038257,
               0.3427191376686096
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Fission,\" first selects a promising solution from the archive by prioritizing those with high total distance and low makespan, indicating potential for balancing route lengths. It then randomly selects two routes from this solution and attempts to merge them by inserting a \"bridge\" node (a customer not in either route) between them, ensuring capacity constraints are met. If merging is infeasible, it instead splits one route into two by finding a high-demand node and dividing the route around it, ensuring both new routes stay within capacity. The strategy dynamically adjusts the bridge or split point based on demand and distance to improve both objectives, yielding a feasible neighbor solution with potentially reduced total distance and more balanced makespan.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy() if len(archive_sorted) > 1 else archive_sorted[0][0].copy()\n\n    # Choose two distinct routes to attempt fusion or fission\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n    route1 = selected_solution[route1_idx].copy()\n    route2 = selected_solution[route2_idx].copy()\n\n    # Attempt Route Fusion: Try to merge route1 and route2 via a bridge node\n    all_customers = set(range(1, len(coords)))\n    used_customers = set()\n    for route in selected_solution:\n        used_customers.update(route[1:-1])  # Exclude depot\n    available_bridges = list(all_customers - used_customers)\n\n    if available_bridges:\n        # Sort bridges by demand (ascending) to prefer smaller bridges\n        available_bridges.sort(key=lambda x: demand[x])\n        for bridge in available_bridges:\n            # Check if adding bridge to route1 or route2 is feasible\n            total_demand_route1 = sum(demand[route1[1:-1]])\n            total_demand_route2 = sum(demand[route2[1:-1]])\n            if total_demand_route1 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route1 and depot\n                new_route = np.concatenate([route1[:-1], [bridge], route2[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n            if total_demand_route2 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route2 and depot\n                new_route = np.concatenate([route2[:-1], [bridge], route1[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n\n    # If fusion failed, attempt Route Fission: Split a route into two\n    # Choose the route with the highest demand (potential for better split)\n    route_to_split = max(selected_solution, key=lambda x: sum(demand[x[1:-1]]))\n    customers_in_route = route_to_split[1:-1]\n    if len(customers_in_route) < 2:\n        return selected_solution\n\n    # Find the best split point (high demand node)\n    best_split_idx = -1\n    best_split_demand = -1\n    for i, node in enumerate(customers_in_route):\n        if demand[node] > best_split_demand:\n            best_split_demand = demand[node]\n            best_split_idx = i\n\n    if best_split_idx != -1:\n        # Split the route at best_split_idx\n        first_part = np.concatenate([[0], customers_in_route[:best_split_idx+1], [0]])\n        second_part = np.concatenate([[0], customers_in_route[best_split_idx+1:], [0]])\n\n        # Check capacity constraints\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution = [route for route in selected_solution if not np.array_equal(route, route_to_split)]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    return selected_solution\n\n",
          "score": [
               -0.7668818254597687,
               0.17718800902366638
          ]
     },
     {
          "algorithm": "{The function begins by selecting a promising solution from the archive using a weighted random selection based on the normalized ranks of the solutions' total distance and makespan, favoring solutions with lower objective values. It then applies a hybrid local search strategy that combines route splitting, cross-exchange, and adaptive 3-opt moves, where route splitting dynamically divides long routes into smaller segments if they exceed a capacity threshold, cross-exchange swaps segments between routes while ensuring feasibility, and adaptive 3-opt selectively reorders nodes in critical segments based on their impact on the makespan. The strategy prioritizes reducing the makespan by focusing on the longest route while minimizing total distance through segment swaps and reordering. After each operation, feasibility is verified by checking vehicle capacities and route continuity, and the process repeats until no further improvements are found or a maximum iteration limit is reached. The final solution is returned as a list of feasible routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weights\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_dist = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-6)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-6)\n    weights = 0.5 * norm_dist + 0.5 * norm_makespan\n    selected_idx = np.random.choice(len(archive), p=weights / np.sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search strategy\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def split_route(route):\n        # Split a route into two if it exceeds capacity\n        if not is_feasible(route):\n            total_demand = np.sum(demand[route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_pos = i\n                    break\n            return [np.concatenate([route[:split_pos], [0]]), np.concatenate([[0], route[split_pos:]])]\n        return [route]\n\n    def cross_exchange(route1, route2):\n        # Cross-exchange between two routes\n        if len(route1) <= 2 or len(route2) <= 2:\n            return route1, route2\n\n        # Find segments to swap\n        i = np.random.randint(1, len(route1) - 1)\n        j = np.random.randint(1, len(route2) - 1)\n\n        # Perform cross-exchange\n        new_route1 = np.concatenate([route1[:i], route2[j:-1], route1[i:]])\n        new_route2 = np.concatenate([route2[:j], route1[i:-1], route2[j:]])\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            return new_route1, new_route2\n        return route1, route2\n\n    def adaptive_3opt(route):\n        # Adaptive 3-opt for makespan reduction\n        if len(route) <= 4:\n            return route\n\n        # Identify critical segments (top 20% longest edges)\n        edges = distance_matrix[route[:-1], route[1:]]\n        sorted_indices = np.argsort(edges)[::-1]\n        critical_indices = sorted_indices[:max(2, len(sorted_indices) // 5)]\n\n        for i in critical_indices:\n            if i + 2 >= len(route) - 1:\n                continue\n            # Try 3-opt move\n            a, b, c, d = route[i], route[i+1], route[i+2], route[i+3]\n            new_route = np.concatenate([route[:i], [a, c, b, d], route[i+3:]])\n            if is_feasible(new_route):\n                return new_route\n        return route\n\n    # Perform local search\n    improved = True\n    max_iter = 100\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Step 1: Split long routes\n        new_solution_split = []\n        for route in new_solution:\n            split_routes = split_route(route)\n            if len(split_routes) > 1:\n                improved = True\n            new_solution_split.extend(split_routes)\n        new_solution = new_solution_split\n\n        # Step 2: Cross-exchange between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = cross_exchange(new_solution[i], new_solution[j])\n            if not np.array_equal(route1, new_solution[i]) or not np.array_equal(route2, new_solution[j]):\n                improved = True\n                new_solution[i] = route1\n                new_solution[j] = route2\n\n        # Step 3: Adaptive 3-opt on longest route\n        if len(new_solution) > 0:\n            lengths = [route_length(route) for route in new_solution]\n            longest_idx = np.argmax(lengths)\n            new_route = adaptive_3opt(new_solution[longest_idx])\n            if not np.array_equal(new_route, new_solution[longest_idx]):\n                improved = True\n                new_solution[longest_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.7953106808011949,
               2.653059244155884
          ]
     },
     {
          "algorithm": "{The proposed local search algorithm combines a multi-objective-aware route splitting and merging heuristic with a demand-aware node reinsertion strategy. First, it intelligently selects a solution from the archive by prioritizing those with high total distance or makespan, as these often contain suboptimal route structures ripe for improvement. Then, it applies a hybrid operator: (1) a demand-based route splitting step that divides overloaded routes by identifying demand clusters and inserting depot nodes at strategic points to create feasible sub-routes, and (2) a node reinsertion step that selectively removes nodes from long routes and reinserts them into other routes while ensuring capacity constraints and minimizing both total distance and makespan. The algorithm dynamically balances these operations based on the current solution's characteristics, using a probabilistic approach to explore promising neighborhoods while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (either high total distance or makespan)\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split and reinsert nodes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Check for overloaded routes\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # Split the route at a point that minimizes demand imbalance\n            best_split = None\n            min_imbalance = float('inf')\n\n            for j in range(1, len(route)-1):\n                left_demand = sum(demand[node] for node in route[1:j+1])\n                right_demand = sum(demand[node] for node in route[j+1:-1])\n\n                imbalance = abs(left_demand - right_demand)\n                if imbalance < min_imbalance and left_demand <= capacity and right_demand <= capacity:\n                    min_imbalance = imbalance\n                    best_split = j\n\n            if best_split is not None:\n                # Split the route\n                new_route1 = np.concatenate([[0], route[1:best_split+1], [0]])\n                new_route2 = np.concatenate([[0], route[best_split+1:], [0]])\n\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n\n    # Node reinsertion to balance routes\n    for _ in range(2):  # Perform multiple reinsertion attempts\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) <= 3:\n            continue\n\n        # Select a node to remove (not the first or last)\n        node_to_remove = random.choice(longest_route[1:-1])\n        node_pos = np.where(longest_route == node_to_remove)[0][0]\n\n        # Remove the node\n        new_route = np.concatenate([longest_route[:node_pos], longest_route[node_pos+1:]])\n        new_solution[longest_route_idx] = new_route\n\n        # Try to reinsert into other routes\n        best_insertion = None\n        min_cost_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n\n            route = new_solution[i]\n            if sum(demand[node] for node in route[1:-1]) + demand[node_to_remove] > capacity:\n                continue\n\n            for j in range(len(route)-1):\n                # Calculate insertion cost\n                prev_node = route[j]\n                next_node = route[j+1]\n\n                cost_increase = distance_matrix[prev_node][node_to_remove] + \\\n                               distance_matrix[node_to_remove][next_node] - \\\n                               distance_matrix[prev_node][next_node]\n\n                if cost_increase < min_cost_increase:\n                    min_cost_increase = cost_increase\n                    best_insertion = (i, j, node_to_remove)\n\n        if best_insertion is not None:\n            route_idx, pos, node = best_insertion\n            route = new_solution[route_idx]\n            new_route = np.concatenate([route[:pos+1], [node], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.7167531560876585,
               0.30838292837142944
          ]
     },
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route reversal and segment relocation with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and reverses the order of its customers to explore alternative paths, while also attempting to relocate a segment of customers from this route to another route if it leads to a better balance between total distance and makespan. The operator carefully checks capacity constraints at each step to ensure feasibility and dynamically adjusts its parameters based on the current solution's characteristics to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    shortest_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try route reversal\n    reversed_route = np.concatenate([shortest_route[:1], shortest_route[-2:0:-1], shortest_route[-1:]])\n    if sum(demand[reversed_route[1:-1]]) <= capacity:\n        new_solution = selected_solution.copy()\n        new_solution[shortest_route_idx] = reversed_route\n        return new_solution\n\n    # Try segment relocation if reversal didn't work\n    for i in range(len(selected_solution)):\n        if i == shortest_route_idx:\n            continue\n        target_route = selected_solution[i].copy()\n\n        for j in range(1, len(shortest_route) - 1):\n            segment = shortest_route[j:]\n            segment_demand = sum(demand[segment[:-1]])\n\n            if sum(demand[target_route[:-1]]) + segment_demand <= capacity:\n                new_shortest_route = np.concatenate([shortest_route[:j], [0]])\n                new_target_route = np.concatenate([target_route[:-1], segment])\n\n                new_solution = selected_solution.copy()\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[i] = new_target_route\n\n                if all(sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                    return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.7510077600425422,
               0.5220215618610382
          ]
     },
     {
          "algorithm": "{The proposed algorithm for selecting a neighbor solution and applying a novel local search strategy involves first identifying the most promising solution from the archive by evaluating a composite score that balances the trade-off between total distance and makespan, then applying a hybrid local search that combines route splitting with adaptive 2-opt moves, where the selection of customers to swap is biased towards those contributing the most to the makespan, ensuring feasibility by always checking vehicle capacity constraints before accepting any move. The algorithm also incorporates a probabilistic acceptance criterion based on the potential improvement in both objectives, allowing for occasional uphill moves to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (either high total distance or makespan)\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging with adaptive node swapping\n    for _ in range(3):  # Multiple iterations for better exploration\n        # Find two routes with the smallest total demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i])\n\n        # Try merging the two smallest routes if their combined demand is within capacity\n        if len(sorted_indices) >= 2:\n            i, j = sorted_indices[0], sorted_indices[1]\n            if i > j:\n                i, j = j, i\n\n            combined_demand = route_demands[i] + route_demands[j]\n            if combined_demand <= capacity:\n                route1, route2 = new_solution[i], new_solution[j]\n\n                # Find the best merge point by minimizing distance increase\n                best_merge = None\n                min_cost_increase = float('inf')\n\n                for pos1 in range(1, len(route1)-1):\n                    for pos2 in range(1, len(route2)-1):\n                        # Calculate cost of merging\n                        cost_increase = (distance_matrix[route1[pos1-1]][route2[pos2]] +\n                                        distance_matrix[route2[pos2-1]][route1[pos1]] -\n                                        distance_matrix[route1[pos1-1]][route1[pos1]] -\n                                        distance_matrix[route2[pos2-1]][route2[pos2]])\n\n                        if cost_increase < min_cost_increase:\n                            min_cost_increase = cost_increase\n                            best_merge = (pos1, pos2)\n\n                if best_merge is not None:\n                    pos1, pos2 = best_merge\n                    merged_route = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n\n        # Adaptive node swapping between routes\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find nodes with high demand in route1 and low demand in route2\n            route1_nodes = route1[1:-1]\n            route2_nodes = route2[1:-1]\n\n            route1_demands = demand[route1_nodes]\n            route2_demands = demand[route2_nodes]\n\n            high_demand_nodes = route1_nodes[route1_demands > np.mean(route1_demands)]\n            low_demand_nodes = route2_nodes[route2_demands < np.mean(route2_demands)]\n\n            if len(high_demand_nodes) > 0 and len(low_demand_nodes) > 0:\n                node1 = random.choice(high_demand_nodes)\n                node2 = random.choice(low_demand_nodes)\n\n                # Check if swapping would violate capacity\n                route1_demand = sum(demand[route1[1:-1]])\n                route2_demand = sum(demand[route2[1:-1]])\n\n                if (route1_demand - demand[node1] + demand[node2] <= capacity and\n                    route2_demand - demand[node2] + demand[node1] <= capacity):\n\n                    # Perform the swap\n                    pos1 = np.where(route1 == node1)[0][0]\n                    pos2 = np.where(route2 == node2)[0][0]\n\n                    route1[pos1], route2[pos2] = route2[pos2], route1[pos1]\n\n    return new_solution\n\n",
          "score": [
               -0.631907589373353,
               0.2649620771408081
          ]
     },
     {
          "algorithm": "{The novel local search strategy combines a randomized route segmentation with a demand-aware insertion heuristic, where selected segments of routes are temporarily removed and reinserted using a greedy approach that prioritizes both distance reduction and load balance, while ensuring feasibility through capacity checks. The algorithm first identifies promising routes in the archive by selecting those with below-average makespan, then randomly segments these routes into smaller segments, removes them, and reinserts them into the most suitable positions in other routes or as new routes, ensuring no vehicle capacity is exceeded and the total distance is minimized while balancing the makespan across routes. The strategy dynamically adapts the segment size and insertion criteria based on the current solution's characteristics to explore diverse neighborhoods effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = [obj[1] for _, obj in archive]\n    avg_makespan = np.mean(makespans)\n    candidates = [sol for sol, obj in archive if obj[1] <= avg_makespan]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Randomly segment the route into smaller segments\n        if len(selected_route) > 3:  # At least depot + 2 nodes + depot\n            segment_start = random.randint(1, len(selected_route) - 2)\n            segment_end = random.randint(segment_start + 1, len(selected_route) - 1)\n            segment = selected_route[segment_start:segment_end]\n\n            # Remove the segment from the route\n            new_route = np.concatenate([selected_route[:segment_start], selected_route[segment_end:]])\n            new_solution[route_idx] = new_route\n\n            # Calculate the total demand of the segment\n            segment_demand = np.sum(demand[segment])\n\n            # Find the best insertion position for the segment in other routes or as a new route\n            best_insertion = None\n            best_score = float('inf')\n\n            # Try inserting into other routes\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                for pos in range(1, len(route)):\n                    # Check if insertion is feasible\n                    if np.sum(demand[route[1:-1]]) + segment_demand <= capacity:\n                        # Calculate the insertion cost\n                        prev_node = route[pos - 1]\n                        next_node = route[pos]\n                        insertion_cost = (distance_matrix[prev_node][segment[0]] +\n                                        np.sum(distance_matrix[segment[:-1], segment[1:]]) +\n                                        distance_matrix[segment[-1]][next_node] -\n                                        distance_matrix[prev_node][next_node])\n                        if insertion_cost < best_score:\n                            best_score = insertion_cost\n                            best_insertion = (i, pos)\n\n            # If no feasible insertion found, create a new route\n            if best_insertion is None:\n                new_route = np.concatenate([[0], segment, [0]])\n                if np.sum(demand[segment]) <= capacity:\n                    new_solution.append(new_route)\n            else:\n                i, pos = best_insertion\n                new_route = np.concatenate([new_solution[i][:pos], segment, new_solution[i][pos:]])\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.4505370099045217,
               0.5841662585735321
          ]
     },
     {
          "algorithm": "{The proposed algorithm for selecting a neighbor solution and applying a novel local search strategy involves first identifying the most promising solution from the archive by evaluating a composite score that balances the trade-off between total distance and makespan, then applying a hybrid local search that combines route splitting with adaptive 2-opt moves, where the selection of customers to swap is biased towards those contributing the most to the makespan, ensuring feasibility by always checking vehicle capacity constraints before accepting any move. The algorithm also incorporates a probabilistic acceptance criterion based on the potential improvement in both objectives, allowing for occasional uphill moves to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting with adaptive 2-opt\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Adaptive 2-opt: select nodes contributing most to makespan\n        route_distances = [distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)]\n        total_route_distance = sum(route_distances)\n        makespan_contributions = [d / total_route_distance for d in route_distances]\n        candidates = sorted(range(len(makespan_contributions)), key=lambda i: makespan_contributions[i], reverse=True)\n\n        # Try swapping top contributors\n        for i in candidates[:min(3, len(candidates))]:\n            if i + 1 >= len(route) - 1:\n                continue\n            a, b = i, i + 1\n            for j in candidates[:min(3, len(candidates))]:\n                if j + 1 >= len(route) - 1 or j == i:\n                    continue\n                c, d = j, j + 1\n\n                # Check if swap is feasible\n                new_route = route.copy()\n                new_route[a+1], new_route[c+1] = new_route[c+1], new_route[a+1]\n\n                # Check capacity constraint\n                current_load = 0\n                valid = True\n                for node in new_route[1:-1]:\n                    current_load += demand[node]\n                    if current_load > capacity:\n                        valid = False\n                        break\n\n                if valid:\n                    new_solution[route_idx] = new_route\n                    break\n\n        # Try route splitting if makespan is too high\n        if len(route) > 4 and total_route_distance > 1.5 * np.mean([sum([distance_matrix[r[i]][r[i+1]] for i in range(len(r)-1)]) for r in new_solution]):\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = route[:split_pos+1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity for both new routes\n            load1 = sum(demand[new_route1[1:-1]])\n            load2 = sum(demand[new_route2[1:-1]])\n\n            if load1 <= capacity and load2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    return new_solution\n\n",
          "score": [
               -0.732965499971339,
               2.763285130262375
          ]
     }
]