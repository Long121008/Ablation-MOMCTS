[
     {
          "algorithm": "{The function begins by selecting a promising solution from the archive using a weighted random selection based on the normalized ranks of the solutions' total distance and makespan, favoring solutions with lower objective values. It then applies a hybrid local search strategy that combines route splitting, cross-exchange, and adaptive 3-opt moves, where route splitting dynamically divides long routes into smaller segments if they exceed a capacity threshold, cross-exchange swaps segments between routes while ensuring feasibility, and adaptive 3-opt selectively reorders nodes in critical segments based on their impact on the makespan. The strategy prioritizes reducing the makespan by focusing on the longest route while minimizing total distance through segment swaps and reordering. After each operation, feasibility is verified by checking vehicle capacities and route continuity, and the process repeats until no further improvements are found or a maximum iteration limit is reached. The final solution is returned as a list of feasible routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weights\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_dist = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-6)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-6)\n    weights = 0.5 * norm_dist + 0.5 * norm_makespan\n    selected_idx = np.random.choice(len(archive), p=weights / np.sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search strategy\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def split_route(route):\n        # Split a route into two if it exceeds capacity\n        if not is_feasible(route):\n            total_demand = np.sum(demand[route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_pos = i\n                    break\n            return [np.concatenate([route[:split_pos], [0]]), np.concatenate([[0], route[split_pos:]])]\n        return [route]\n\n    def cross_exchange(route1, route2):\n        # Cross-exchange between two routes\n        if len(route1) <= 2 or len(route2) <= 2:\n            return route1, route2\n\n        # Find segments to swap\n        i = np.random.randint(1, len(route1) - 1)\n        j = np.random.randint(1, len(route2) - 1)\n\n        # Perform cross-exchange\n        new_route1 = np.concatenate([route1[:i], route2[j:-1], route1[i:]])\n        new_route2 = np.concatenate([route2[:j], route1[i:-1], route2[j:]])\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            return new_route1, new_route2\n        return route1, route2\n\n    def adaptive_3opt(route):\n        # Adaptive 3-opt for makespan reduction\n        if len(route) <= 4:\n            return route\n\n        # Identify critical segments (top 20% longest edges)\n        edges = distance_matrix[route[:-1], route[1:]]\n        sorted_indices = np.argsort(edges)[::-1]\n        critical_indices = sorted_indices[:max(2, len(sorted_indices) // 5)]\n\n        for i in critical_indices:\n            if i + 2 >= len(route) - 1:\n                continue\n            # Try 3-opt move\n            a, b, c, d = route[i], route[i+1], route[i+2], route[i+3]\n            new_route = np.concatenate([route[:i], [a, c, b, d], route[i+3:]])\n            if is_feasible(new_route):\n                return new_route\n        return route\n\n    # Perform local search\n    improved = True\n    max_iter = 100\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Step 1: Split long routes\n        new_solution_split = []\n        for route in new_solution:\n            split_routes = split_route(route)\n            if len(split_routes) > 1:\n                improved = True\n            new_solution_split.extend(split_routes)\n        new_solution = new_solution_split\n\n        # Step 2: Cross-exchange between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = cross_exchange(new_solution[i], new_solution[j])\n            if not np.array_equal(route1, new_solution[i]) or not np.array_equal(route2, new_solution[j]):\n                improved = True\n                new_solution[i] = route1\n                new_solution[j] = route2\n\n        # Step 3: Adaptive 3-opt on longest route\n        if len(new_solution) > 0:\n            lengths = [route_length(route) for route in new_solution]\n            longest_idx = np.argmax(lengths)\n            new_route = adaptive_3opt(new_solution[longest_idx])\n            if not np.array_equal(new_route, new_solution[longest_idx]):\n                improved = True\n                new_solution[longest_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.7953106808011949,
               2.653059244155884
          ]
     },
     {
          "algorithm": "{The algorithm first intelligently selects a promising solution from the archive by identifying those with low total distance and makespan, then applies a hybrid local search operator that combines route merging, customer reallocation, and a novel \"route balancing\" step to reduce both objectives. Route merging combines short routes to save distance, while customer reallocation redistributes demand to balance loads, and route balancing adjusts route lengths by iteratively moving customers between routes to minimize the maximum route length. The method ensures feasibility by checking capacity constraints at each step and uses a probabilistic acceptance criterion to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with low total distance and makespan\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route merging (combine short routes to reduce total distance)\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) + len(new_solution[j]) - 2 <= 10:  # Limit route length\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    # Check if merging improves total distance\n                    original_dist = distance_matrix[new_solution[i][-2], 0] + distance_matrix[new_solution[j][1], 0]\n                    merged_dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]\n                    if merged_dist < original_dist:\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    # Step 2: Customer reallocation (redistribute customers to balance loads)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        current_load = np.sum(demand[route[1:-1]])\n        if current_load < capacity * 0.7:  # If route is underutilized\n            for other_route in new_solution:\n                if len(other_route) <= 3 or other_route is route:\n                    continue\n                # Try to move a customer from other_route to this route\n                for i in range(1, len(other_route) - 1):\n                    customer = other_route[i]\n                    new_load = current_load + demand[customer]\n                    if new_load <= capacity:\n                        # Check if moving improves makespan\n                        original_dist = distance_matrix[other_route[i-1], other_route[i]] + distance_matrix[other_route[i], other_route[i+1]]\n                        new_dist = distance_matrix[other_route[i-1], other_route[i+1]] + distance_matrix[route[-2], customer] + distance_matrix[customer, 0]\n                        if new_dist < original_dist:\n                            # Perform the move\n                            route[-1] = customer\n                            route = np.append(route, 0)\n                            other_route = np.delete(other_route, i)\n                            current_load = new_load\n                            break\n\n    # Step 3: Route balancing (adjust route lengths to minimize makespan)\n    if len(new_solution) > 1:\n        max_route = max(new_solution, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n        min_route = min(new_solution, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n        if max_route is not min_route:\n            # Try to move a customer from max_route to min_route\n            for i in range(1, len(max_route) - 1):\n                customer = max_route[i]\n                if np.sum(demand[min_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_max_dist = np.sum(distance_matrix[max_route[:-1], max_route[1:]])\n                    new_max_dist = original_max_dist - distance_matrix[max_route[i-1], max_route[i]] - distance_matrix[max_route[i], max_route[i+1]] + distance_matrix[max_route[i-1], max_route[i+1]]\n                    new_min_dist = np.sum(distance_matrix[min_route[:-1], min_route[1:]]) + distance_matrix[min_route[-2], customer] + distance_matrix[customer, 0]\n                    if new_max_dist < original_max_dist and new_min_dist < np.sum(distance_matrix[max_route[:-1], max_route[1:]]):\n                        # Perform the move\n                        min_route[-1] = customer\n                        min_route = np.append(min_route, 0)\n                        max_route = np.delete(max_route, i)\n                        break\n\n    # Ensure solution is feasible and non-empty\n    if not new_solution:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7722103387038257,
               0.3427191376686096
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Fission,\" first selects a promising solution from the archive by prioritizing those with high total distance and low makespan, indicating potential for balancing route lengths. It then randomly selects two routes from this solution and attempts to merge them by inserting a \"bridge\" node (a customer not in either route) between them, ensuring capacity constraints are met. If merging is infeasible, it instead splits one route into two by finding a high-demand node and dividing the route around it, ensuring both new routes stay within capacity. The strategy dynamically adjusts the bridge or split point based on demand and distance to improve both objectives, yielding a feasible neighbor solution with potentially reduced total distance and more balanced makespan.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy() if len(archive_sorted) > 1 else archive_sorted[0][0].copy()\n\n    # Choose two distinct routes to attempt fusion or fission\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n    route1 = selected_solution[route1_idx].copy()\n    route2 = selected_solution[route2_idx].copy()\n\n    # Attempt Route Fusion: Try to merge route1 and route2 via a bridge node\n    all_customers = set(range(1, len(coords)))\n    used_customers = set()\n    for route in selected_solution:\n        used_customers.update(route[1:-1])  # Exclude depot\n    available_bridges = list(all_customers - used_customers)\n\n    if available_bridges:\n        # Sort bridges by demand (ascending) to prefer smaller bridges\n        available_bridges.sort(key=lambda x: demand[x])\n        for bridge in available_bridges:\n            # Check if adding bridge to route1 or route2 is feasible\n            total_demand_route1 = sum(demand[route1[1:-1]])\n            total_demand_route2 = sum(demand[route2[1:-1]])\n            if total_demand_route1 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route1 and depot\n                new_route = np.concatenate([route1[:-1], [bridge], route2[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n            if total_demand_route2 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route2 and depot\n                new_route = np.concatenate([route2[:-1], [bridge], route1[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n\n    # If fusion failed, attempt Route Fission: Split a route into two\n    # Choose the route with the highest demand (potential for better split)\n    route_to_split = max(selected_solution, key=lambda x: sum(demand[x[1:-1]]))\n    customers_in_route = route_to_split[1:-1]\n    if len(customers_in_route) < 2:\n        return selected_solution\n\n    # Find the best split point (high demand node)\n    best_split_idx = -1\n    best_split_demand = -1\n    for i, node in enumerate(customers_in_route):\n        if demand[node] > best_split_demand:\n            best_split_demand = demand[node]\n            best_split_idx = i\n\n    if best_split_idx != -1:\n        # Split the route at best_split_idx\n        first_part = np.concatenate([[0], customers_in_route[:best_split_idx+1], [0]])\n        second_part = np.concatenate([[0], customers_in_route[best_split_idx+1:], [0]])\n\n        # Check capacity constraints\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution = [route for route in selected_solution if not np.array_equal(route, route_to_split)]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    return selected_solution\n\n",
          "score": [
               -0.7668818254597687,
               0.17718800902366638
          ]
     },
     {
          "algorithm": "{The proposed algorithm for selecting a neighbor solution and applying a novel local search strategy involves first identifying the most promising solution from the archive by evaluating a composite score that balances the trade-off between total distance and makespan, then applying a hybrid local search that combines route splitting with adaptive 2-opt moves, where the selection of customers to swap is biased towards those contributing the most to the makespan, ensuring feasibility by always checking vehicle capacity constraints before accepting any move. The algorithm also incorporates a probabilistic acceptance criterion based on the potential improvement in both objectives, allowing for occasional uphill moves to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting with adaptive 2-opt\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Adaptive 2-opt: select nodes contributing most to makespan\n        route_distances = [distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)]\n        total_route_distance = sum(route_distances)\n        makespan_contributions = [d / total_route_distance for d in route_distances]\n        candidates = sorted(range(len(makespan_contributions)), key=lambda i: makespan_contributions[i], reverse=True)\n\n        # Try swapping top contributors\n        for i in candidates[:min(3, len(candidates))]:\n            if i + 1 >= len(route) - 1:\n                continue\n            a, b = i, i + 1\n            for j in candidates[:min(3, len(candidates))]:\n                if j + 1 >= len(route) - 1 or j == i:\n                    continue\n                c, d = j, j + 1\n\n                # Check if swap is feasible\n                new_route = route.copy()\n                new_route[a+1], new_route[c+1] = new_route[c+1], new_route[a+1]\n\n                # Check capacity constraint\n                current_load = 0\n                valid = True\n                for node in new_route[1:-1]:\n                    current_load += demand[node]\n                    if current_load > capacity:\n                        valid = False\n                        break\n\n                if valid:\n                    new_solution[route_idx] = new_route\n                    break\n\n        # Try route splitting if makespan is too high\n        if len(route) > 4 and total_route_distance > 1.5 * np.mean([sum([distance_matrix[r[i]][r[i+1]] for i in range(len(r)-1)]) for r in new_solution]):\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = route[:split_pos+1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity for both new routes\n            load1 = sum(demand[new_route1[1:-1]])\n            load2 = sum(demand[new_route2[1:-1]])\n\n            if load1 <= capacity and load2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    return new_solution\n\n",
          "score": [
               -0.732965499971339,
               2.763285130262375
          ]
     },
     {
          "algorithm": "{The proposed local search algorithm combines a multi-objective-aware route splitting and merging heuristic with a demand-aware node reinsertion strategy. First, it intelligently selects a solution from the archive by prioritizing those with high total distance or makespan, as these often contain suboptimal route structures ripe for improvement. Then, it applies a hybrid operator: (1) a demand-based route splitting step that divides overloaded routes by identifying demand clusters and inserting depot nodes at strategic points to create feasible sub-routes, and (2) a node reinsertion step that selectively removes nodes from long routes and reinserts them into other routes while ensuring capacity constraints and minimizing both total distance and makespan. The algorithm dynamically balances these operations based on the current solution's characteristics, using a probabilistic approach to explore promising neighborhoods while maintaining feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (either high total distance or makespan)\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split and reinsert nodes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Check for overloaded routes\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # Split the route at a point that minimizes demand imbalance\n            best_split = None\n            min_imbalance = float('inf')\n\n            for j in range(1, len(route)-1):\n                left_demand = sum(demand[node] for node in route[1:j+1])\n                right_demand = sum(demand[node] for node in route[j+1:-1])\n\n                imbalance = abs(left_demand - right_demand)\n                if imbalance < min_imbalance and left_demand <= capacity and right_demand <= capacity:\n                    min_imbalance = imbalance\n                    best_split = j\n\n            if best_split is not None:\n                # Split the route\n                new_route1 = np.concatenate([[0], route[1:best_split+1], [0]])\n                new_route2 = np.concatenate([[0], route[best_split+1:], [0]])\n\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n\n    # Node reinsertion to balance routes\n    for _ in range(2):  # Perform multiple reinsertion attempts\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) <= 3:\n            continue\n\n        # Select a node to remove (not the first or last)\n        node_to_remove = random.choice(longest_route[1:-1])\n        node_pos = np.where(longest_route == node_to_remove)[0][0]\n\n        # Remove the node\n        new_route = np.concatenate([longest_route[:node_pos], longest_route[node_pos+1:]])\n        new_solution[longest_route_idx] = new_route\n\n        # Try to reinsert into other routes\n        best_insertion = None\n        min_cost_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n\n            route = new_solution[i]\n            if sum(demand[node] for node in route[1:-1]) + demand[node_to_remove] > capacity:\n                continue\n\n            for j in range(len(route)-1):\n                # Calculate insertion cost\n                prev_node = route[j]\n                next_node = route[j+1]\n\n                cost_increase = distance_matrix[prev_node][node_to_remove] + \\\n                               distance_matrix[node_to_remove][next_node] - \\\n                               distance_matrix[prev_node][next_node]\n\n                if cost_increase < min_cost_increase:\n                    min_cost_increase = cost_increase\n                    best_insertion = (i, j, node_to_remove)\n\n        if best_insertion is not None:\n            route_idx, pos, node = best_insertion\n            route = new_solution[route_idx]\n            new_route = np.concatenate([route[:pos+1], [node], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.7167531560876585,
               0.30838292837142944
          ]
     },
     {
          "algorithm": "{The algorithm selects a promising solution from the archive by first ranking solutions based on a combined objective score, calculated as the weighted sum of normalized total distance and makespan, where weights are inversely proportional to the range of each objective. It then applies a hybrid local search operator that combines route merging and split insertion, where routes are merged if their combined demand fits within capacity, and split insertion involves removing a segment from one route and inserting it into another while ensuring feasibility. The selected solution is probabilistically chosen based on the combined score, and the hybrid operator is applied to generate a neighbor solution that balances distance and makespan reduction.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on combined objective score\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    min_dist, max_dist = np.min(total_distances), np.max(total_distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    if max_dist == min_dist:\n        norm_dist = np.zeros_like(total_distances)\n    else:\n        norm_dist = (total_distances - min_dist) / (max_dist - min_dist)\n\n    if max_makespan == min_makespan:\n        norm_makespan = np.zeros_like(makespans)\n    else:\n        norm_makespan = (makespans - min_makespan) / (max_makespan - min_makespan)\n\n    # Weighted sum of normalized objectives (inverse weights)\n    weights = np.array([0.5, 0.5])  # Equal weight for simplicity\n    combined_scores = weights[0] * norm_dist + weights[1] * norm_makespan\n\n    # Select solution with lowest combined score (best balance)\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: route merging + split insertion\n    new_solution = selected_solution.copy()\n\n    # Try route merging\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Try split insertion\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least 3 nodes to split (depot, customer, depot)\n            # Select a random segment to move\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n\n            segment = route[start:end]\n            remaining_route = np.concatenate([route[:start], route[end:]])\n\n            # Try inserting segment into another route\n            for other_idx in range(len(new_solution)):\n                if other_idx == route_idx:\n                    continue\n\n                other_route = new_solution[other_idx]\n                # Find insertion points\n                for pos in range(1, len(other_route)):\n                    # Insert segment into other_route at position pos\n                    new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                    # Check feasibility\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[route_idx] = remaining_route\n                        new_solution[other_idx] = new_route\n                        break\n\n    return new_solution\n\n",
          "score": [
               -0.6689573601547063,
               0.7467630207538605
          ]
     },
     {
          "algorithm": "{The novel local search strategy combines a randomized route segmentation with a demand-aware insertion heuristic, where selected segments of routes are temporarily removed and reinserted using a greedy approach that prioritizes both distance reduction and load balance, while ensuring feasibility through capacity checks. The algorithm first identifies promising routes in the archive by selecting those with below-average makespan, then randomly segments these routes into smaller segments, removes them, and reinserts them into the most suitable positions in other routes or as new routes, ensuring no vehicle capacity is exceeded and the total distance is minimized while balancing the makespan across routes. The strategy dynamically adapts the segment size and insertion criteria based on the current solution's characteristics to explore diverse neighborhoods effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    avg_makespan = np.mean(makespans)\n    candidates = [sol for sol, obj in archive if obj[1] <= avg_makespan]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Randomly segment the route into smaller segments\n        if len(selected_route) > 3:  # At least depot + 2 nodes + depot\n            segment_start = random.randint(1, len(selected_route) - 2)\n            segment_end = random.randint(segment_start + 1, len(selected_route) - 1)\n            segment = selected_route[segment_start:segment_end]\n\n            # Remove the segment from the route\n            new_route = np.concatenate([selected_route[:segment_start], selected_route[segment_end:]])\n            new_solution[route_idx] = new_route\n\n            # Calculate the total demand of the segment\n            segment_demand = np.sum(demand[segment])\n\n            # Find the best insertion position for the segment in other routes or as a new route\n            best_insertion = None\n            best_score = float('inf')\n\n            # Try inserting into other routes\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                for pos in range(1, len(route)):\n                    # Check if insertion is feasible\n                    if np.sum(demand[route[1:-1]]) + segment_demand <= capacity:\n                        # Calculate the insertion cost\n                        prev_node = route[pos - 1]\n                        next_node = route[pos]\n                        insertion_cost = (distance_matrix[prev_node][segment[0]] +\n                                        np.sum(distance_matrix[segment[:-1], segment[1:]]) +\n                                        distance_matrix[segment[-1]][next_node] -\n                                        distance_matrix[prev_node][next_node])\n                        if insertion_cost < best_score:\n                            best_score = insertion_cost\n                            best_insertion = (i, pos)\n\n            # If no feasible insertion found, create a new route\n            if best_insertion is None:\n                new_route = np.concatenate([[0], segment, [0]])\n                if np.sum(demand[segment]) <= capacity:\n                    new_solution.append(new_route)\n            else:\n                i, pos = best_insertion\n                new_route = np.concatenate([new_solution[i][:pos], segment, new_solution[i][pos:]])\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.4505370099045217,
               0.5841662585735321
          ]
     },
     {
          "algorithm": "{The novel hybrid local search operator first intelligently selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a combination of route merging and segment reversal with feasibility checks to generate a neighbor solution. It identifies the longest route in the selected solution and attempts to merge it with another route by relocating a segment of customers from the longest route to the end of a shorter route, ensuring capacity constraints are met. If merging is infeasible, it performs a segment reversal within the longest route to reduce its length and improve the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the longest route\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Try to merge with another route\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = selected_solution[i].copy()\n\n        # Find a segment in the longest route to move\n        for j in range(1, len(longest_route) - 1):\n            segment = longest_route[j:]\n            segment_demand = sum(demand[segment[:-1]])\n\n            # Check if the segment can be added to the other route\n            if sum(demand[other_route[:-1]]) + segment_demand <= capacity:\n                # Create new routes\n                new_longest_route = np.concatenate([longest_route[:j], [0]])\n                new_other_route = np.concatenate([other_route[:-1], segment])\n\n                # Update solution\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution[i] = new_other_route\n\n                # Check feasibility\n                if all(sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                    return new_solution\n\n    # If merging didn't work, try segment reversal in the longest route\n    for j in range(1, len(longest_route) - 2):\n        reversed_segment = longest_route[j:-1][::-1]\n        new_route = np.concatenate([longest_route[:j], reversed_segment, [0]])\n\n        # Check capacity constraint\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_route\n            return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.5867437185259752,
               1.5572326481342316
          ]
     },
     {
          "algorithm": "{The function first selects a promising solution from the archive by identifying the one with the lowest makespan, as it likely has routes that are not overly long and may contain inefficiencies that can be optimized. It then applies a hybrid local search operator that combines route merging and customer reallocation to balance the makespan and total distance. Specifically, it randomly selects two routes, merges them into a single route if feasible, and then redistributes customers between the remaining routes to improve the makespan while minimizing the total distance. If merging is not feasible, it instead reallocates customers between routes by moving a customer from a long route to a shorter one, ensuring capacity constraints are respected. The neighbor solution is generated by applying the most beneficial transformation found during this process, ensuring feasibility and potentially improving both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Calculate total demand of merged route\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        # Try merging the two routes if feasible\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove the two routes and add the merged one\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n        else:\n            # If merging is not feasible, try reallocating a customer from a long route to a short one\n            # Identify the longest and shortest routes\n            route_lengths = [sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n            longest_idx = np.argmax(route_lengths)\n            shortest_idx = np.argmin(route_lengths)\n\n            if longest_idx != shortest_idx:\n                long_route = new_solution[longest_idx]\n                short_route = new_solution[shortest_idx]\n\n                # Find a customer to move from long_route to short_route\n                for customer in long_route[1:-1]:\n                    if sum(demand[short_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into short_route (random position)\n                        insert_pos = random.randint(1, len(short_route)-1)\n                        short_route = np.insert(short_route, insert_pos, customer)\n                        long_route = np.delete(long_route, np.where(long_route == customer)[0][0])\n\n                        # Update the solution\n                        new_solution[shortest_idx] = short_route\n                        new_solution[longest_idx] = long_route\n                        break\n\n    return new_solution\n\n",
          "score": [
               -0.5731379216207272,
               3.3867177069187164
          ]
     },
     {
          "algorithm": "{The novel hybrid local search algorithm combines route fragmentation with cross-route insertion and capacity-aware route merging to generate neighbors. It first randomly selects a solution from the archive with a probability inversely proportional to its makespan, favoring solutions with shorter longest routes. Then, it splits a randomly chosen route into two segments at a customer node, ensuring both segments can be served by separate vehicles without exceeding capacity. Next, it identifies the most promising insertion points in other routes for the split segment, prioritizing locations that minimize the increase in total distance while maintaining feasibility. Finally, it merges the best insertion candidate back into the original solution, creating a new neighbor that balances distance and makespan objectives by reducing the longest route while intelligently reallocating customers. The algorithm carefully checks capacity constraints at each step to ensure feasibility, and it dynamically adjusts its parameters based on the current solution's characteristics to explore diverse neighborhoods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_makespan = sum(obj[1] for _, obj in archive)\n    probs = [1 - (obj[1] / total_makespan) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to split\n    if len(base_solution) < 2:\n        return base_solution.copy()\n\n    route_idx = random.randint(0, len(base_solution) - 1)\n    route = base_solution[route_idx]\n\n    # Find a split point that maintains capacity constraints\n    valid_splits = []\n    for i in range(1, len(route) - 1):\n        segment1 = route[:i+1]\n        segment2 = [0] + route[i+1:]\n\n        # Check capacity constraints\n        if (sum(demand[segment1]) <= capacity and\n            sum(demand[segment2]) <= capacity):\n            valid_splits.append(i)\n\n    if not valid_splits:\n        return base_solution.copy()\n\n    split_point = random.choice(valid_splits)\n    segment = route[split_point:]\n\n    # Find best insertion points in other routes\n    best_insertion = None\n    best_cost_increase = float('inf')\n    best_route_idx = -1\n\n    for i, other_route in enumerate(base_solution):\n        if i == route_idx:\n            continue\n\n        for j in range(1, len(other_route)):\n            # Try inserting segment before j\n            new_route = np.concatenate([other_route[:j], segment, other_route[j:]])\n\n            if sum(demand[new_route]) > capacity:\n                continue\n\n            # Calculate cost increase\n            cost_increase = (distance_matrix[segment[-1], other_route[j]] +\n                           distance_matrix[other_route[j-1], segment[0]] -\n                           distance_matrix[other_route[j-1], other_route[j]])\n\n            if cost_increase < best_cost_increase:\n                best_cost_increase = cost_increase\n                best_insertion = new_route\n                best_route_idx = i\n\n    if best_insertion is not None:\n        # Create new solution\n        new_solution = base_solution.copy()\n        new_solution[route_idx] = route[:split_point] + [0] if split_point > 0 else [0]\n        new_solution[best_route_idx] = best_insertion\n\n        # Remove empty routes\n        new_solution = [r for r in new_solution if len(r) > 2 or (len(r) == 2 and r[0] == 0 and r[1] == 0)]\n\n        return new_solution\n\n    return base_solution.copy()\n\n",
          "score": [
               -0.5319310820257193,
               2.2146174907684326
          ]
     }
]