[
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route splitting and customer reinsertion with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and attempts to split it into two routes by relocating a segment of customers to a new route, ensuring capacity constraints are met. If splitting is infeasible, it performs a customer reinsertion by removing a customer from the shortest route and inserting it into another route, choosing the insertion position that minimizes the increase in total distance while maintaining the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try to split the shortest route into two\n    for i in range(1, len(shortest_route) - 1):\n        first_part = shortest_route[:i+1]\n        second_part = np.concatenate([[0], shortest_route[i+1:]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[shortest_route_idx] = first_part\n            new_solution.append(second_part)\n\n            # Check if this improves the makespan\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) <= max(route_lengths):\n                return new_solution\n\n    # If splitting didn't work, try reinserting a customer from the shortest route\n    if len(selected_solution) > 1:\n        # Find another route to insert into\n        for target_route_idx in range(len(selected_solution)):\n            if target_route_idx == shortest_route_idx:\n                continue\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Try moving each customer from shortest route to target route\n            for customer in shortest_route[1:-1]:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_increase = float('inf')\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_pos = pos\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_shortest_route = np.delete(shortest_route, np.where(shortest_route == customer)[0][0])\n                    new_target_route = np.insert(target_route, best_pos, customer)\n\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    new_solution[target_route_idx] = new_target_route\n\n                    # Check if this improves the makespan\n                    new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                    if max(new_route_lengths) <= max(route_lengths):\n                        return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8236050826838496,
               0.12729865312576294
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Multi-Objective Route Balancing and Diversification,\" first selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, indicating potential for improving makespan while maintaining or reducing total distance. It then identifies the longest route in the solution and attempts to redistribute its customers to other routes by strategically inserting segments at positions that minimize the increase in total distance and balance the makespan across all routes. If redistribution is infeasible, it creates a new route by extracting a segment of customers from the longest route that forms a compact cluster in space, ensuring the new route's makespan is below the current average makespan. The operator dynamically adjusts the segment size and insertion points based on spatial proximity and demand patterns to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives while maintaining feasibility through careful capacity checks and spatial analysis.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and makespan\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    makespan = max(route_lengths)\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Try to redistribute customers from the longest route to other routes\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n        target_route = selected_solution[i].copy()\n\n        # Find the best segment to move (minimize distance increase)\n        best_segment = None\n        best_increase = float('inf')\n\n        for j in range(1, len(longest_route) - 1):\n            segment = longest_route[j:]\n            segment_demand = sum(demand[segment[:-1]])\n\n            if sum(demand[target_route[:-1]]) + segment_demand <= capacity:\n                # Calculate potential increase in total distance\n                insert_positions = range(1, len(target_route))\n                for pos in insert_positions:\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    first_node = segment[0]\n                    last_node = segment[-2]\n\n                    distance_increase = (distance_matrix[prev_node][first_node] +\n                                        distance_matrix[last_node][next_node] -\n                                        distance_matrix[prev_node][next_node])\n\n                    if distance_increase < best_increase:\n                        best_increase = distance_increase\n                        best_segment = (j, segment)\n\n        if best_segment is not None:\n            j, segment = best_segment\n            new_longest_route = np.concatenate([longest_route[:j], [0]])\n            new_target_route = np.concatenate([target_route[:-1], segment])\n\n            # Check makespan improvement\n            new_longest_length = sum(distance_matrix[new_longest_route[:-1], new_longest_route[1:]])\n            new_target_length = sum(distance_matrix[new_target_route[:-1], new_target_route[1:]])\n\n            if max(new_longest_length, new_target_length) < makespan:\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution[i] = new_target_route\n                return new_solution\n\n    # If redistribution failed, try creating a new route from a compact segment\n    if len(longest_route) > 3:  # Need at least 2 customers to form a new route\n        # Find the most compact segment (minimize spatial spread)\n        min_spread = float('inf')\n        best_segment = None\n\n        for j in range(1, len(longest_route) - 2):\n            for k in range(j + 1, len(longest_route) - 1):\n                segment = longest_route[j:k+1]\n                segment_nodes = segment[:-1]\n                segment_demand = sum(demand[segment_nodes])\n\n                if segment_demand > capacity:\n                    continue\n\n                # Calculate spatial spread (max distance between any two nodes in segment)\n                max_dist = 0\n                for node1 in segment_nodes:\n                    for node2 in segment_nodes:\n                        if node1 != node2:\n                            dist = distance_matrix[node1][node2]\n                            if dist > max_dist:\n                                max_dist = dist\n\n                if max_dist < min_spread:\n                    min_spread = max_dist\n                    best_segment = (j, k, segment)\n\n        if best_segment is not None:\n            j, k, segment = best_segment\n            new_longest_route = np.concatenate([longest_route[:j], longest_route[k+1:]])\n            new_route = np.concatenate([[0], segment, [0]])\n\n            # Check makespan improvement\n            new_longest_length = sum(distance_matrix[new_longest_route[:-1], new_longest_route[1:]])\n            new_route_length = sum(distance_matrix[new_route[:-1], new_route[1:]])\n\n            if max(new_longest_length, new_route_length) < makespan:\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution.append(new_route)\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8520311510008584,
               0.3980441987514496
          ]
     },
     {
          "algorithm": "{The novel \"Route Reconstruction and Demand Harmonization\" algorithm first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, indicating potential for route optimization. It then reconstructs routes by iteratively removing the longest route and redistributing its customers to other routes using a \"demand-aware\" insertion heuristic that minimizes both the increase in total distance and the deviation from an ideal load balance. The algorithm dynamically adjusts the insertion points based on demand proximity and spatial clustering to create balanced routes, while ensuring feasibility through strict capacity checks. If redistribution fails, it attempts to create new routes by grouping spatially close, low-demand customers. The method combines these steps in a probabilistic framework to explore diverse neighborhoods while maintaining solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers_to_reinsert = longest_route[1:-1]\n\n    # Remove the longest route\n    del new_solution[longest_route_idx]\n\n    # Sort customers by demand (ascending) to prioritize smaller customers\n    customers_to_reinsert = sorted(customers_to_reinsert, key=lambda x: demand[x])\n\n    # Calculate ideal load per route (excluding the longest route)\n    remaining_capacity = capacity * len(new_solution)\n    ideal_load = remaining_capacity / len(new_solution)\n\n    # Reinsert customers into existing routes\n    for customer in customers_to_reinsert:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        for i, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                insertion_cost = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                # Calculate load deviation from ideal\n                current_load = sum(demand[route[1:-1]])\n                new_load = current_load + demand[customer]\n                load_dev = abs(new_load - ideal_load)\n\n                # Combine cost and load deviation\n                total_cost = insertion_cost + 0.1 * load_dev\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            # Insert the customer\n            route = new_solution[best_route_idx]\n            new_route = np.insert(route, best_position, customer)\n            new_solution[best_route_idx] = new_route\n\n    # If some customers couldn't be reinserted, create new routes\n    remaining_customers = [c for c in customers_to_reinsert if c not in [node for route in new_solution for node in route[1:-1]]]\n    if remaining_customers:\n        # Group remaining customers by spatial proximity and low demand\n        remaining_customers = sorted(remaining_customers, key=lambda x: demand[x])\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            for i, customer in enumerate(remaining_customers):\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    break\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
          "score": [
               -0.9619479325462242,
               1.234698325395584
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Adaptive Route Clustering with Demand-Based Merging,\" first selects the solution with the highest makespan from the archive to identify the most imbalanced route, then dynamically clusters customers into new routes based on their demand profiles, ensuring capacity constraints are maintained through a novel demand-aware merging process that prioritizes spatial proximity and demand compatibility, while adaptively adjusting cluster boundaries to balance route lengths and minimize total distance, resulting in a feasible neighbor solution that significantly reduces makespan while improving overall route efficiency.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    # Sort unassigned customers by demand (descending) and then by distance to depot\n    unassigned_customers.sort(key=lambda x: (-demand[x], distance_matrix[0][x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            if len(current_route) > 1:  # Avoid adding empty routes\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    # Combine with existing routes\n    new_solution = selected_solution + new_routes\n\n    return new_solution\n\n",
          "score": [
               -0.7911038221089215,
               0.11675745248794556
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Demand-Driven Route Segmentation,\" first selects a solution from the archive by prioritizing those with the highest total distance and highest makespan, indicating potential for significant improvement in both objectives. It then analyzes the demand patterns across all routes and identifies segments of customers with similar demand profiles that can be strategically relocated or merged. The operator dynamically segments routes based on cumulative demand thresholds, creating new routes by extracting segments that form compact spatial clusters while ensuring capacity constraints are met. It then evaluates multiple insertion points across all existing routes, selecting the combination that maximizes the reduction in total distance while maintaining or improving the makespan. If no beneficial relocation is found, it attempts to merge two shortest routes if their combined demand is within capacity limits, creating a more efficient route configuration. The operator dynamically adjusts its segmentation strategy based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis and demand-driven segmentation to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and lengths\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n\n    # Find routes with similar demand patterns\n    demand_threshold = capacity * 0.3\n    similar_routes = []\n    for i in range(len(selected_solution)):\n        for j in range(i+1, len(selected_solution)):\n            if abs(route_demands[i] - route_demands[j]) <= demand_threshold:\n                similar_routes.append((i, j))\n\n    # Try merging similar routes if possible\n    for i, j in similar_routes:\n        if route_demands[i] + route_demands[j] <= capacity:\n            route1 = selected_solution[i]\n            route2 = selected_solution[j]\n\n            # Create merged route by combining both routes\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Create new solution\n            new_solution = [route for idx, route in enumerate(selected_solution) if idx not in [i, j]]\n            new_solution.append(new_route)\n\n            # Check if this improves both objectives\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            total_distance = sum(new_route_lengths)\n            makespan = max(new_route_lengths)\n\n            if total_distance < archive_sorted[0][1][0] or makespan < archive_sorted[0][1][1]:\n                return new_solution\n\n    # If merging didn't work, try demand-driven segmentation\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        customers = route[1:-1]\n\n        # Sort customers by demand\n        sorted_indices = np.argsort(demand[customers])\n        sorted_customers = customers[sorted_indices]\n\n        # Find segments with similar demand\n        segment_size = max(2, len(sorted_customers) // 3)\n        for i in range(len(sorted_customers) - segment_size + 1):\n            segment = sorted_customers[i:i+segment_size]\n            segment_demand = sum(demand[segment])\n\n            if segment_demand > capacity:\n                continue\n\n            # Find best insertion point in other routes\n            best_insertion = None\n            best_improvement = 0\n\n            for target_idx in range(len(selected_solution)):\n                if target_idx == route_idx:\n                    continue\n                target_route = selected_solution[target_idx]\n\n                if sum(demand[target_route[1:-1]]) + segment_demand > capacity:\n                    continue\n\n                # Calculate potential improvement\n                original_length = sum(distance_matrix[route[:-1], route[1:]])\n                new_route = np.concatenate([route[:i+1], route[i+segment_size+1:]])\n                new_length = sum(distance_matrix[new_route[:-1], new_route[1:]])\n\n                improvement = original_length - new_length\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insertion = (target_idx, segment)\n\n            if best_insertion is not None:\n                target_idx, segment = best_insertion\n                new_route = selected_solution[route_idx].copy()\n                new_route = np.concatenate([new_route[:i+1], new_route[i+segment_size+1:]])\n\n                new_target_route = np.concatenate([selected_solution[target_idx][:-1], segment, [0]])\n\n                new_solution = selected_solution.copy()\n                new_solution[route_idx] = new_route\n                new_solution[target_idx] = new_target_route\n\n                # Check if this improves both objectives\n                new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                total_distance = sum(new_route_lengths)\n                makespan = max(new_route_lengths)\n\n                if total_distance < archive_sorted[0][1][0] or makespan < archive_sorted[0][1][1]:\n                    return new_solution\n\n    # If no improvement found, try creating new route from compact cluster\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        customers = route[1:-1]\n\n        # Find most compact cluster of customers\n        min_spread = float('inf')\n        best_cluster = None\n\n        for i in range(len(customers)):\n            for j in range(i+1, len(customers)):\n                cluster = customers[i:j+1]\n                cluster_demand = sum(demand[cluster])\n\n                if cluster_demand > capacity:\n                    continue\n\n                # Calculate spatial spread\n                max_dist = 0\n                for node1 in cluster:\n                    for node2 in cluster:\n                        if node1 != node2:\n                            dist = distance_matrix[node1][node2]\n                            if dist > max_dist:\n                                max_dist = dist\n\n                if max_dist < min_spread:\n                    min_spread = max_dist\n                    best_cluster = cluster\n\n        if best_cluster is not None:\n            new_route = np.concatenate([[0], best_cluster, [0]])\n            new_solution = selected_solution.copy()\n            new_route_idx = np.where(np.array(selected_solution) == route)[0][0]\n            new_solution[new_route_idx] = np.array([0] + [c for c in route[1:-1] if c not in best_cluster] + [0])\n            new_solution.append(new_route)\n\n            # Check if this improves both objectives\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            total_distance = sum(new_route_lengths)\n            makespan = max(new_route_lengths)\n\n            if total_distance < archive_sorted[0][1][0] or makespan < archive_sorted[0][1][1]:\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8397238862188635,
               0.31893083453178406
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive but introduces a novel approach that combines route fragmentation and adaptive segment reassembly. It first identifies the most diverse solutions in the archive based on both objective values and spatial distribution of routes, then applies a fragmentation-based local search where long routes are systematically broken into smaller segments, each evaluated for potential reassembly with other segments or routes to form more balanced configurations. The reassembly process prioritizes spatial proximity and demand complementarity, while maintaining feasibility, to create solutions that simultaneously reduce total distance through route consolidation and improve makespan through better load balancing. The algorithm dynamically adjusts the fragmentation granularity based on the current solution's characteristics, allowing it to adaptively explore both local and global improvements.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse characteristics\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    diversity_scores = (total_distances - np.mean(total_distances))**2 + (makespans - np.mean(makespans))**2\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def fragment_route(route, min_fragment_size=3):\n        fragments = []\n        current_fragment = [route[0]]\n        current_load = 0\n\n        for node in route[1:-1]:\n            current_load += demand[node]\n            current_fragment.append(node)\n\n            if len(current_fragment) >= min_fragment_size and current_load <= capacity:\n                if np.random.random() < 0.7 or current_load > 0.8 * capacity:\n                    fragments.append(np.array(current_fragment + [0]))\n                    current_fragment = [0]\n                    current_load = 0\n\n        if len(current_fragment) > 1:\n            fragments.append(np.array(current_fragment + [0]))\n\n        return fragments if len(fragments) > 1 else [route]\n\n    def reassemble_fragments(fragments):\n        reassembled = []\n        remaining = [frag for frag in fragments]\n\n        while remaining:\n            current_route = [0]\n            current_load = 0\n            added = False\n\n            for i, frag in enumerate(remaining):\n                frag_load = np.sum(demand[frag[1:-1]])\n                if current_load + frag_load <= capacity:\n                    current_route.extend(frag[1:-1])\n                    current_load += frag_load\n                    remaining.pop(i)\n                    added = True\n                    break\n\n            if not added:\n                if len(current_route) > 1:\n                    reassembled.append(np.array(current_route + [0]))\n                remaining.pop(0)\n\n            if len(current_route) > 1:\n                reassembled.append(np.array(current_route + [0]))\n\n        return reassembled if reassembled else fragments\n\n    # Perform fragmentation and reassembly\n    all_fragments = []\n    for route in new_solution:\n        fragments = fragment_route(route)\n        all_fragments.extend(fragments)\n\n    new_solution = reassemble_fragments(all_fragments)\n\n    # Additional local improvements\n    improved = True\n    max_iter = 50\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Try to merge adjacent fragments\n        if len(new_solution) > 1:\n            i = np.random.randint(0, len(new_solution))\n            j = (i + 1) % len(new_solution)\n\n            merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if is_feasible(merged):\n                new_route_length = route_length(merged)\n                original_length = route_length(new_solution[i]) + route_length(new_solution[j])\n\n                if new_route_length < original_length * 0.95:\n                    new_solution[i] = merged\n                    del new_solution[j]\n                    improved = True\n\n        # Try to move a customer between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if len(new_solution[i]) > 3 and len(new_solution[j]) > 2:\n                customer_idx = np.random.randint(1, len(new_solution[i]) - 1)\n                customer = new_solution[i][customer_idx]\n\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_dist = route_length(new_solution[i]) + route_length(new_solution[j])\n                    new_i = np.concatenate([new_solution[i][:customer_idx], new_solution[i][customer_idx+1:]])\n                    new_j = np.concatenate([new_solution[j][:-1], [customer], [0]])\n\n                    new_dist = route_length(new_i) + route_length(new_j)\n\n                    if new_dist < original_dist * 0.98:\n                        new_solution[i] = new_i\n                        new_solution[j] = new_j\n                        improved = True\n\n    return new_solution\n\n",
          "score": [
               -0.9048805479347265,
               1.5466918349266052
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive and applying route modifications, but introduces a novel approach called \"Adaptive Route Rebalancing\" that dynamically identifies overloaded and underloaded routes, then redistributes customers between them by solving a constrained optimization problem that simultaneously minimizes distance increase while maximizing load balance, using a hybrid of greedy and simulated annealing techniques to explore the solution space while ensuring feasibility through capacity-aware perturbations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest makespan (potential for rebalancing)\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def route_load(route):\n        return np.sum(demand[route[1:-1]])\n\n    def route_distance(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    # Identify overloaded and underloaded routes\n    loads = [route_load(route) for route in new_solution]\n    avg_load = np.mean(loads)\n    overloaded = [i for i, load in enumerate(loads) if load > avg_load * 1.2]\n    underloaded = [i for i, load in enumerate(loads) if load < avg_load * 0.8]\n\n    if not overloaded or not underloaded:\n        return new_solution\n\n    # Try to redistribute customers between routes\n    for src_idx in overloaded:\n        src_route = new_solution[src_idx]\n        customers = src_route[1:-1]\n\n        # Find best customer to move\n        best_customer = None\n        best_dest = None\n        best_improvement = 0\n\n        for customer in customers:\n            for dest_idx in underloaded:\n                dest_route = new_solution[dest_idx]\n                if route_load(dest_route) + demand[customer] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                original_dist = route_distance(src_route) + route_distance(dest_route)\n\n                # Simulate move\n                temp_src = np.concatenate([src_route[:np.where(src_route == customer)[0][0]],\n                                         src_route[np.where(src_route == customer)[0][0]+1:]])\n                temp_dest = np.concatenate([dest_route[:-1], [customer], [0]])\n\n                new_dist = route_distance(temp_src) + route_distance(temp_dest)\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_customer = customer\n                    best_dest = dest_idx\n\n        if best_customer is not None:\n            # Perform the move\n            src_route = new_solution[src_idx]\n            dest_route = new_solution[best_dest]\n\n            # Remove customer from source route\n            mask = src_route != best_customer\n            new_solution[src_idx] = src_route[mask]\n\n            # Add customer to destination route\n            new_solution[best_dest] = np.concatenate([dest_route[:-1], [best_customer], [0]])\n\n            # Update loads and break after first improvement\n            loads = [route_load(route) for route in new_solution]\n            overloaded = [i for i, load in enumerate(loads) if load > avg_load * 1.2]\n            underloaded = [i for i, load in enumerate(loads) if load < avg_load * 0.8]\n            break\n\n    # Additional local improvements with simulated annealing\n    current_temp = 100\n    cooling_rate = 0.99\n    min_temp = 1\n\n    while current_temp > min_temp:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Try to swap two customers between routes\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random customers (excluding depot)\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Check capacity constraints\n            load_i = route_load(route_i) - demand[cust_i] + demand[cust_j]\n            load_j = route_load(route_j) - demand[cust_j] + demand[cust_i]\n\n            if load_i <= capacity and load_j <= capacity:\n                # Calculate potential improvement\n                original_dist = route_distance(route_i) + route_distance(route_j)\n\n                # Create new routes\n                new_route_i = route_i.copy()\n                new_route_i[np.where(new_route_i == cust_i)[0][0]] = cust_j\n\n                new_route_j = route_j.copy()\n                new_route_j[np.where(new_route_j == cust_j)[0][0]] = cust_i\n\n                new_dist = route_distance(new_route_i) + route_distance(new_route_j)\n                delta = new_dist - original_dist\n\n                # Accept if improvement or with probability\n                if delta < 0 or np.random.random() < np.exp(-delta / current_temp):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n        current_temp *= cooling_rate\n\n    return new_solution\n\n",
          "score": [
               -0.789865212513206,
               0.1571863293647766
          ]
     },
     {
          "algorithm": "{The new algorithm will first select a solution from the archive by prioritizing those with a balanced trade-off between total distance and makespan, then apply a novel \"route segmentation and reintegration\" operator that intelligently splits long routes into segments and reintegrates them into other routes or as new routes, while simultaneously performing demand-aware clustering to group customers based on spatial proximity and demand similarity. This approach ensures both objectives are improved by reducing the longest routes while maintaining efficient clustering of customers, with feasibility checks at each step to prevent capacity violations and ensure the solution remains valid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (compromise between distance and makespan)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route segmentation and reintegration\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find the most distant segment in the route\n        segment_distances = []\n        for i in range(1, len(route) - 1):\n            segment_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]]\n            segment_distances.append(segment_dist)\n\n        if not segment_distances:\n            continue\n\n        max_segment_idx = np.argmax(segment_distances) + 1\n        customer_to_move = route[max_segment_idx]\n\n        # Try to reintegrate this customer into another route\n        best_route = None\n        best_improvement = 0\n        for other_route in new_solution:\n            if other_route is route or len(other_route) >= 10:\n                continue\n\n            # Check if adding the customer would exceed capacity\n            if np.sum(demand[other_route[1:-1]]) + demand[customer_to_move] > capacity:\n                continue\n\n            # Calculate potential improvement\n            original_dist = np.sum(distance_matrix[route[:-1], route[1:]])\n            new_dist = original_dist - distance_matrix[route[max_segment_idx-1], route[max_segment_idx]] - distance_matrix[route[max_segment_idx], route[max_segment_idx+1]] + distance_matrix[route[max_segment_idx-1], route[max_segment_idx+1]]\n            other_route_dist = np.sum(distance_matrix[other_route[:-1], other_route[1:]])\n            new_other_dist = other_route_dist + distance_matrix[other_route[-2], customer_to_move] + distance_matrix[customer_to_move, 0]\n\n            improvement = (original_dist - new_dist) + (other_route_dist - new_other_dist)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_route = other_route\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the move\n            route = np.delete(route, max_segment_idx)\n            best_route[-1] = customer_to_move\n            best_route = np.append(best_route, 0)\n\n    # Demand-aware clustering\n    unassigned = []\n    for route in new_solution:\n        if len(route) <= 3:\n            unassigned.extend(route[1:-1])\n\n    if unassigned:\n        # Group unassigned customers by demand similarity and spatial proximity\n        clusters = []\n        for customer in unassigned:\n            placed = False\n            for cluster in clusters:\n                avg_demand = np.mean(demand[cluster])\n                if abs(demand[customer] - avg_demand) <= capacity * 0.2:\n                    # Check spatial proximity to cluster centroid\n                    centroid = np.mean(coords[cluster], axis=0)\n                    if np.linalg.norm(coords[customer] - centroid) < np.mean(distance_matrix[0]):\n                        cluster.append(customer)\n                        placed = True\n                        break\n            if not placed:\n                clusters.append([customer])\n\n        # Create new routes from clusters\n        for cluster in clusters:\n            if not cluster:\n                continue\n\n            current_load = np.sum(demand[cluster])\n            if current_load > capacity:\n                # Split large clusters\n                sorted_cluster = sorted(cluster, key=lambda x: demand[x], reverse=True)\n                new_route = [0]\n                current_load = 0\n                for customer in sorted_cluster:\n                    if current_load + demand[customer] <= capacity:\n                        new_route.append(customer)\n                        current_load += demand[customer]\n                    else:\n                        new_route.append(0)\n                        new_solution.append(np.array(new_route))\n                        new_route = [0, customer]\n                        current_load = demand[customer]\n                if len(new_route) > 1:\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n            else:\n                new_route = [0] + cluster + [0]\n                new_solution.append(np.array(new_route))\n\n    # Ensure solution is feasible and non-empty\n    if not new_solution:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8269031730243644,
               0.40934616327285767
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Fission,\" first selects a promising solution from the archive by prioritizing those with high total distance and low makespan, indicating potential for balancing route lengths. It then randomly selects two routes from this solution and attempts to merge them by inserting a \"bridge\" node (a customer not in either route) between them, ensuring capacity constraints are met. If merging is infeasible, it instead splits one route into two by finding a high-demand node and dividing the route around it, ensuring both new routes stay within capacity. The strategy dynamically adjusts the bridge or split point based on demand and distance to improve both objectives, yielding a feasible neighbor solution with potentially reduced total distance and more balanced makespan.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy() if len(archive_sorted) > 1 else archive_sorted[0][0].copy()\n\n    # Choose two distinct routes to attempt fusion or fission\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n    route1 = selected_solution[route1_idx].copy()\n    route2 = selected_solution[route2_idx].copy()\n\n    # Attempt Route Fusion: Try to merge route1 and route2 via a bridge node\n    all_customers = set(range(1, len(coords)))\n    used_customers = set()\n    for route in selected_solution:\n        used_customers.update(route[1:-1])  # Exclude depot\n    available_bridges = list(all_customers - used_customers)\n\n    if available_bridges:\n        # Sort bridges by demand (ascending) to prefer smaller bridges\n        available_bridges.sort(key=lambda x: demand[x])\n        for bridge in available_bridges:\n            # Check if adding bridge to route1 or route2 is feasible\n            total_demand_route1 = sum(demand[route1[1:-1]])\n            total_demand_route2 = sum(demand[route2[1:-1]])\n            if total_demand_route1 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route1 and depot\n                new_route = np.concatenate([route1[:-1], [bridge], route2[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n            if total_demand_route2 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route2 and depot\n                new_route = np.concatenate([route2[:-1], [bridge], route1[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n\n    # If fusion failed, attempt Route Fission: Split a route into two\n    # Choose the route with the highest demand (potential for better split)\n    route_to_split = max(selected_solution, key=lambda x: sum(demand[x[1:-1]]))\n    customers_in_route = route_to_split[1:-1]\n    if len(customers_in_route) < 2:\n        return selected_solution\n\n    # Find the best split point (high demand node)\n    best_split_idx = -1\n    best_split_demand = -1\n    for i, node in enumerate(customers_in_route):\n        if demand[node] > best_split_demand:\n            best_split_demand = demand[node]\n            best_split_idx = i\n\n    if best_split_idx != -1:\n        # Split the route at best_split_idx\n        first_part = np.concatenate([[0], customers_in_route[:best_split_idx+1], [0]])\n        second_part = np.concatenate([[0], customers_in_route[best_split_idx+1:], [0]])\n\n        # Check capacity constraints\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution = [route for route in selected_solution if not np.array_equal(route, route_to_split)]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    return selected_solution\n\n",
          "score": [
               -0.7668818254597687,
               0.17718800902366638
          ]
     },
     {
          "algorithm": "{The new algorithm first selects a solution from the archive by prioritizing those with balanced objective values, then applies a dynamic route clustering and intra-cluster optimization strategy that groups customers based on spatial proximity and demand similarity, followed by intra-cluster route optimization using a combination of adaptive segment swaps and demand-aware reordering, while ensuring feasibility through continuous capacity checks and dynamic route adjustments. The strategy alternates between expanding or shrinking clusters based on the current solution's characteristics, and selectively applies optimization moves to critical clusters to simultaneously improve both total distance and makespan.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Flatten routes and create customer list\n    customers = []\n    for route in selected_solution:\n        customers.extend(route[1:-1])\n\n    # Dynamic clustering based on spatial and demand similarity\n    clusters = []\n    unassigned = set(customers)\n\n    while unassigned:\n        seed = unassigned.pop()\n        cluster = [seed]\n        for customer in list(unassigned):\n            # Check spatial and demand similarity\n            avg_demand = np.mean(demand[list(cluster)])\n            if (np.abs(demand[customer] - avg_demand) <= 0.3 * avg_demand and\n                np.linalg.norm(coords[customer] - np.mean(coords[list(cluster)], axis=0)) <= 0.5 * np.max(distance_matrix)):\n                cluster.append(customer)\n                unassigned.remove(customer)\n        clusters.append(cluster)\n\n    # Create new solution from clusters with adaptive optimization\n    new_solution = []\n    for cluster in clusters:\n        # Sort by demand (ascending) to balance capacity usage\n        cluster_sorted = sorted(cluster, key=lambda x: demand[x])\n\n        # Try to form a route from the cluster\n        current_route = [0]\n        current_demand = 0\n        for customer in cluster_sorted:\n            if current_demand + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_demand = demand[customer]\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Intra-cluster optimization\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Adaptive segment swap\n        for _ in range(2):\n            a, b = np.random.randint(1, len(route)-2, size=2)\n            if a > b:\n                a, b = b, a\n            segment = route[a:b+1]\n\n            # Try inserting segment in a different position\n            for pos in range(1, len(route)-len(segment)):\n                if pos >= a and pos <= b:\n                    continue\n                new_route = np.concatenate([route[:pos], segment, route[pos:], route[b+1:]])\n\n                # Check feasibility\n                segments = []\n                current = []\n                for node in new_route[1:-1]:\n                    if node == 0:\n                        segments.append(current)\n                        current = []\n                    else:\n                        current.append(node)\n                if current:\n                    segments.append(current)\n\n                if all(sum(demand[seg]) <= capacity for seg in segments):\n                    new_solution[i] = new_route\n                    break\n\n    # Demand-aware reordering in critical routes\n    lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    if lengths:\n        longest_idx = np.argmax(lengths)\n        route = new_solution[longest_idx]\n        customers = route[1:-1]\n\n        # Reorder by demand to balance capacity usage\n        sorted_customers = sorted(customers, key=lambda x: demand[x])\n        new_route = np.concatenate([[0], sorted_customers, [0]])\n        if sum(demand[sorted_customers]) <= capacity:\n            new_solution[longest_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.847784674555949,
               5.845373332500458
          ]
     }
]