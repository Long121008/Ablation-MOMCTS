[
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route splitting and customer reinsertion with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and attempts to split it into two routes by relocating a segment of customers to a new route, ensuring capacity constraints are met. If splitting is infeasible, it performs a customer reinsertion by removing a customer from the shortest route and inserting it into another route, choosing the insertion position that minimizes the increase in total distance while maintaining the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try to split the shortest route into two\n    for i in range(1, len(shortest_route) - 1):\n        first_part = shortest_route[:i+1]\n        second_part = np.concatenate([[0], shortest_route[i+1:]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[shortest_route_idx] = first_part\n            new_solution.append(second_part)\n\n            # Check if this improves the makespan\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) <= max(route_lengths):\n                return new_solution\n\n    # If splitting didn't work, try reinserting a customer from the shortest route\n    if len(selected_solution) > 1:\n        # Find another route to insert into\n        for target_route_idx in range(len(selected_solution)):\n            if target_route_idx == shortest_route_idx:\n                continue\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Try moving each customer from shortest route to target route\n            for customer in shortest_route[1:-1]:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_increase = float('inf')\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_pos = pos\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_shortest_route = np.delete(shortest_route, np.where(shortest_route == customer)[0][0])\n                    new_target_route = np.insert(target_route, best_pos, customer)\n\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    new_solution[target_route_idx] = new_target_route\n\n                    # Check if this improves the makespan\n                    new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                    if max(new_route_lengths) <= max(route_lengths):\n                        return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8236050826838496,
               0.12729865312576294
          ]
     },
     {
          "algorithm": "{The novel \"Route Reconstruction and Demand Harmonization\" algorithm first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, indicating potential for route optimization. It then reconstructs routes by iteratively removing the longest route and redistributing its customers to other routes using a \"demand-aware\" insertion heuristic that minimizes both the increase in total distance and the deviation from an ideal load balance. The algorithm dynamically adjusts the insertion points based on demand proximity and spatial clustering to create balanced routes, while ensuring feasibility through strict capacity checks. If redistribution fails, it attempts to create new routes by grouping spatially close, low-demand customers. The method combines these steps in a probabilistic framework to explore diverse neighborhoods while maintaining solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers_to_reinsert = longest_route[1:-1]\n\n    # Remove the longest route\n    del new_solution[longest_route_idx]\n\n    # Sort customers by demand (ascending) to prioritize smaller customers\n    customers_to_reinsert = sorted(customers_to_reinsert, key=lambda x: demand[x])\n\n    # Calculate ideal load per route (excluding the longest route)\n    remaining_capacity = capacity * len(new_solution)\n    ideal_load = remaining_capacity / len(new_solution)\n\n    # Reinsert customers into existing routes\n    for customer in customers_to_reinsert:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        for i, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                insertion_cost = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                # Calculate load deviation from ideal\n                current_load = sum(demand[route[1:-1]])\n                new_load = current_load + demand[customer]\n                load_dev = abs(new_load - ideal_load)\n\n                # Combine cost and load deviation\n                total_cost = insertion_cost + 0.1 * load_dev\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            # Insert the customer\n            route = new_solution[best_route_idx]\n            new_route = np.insert(route, best_position, customer)\n            new_solution[best_route_idx] = new_route\n\n    # If some customers couldn't be reinserted, create new routes\n    remaining_customers = [c for c in customers_to_reinsert if c not in [node for route in new_solution for node in route[1:-1]]]\n    if remaining_customers:\n        # Group remaining customers by spatial proximity and low demand\n        remaining_customers = sorted(remaining_customers, key=lambda x: demand[x])\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            for i, customer in enumerate(remaining_customers):\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    break\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
          "score": [
               -0.9619479325462242,
               1.234698325395584
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Adaptive Route Clustering with Demand-Based Merging,\" first selects the solution with the highest makespan from the archive to identify the most imbalanced route, then dynamically clusters customers into new routes based on their demand profiles, ensuring capacity constraints are maintained through a novel demand-aware merging process that prioritizes spatial proximity and demand compatibility, while adaptively adjusting cluster boundaries to balance route lengths and minimize total distance, resulting in a feasible neighbor solution that significantly reduces makespan while improving overall route efficiency.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    # Sort unassigned customers by demand (descending) and then by distance to depot\n    unassigned_customers.sort(key=lambda x: (-demand[x], distance_matrix[0][x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            if len(current_route) > 1:  # Avoid adding empty routes\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    # Combine with existing routes\n    new_solution = selected_solution + new_routes\n\n    return new_solution\n\n",
          "score": [
               -0.7911038221089215,
               0.11675745248794556
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Spatial Cluster Refinement and Demand-Adaptive Routing,\" first selects a solution from the archive by prioritizing those with the highest total distance and highest makespan, indicating potential for significant improvement in both objectives. It then identifies spatial clusters of customers in the solution by grouping nearby customers based on a dynamic threshold that balances spatial proximity and demand feasibility. The algorithm then attempts to reassign customers from these clusters to new routes or existing routes by strategically inserting them at positions that minimize both the increase in total distance and the makespan, while ensuring vehicle capacity constraints are met. If direct reassignment is infeasible, it creates new routes by extracting compact spatial clusters that can be served by a single vehicle, ensuring the new routes' makespan is below the current average. The operator dynamically adjusts the cluster threshold and insertion criteria based on demand patterns and spatial distribution to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives through careful spatial analysis and demand-aware routing adjustments.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and makespan\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    makespan = max(route_lengths)\n\n    # Find spatial clusters of customers\n    all_customers = []\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.unique(all_customers)\n\n    clusters = []\n    visited = set()\n\n    for customer in all_customers:\n        if customer in visited:\n            continue\n        cluster = [customer]\n        visited.add(customer)\n\n        # Find all customers within a dynamic threshold distance\n        threshold = 1.5 * np.mean(distance_matrix[customer][all_customers])\n        for other in all_customers:\n            if other not in visited and distance_matrix[customer][other] <= threshold:\n                cluster.append(other)\n                visited.add(other)\n\n        clusters.append(cluster)\n\n    # Try to reassign clusters to existing routes or create new routes\n    for cluster in clusters:\n        cluster_demand = sum(demand[cluster])\n        if cluster_demand > capacity:\n            continue\n\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        # Try to insert the cluster into existing routes\n        for i, route in enumerate(selected_solution):\n            current_demand = sum(demand[route[1:-1]])\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                # Calculate cost of inserting cluster at this position\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                cost_increase = (distance_matrix[prev_node][first_node] +\n                                distance_matrix[last_node][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                if cost_increase < best_cost:\n                    best_cost = cost_increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = selected_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            selected_solution[best_route] = new_route\n            continue\n\n        # If no good insertion found, create a new route\n        new_route = np.concatenate([[0], cluster, [0]])\n        selected_solution.append(new_route)\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    # Check if any route exceeds capacity\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to original solution\n            return archive_sorted[0][0].copy()\n\n    return selected_solution\n\n",
          "score": [
               -0.8698950547833597,
               0.28535816073417664
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Dynamic Demand-Adaptive Route Clustering and Relocation,\" first selects a solution from the archive by prioritizing those with the highest makespan and highest total distance, indicating significant potential for improvement in both objectives. It then clusters customers based on both spatial proximity and demand similarity, creating demand-adaptive clusters that can be efficiently relocated or merged. The operator dynamically identifies the most promising clusters by analyzing demand profiles and spatial compactness, then evaluates multiple relocation strategies that prioritize reducing the makespan while maintaining or improving the total distance. If no beneficial relocation is found, it attempts to merge clusters from different routes when their combined demand is within capacity limits, creating more balanced and efficient route configurations. The operator dynamically adjusts its clustering and relocation strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of demand-adaptive clustering and spatial analysis to generate high-quality neighbor solutions that improve both objectives while maintaining feasibility through careful capacity checks and spatial considerations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Create demand-adaptive clusters\n    all_customers = np.concatenate([route[1:-1] for route in selected_solution])\n    cluster_centers = []\n    cluster_members = []\n\n    for customer in all_customers:\n        # Find the nearest cluster center with similar demand\n        best_cluster = None\n        best_distance = float('inf')\n\n        for i, center in enumerate(cluster_centers):\n            dist = distance_matrix[customer][center]\n            demand_diff = abs(demand[customer] - demand[center])\n\n            if demand_diff <= capacity * 0.2 and dist < best_distance:\n                best_distance = dist\n                best_cluster = i\n\n        if best_cluster is not None:\n            cluster_members[best_cluster].append(customer)\n        else:\n            cluster_centers.append(customer)\n            cluster_members.append([customer])\n\n    # Try to relocate clusters to balance makespan\n    for i, cluster in enumerate(cluster_members):\n        cluster_demand = sum(demand[cluster])\n\n        # Find best route to insert this cluster\n        best_route = None\n        best_position = None\n        best_improvement = 0\n\n        for route_idx in range(len(selected_solution)):\n            route = selected_solution[route_idx]\n            if sum(demand[route[1:-1]]) + cluster_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for pos in range(1, len(route)):\n                # Calculate potential improvement\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                distance_increase = (distance_matrix[prev_node][first_node] +\n                                   distance_matrix[last_node][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                # Calculate new makespan\n                current_length = route_lengths[route_idx]\n                new_length = current_length + distance_increase\n                new_makespan = max(max(route_lengths), new_length)\n\n                improvement = (max(route_lengths) - new_makespan) * 0.7 + (sum(route_lengths) - (sum(route_lengths) + distance_increase)) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = route_idx\n                    best_position = pos\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the relocation\n            new_route = np.concatenate([selected_solution[best_route][:best_position],\n                                      np.array(cluster),\n                                      selected_solution[best_route][best_position:]])\n\n            new_solution = selected_solution.copy()\n            new_solution[best_route] = new_route\n\n            # Remove relocated customers from their original routes\n            for customer in cluster:\n                for route_idx in range(len(new_solution)):\n                    if customer in new_solution[route_idx][1:-1]:\n                        mask = new_solution[route_idx] != customer\n                        new_solution[route_idx] = new_solution[route_idx][mask]\n                        if len(new_solution[route_idx]) == 2:  # Only depot left\n                            new_solution.pop(route_idx)\n                        break\n\n            return new_solution\n\n    # If relocation didn't work, try merging clusters from different routes\n    for i in range(len(cluster_members)):\n        for j in range(i+1, len(cluster_members)):\n            combined_demand = sum(demand[cluster_members[i]]) + sum(demand[cluster_members[j]])\n\n            if combined_demand <= capacity:\n                # Find best pair of routes to merge these clusters\n                best_pair = None\n                best_improvement = 0\n\n                for route1_idx in range(len(selected_solution)):\n                    for route2_idx in range(route1_idx+1, len(selected_solution)):\n                        if (sum(demand[selected_solution[route1_idx][1:-1]]) +\n                            sum(demand[selected_solution[route2_idx][1:-1]])) + combined_demand <= capacity:\n\n                            # Calculate potential improvement\n                            original_length = sum(distance_matrix[selected_solution[route1_idx][:-1], selected_solution[route1_idx][1:]]) + \\\n                                             sum(distance_matrix[selected_solution[route2_idx][:-1], selected_solution[route2_idx][1:]])\n\n                            # Create merged route\n                            merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                          cluster_members[i],\n                                                          selected_solution[route2_idx][1:]])\n\n                            new_length = sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n                            improvement = original_length - new_length\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_pair = (route1_idx, route2_idx)\n\n                if best_pair is not None and best_improvement > 0:\n                    route1_idx, route2_idx = best_pair\n                    merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                  cluster_members[i],\n                                                  selected_solution[route2_idx][1:]])\n\n                    new_solution = [route for idx, route in enumerate(selected_solution)\n                                  if idx not in [route1_idx, route2_idx]]\n                    new_solution.append(merged_route)\n\n                    # Remove merged clusters from their original positions\n                    for customer in cluster_members[i] + cluster_members[j]:\n                        for route_idx in range(len(new_solution)):\n                            if customer in new_solution[route_idx][1:-1]:\n                                mask = new_solution[route_idx] != customer\n                                new_solution[route_idx] = new_solution[route_idx][mask]\n                                if len(new_solution[route_idx]) == 2:  # Only depot left\n                                    new_solution.pop(route_idx)\n                                break\n\n                    return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.9304719574529826,
               0.4577655494213104
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Multi-Objective Route Balancing,\" first identifies the solution with the highest makespan and second-highest total distance from the archive, suggesting it has significant potential for improvement in both objectives. It then analyzes the spatial distribution of customers and demand patterns across all routes, dynamically grouping customers into clusters based on a combination of spatial proximity and demand similarity. The algorithm then strategically redistributes these clusters by either merging them with existing routes or creating entirely new routes, carefully evaluating each move to ensure it reduces the makespan while maintaining or improving the total distance. If no beneficial redistribution is found, it attempts to balance the routes by transferring customers from the longest routes to shorter ones, ensuring capacity constraints are met throughout the process. The operator dynamically adjusts its clustering and redistribution strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective balancing to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Find the shortest route\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx]\n\n    # Try to transfer customers from longest to shortest route\n    for customer in longest_customers:\n        if route_demands[shortest_route_idx] + demand[customer] <= capacity:\n            # Find best insertion position in shortest route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(shortest_route)):\n                prev_node = shortest_route[pos-1]\n                next_node = shortest_route[pos]\n                current_dist = distance_matrix[prev_node][next_node]\n                new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                increase = new_dist - current_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Create new routes\n            new_longest_route = np.concatenate([longest_route[:np.where(longest_route == customer)[0][0]],\n                                               longest_route[np.where(longest_route == customer)[0][0]+1:]])\n            new_shortest_route = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution[shortest_route_idx] = new_shortest_route\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < route_lengths[longest_route_idx]:\n                return new_solution\n\n    # If no transfer worked, try to create new route from compact cluster\n    if len(longest_customers) > 1:\n        # Find most compact cluster of 2 customers\n        min_spread = float('inf')\n        best_pair = (longest_customers[0], longest_customers[1])\n\n        for i in range(len(longest_customers)):\n            for j in range(i+1, len(longest_customers)):\n                dist = distance_matrix[longest_customers[i]][longest_customers[j]]\n                if dist < min_spread:\n                    min_spread = dist\n                    best_pair = (longest_customers[i], longest_customers[j])\n\n        # Check if pair can form a new route\n        if demand[best_pair[0]] + demand[best_pair[1]] <= capacity:\n            new_route = np.array([0, best_pair[0], best_pair[1], 0])\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in best_pair] + [0])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < route_lengths[longest_route_idx]:\n                return new_solution\n\n    # If no improvement found, try to merge two shortest routes if possible\n    if len(selected_solution) > 2:\n        # Find two shortest routes\n        sorted_indices = np.argsort(route_lengths)\n        route1_idx = sorted_indices[0]\n        route2_idx = sorted_indices[1]\n\n        if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n            route1 = selected_solution[route1_idx]\n            route2 = selected_solution[route2_idx]\n\n            # Create merged route\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(selected_solution)\n                          if idx not in [route1_idx, route2_idx]]\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8925838658920906,
               0.30188223719596863
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Spatial-Demand Hybrid Clustering with Adaptive Route Splitting,\" first selects the solution with the highest total distance from the archive to identify the most inefficient route, then applies a novel spatial-demand hybrid clustering approach that dynamically partitions customers into clusters based on both geographic proximity and demand compatibility, while adaptively splitting and merging routes to balance spatial efficiency and demand constraints, resulting in a feasible neighbor solution that significantly reduces total distance while improving route balance and minimizing makespan through a hybrid operator that combines spatial optimization with demand-aware route adjustments.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    unassigned_customers.sort(key=lambda x: (coords[x][0], coords[x][1], demand[x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n    current_center = np.array([0.0, 0.0])\n    customer_count = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n            customer_count += 1\n            current_center = ((customer_count - 1) * current_center + coords[customer]) / customer_count\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n            customer_count = 1\n            current_center = coords[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            split_point = len(route) // 2\n            first_part = np.concatenate([route[:split_point], [0]])\n            second_part = np.concatenate([[0], route[split_point:-1], [0]])\n            selected_solution[i] = first_part\n            selected_solution.append(second_part)\n\n    new_solution = selected_solution + new_routes\n    return new_solution\n\n",
          "score": [
               -0.8075392774613397,
               0.12542086839675903
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive and applying route modifications, but introduces a novel approach called \"Adaptive Route Rebalancing\" that dynamically identifies overloaded and underloaded routes, then redistributes customers between them by solving a constrained optimization problem that simultaneously minimizes distance increase while maximizing load balance, using a hybrid of greedy and simulated annealing techniques to explore the solution space while ensuring feasibility through capacity-aware perturbations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest makespan (potential for rebalancing)\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def route_load(route):\n        return np.sum(demand[route[1:-1]])\n\n    def route_distance(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    # Identify overloaded and underloaded routes\n    loads = [route_load(route) for route in new_solution]\n    avg_load = np.mean(loads)\n    overloaded = [i for i, load in enumerate(loads) if load > avg_load * 1.2]\n    underloaded = [i for i, load in enumerate(loads) if load < avg_load * 0.8]\n\n    if not overloaded or not underloaded:\n        return new_solution\n\n    # Try to redistribute customers between routes\n    for src_idx in overloaded:\n        src_route = new_solution[src_idx]\n        customers = src_route[1:-1]\n\n        # Find best customer to move\n        best_customer = None\n        best_dest = None\n        best_improvement = 0\n\n        for customer in customers:\n            for dest_idx in underloaded:\n                dest_route = new_solution[dest_idx]\n                if route_load(dest_route) + demand[customer] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                original_dist = route_distance(src_route) + route_distance(dest_route)\n\n                # Simulate move\n                temp_src = np.concatenate([src_route[:np.where(src_route == customer)[0][0]],\n                                         src_route[np.where(src_route == customer)[0][0]+1:]])\n                temp_dest = np.concatenate([dest_route[:-1], [customer], [0]])\n\n                new_dist = route_distance(temp_src) + route_distance(temp_dest)\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_customer = customer\n                    best_dest = dest_idx\n\n        if best_customer is not None:\n            # Perform the move\n            src_route = new_solution[src_idx]\n            dest_route = new_solution[best_dest]\n\n            # Remove customer from source route\n            mask = src_route != best_customer\n            new_solution[src_idx] = src_route[mask]\n\n            # Add customer to destination route\n            new_solution[best_dest] = np.concatenate([dest_route[:-1], [best_customer], [0]])\n\n            # Update loads and break after first improvement\n            loads = [route_load(route) for route in new_solution]\n            overloaded = [i for i, load in enumerate(loads) if load > avg_load * 1.2]\n            underloaded = [i for i, load in enumerate(loads) if load < avg_load * 0.8]\n            break\n\n    # Additional local improvements with simulated annealing\n    current_temp = 100\n    cooling_rate = 0.99\n    min_temp = 1\n\n    while current_temp > min_temp:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Try to swap two customers between routes\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random customers (excluding depot)\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Check capacity constraints\n            load_i = route_load(route_i) - demand[cust_i] + demand[cust_j]\n            load_j = route_load(route_j) - demand[cust_j] + demand[cust_i]\n\n            if load_i <= capacity and load_j <= capacity:\n                # Calculate potential improvement\n                original_dist = route_distance(route_i) + route_distance(route_j)\n\n                # Create new routes\n                new_route_i = route_i.copy()\n                new_route_i[np.where(new_route_i == cust_i)[0][0]] = cust_j\n\n                new_route_j = route_j.copy()\n                new_route_j[np.where(new_route_j == cust_j)[0][0]] = cust_i\n\n                new_dist = route_distance(new_route_i) + route_distance(new_route_j)\n                delta = new_dist - original_dist\n\n                # Accept if improvement or with probability\n                if delta < 0 or np.random.random() < np.exp(-delta / current_temp):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n        current_temp *= cooling_rate\n\n    return new_solution\n\n",
          "score": [
               -0.789865212513206,
               0.1571863293647766
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Demand-Spatial Bifurcation and Consolidation,\" first selects a solution from the archive by prioritizing those with the highest makespan and total distance, indicating significant potential for improvement in both objectives. It then analyzes the demand distribution and spatial proximity of customers to identify \"demand-spatial hotspots\" - regions where high-demand customers are densely packed. The algorithm strategically splits these hotspots into multiple smaller, balanced clusters by considering both demand feasibility and spatial compactness, creating new routes that serve these clusters while maintaining vehicle capacity constraints. Simultaneously, it consolidates underutilized routes by merging them with nearby clusters when feasible, reducing the makespan and total distance. The operator dynamically adjusts its clustering and merging criteria based on demand imbalances and spatial distribution, ultimately creating a new neighbor solution that improves both objectives through careful demand-spatial analysis and adaptive route restructuring.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Identify all customers in the solution\n    all_customers = []\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.unique(all_customers)\n\n    # Calculate demand and spatial density for each customer\n    customer_density = []\n    for customer in all_customers:\n        # Spatial density: average distance to other customers\n        spatial_density = np.mean(distance_matrix[customer][all_customers])\n        customer_density.append((customer, demand[customer], spatial_density))\n\n    # Sort customers by demand-to-density ratio (higher ratio indicates potential hotspot)\n    customer_density.sort(key=lambda x: x[1]/x[2], reverse=True)\n\n    # Identify demand-spatial hotspots\n    hotspot_threshold = 0.7 * np.mean([d[1]/d[2] for d in customer_density])\n    hotspots = [c[0] for c in customer_density if c[1]/c[2] >= hotspot_threshold]\n\n    # Split hotspots into balanced clusters\n    clusters = []\n    visited = set()\n\n    for hotspot in hotspots:\n        if hotspot in visited:\n            continue\n\n        cluster = [hotspot]\n        visited.add(hotspot)\n        current_demand = demand[hotspot]\n\n        # Find nearby customers to complement the hotspot\n        for customer in all_customers:\n            if customer in visited or customer == hotspot:\n                continue\n\n            # Check if adding this customer maintains balance\n            if current_demand + demand[customer] <= capacity * 0.9:  # Allow some slack\n                # Check spatial proximity\n                if distance_matrix[hotspot][customer] <= 1.2 * np.mean(distance_matrix[hotspot][all_customers]):\n                    cluster.append(customer)\n                    visited.add(customer)\n                    current_demand += demand[customer]\n\n        clusters.append(cluster)\n\n    # Process clusters: either create new routes or merge with existing ones\n    for cluster in clusters:\n        cluster_demand = sum(demand[cluster])\n        if cluster_demand > capacity:\n            continue\n\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        # Try to merge with existing routes\n        for i, route in enumerate(selected_solution):\n            current_demand = sum(demand[route[1:-1]])\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            # Find best insertion position in the route\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                cost_increase = (distance_matrix[prev_node][first_node] +\n                               distance_matrix[last_node][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                if cost_increase < best_cost:\n                    best_cost = cost_increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            # Merge cluster into the best route\n            route = selected_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            selected_solution[best_route] = new_route\n        else:\n            # Create a new route for the cluster\n            new_route = np.concatenate([[0], cluster, [0]])\n            selected_solution.append(new_route)\n\n    # Consolidate underutilized routes\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    underutilized_threshold = 0.3 * capacity\n\n    for i in range(len(selected_solution)-1, -1, -1):\n        if len(selected_solution[i]) <= 2:\n            continue\n\n        if route_demands[i] <= underutilized_threshold:\n            # Try to merge with another underutilized route\n            merged = False\n            for j in range(len(selected_solution)):\n                if i == j or len(selected_solution[j]) <= 2:\n                    continue\n\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand <= capacity:\n                    # Merge routes\n                    route1 = selected_solution[i]\n                    route2 = selected_solution[j]\n                    new_route = np.concatenate([route1[:-1], route2[1:]])\n                    selected_solution[j] = new_route\n                    selected_solution.pop(i)\n                    route_demands[j] = combined_demand\n                    merged = True\n                    break\n\n            if not merged:\n                # If no good merge found, try to insert into another route\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n                cluster = selected_solution[i][1:-1]\n\n                for j in range(len(selected_solution)):\n                    if i == j:\n                        continue\n\n                    current_demand = route_demands[j]\n                    if current_demand + route_demands[i] > capacity:\n                        continue\n\n                    for pos in range(1, len(selected_solution[j])):\n                        prev_node = selected_solution[j][pos-1]\n                        next_node = selected_solution[j][pos]\n                        first_node = cluster[0]\n                        last_node = cluster[-1]\n\n                        cost_increase = (distance_matrix[prev_node][first_node] +\n                                       distance_matrix[last_node][next_node] -\n                                       distance_matrix[prev_node][next_node])\n\n                        if cost_increase < best_cost:\n                            best_cost = cost_increase\n                            best_route = j\n                            best_pos = pos\n\n                if best_route is not None:\n                    route = selected_solution[best_route]\n                    new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n                    selected_solution[best_route] = new_route\n                    selected_solution.pop(i)\n\n    # Remove empty routes and check capacity constraints\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return archive_sorted[0][0].copy()\n\n    return selected_solution\n\n",
          "score": [
               -0.9490963413301584,
               3.460566610097885
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive but introduces a novel approach that combines route fragmentation and adaptive segment reassembly. It first identifies the most diverse solutions in the archive based on both objective values and spatial distribution of routes, then applies a fragmentation-based local search where long routes are systematically broken into smaller segments, each evaluated for potential reassembly with other segments or routes to form more balanced configurations. The reassembly process prioritizes spatial proximity and demand complementarity, while maintaining feasibility, to create solutions that simultaneously reduce total distance through route consolidation and improve makespan through better load balancing. The algorithm dynamically adjusts the fragmentation granularity based on the current solution's characteristics, allowing it to adaptively explore both local and global improvements.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse characteristics\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    diversity_scores = (total_distances - np.mean(total_distances))**2 + (makespans - np.mean(makespans))**2\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def fragment_route(route, min_fragment_size=3):\n        fragments = []\n        current_fragment = [route[0]]\n        current_load = 0\n\n        for node in route[1:-1]:\n            current_load += demand[node]\n            current_fragment.append(node)\n\n            if len(current_fragment) >= min_fragment_size and current_load <= capacity:\n                if np.random.random() < 0.7 or current_load > 0.8 * capacity:\n                    fragments.append(np.array(current_fragment + [0]))\n                    current_fragment = [0]\n                    current_load = 0\n\n        if len(current_fragment) > 1:\n            fragments.append(np.array(current_fragment + [0]))\n\n        return fragments if len(fragments) > 1 else [route]\n\n    def reassemble_fragments(fragments):\n        reassembled = []\n        remaining = [frag for frag in fragments]\n\n        while remaining:\n            current_route = [0]\n            current_load = 0\n            added = False\n\n            for i, frag in enumerate(remaining):\n                frag_load = np.sum(demand[frag[1:-1]])\n                if current_load + frag_load <= capacity:\n                    current_route.extend(frag[1:-1])\n                    current_load += frag_load\n                    remaining.pop(i)\n                    added = True\n                    break\n\n            if not added:\n                if len(current_route) > 1:\n                    reassembled.append(np.array(current_route + [0]))\n                remaining.pop(0)\n\n            if len(current_route) > 1:\n                reassembled.append(np.array(current_route + [0]))\n\n        return reassembled if reassembled else fragments\n\n    # Perform fragmentation and reassembly\n    all_fragments = []\n    for route in new_solution:\n        fragments = fragment_route(route)\n        all_fragments.extend(fragments)\n\n    new_solution = reassemble_fragments(all_fragments)\n\n    # Additional local improvements\n    improved = True\n    max_iter = 50\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Try to merge adjacent fragments\n        if len(new_solution) > 1:\n            i = np.random.randint(0, len(new_solution))\n            j = (i + 1) % len(new_solution)\n\n            merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if is_feasible(merged):\n                new_route_length = route_length(merged)\n                original_length = route_length(new_solution[i]) + route_length(new_solution[j])\n\n                if new_route_length < original_length * 0.95:\n                    new_solution[i] = merged\n                    del new_solution[j]\n                    improved = True\n\n        # Try to move a customer between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if len(new_solution[i]) > 3 and len(new_solution[j]) > 2:\n                customer_idx = np.random.randint(1, len(new_solution[i]) - 1)\n                customer = new_solution[i][customer_idx]\n\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_dist = route_length(new_solution[i]) + route_length(new_solution[j])\n                    new_i = np.concatenate([new_solution[i][:customer_idx], new_solution[i][customer_idx+1:]])\n                    new_j = np.concatenate([new_solution[j][:-1], [customer], [0]])\n\n                    new_dist = route_length(new_i) + route_length(new_j)\n\n                    if new_dist < original_dist * 0.98:\n                        new_solution[i] = new_i\n                        new_solution[j] = new_j\n                        improved = True\n\n    return new_solution\n\n",
          "score": [
               -0.9048805479347265,
               1.5466918349266052
          ]
     }
]