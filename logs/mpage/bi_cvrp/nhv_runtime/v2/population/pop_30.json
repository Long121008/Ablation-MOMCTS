[
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route splitting and customer reinsertion with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and attempts to split it into two routes by relocating a segment of customers to a new route, ensuring capacity constraints are met. If splitting is infeasible, it performs a customer reinsertion by removing a customer from the shortest route and inserting it into another route, choosing the insertion position that minimizes the increase in total distance while maintaining the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try to split the shortest route into two\n    for i in range(1, len(shortest_route) - 1):\n        first_part = shortest_route[:i+1]\n        second_part = np.concatenate([[0], shortest_route[i+1:]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[shortest_route_idx] = first_part\n            new_solution.append(second_part)\n\n            # Check if this improves the makespan\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) <= max(route_lengths):\n                return new_solution\n\n    # If splitting didn't work, try reinserting a customer from the shortest route\n    if len(selected_solution) > 1:\n        # Find another route to insert into\n        for target_route_idx in range(len(selected_solution)):\n            if target_route_idx == shortest_route_idx:\n                continue\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Try moving each customer from shortest route to target route\n            for customer in shortest_route[1:-1]:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_increase = float('inf')\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_pos = pos\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_shortest_route = np.delete(shortest_route, np.where(shortest_route == customer)[0][0])\n                    new_target_route = np.insert(target_route, best_pos, customer)\n\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    new_solution[target_route_idx] = new_target_route\n\n                    # Check if this improves the makespan\n                    new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                    if max(new_route_lengths) <= max(route_lengths):\n                        return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8236050826838496,
               0.12729865312576294
          ]
     },
     {
          "algorithm": "{The novel \"Route Reconstruction and Demand Harmonization\" algorithm first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, indicating potential for route optimization. It then reconstructs routes by iteratively removing the longest route and redistributing its customers to other routes using a \"demand-aware\" insertion heuristic that minimizes both the increase in total distance and the deviation from an ideal load balance. The algorithm dynamically adjusts the insertion points based on demand proximity and spatial clustering to create balanced routes, while ensuring feasibility through strict capacity checks. If redistribution fails, it attempts to create new routes by grouping spatially close, low-demand customers. The method combines these steps in a probabilistic framework to explore diverse neighborhoods while maintaining solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers_to_reinsert = longest_route[1:-1]\n\n    # Remove the longest route\n    del new_solution[longest_route_idx]\n\n    # Sort customers by demand (ascending) to prioritize smaller customers\n    customers_to_reinsert = sorted(customers_to_reinsert, key=lambda x: demand[x])\n\n    # Calculate ideal load per route (excluding the longest route)\n    remaining_capacity = capacity * len(new_solution)\n    ideal_load = remaining_capacity / len(new_solution)\n\n    # Reinsert customers into existing routes\n    for customer in customers_to_reinsert:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        for i, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                insertion_cost = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                # Calculate load deviation from ideal\n                current_load = sum(demand[route[1:-1]])\n                new_load = current_load + demand[customer]\n                load_dev = abs(new_load - ideal_load)\n\n                # Combine cost and load deviation\n                total_cost = insertion_cost + 0.1 * load_dev\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            # Insert the customer\n            route = new_solution[best_route_idx]\n            new_route = np.insert(route, best_position, customer)\n            new_solution[best_route_idx] = new_route\n\n    # If some customers couldn't be reinserted, create new routes\n    remaining_customers = [c for c in customers_to_reinsert if c not in [node for route in new_solution for node in route[1:-1]]]\n    if remaining_customers:\n        # Group remaining customers by spatial proximity and low demand\n        remaining_customers = sorted(remaining_customers, key=lambda x: demand[x])\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            for i, customer in enumerate(remaining_customers):\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    break\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
          "score": [
               -0.9619479325462242,
               1.234698325395584
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Adaptive Route Clustering with Demand-Based Merging,\" first selects the solution with the highest makespan from the archive to identify the most imbalanced route, then dynamically clusters customers into new routes based on their demand profiles, ensuring capacity constraints are maintained through a novel demand-aware merging process that prioritizes spatial proximity and demand compatibility, while adaptively adjusting cluster boundaries to balance route lengths and minimize total distance, resulting in a feasible neighbor solution that significantly reduces makespan while improving overall route efficiency.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    # Sort unassigned customers by demand (descending) and then by distance to depot\n    unassigned_customers.sort(key=lambda x: (-demand[x], distance_matrix[0][x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            if len(current_route) > 1:  # Avoid adding empty routes\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    # Combine with existing routes\n    new_solution = selected_solution + new_routes\n\n    return new_solution\n\n",
          "score": [
               -0.7911038221089215,
               0.11675745248794556
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Spatial Cluster Refinement and Demand-Adaptive Routing,\" first selects a solution from the archive by prioritizing those with the highest total distance and highest makespan, indicating potential for significant improvement in both objectives. It then identifies spatial clusters of customers in the solution by grouping nearby customers based on a dynamic threshold that balances spatial proximity and demand feasibility. The algorithm then attempts to reassign customers from these clusters to new routes or existing routes by strategically inserting them at positions that minimize both the increase in total distance and the makespan, while ensuring vehicle capacity constraints are met. If direct reassignment is infeasible, it creates new routes by extracting compact spatial clusters that can be served by a single vehicle, ensuring the new routes' makespan is below the current average. The operator dynamically adjusts the cluster threshold and insertion criteria based on demand patterns and spatial distribution to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives through careful spatial analysis and demand-aware routing adjustments.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and makespan\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    makespan = max(route_lengths)\n\n    # Find spatial clusters of customers\n    all_customers = []\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = np.unique(all_customers)\n\n    clusters = []\n    visited = set()\n\n    for customer in all_customers:\n        if customer in visited:\n            continue\n        cluster = [customer]\n        visited.add(customer)\n\n        # Find all customers within a dynamic threshold distance\n        threshold = 1.5 * np.mean(distance_matrix[customer][all_customers])\n        for other in all_customers:\n            if other not in visited and distance_matrix[customer][other] <= threshold:\n                cluster.append(other)\n                visited.add(other)\n\n        clusters.append(cluster)\n\n    # Try to reassign clusters to existing routes or create new routes\n    for cluster in clusters:\n        cluster_demand = sum(demand[cluster])\n        if cluster_demand > capacity:\n            continue\n\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        # Try to insert the cluster into existing routes\n        for i, route in enumerate(selected_solution):\n            current_demand = sum(demand[route[1:-1]])\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                # Calculate cost of inserting cluster at this position\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                cost_increase = (distance_matrix[prev_node][first_node] +\n                                distance_matrix[last_node][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                if cost_increase < best_cost:\n                    best_cost = cost_increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = selected_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            selected_solution[best_route] = new_route\n            continue\n\n        # If no good insertion found, create a new route\n        new_route = np.concatenate([[0], cluster, [0]])\n        selected_solution.append(new_route)\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    # Check if any route exceeds capacity\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to original solution\n            return archive_sorted[0][0].copy()\n\n    return selected_solution\n\n",
          "score": [
               -0.8698950547833597,
               0.28535816073417664
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Dynamic Demand-Adaptive Route Clustering and Relocation,\" first selects a solution from the archive by prioritizing those with the highest makespan and highest total distance, indicating significant potential for improvement in both objectives. It then clusters customers based on both spatial proximity and demand similarity, creating demand-adaptive clusters that can be efficiently relocated or merged. The operator dynamically identifies the most promising clusters by analyzing demand profiles and spatial compactness, then evaluates multiple relocation strategies that prioritize reducing the makespan while maintaining or improving the total distance. If no beneficial relocation is found, it attempts to merge clusters from different routes when their combined demand is within capacity limits, creating more balanced and efficient route configurations. The operator dynamically adjusts its clustering and relocation strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of demand-adaptive clustering and spatial analysis to generate high-quality neighbor solutions that improve both objectives while maintaining feasibility through careful capacity checks and spatial considerations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Create demand-adaptive clusters\n    all_customers = np.concatenate([route[1:-1] for route in selected_solution])\n    cluster_centers = []\n    cluster_members = []\n\n    for customer in all_customers:\n        # Find the nearest cluster center with similar demand\n        best_cluster = None\n        best_distance = float('inf')\n\n        for i, center in enumerate(cluster_centers):\n            dist = distance_matrix[customer][center]\n            demand_diff = abs(demand[customer] - demand[center])\n\n            if demand_diff <= capacity * 0.2 and dist < best_distance:\n                best_distance = dist\n                best_cluster = i\n\n        if best_cluster is not None:\n            cluster_members[best_cluster].append(customer)\n        else:\n            cluster_centers.append(customer)\n            cluster_members.append([customer])\n\n    # Try to relocate clusters to balance makespan\n    for i, cluster in enumerate(cluster_members):\n        cluster_demand = sum(demand[cluster])\n\n        # Find best route to insert this cluster\n        best_route = None\n        best_position = None\n        best_improvement = 0\n\n        for route_idx in range(len(selected_solution)):\n            route = selected_solution[route_idx]\n            if sum(demand[route[1:-1]]) + cluster_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for pos in range(1, len(route)):\n                # Calculate potential improvement\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                distance_increase = (distance_matrix[prev_node][first_node] +\n                                   distance_matrix[last_node][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                # Calculate new makespan\n                current_length = route_lengths[route_idx]\n                new_length = current_length + distance_increase\n                new_makespan = max(max(route_lengths), new_length)\n\n                improvement = (max(route_lengths) - new_makespan) * 0.7 + (sum(route_lengths) - (sum(route_lengths) + distance_increase)) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = route_idx\n                    best_position = pos\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the relocation\n            new_route = np.concatenate([selected_solution[best_route][:best_position],\n                                      np.array(cluster),\n                                      selected_solution[best_route][best_position:]])\n\n            new_solution = selected_solution.copy()\n            new_solution[best_route] = new_route\n\n            # Remove relocated customers from their original routes\n            for customer in cluster:\n                for route_idx in range(len(new_solution)):\n                    if customer in new_solution[route_idx][1:-1]:\n                        mask = new_solution[route_idx] != customer\n                        new_solution[route_idx] = new_solution[route_idx][mask]\n                        if len(new_solution[route_idx]) == 2:  # Only depot left\n                            new_solution.pop(route_idx)\n                        break\n\n            return new_solution\n\n    # If relocation didn't work, try merging clusters from different routes\n    for i in range(len(cluster_members)):\n        for j in range(i+1, len(cluster_members)):\n            combined_demand = sum(demand[cluster_members[i]]) + sum(demand[cluster_members[j]])\n\n            if combined_demand <= capacity:\n                # Find best pair of routes to merge these clusters\n                best_pair = None\n                best_improvement = 0\n\n                for route1_idx in range(len(selected_solution)):\n                    for route2_idx in range(route1_idx+1, len(selected_solution)):\n                        if (sum(demand[selected_solution[route1_idx][1:-1]]) +\n                            sum(demand[selected_solution[route2_idx][1:-1]])) + combined_demand <= capacity:\n\n                            # Calculate potential improvement\n                            original_length = sum(distance_matrix[selected_solution[route1_idx][:-1], selected_solution[route1_idx][1:]]) + \\\n                                             sum(distance_matrix[selected_solution[route2_idx][:-1], selected_solution[route2_idx][1:]])\n\n                            # Create merged route\n                            merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                          cluster_members[i],\n                                                          selected_solution[route2_idx][1:]])\n\n                            new_length = sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n                            improvement = original_length - new_length\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_pair = (route1_idx, route2_idx)\n\n                if best_pair is not None and best_improvement > 0:\n                    route1_idx, route2_idx = best_pair\n                    merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                  cluster_members[i],\n                                                  selected_solution[route2_idx][1:]])\n\n                    new_solution = [route for idx, route in enumerate(selected_solution)\n                                  if idx not in [route1_idx, route2_idx]]\n                    new_solution.append(merged_route)\n\n                    # Remove merged clusters from their original positions\n                    for customer in cluster_members[i] + cluster_members[j]:\n                        for route_idx in range(len(new_solution)):\n                            if customer in new_solution[route_idx][1:-1]:\n                                mask = new_solution[route_idx] != customer\n                                new_solution[route_idx] = new_solution[route_idx][mask]\n                                if len(new_solution[route_idx]) == 2:  # Only depot left\n                                    new_solution.pop(route_idx)\n                                break\n\n                    return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.9304719574529826,
               0.4577655494213104
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Multi-Objective Route Balancing,\" first identifies the solution with the highest makespan and second-highest total distance from the archive, suggesting it has significant potential for improvement in both objectives. It then analyzes the spatial distribution of customers and demand patterns across all routes, dynamically grouping customers into clusters based on a combination of spatial proximity and demand similarity. The algorithm then strategically redistributes these clusters by either merging them with existing routes or creating entirely new routes, carefully evaluating each move to ensure it reduces the makespan while maintaining or improving the total distance. If no beneficial redistribution is found, it attempts to balance the routes by transferring customers from the longest routes to shorter ones, ensuring capacity constraints are met throughout the process. The operator dynamically adjusts its clustering and redistribution strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective balancing to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Find the shortest route\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx]\n\n    # Try to transfer customers from longest to shortest route\n    for customer in longest_customers:\n        if route_demands[shortest_route_idx] + demand[customer] <= capacity:\n            # Find best insertion position in shortest route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(shortest_route)):\n                prev_node = shortest_route[pos-1]\n                next_node = shortest_route[pos]\n                current_dist = distance_matrix[prev_node][next_node]\n                new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                increase = new_dist - current_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Create new routes\n            new_longest_route = np.concatenate([longest_route[:np.where(longest_route == customer)[0][0]],\n                                               longest_route[np.where(longest_route == customer)[0][0]+1:]])\n            new_shortest_route = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution[shortest_route_idx] = new_shortest_route\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < route_lengths[longest_route_idx]:\n                return new_solution\n\n    # If no transfer worked, try to create new route from compact cluster\n    if len(longest_customers) > 1:\n        # Find most compact cluster of 2 customers\n        min_spread = float('inf')\n        best_pair = (longest_customers[0], longest_customers[1])\n\n        for i in range(len(longest_customers)):\n            for j in range(i+1, len(longest_customers)):\n                dist = distance_matrix[longest_customers[i]][longest_customers[j]]\n                if dist < min_spread:\n                    min_spread = dist\n                    best_pair = (longest_customers[i], longest_customers[j])\n\n        # Check if pair can form a new route\n        if demand[best_pair[0]] + demand[best_pair[1]] <= capacity:\n            new_route = np.array([0, best_pair[0], best_pair[1], 0])\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in best_pair] + [0])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < route_lengths[longest_route_idx]:\n                return new_solution\n\n    # If no improvement found, try to merge two shortest routes if possible\n    if len(selected_solution) > 2:\n        # Find two shortest routes\n        sorted_indices = np.argsort(route_lengths)\n        route1_idx = sorted_indices[0]\n        route2_idx = sorted_indices[1]\n\n        if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n            route1 = selected_solution[route1_idx]\n            route2 = selected_solution[route2_idx]\n\n            # Create merged route\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(selected_solution)\n                          if idx not in [route1_idx, route2_idx]]\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8925838658920906,
               0.30188223719596863
          ]
     },
     {
          "algorithm": "{The new algorithm, \"Spatial-Demand Hybrid Clustering with Adaptive Route Splitting,\" first selects the solution with the highest total distance from the archive to identify the most inefficient route, then applies a novel spatial-demand hybrid clustering approach that dynamically partitions customers into clusters based on both geographic proximity and demand compatibility, while adaptively splitting and merging routes to balance spatial efficiency and demand constraints, resulting in a feasible neighbor solution that significantly reduces total distance while improving route balance and minimizing makespan through a hybrid operator that combines spatial optimization with demand-aware route adjustments.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    unassigned_customers.sort(key=lambda x: (coords[x][0], coords[x][1], demand[x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n    current_center = np.array([0.0, 0.0])\n    customer_count = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n            customer_count += 1\n            current_center = ((customer_count - 1) * current_center + coords[customer]) / customer_count\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n            customer_count = 1\n            current_center = coords[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            split_point = len(route) // 2\n            first_part = np.concatenate([route[:split_point], [0]])\n            second_part = np.concatenate([[0], route[split_point:-1], [0]])\n            selected_solution[i] = first_part\n            selected_solution.append(second_part)\n\n    new_solution = selected_solution + new_routes\n    return new_solution\n\n",
          "score": [
               -0.8075392774613397,
               0.12542086839675903
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Adaptive Demand-Spatial Bifurcation and Consolidation,\" first selects a solution from the archive by prioritizing those with the highest makespan and total distance, indicating significant potential for improvement in both objectives. It then analyzes the demand distribution and spatial proximity of customers to identify \"demand-spatial hotspots\" - regions where high-demand customers are densely packed. The algorithm strategically splits these hotspots into multiple smaller, balanced clusters by considering both demand feasibility and spatial compactness, creating new routes that serve these clusters while maintaining vehicle capacity constraints. Simultaneously, it consolidates underutilized routes by merging them with nearby clusters when feasible, reducing the makespan and total distance. The operator dynamically adjusts its clustering and merging criteria based on demand imbalances and spatial distribution, ultimately creating a new neighbor solution that improves both objectives through careful demand-spatial analysis and adaptive route restructuring.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and lengths\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n\n    # Identify overloaded routes and underutilized routes\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d > capacity]\n    underutilized_routes = [i for i, d in enumerate(route_demands) if d < capacity * 0.3]\n\n    # If there are overloaded routes, try to split them\n    for route_idx in overloaded_routes:\n        route = selected_solution[route_idx]\n        customers = route[1:-1]\n\n        # Find the best split point based on demand balance\n        best_split = None\n        min_demand_diff = float('inf')\n\n        for i in range(1, len(customers)):\n            demand1 = sum(demand[customers[:i]])\n            demand2 = sum(demand[customers[i:]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                demand_diff = abs(demand1 - demand2)\n                if demand_diff < min_demand_diff:\n                    min_demand_diff = demand_diff\n                    best_split = i\n\n        if best_split is not None:\n            # Create two new routes\n            new_route1 = np.concatenate([[0], customers[:best_split], [0]])\n            new_route2 = np.concatenate([[0], customers[best_split:], [0]])\n\n            # Replace the original route with the two new routes\n            new_solution = [route for i, route in enumerate(selected_solution) if i != route_idx]\n            new_solution.extend([new_route1, new_route2])\n\n            # Check if any underutilized routes can be merged\n            for under_route_idx in underutilized_routes:\n                under_route = new_solution[under_route_idx]\n                under_demand = sum(demand[under_route[1:-1]])\n\n                for new_route in [new_route1, new_route2]:\n                    new_demand = sum(demand[new_route[1:-1]])\n                    if under_demand + new_demand <= capacity:\n                        # Merge routes\n                        merged_route = np.concatenate([under_route[:-1], new_route[1:]])\n                        new_solution[under_route_idx] = merged_route\n                        new_solution.remove(new_route)\n                        break\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n            # If the new solution is better, return it\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    # If no improvement from splitting, try merging underutilized routes\n    if len(underutilized_routes) >= 2:\n        for i in range(len(underutilized_routes)-1):\n            for j in range(i+1, len(underutilized_routes)):\n                route1_idx = underutilized_routes[i]\n                route2_idx = underutilized_routes[j]\n\n                if route1_idx >= len(selected_solution) or route2_idx >= len(selected_solution):\n                    continue\n\n                route1 = selected_solution[route1_idx]\n                route2 = selected_solution[route2_idx]\n\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if combined_demand <= capacity:\n                    # Find the best insertion point to merge\n                    best_insertion = None\n                    min_distance_increase = float('inf')\n\n                    for pos in range(1, len(route1)):\n                        prev_node = route1[pos-1]\n                        next_node = route1[pos]\n                        first_node = route2[1]\n                        last_node = route2[-2]\n\n                        distance_increase = (distance_matrix[prev_node][first_node] +\n                                           distance_matrix[last_node][next_node] -\n                                           distance_matrix[prev_node][next_node])\n\n                        if distance_increase < min_distance_increase:\n                            min_distance_increase = distance_increase\n                            best_insertion = pos\n\n                    if best_insertion is not None:\n                        # Merge routes\n                        new_route = np.concatenate([route1[:best_insertion], route2[1:-1], route1[best_insertion:]])\n                        new_solution = [route for idx, route in enumerate(selected_solution)\n                                      if idx not in [route1_idx, route2_idx]]\n                        new_solution.append(new_route)\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n                        # If the new solution is better, return it\n                        new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                        if max(new_route_lengths) < max(route_lengths):\n                            return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8618736113167713,
               0.2335127592086792
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Demand-Aware Spatial Partitioning and Multi-Objective Route Realignment,\" first selects a solution from the archive by prioritizing those with the highest makespan and second-highest total distance, indicating significant potential for improvement in both objectives. It then partitions the solution space into demand-aware spatial regions by clustering customers based on both spatial proximity and demand similarity, dynamically adjusting the cluster formation to balance the trade-off between spatial compactness and demand feasibility. The algorithm then strategically realigns these clusters by either merging them with existing routes, splitting them into new routes, or redistributing them to reduce the makespan while maintaining or improving the total distance. The operator employs a hybrid evaluation framework that considers both spatial and demand metrics to assess the quality of each realignment move, ensuring that all generated neighbor solutions are feasible and potentially dominate the current Pareto front in the bi-objective space. The method dynamically adapts its clustering and realignment strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective optimization to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Find demand-aware spatial clusters in the longest route\n    clusters = []\n    cluster_demands = []\n    temp_cluster = []\n    temp_demand = 0\n\n    for customer in longest_customers:\n        if temp_demand + demand[customer] <= capacity * 0.7:  # Allow some slack for insertion\n            temp_cluster.append(customer)\n            temp_demand += demand[customer]\n        else:\n            if temp_cluster:\n                clusters.append(temp_cluster)\n                cluster_demands.append(temp_demand)\n                temp_cluster = [customer]\n                temp_demand = demand[customer]\n    if temp_cluster:\n        clusters.append(temp_cluster)\n        cluster_demands.append(temp_demand)\n\n    # Try to reassign clusters to other routes or create new routes\n    new_solution = selected_solution.copy()\n    for i, cluster in enumerate(clusters):\n        cluster_demand = cluster_demands[i]\n        best_route = None\n        best_pos = None\n        best_score = float('inf')\n\n        # Try to insert the cluster into existing routes\n        for j, route in enumerate(new_solution):\n            if j == longest_route_idx:\n                continue\n            current_demand = route_demands[j]\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            # Find best insertion position\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                # Calculate spatial compactness score\n                spatial_score = (distance_matrix[prev_node][first_node] +\n                                distance_matrix[last_node][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                # Calculate demand balance score\n                demand_balance = abs((current_demand + cluster_demand) - capacity/2)\n\n                # Combined score\n                combined_score = spatial_score + 0.5 * demand_balance\n\n                if combined_score < best_score:\n                    best_score = combined_score\n                    best_route = j\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = new_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            new_solution[best_route] = new_route\n\n            # Update the longest route\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in cluster] + [0])\n            new_solution[longest_route_idx] = new_longest_route\n            longest_customers = new_longest_route[1:-1]\n\n            # Update route demands\n            route_demands[best_route] += cluster_demand\n            route_demands[longest_route_idx] -= cluster_demand\n            break\n\n    # If no cluster was moved, try to create a new route from a compact cluster\n    if len(longest_customers) > 1:\n        # Find most compact cluster of 2 customers\n        min_spread = float('inf')\n        best_pair = (longest_customers[0], longest_customers[1])\n\n        for i in range(len(longest_customers)):\n            for j in range(i+1, len(longest_customers)):\n                dist = distance_matrix[longest_customers[i]][longest_customers[j]]\n                if dist < min_spread:\n                    min_spread = dist\n                    best_pair = (longest_customers[i], longest_customers[j])\n\n        # Check if pair can form a new route\n        if demand[best_pair[0]] + demand[best_pair[1]] <= capacity:\n            new_route = np.array([0, best_pair[0], best_pair[1], 0])\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in best_pair] + [0])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    # If no improvement found, try to merge two shortest routes if possible\n    if len(new_solution) > 2:\n        # Find two shortest routes\n        sorted_indices = np.argsort([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        route1_idx = sorted_indices[0]\n        route2_idx = sorted_indices[1]\n\n        if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Create merged route\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution)\n                          if idx not in [route1_idx, route2_idx]]\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    return new_solution\n\n",
          "score": [
               -0.9406303032711061,
               0.7295059561729431
          ]
     },
     {
          "algorithm": "{The novel \"Spatial-Demand Harmonization with Adaptive Route Fusion\" algorithm first selects a solution from the archive by prioritizing those with the highest total distance and moderate makespan, then dynamically identifies spatial-demand clusters by analyzing customer demand patterns and geographic proximity, creating a demand-weighted spatial grid to group customers into potential route segments, then adaptively fuses these clusters by solving a minimum spanning tree problem on a demand-weighted graph, where edges represent spatial adjacency and weights reflect both distance and demand compatibility, ensuring capacity constraints through a local search-based demand balancing step that iteratively adjusts cluster assignments to minimize capacity violations while optimizing both objectives, finally producing a neighbor solution that harmonizes spatial efficiency with demand balance through a novel combination of clustering and fusion techniques.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Collect all customers from selected solution\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    # Create demand-weighted spatial grid\n    from sklearn.cluster import KMeans\n    k = max(3, len(unassigned_customers) // 5)  # Dynamic number of clusters\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(coords[unassigned_customers])\n    clusters = kmeans.labels_\n\n    # Create cluster demand and centroids\n    cluster_info = []\n    for i in range(k):\n        cluster_customers = [unassigned_customers[j] for j in range(len(unassigned_customers)) if clusters[j] == i]\n        if not cluster_customers:\n            continue\n        total_demand = sum(demand[cluster_customers])\n        centroid = coords[cluster_customers].mean(axis=0)\n        cluster_info.append((i, cluster_customers, total_demand, centroid))\n\n    # Sort clusters by total demand (descending)\n    cluster_info.sort(key=lambda x: -x[2])\n\n    # Create initial routes from clusters\n    new_routes = []\n    for cluster in cluster_info:\n        cluster_customers = cluster[1]\n        current_route = [0]\n        current_load = 0\n        for customer in cluster_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n\n    # Combine with existing routes\n    new_solution = selected_solution + new_routes\n\n    # Adaptive route fusion\n    from scipy.spatial import distance_matrix as scipy_distance_matrix\n\n    # Create distance matrix for all routes\n    route_centroids = []\n    for route in new_solution:\n        route_customers = route[1:-1]\n        if len(route_customers) > 0:\n            centroid = coords[route_customers].mean(axis=0)\n        else:\n            centroid = coords[0]  # depot if empty route\n        route_centroids.append(centroid)\n    route_dist_matrix = scipy_distance_matrix(route_centroids, route_centroids)\n\n    # Find closest route pairs for potential merging\n    route_pairs = []\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route_pairs.append((i, j, route_dist_matrix[i][j]))\n\n    # Sort by distance (ascending)\n    route_pairs.sort(key=lambda x: x[2])\n\n    # Try merging closest routes if feasible\n    for pair in route_pairs:\n        i, j, dist = pair\n        if i >= len(new_solution) or j >= len(new_solution):\n            continue\n\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if combined_demand > capacity:\n            continue\n\n        # Find best insertion point\n        best_insertion = None\n        min_distance_increase = float('inf')\n\n        for pos in range(1, len(route1)):\n            prev_node = route1[pos-1]\n            next_node = route1[pos]\n            first_node = route2[1]\n            last_node = route2[-2]\n\n            distance_increase = (distance_matrix[prev_node][first_node] +\n                               distance_matrix[last_node][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n            if distance_increase < min_distance_increase:\n                min_distance_increase = distance_increase\n                best_insertion = pos\n\n        if best_insertion is not None:\n            # Merge routes\n            new_route = np.concatenate([route1[:best_insertion], route2[1:-1], route1[best_insertion:]])\n            merged_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n            merged_solution.append(new_route)\n\n            # Check capacity constraint\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) > capacity:\n                    break\n            else:\n                # If all routes satisfy capacity, return merged solution\n                return merged_solution\n\n    return new_solution\n\n",
          "score": [
               -0.623142682819154,
               0.11720675230026245
          ]
     }
]