[
     {
          "algorithm": "{The novel hybrid local search operator first selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a combination of route splitting and customer reinsertion with feasibility checks to generate a neighbor solution. It identifies the shortest route in the selected solution and attempts to split it into two routes by relocating a segment of customers to a new route, ensuring capacity constraints are met. If splitting is infeasible, it performs a customer reinsertion by removing a customer from the shortest route and inserting it into another route, choosing the insertion position that minimizes the increase in total distance while maintaining the makespan. The operator also considers the distance matrix to ensure the new solution maintains or improves the total travel distance while minimizing the makespan. The process repeats for a predefined number of iterations or until no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find the shortest route\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Try to split the shortest route into two\n    for i in range(1, len(shortest_route) - 1):\n        first_part = shortest_route[:i+1]\n        second_part = np.concatenate([[0], shortest_route[i+1:]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[shortest_route_idx] = first_part\n            new_solution.append(second_part)\n\n            # Check if this improves the makespan\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) <= max(route_lengths):\n                return new_solution\n\n    # If splitting didn't work, try reinserting a customer from the shortest route\n    if len(selected_solution) > 1:\n        # Find another route to insert into\n        for target_route_idx in range(len(selected_solution)):\n            if target_route_idx == shortest_route_idx:\n                continue\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Try moving each customer from shortest route to target route\n            for customer in shortest_route[1:-1]:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_increase = float('inf')\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_pos = pos\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_shortest_route = np.delete(shortest_route, np.where(shortest_route == customer)[0][0])\n                    new_target_route = np.insert(target_route, best_pos, customer)\n\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    new_solution[target_route_idx] = new_target_route\n\n                    # Check if this improves the makespan\n                    new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                    if max(new_route_lengths) <= max(route_lengths):\n                        return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8236050826838496,
               0.12729865312576294
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the idea of intelligently selecting solutions from the archive but introduces a novel approach that combines route fragmentation and adaptive segment reassembly. It first identifies the most diverse solutions in the archive based on both objective values and spatial distribution of routes, then applies a fragmentation-based local search where long routes are systematically broken into smaller segments, each evaluated for potential reassembly with other segments or routes to form more balanced configurations. The reassembly process prioritizes spatial proximity and demand complementarity, while maintaining feasibility, to create solutions that simultaneously reduce total distance through route consolidation and improve makespan through better load balancing. The algorithm dynamically adjusts the fragmentation granularity based on the current solution's characteristics, allowing it to adaptively explore both local and global improvements.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse characteristics\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    diversity_scores = (total_distances - np.mean(total_distances))**2 + (makespans - np.mean(makespans))**2\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def fragment_route(route, min_fragment_size=3):\n        fragments = []\n        current_fragment = [route[0]]\n        current_load = 0\n\n        for node in route[1:-1]:\n            current_load += demand[node]\n            current_fragment.append(node)\n\n            if len(current_fragment) >= min_fragment_size and current_load <= capacity:\n                if np.random.random() < 0.7 or current_load > 0.8 * capacity:\n                    fragments.append(np.array(current_fragment + [0]))\n                    current_fragment = [0]\n                    current_load = 0\n\n        if len(current_fragment) > 1:\n            fragments.append(np.array(current_fragment + [0]))\n\n        return fragments if len(fragments) > 1 else [route]\n\n    def reassemble_fragments(fragments):\n        reassembled = []\n        remaining = [frag for frag in fragments]\n\n        while remaining:\n            current_route = [0]\n            current_load = 0\n            added = False\n\n            for i, frag in enumerate(remaining):\n                frag_load = np.sum(demand[frag[1:-1]])\n                if current_load + frag_load <= capacity:\n                    current_route.extend(frag[1:-1])\n                    current_load += frag_load\n                    remaining.pop(i)\n                    added = True\n                    break\n\n            if not added:\n                if len(current_route) > 1:\n                    reassembled.append(np.array(current_route + [0]))\n                remaining.pop(0)\n\n            if len(current_route) > 1:\n                reassembled.append(np.array(current_route + [0]))\n\n        return reassembled if reassembled else fragments\n\n    # Perform fragmentation and reassembly\n    all_fragments = []\n    for route in new_solution:\n        fragments = fragment_route(route)\n        all_fragments.extend(fragments)\n\n    new_solution = reassemble_fragments(all_fragments)\n\n    # Additional local improvements\n    improved = True\n    max_iter = 50\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Try to merge adjacent fragments\n        if len(new_solution) > 1:\n            i = np.random.randint(0, len(new_solution))\n            j = (i + 1) % len(new_solution)\n\n            merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if is_feasible(merged):\n                new_route_length = route_length(merged)\n                original_length = route_length(new_solution[i]) + route_length(new_solution[j])\n\n                if new_route_length < original_length * 0.95:\n                    new_solution[i] = merged\n                    del new_solution[j]\n                    improved = True\n\n        # Try to move a customer between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if len(new_solution[i]) > 3 and len(new_solution[j]) > 2:\n                customer_idx = np.random.randint(1, len(new_solution[i]) - 1)\n                customer = new_solution[i][customer_idx]\n\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_dist = route_length(new_solution[i]) + route_length(new_solution[j])\n                    new_i = np.concatenate([new_solution[i][:customer_idx], new_solution[i][customer_idx+1:]])\n                    new_j = np.concatenate([new_solution[j][:-1], [customer], [0]])\n\n                    new_dist = route_length(new_i) + route_length(new_j)\n\n                    if new_dist < original_dist * 0.98:\n                        new_solution[i] = new_i\n                        new_solution[j] = new_j\n                        improved = True\n\n    return new_solution\n\n",
          "score": [
               -0.9048805479347265,
               1.5466918349266052
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Multi-Objective Route Balancing and Diversification,\" first selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, indicating potential for improving makespan while maintaining or reducing total distance. It then identifies the longest route in the solution and attempts to redistribute its customers to other routes by strategically inserting segments at positions that minimize the increase in total distance and balance the makespan across all routes. If redistribution is infeasible, it creates a new route by extracting a segment of customers from the longest route that forms a compact cluster in space, ensuring the new route's makespan is below the current average makespan. The operator dynamically adjusts the segment size and insertion points based on spatial proximity and demand patterns to explore diverse neighborhoods, ultimately creating a new neighbor solution that improves both objectives while maintaining feasibility through careful capacity checks and spatial analysis.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and makespan\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    makespan = max(route_lengths)\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Try to redistribute customers from the longest route to other routes\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n        target_route = selected_solution[i].copy()\n\n        # Find the best segment to move (minimize distance increase)\n        best_segment = None\n        best_increase = float('inf')\n\n        for j in range(1, len(longest_route) - 1):\n            segment = longest_route[j:]\n            segment_demand = sum(demand[segment[:-1]])\n\n            if sum(demand[target_route[:-1]]) + segment_demand <= capacity:\n                # Calculate potential increase in total distance\n                insert_positions = range(1, len(target_route))\n                for pos in insert_positions:\n                    # Calculate distance increase\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    first_node = segment[0]\n                    last_node = segment[-2]\n\n                    distance_increase = (distance_matrix[prev_node][first_node] +\n                                        distance_matrix[last_node][next_node] -\n                                        distance_matrix[prev_node][next_node])\n\n                    if distance_increase < best_increase:\n                        best_increase = distance_increase\n                        best_segment = (j, segment)\n\n        if best_segment is not None:\n            j, segment = best_segment\n            new_longest_route = np.concatenate([longest_route[:j], [0]])\n            new_target_route = np.concatenate([target_route[:-1], segment])\n\n            # Check makespan improvement\n            new_longest_length = sum(distance_matrix[new_longest_route[:-1], new_longest_route[1:]])\n            new_target_length = sum(distance_matrix[new_target_route[:-1], new_target_route[1:]])\n\n            if max(new_longest_length, new_target_length) < makespan:\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution[i] = new_target_route\n                return new_solution\n\n    # If redistribution failed, try creating a new route from a compact segment\n    if len(longest_route) > 3:  # Need at least 2 customers to form a new route\n        # Find the most compact segment (minimize spatial spread)\n        min_spread = float('inf')\n        best_segment = None\n\n        for j in range(1, len(longest_route) - 2):\n            for k in range(j + 1, len(longest_route) - 1):\n                segment = longest_route[j:k+1]\n                segment_nodes = segment[:-1]\n                segment_demand = sum(demand[segment_nodes])\n\n                if segment_demand > capacity:\n                    continue\n\n                # Calculate spatial spread (max distance between any two nodes in segment)\n                max_dist = 0\n                for node1 in segment_nodes:\n                    for node2 in segment_nodes:\n                        if node1 != node2:\n                            dist = distance_matrix[node1][node2]\n                            if dist > max_dist:\n                                max_dist = dist\n\n                if max_dist < min_spread:\n                    min_spread = max_dist\n                    best_segment = (j, k, segment)\n\n        if best_segment is not None:\n            j, k, segment = best_segment\n            new_longest_route = np.concatenate([longest_route[:j], longest_route[k+1:]])\n            new_route = np.concatenate([[0], segment, [0]])\n\n            # Check makespan improvement\n            new_longest_length = sum(distance_matrix[new_longest_route[:-1], new_longest_route[1:]])\n            new_route_length = sum(distance_matrix[new_route[:-1], new_route[1:]])\n\n            if max(new_longest_length, new_route_length) < makespan:\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution.append(new_route)\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8520311510008584,
               0.3980441987514496
          ]
     },
     {
          "algorithm": "{The algorithm first intelligently selects a promising solution from the archive by identifying those with low total distance and makespan, then applies a hybrid local search operator that combines route merging, customer reallocation, and a novel \"route balancing\" step to reduce both objectives. Route merging combines short routes to save distance, while customer reallocation redistributes demand to balance loads, and route balancing adjusts route lengths by iteratively moving customers between routes to minimize the maximum route length. The method ensures feasibility by checking capacity constraints at each step and uses a probabilistic acceptance criterion to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with low total distance and makespan\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route merging (combine short routes to reduce total distance)\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) + len(new_solution[j]) - 2 <= 10:  # Limit route length\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    # Check if merging improves total distance\n                    original_dist = distance_matrix[new_solution[i][-2], 0] + distance_matrix[new_solution[j][1], 0]\n                    merged_dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]\n                    if merged_dist < original_dist:\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    # Step 2: Customer reallocation (redistribute customers to balance loads)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        current_load = np.sum(demand[route[1:-1]])\n        if current_load < capacity * 0.7:  # If route is underutilized\n            for other_route in new_solution:\n                if len(other_route) <= 3 or other_route is route:\n                    continue\n                # Try to move a customer from other_route to this route\n                for i in range(1, len(other_route) - 1):\n                    customer = other_route[i]\n                    new_load = current_load + demand[customer]\n                    if new_load <= capacity:\n                        # Check if moving improves makespan\n                        original_dist = distance_matrix[other_route[i-1], other_route[i]] + distance_matrix[other_route[i], other_route[i+1]]\n                        new_dist = distance_matrix[other_route[i-1], other_route[i+1]] + distance_matrix[route[-2], customer] + distance_matrix[customer, 0]\n                        if new_dist < original_dist:\n                            # Perform the move\n                            route[-1] = customer\n                            route = np.append(route, 0)\n                            other_route = np.delete(other_route, i)\n                            current_load = new_load\n                            break\n\n    # Step 3: Route balancing (adjust route lengths to minimize makespan)\n    if len(new_solution) > 1:\n        max_route = max(new_solution, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n        min_route = min(new_solution, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n        if max_route is not min_route:\n            # Try to move a customer from max_route to min_route\n            for i in range(1, len(max_route) - 1):\n                customer = max_route[i]\n                if np.sum(demand[min_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential improvement\n                    original_max_dist = np.sum(distance_matrix[max_route[:-1], max_route[1:]])\n                    new_max_dist = original_max_dist - distance_matrix[max_route[i-1], max_route[i]] - distance_matrix[max_route[i], max_route[i+1]] + distance_matrix[max_route[i-1], max_route[i+1]]\n                    new_min_dist = np.sum(distance_matrix[min_route[:-1], min_route[1:]]) + distance_matrix[min_route[-2], customer] + distance_matrix[customer, 0]\n                    if new_max_dist < original_max_dist and new_min_dist < np.sum(distance_matrix[max_route[:-1], max_route[1:]]):\n                        # Perform the move\n                        min_route[-1] = customer\n                        min_route = np.append(min_route, 0)\n                        max_route = np.delete(max_route, i)\n                        break\n\n    # Ensure solution is feasible and non-empty\n    if not new_solution:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7722103387038257,
               0.3427191376686096
          ]
     },
     {
          "algorithm": "{The novel local search strategy, called \"Route Fusion and Fission,\" first selects a promising solution from the archive by prioritizing those with high total distance and low makespan, indicating potential for balancing route lengths. It then randomly selects two routes from this solution and attempts to merge them by inserting a \"bridge\" node (a customer not in either route) between them, ensuring capacity constraints are met. If merging is infeasible, it instead splits one route into two by finding a high-demand node and dividing the route around it, ensuring both new routes stay within capacity. The strategy dynamically adjusts the bridge or split point based on demand and distance to improve both objectives, yielding a feasible neighbor solution with potentially reduced total distance and more balanced makespan.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy() if len(archive_sorted) > 1 else archive_sorted[0][0].copy()\n\n    # Choose two distinct routes to attempt fusion or fission\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n    route1 = selected_solution[route1_idx].copy()\n    route2 = selected_solution[route2_idx].copy()\n\n    # Attempt Route Fusion: Try to merge route1 and route2 via a bridge node\n    all_customers = set(range(1, len(coords)))\n    used_customers = set()\n    for route in selected_solution:\n        used_customers.update(route[1:-1])  # Exclude depot\n    available_bridges = list(all_customers - used_customers)\n\n    if available_bridges:\n        # Sort bridges by demand (ascending) to prefer smaller bridges\n        available_bridges.sort(key=lambda x: demand[x])\n        for bridge in available_bridges:\n            # Check if adding bridge to route1 or route2 is feasible\n            total_demand_route1 = sum(demand[route1[1:-1]])\n            total_demand_route2 = sum(demand[route2[1:-1]])\n            if total_demand_route1 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route1 and depot\n                new_route = np.concatenate([route1[:-1], [bridge], route2[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n            if total_demand_route2 + demand[bridge] <= capacity:\n                # Insert bridge between last node of route2 and depot\n                new_route = np.concatenate([route2[:-1], [bridge], route1[1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Replace the two routes with the merged route\n                    new_solution = [route for i, route in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n                    new_solution.append(new_route)\n                    return new_solution\n\n    # If fusion failed, attempt Route Fission: Split a route into two\n    # Choose the route with the highest demand (potential for better split)\n    route_to_split = max(selected_solution, key=lambda x: sum(demand[x[1:-1]]))\n    customers_in_route = route_to_split[1:-1]\n    if len(customers_in_route) < 2:\n        return selected_solution\n\n    # Find the best split point (high demand node)\n    best_split_idx = -1\n    best_split_demand = -1\n    for i, node in enumerate(customers_in_route):\n        if demand[node] > best_split_demand:\n            best_split_demand = demand[node]\n            best_split_idx = i\n\n    if best_split_idx != -1:\n        # Split the route at best_split_idx\n        first_part = np.concatenate([[0], customers_in_route[:best_split_idx+1], [0]])\n        second_part = np.concatenate([[0], customers_in_route[best_split_idx+1:], [0]])\n\n        # Check capacity constraints\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution = [route for route in selected_solution if not np.array_equal(route, route_to_split)]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    return selected_solution\n\n",
          "score": [
               -0.7668818254597687,
               0.17718800902366638
          ]
     },
     {
          "algorithm": "{The function begins by selecting a promising solution from the archive using a weighted random selection based on the normalized ranks of the solutions' total distance and makespan, favoring solutions with lower objective values. It then applies a hybrid local search strategy that combines route splitting, cross-exchange, and adaptive 3-opt moves, where route splitting dynamically divides long routes into smaller segments if they exceed a capacity threshold, cross-exchange swaps segments between routes while ensuring feasibility, and adaptive 3-opt selectively reorders nodes in critical segments based on their impact on the makespan. The strategy prioritizes reducing the makespan by focusing on the longest route while minimizing total distance through segment swaps and reordering. After each operation, feasibility is verified by checking vehicle capacities and route continuity, and the process repeats until no further improvements are found or a maximum iteration limit is reached. The final solution is returned as a list of feasible routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weights\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_dist = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-6)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-6)\n    weights = 0.5 * norm_dist + 0.5 * norm_makespan\n    selected_idx = np.random.choice(len(archive), p=weights / np.sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search strategy\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def route_length(route):\n        return np.sum(distance_matrix[route[:-1], route[1:]])\n\n    def split_route(route):\n        # Split a route into two if it exceeds capacity\n        if not is_feasible(route):\n            total_demand = np.sum(demand[route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_pos = i\n                    break\n            return [np.concatenate([route[:split_pos], [0]]), np.concatenate([[0], route[split_pos:]])]\n        return [route]\n\n    def cross_exchange(route1, route2):\n        # Cross-exchange between two routes\n        if len(route1) <= 2 or len(route2) <= 2:\n            return route1, route2\n\n        # Find segments to swap\n        i = np.random.randint(1, len(route1) - 1)\n        j = np.random.randint(1, len(route2) - 1)\n\n        # Perform cross-exchange\n        new_route1 = np.concatenate([route1[:i], route2[j:-1], route1[i:]])\n        new_route2 = np.concatenate([route2[:j], route1[i:-1], route2[j:]])\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            return new_route1, new_route2\n        return route1, route2\n\n    def adaptive_3opt(route):\n        # Adaptive 3-opt for makespan reduction\n        if len(route) <= 4:\n            return route\n\n        # Identify critical segments (top 20% longest edges)\n        edges = distance_matrix[route[:-1], route[1:]]\n        sorted_indices = np.argsort(edges)[::-1]\n        critical_indices = sorted_indices[:max(2, len(sorted_indices) // 5)]\n\n        for i in critical_indices:\n            if i + 2 >= len(route) - 1:\n                continue\n            # Try 3-opt move\n            a, b, c, d = route[i], route[i+1], route[i+2], route[i+3]\n            new_route = np.concatenate([route[:i], [a, c, b, d], route[i+3:]])\n            if is_feasible(new_route):\n                return new_route\n        return route\n\n    # Perform local search\n    improved = True\n    max_iter = 100\n    iter_count = 0\n\n    while improved and iter_count < max_iter:\n        improved = False\n        iter_count += 1\n\n        # Step 1: Split long routes\n        new_solution_split = []\n        for route in new_solution:\n            split_routes = split_route(route)\n            if len(split_routes) > 1:\n                improved = True\n            new_solution_split.extend(split_routes)\n        new_solution = new_solution_split\n\n        # Step 2: Cross-exchange between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = cross_exchange(new_solution[i], new_solution[j])\n            if not np.array_equal(route1, new_solution[i]) or not np.array_equal(route2, new_solution[j]):\n                improved = True\n                new_solution[i] = route1\n                new_solution[j] = route2\n\n        # Step 3: Adaptive 3-opt on longest route\n        if len(new_solution) > 0:\n            lengths = [route_length(route) for route in new_solution]\n            longest_idx = np.argmax(lengths)\n            new_route = adaptive_3opt(new_solution[longest_idx])\n            if not np.array_equal(new_route, new_solution[longest_idx]):\n                improved = True\n                new_solution[longest_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.7953106808011949,
               2.653059244155884
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is selecting a promising solution from the archive and applying a combination of route modifications (splitting, reinsertion, and adaptive 2-opt) to generate neighbors while ensuring feasibility. The new algorithm will instead prioritize solutions with high makespan and low total distance, then apply a novel hybrid local search that combines route merging with intelligent customer reallocation, where customers are moved between routes based on their demand and location to balance both objectives, while always checking capacity constraints and using a probabilistic acceptance criterion to allow occasional improvements in one objective without worsening the other.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current makespan and total distance\n    current_makespan = max([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    current_total_distance = sum([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n    # Try to merge routes to reduce makespan\n    if len(new_solution) > 1:\n        # Sort routes by length (ascending)\n        route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        sorted_indices = np.argsort(route_lengths)\n\n        # Try merging shortest routes first\n        for i in range(len(sorted_indices)):\n            for j in range(i + 1, len(sorted_indices)):\n                route1_idx = sorted_indices[i]\n                route2_idx = sorted_indices[j]\n\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check if merging is feasible\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand > capacity:\n                    continue\n\n                # Calculate distance between last of route1 and first of route2\n                last_node1 = route1[-2]\n                first_node2 = route2[1]\n\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Create new solution\n                temp_solution = [r.copy() for r in new_solution]\n                temp_solution[route1_idx] = merged_route\n                temp_solution.pop(route2_idx)\n\n                # Calculate new metrics\n                new_makespan = max([sum(distance_matrix[r[:-1], r[1:]]) for r in temp_solution])\n                new_total_distance = sum([sum(distance_matrix[r[:-1], r[1:]]) for r in temp_solution])\n\n                # Accept if makespan improves or total distance decreases\n                if (new_makespan < current_makespan) or (new_total_distance < current_total_distance):\n                    new_solution = temp_solution\n                    current_makespan = new_makespan\n                    current_total_distance = new_total_distance\n                    break\n\n    # Intelligent customer reallocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 2:  # Skip empty or trivial routes\n            continue\n\n        # Identify customers to potentially move\n        customers = route[1:-1]\n        customer_demands = demand[customers]\n        customer_positions = np.arange(1, len(route)-1)\n\n        # Sort customers by demand (descending) to prioritize heavier customers\n        sorted_customer_indices = np.argsort(-customer_demands)\n\n        for customer_local_idx in sorted_customer_indices:\n            customer = customers[customer_local_idx]\n            customer_pos = customer_positions[customer_local_idx]\n\n            # Try to find a better route for this customer\n            best_route_idx = -1\n            best_pos = -1\n            best_improvement = 0\n\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == route_idx:\n                    continue\n\n                target_route = new_solution[target_route_idx]\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Evaluate all possible insertion positions\n                for pos in range(1, len(target_route)):\n                    # Calculate the change in total distance\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    current_node = route[customer_pos]\n\n                    # Distance without customer\n                    old_distance = distance_matrix[prev_node][next_node]\n\n                    # Distance with customer\n                    new_distance = (distance_matrix[prev_node][current_node] +\n                                 distance_matrix[current_node][next_node])\n\n                    improvement = old_distance - new_distance\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = target_route_idx\n                        best_pos = pos\n\n            # If we found a better position, move the customer\n            if best_route_idx != -1:\n                # Remove from current route\n                new_solution[route_idx] = np.delete(route, customer_pos + 1)\n\n                # Add to target route\n                target_route = new_solution[best_route_idx]\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n                # Update route lengths for future checks\n                route = new_solution[route_idx]\n                customers = route[1:-1]\n                customer_positions = np.arange(1, len(route)-1)\n\n    return new_solution\n\n",
          "score": [
               -0.8113151149899267,
               6.312052488327026
          ]
     },
     {
          "algorithm": "{The proposed algorithm for selecting a neighbor solution and applying a novel local search strategy involves first identifying the most promising solution from the archive by evaluating a composite score that balances the trade-off between total distance and makespan, then applying a hybrid local search that combines route splitting with adaptive 2-opt moves, where the selection of customers to swap is biased towards those contributing the most to the makespan, ensuring feasibility by always checking vehicle capacity constraints before accepting any move. The algorithm also incorporates a probabilistic acceptance criterion based on the potential improvement in both objectives, allowing for occasional uphill moves to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (either high total distance or makespan)\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging with adaptive node swapping\n    for _ in range(3):  # Multiple iterations for better exploration\n        # Find two routes with the smallest total demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i])\n\n        # Try merging the two smallest routes if their combined demand is within capacity\n        if len(sorted_indices) >= 2:\n            i, j = sorted_indices[0], sorted_indices[1]\n            if i > j:\n                i, j = j, i\n\n            combined_demand = route_demands[i] + route_demands[j]\n            if combined_demand <= capacity:\n                route1, route2 = new_solution[i], new_solution[j]\n\n                # Find the best merge point by minimizing distance increase\n                best_merge = None\n                min_cost_increase = float('inf')\n\n                for pos1 in range(1, len(route1)-1):\n                    for pos2 in range(1, len(route2)-1):\n                        # Calculate cost of merging\n                        cost_increase = (distance_matrix[route1[pos1-1]][route2[pos2]] +\n                                        distance_matrix[route2[pos2-1]][route1[pos1]] -\n                                        distance_matrix[route1[pos1-1]][route1[pos1]] -\n                                        distance_matrix[route2[pos2-1]][route2[pos2]])\n\n                        if cost_increase < min_cost_increase:\n                            min_cost_increase = cost_increase\n                            best_merge = (pos1, pos2)\n\n                if best_merge is not None:\n                    pos1, pos2 = best_merge\n                    merged_route = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n\n        # Adaptive node swapping between routes\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find nodes with high demand in route1 and low demand in route2\n            route1_nodes = route1[1:-1]\n            route2_nodes = route2[1:-1]\n\n            route1_demands = demand[route1_nodes]\n            route2_demands = demand[route2_nodes]\n\n            high_demand_nodes = route1_nodes[route1_demands > np.mean(route1_demands)]\n            low_demand_nodes = route2_nodes[route2_demands < np.mean(route2_demands)]\n\n            if len(high_demand_nodes) > 0 and len(low_demand_nodes) > 0:\n                node1 = random.choice(high_demand_nodes)\n                node2 = random.choice(low_demand_nodes)\n\n                # Check if swapping would violate capacity\n                route1_demand = sum(demand[route1[1:-1]])\n                route2_demand = sum(demand[route2[1:-1]])\n\n                if (route1_demand - demand[node1] + demand[node2] <= capacity and\n                    route2_demand - demand[node2] + demand[node1] <= capacity):\n\n                    # Perform the swap\n                    pos1 = np.where(route1 == node1)[0][0]\n                    pos2 = np.where(route2 == node2)[0][0]\n\n                    route1[pos1], route2[pos2] = route2[pos2], route1[pos1]\n\n    return new_solution\n\n",
          "score": [
               -0.39303956251387906,
               0.2583528757095337
          ]
     },
     {
          "algorithm": "{The novel algorithm, called \"Route Rebalancing with Demand-Aware Clustering,\" first selects a solution from the archive by prioritizing those with the highest makespan, indicating potential for route length balancing, and then applies a demand-aware clustering approach to regroup customers into routes. It begins by identifying clusters of customers with similar demands and spatial proximity using a k-means-like algorithm, where the number of clusters is determined by the current number of routes. Next, it assigns each cluster to the route with the least remaining capacity that can accommodate its total demand, ensuring feasibility. If a cluster cannot fit into any existing route, it creates a new route. Finally, it refines the solution by iteratively moving customers between routes to further balance the makespan and reduce total distance, while always checking capacity constraints. This approach combines clustering and rebalancing to create a neighbor solution that improves both objectives through intelligent regrouping of customers.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest makespan for rebalancing\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Extract all customers from the solution\n    all_customers = []\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n    all_customers = list(set(all_customers))\n\n    if not all_customers:\n        return selected_solution\n\n    # Determine number of clusters (current number of routes)\n    n_clusters = len(selected_solution)\n\n    # Perform demand-aware clustering (simplified k-means approach)\n    clusters = {i: [] for i in range(n_clusters)}\n    # Initial centroids: first n_clusters customers\n    centroids = all_customers[:n_clusters]\n\n    for _ in range(10):  # Fixed number of iterations for simplicity\n        # Assign customers to nearest centroid based on demand and distance\n        for customer in all_customers:\n            if customer in centroids:\n                continue\n            # Find cluster with closest centroid (demand + distance)\n            best_cluster = 0\n            min_score = float('inf')\n            for cluster_idx in range(n_clusters):\n                centroid = centroids[cluster_idx]\n                # Score combines demand difference and distance\n                score = abs(demand[customer] - demand[centroid]) + distance_matrix[customer][centroid]\n                if score < min_score:\n                    min_score = score\n                    best_cluster = cluster_idx\n            clusters[best_cluster].append(customer)\n\n        # Update centroids (customer with median demand in each cluster)\n        new_centroids = []\n        for cluster_idx in range(n_clusters):\n            cluster_customers = clusters[cluster_idx]\n            if not cluster_customers:\n                new_centroids.append(centroids[cluster_idx])\n                continue\n            # Find customer with median demand\n            sorted_customers = sorted(cluster_customers, key=lambda x: demand[x])\n            median_idx = len(sorted_customers) // 2\n            new_centroids.append(sorted_customers[median_idx])\n        centroids = new_centroids\n        clusters = {i: [] for i in range(n_clusters)}\n\n    # Assign clusters to routes\n    new_solution = []\n    route_capacities = [0.0] * n_clusters\n    route_customers = [[] for _ in range(n_clusters)]\n\n    for cluster_idx in range(n_clusters):\n        cluster_demand = sum(demand[customer] for customer in clusters[cluster_idx])\n        # Find route with least remaining capacity that can accommodate the cluster\n        best_route = -1\n        min_remaining = float('inf')\n        for route_idx in range(len(selected_solution)):\n            remaining = capacity - sum(demand[customer] for customer in selected_solution[route_idx][1:-1])\n            if remaining >= cluster_demand and remaining < min_remaining:\n                min_remaining = remaining\n                best_route = route_idx\n\n        if best_route != -1:\n            # Assign cluster to best route\n            route_customers[best_route].extend(clusters[cluster_idx])\n            route_capacities[best_route] += cluster_demand\n        else:\n            # Create new route if no existing route can accommodate\n            new_solution.append(np.concatenate([[0], clusters[cluster_idx], [0]]))\n\n    # Build routes from assigned customers\n    for route_idx in range(n_clusters):\n        if route_customers[route_idx]:\n            new_solution.append(np.concatenate([[0], route_customers[route_idx], [0]]))\n\n    # Refine solution by moving customers between routes\n    for _ in range(5):  # Fixed number of iterations for simplicity\n        improved = False\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            customers = route[1:-1]\n            if len(customers) < 2:\n                continue\n\n            for customer in customers:\n                # Try moving customer to another route\n                for other_idx in range(len(new_solution)):\n                    if other_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_idx]\n                    other_demand = sum(demand[other_route[1:-1]])\n\n                    if other_demand + demand[customer] <= capacity:\n                        # Calculate potential makespan improvement\n                        current_makespan = max(sum(distance_matrix[np.concatenate([route[:i], route[i+1:]])])\n                                             for i in range(1, len(route)-1))\n                        new_makespan = max(sum(distance_matrix[np.concatenate([other_route[:i], [customer], other_route[i:]])])\n                                         for i in range(1, len(other_route)))\n\n                        if new_makespan < current_makespan:\n                            # Update routes\n                            new_route = route[1:-1].tolist()\n                            new_route.remove(customer)\n                            new_solution[route_idx] = np.concatenate([[0], new_route, [0]])\n\n                            new_other_route = other_route[1:-1].tolist()\n                            new_other_route.append(customer)\n                            new_solution[other_idx] = np.concatenate([[0], new_other_route, [0]])\n\n                            improved = True\n                            break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.7944780691536588,
               9.371444314718246
          ]
     },
     {
          "algorithm": "{The new algorithm, called \"Route Rebalancing with Adaptive Insertion,\" first identifies the most balanced solution in the archive by prioritizing those with the smallest difference between makespan and total distance, then selectively rebalances routes by strategically inserting customers from overloaded routes into underutilized routes, ensuring capacity constraints are met while adaptively adjusting insertion points based on both demand and distance metrics to improve both objectives. This hybrid approach combines the strengths of route fusion and fission with a novel adaptive insertion mechanism that dynamically selects insertion points to minimize both the total distance and makespan, while maintaining feasibility through rigorous capacity checks.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][1] - x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current loads for each route\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_indices = list(range(len(new_solution)))\n\n    # Identify overloaded and underloaded routes\n    overloaded_routes = [i for i in route_indices if route_loads[i] > 0.8 * capacity]\n    underloaded_routes = [i for i in route_indices if route_loads[i] < 0.5 * capacity]\n\n    if not overloaded_routes or not underloaded_routes:\n        return new_solution\n\n    # Try to rebalance by moving customers from overloaded to underloaded routes\n    for over_idx in overloaded_routes:\n        over_route = new_solution[over_idx]\n        customers = over_route[1:-1]\n        if len(customers) < 2:\n            continue\n\n        # Sort customers by demand (descending) to prioritize high-demand nodes\n        sorted_customers = sorted(customers, key=lambda x: -demand[x])\n\n        for customer in sorted_customers:\n            # Find the best underloaded route for insertion\n            best_under_idx = -1\n            min_increase = float('inf')\n\n            for under_idx in underloaded_routes:\n                under_route = new_solution[under_idx]\n                if route_loads[under_idx] + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position in the underloaded route\n                for i in range(len(under_route) - 1):\n                    # Calculate the increase in distance if we insert customer between i and i+1\n                    dist_increase = (distance_matrix[under_route[i]][customer] +\n                                    distance_matrix[customer][under_route[i+1]] -\n                                    distance_matrix[under_route[i]][under_route[i+1]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_under_idx = under_idx\n                        best_pos = i\n\n            if best_under_idx != -1:\n                # Perform the insertion\n                under_route = new_solution[best_under_idx]\n                new_under_route = np.concatenate([\n                    under_route[:best_pos+1],\n                    [customer],\n                    under_route[best_pos+1:]\n                ])\n                new_solution[best_under_idx] = new_under_route\n\n                # Remove the customer from the overloaded route\n                new_over_route = np.concatenate([\n                    over_route[:np.where(over_route == customer)[0][0]],\n                    over_route[np.where(over_route == customer)[0][0]+1:]\n                ])\n                new_solution[over_idx] = new_over_route\n\n                # Update route loads\n                route_loads[best_under_idx] += demand[customer]\n                route_loads[over_idx] -= demand[customer]\n\n                # Break after first successful move to limit computational effort\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.7626367939410912,
               2.193161219358444
          ]
     }
]