[
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, \"Spatial-Demand Hybrid Clustering with Adaptive Route Splitting,\" first selects the solution with the highest total distance from the archive to identify the most inefficient route, then applies a novel spatial-demand hybrid clustering approach that dynamically partitions customers into clusters based on both geographic proximity and demand compatibility, while adaptively splitting and merging routes to balance spatial efficiency and demand constraints, resulting in a feasible neighbor solution that significantly reduces total distance while improving route balance and minimizing makespan through a hybrid operator that combines spatial optimization with demand-aware route adjustments.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    unassigned_customers.sort(key=lambda x: (coords[x][0], coords[x][1], demand[x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n    current_center = np.array([0.0, 0.0])\n    customer_count = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n            customer_count += 1\n            current_center = ((customer_count - 1) * current_center + coords[customer]) / customer_count\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n            customer_count = 1\n            current_center = coords[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            split_point = len(route) // 2\n            first_part = np.concatenate([route[:split_point], [0]])\n            second_part = np.concatenate([[0], route[split_point:-1], [0]])\n            selected_solution[i] = first_part\n            selected_solution.append(second_part)\n\n    new_solution = selected_solution + new_routes\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy, called \"Adaptive Multi-Objective Route Balancing,\" first identifies the solution with the highest makespan and second-highest total distance from the archive, suggesting it has significant potential for improvement in both objectives. It then analyzes the spatial distribution of customers and demand patterns across all routes, dynamically grouping customers into clusters based on a combination of spatial proximity and demand similarity. The algorithm then strategically redistributes these clusters by either merging them with existing routes or creating entirely new routes, carefully evaluating each move to ensure it reduces the makespan while maintaining or improving the total distance. If no beneficial redistribution is found, it attempts to balance the routes by transferring customers from the longest routes to shorter ones, ensuring capacity constraints are met throughout the process. The operator dynamically adjusts its clustering and redistribution strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective balancing to generate high-quality neighbor solutions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Find the shortest route\n    shortest_route_idx = np.argmin(route_lengths)\n    shortest_route = selected_solution[shortest_route_idx]\n\n    # Try to transfer customers from longest to shortest route\n    for customer in longest_customers:\n        if route_demands[shortest_route_idx] + demand[customer] <= capacity:\n            # Find best insertion position in shortest route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(shortest_route)):\n                prev_node = shortest_route[pos-1]\n                next_node = shortest_route[pos]\n                current_dist = distance_matrix[prev_node][next_node]\n                new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                increase = new_dist - current_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Create new routes\n            new_longest_route = np.concatenate([longest_route[:np.where(longest_route == customer)[0][0]],\n                                               longest_route[np.where(longest_route == customer)[0][0]+1:]])\n            new_shortest_route = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution[shortest_route_idx] = new_shortest_route\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < route_lengths[longest_route_idx]:\n                return new_solution\n\n    # If no transfer worked, try to create new route from compact cluster\n    if len(longest_customers) > 1:\n        # Find most compact cluster of 2 customers\n        min_spread = float('inf')\n        best_pair = (longest_customers[0], longest_customers[1])\n\n        for i in range(len(longest_customers)):\n            for j in range(i+1, len(longest_customers)):\n                dist = distance_matrix[longest_customers[i]][longest_customers[j]]\n                if dist < min_spread:\n                    min_spread = dist\n                    best_pair = (longest_customers[i], longest_customers[j])\n\n        # Check if pair can form a new route\n        if demand[best_pair[0]] + demand[best_pair[1]] <= capacity:\n            new_route = np.array([0, best_pair[0], best_pair[1], 0])\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in best_pair] + [0])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < route_lengths[longest_route_idx]:\n                return new_solution\n\n    # If no improvement found, try to merge two shortest routes if possible\n    if len(selected_solution) > 2:\n        # Find two shortest routes\n        sorted_indices = np.argsort(route_lengths)\n        route1_idx = sorted_indices[0]\n        route2_idx = sorted_indices[1]\n\n        if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n            route1 = selected_solution[route1_idx]\n            route2 = selected_solution[route2_idx]\n\n            # Create merged route\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(selected_solution)\n                          if idx not in [route1_idx, route2_idx]]\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    return selected_solution.copy()\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The new algorithm, \"Adaptive Demand-Distance Hybrid Route Fusion,\" first selects the solution with the highest makespan and second-lowest total distance from the archive, identifying it as a candidate for improvement in both objectives. It then analyzes the spatial distribution and demand patterns of all routes, dynamically clustering customers based on a combination of spatial proximity and demand compatibility, while evaluating potential route fusions that could reduce the makespan without significantly increasing the total distance. The algorithm strategically merges routes by selecting pairs of routes with complementary spatial and demand characteristics, carefully evaluating each fusion to ensure it improves the makespan while maintaining or slightly improving the total distance. If no beneficial fusion is found, it attempts to redistribute customers between routes by considering both spatial and demand factors, ensuring capacity constraints are met throughout the process. The operator dynamically adjusts its clustering and fusion strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective balancing to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Try to fuse with another route\n    best_fusion = None\n    best_improvement = 0\n    current_makespan = max(route_lengths)\n\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n\n        other_route = selected_solution[i]\n        other_customers = other_route[1:-1]\n\n        # Check if fusion is possible\n        if route_demands[i] + route_demands[longest_route_idx] > capacity:\n            continue\n\n        # Calculate potential fusion\n        fused_customers = np.concatenate([longest_customers, other_customers])\n        fused_route = np.concatenate([[0], fused_customers, [0]])\n        fused_length = sum(distance_matrix[fused_route[:-1], fused_route[1:]])\n\n        # Calculate new makespan\n        new_route_lengths = route_lengths.copy()\n        new_route_lengths[longest_route_idx] = fused_length\n        new_route_lengths[i] = 0  # Mark for removal\n        new_makespan = max(new_route_lengths)\n\n        # Check if makespan improvement is significant\n        improvement = current_makespan - new_makespan\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_fusion = (i, fused_route)\n\n    # Apply best fusion if found\n    if best_fusion is not None:\n        other_idx, fused_route = best_fusion\n        new_solution = [route for idx, route in enumerate(selected_solution)\n                       if idx != other_idx and idx != longest_route_idx]\n        new_solution.append(fused_route)\n\n        # Calculate new objectives\n        new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        new_total_distance = sum(new_route_lengths)\n        new_makespan = max(new_route_lengths)\n\n        # Check if objectives improved\n        if new_makespan < current_makespan:\n            return new_solution\n\n    # If no fusion worked, try to redistribute customers\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n\n        current_route = selected_solution[i]\n        current_customers = current_route[1:-1]\n\n        for customer in longest_customers:\n            # Check if transfer is possible\n            if route_demands[i] + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(current_route)):\n                prev_node = current_route[pos-1]\n                next_node = current_route[pos]\n                current_dist = distance_matrix[prev_node][next_node]\n                new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                increase = new_dist - current_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Create new routes\n            new_longest_route = np.concatenate([longest_route[:np.where(longest_route == customer)[0][0]],\n                                               longest_route[np.where(longest_route == customer)[0][0]+1:]])\n            new_current_route = np.concatenate([current_route[:best_pos], [customer], current_route[best_pos:]])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution[i] = new_current_route\n\n            # Calculate new objectives\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            new_total_distance = sum(new_route_lengths)\n            new_makespan = max(new_route_lengths)\n\n            # Check if makespan improved\n            if new_makespan < current_makespan:\n                return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.8033886333049972,
               0.9820551872253418
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Try to fuse with another route\n    best_fusion = None\n    best_improvement = 0\n    current_makespan = max(route_lengths)\n\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n\n        other_route = selected_solution[i]\n        other_customers = other_route[1:-1]\n\n        # Check if fusion is possible\n        if route_demands[i] + route_demands[longest_route_idx] > capacity:\n            continue\n\n        # Calculate potential fusion\n        fused_customers = np.concatenate([longest_customers, other_customers])\n        fused_route = np.concatenate([[0], fused_customers, [0]])\n        fused_length = sum(distance_matrix[fused_route[:-1], fused_route[1:]])\n\n        # Calculate new makespan\n        new_route_lengths = route_lengths.copy()\n        new_route_lengths[longest_route_idx] = fused_length\n        new_route_lengths[i] = 0  # Mark for removal\n        new_makespan = max(new_route_lengths)\n\n        # Check if makespan improvement is significant\n        improvement = current_makespan - new_makespan\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_fusion = (i, fused_route)\n\n    # Apply best fusion if found\n    if best_fusion is not None:\n        other_idx, fused_route = best_fusion\n        new_solution = [route for idx, route in enumerate(selected_solution)\n                       if idx != other_idx and idx != longest_route_idx]\n        new_solution.append(fused_route)\n\n        # Calculate new objectives\n        new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        new_total_distance = sum(new_route_lengths)\n        new_makespan = max(new_route_lengths)\n\n        # Check if objectives improved\n        if new_makespan < current_makespan:\n            return new_solution\n\n    # If no fusion worked, try to redistribute customers\n    for i in range(len(selected_solution)):\n        if i == longest_route_idx:\n            continue\n\n        current_route = selected_solution[i]\n        current_customers = current_route[1:-1]\n\n        for customer in longest_customers:\n            # Check if transfer is possible\n            if route_demands[i] + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(current_route)):\n                prev_node = current_route[pos-1]\n                next_node = current_route[pos]\n                current_dist = distance_matrix[prev_node][next_node]\n                new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                increase = new_dist - current_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Create new routes\n            new_longest_route = np.concatenate([longest_route[:np.where(longest_route == customer)[0][0]],\n                                               longest_route[np.where(longest_route == customer)[0][0]+1:]])\n            new_current_route = np.concatenate([current_route[:best_pos], [customer], current_route[best_pos:]])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution[i] = new_current_route\n\n            # Calculate new objectives\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            new_total_distance = sum(new_route_lengths)\n            new_makespan = max(new_route_lengths)\n\n            # Check if makespan improved\n            if new_makespan < current_makespan:\n                return new_solution\n\n    return selected_solution.copy()\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy, called \"Adaptive Demand-Spatial Bifurcation and Consolidation,\" first selects a solution from the archive by prioritizing those with the highest makespan and total distance, indicating significant potential for improvement in both objectives. It then analyzes the demand distribution and spatial proximity of customers to identify \"demand-spatial hotspots\" - regions where high-demand customers are densely packed. The algorithm strategically splits these hotspots into multiple smaller, balanced clusters by considering both demand feasibility and spatial compactness, creating new routes that serve these clusters while maintaining vehicle capacity constraints. Simultaneously, it consolidates underutilized routes by merging them with nearby clusters when feasible, reducing the makespan and total distance. The operator dynamically adjusts its clustering and merging criteria based on demand imbalances and spatial distribution, ultimately creating a new neighbor solution that improves both objectives through careful demand-spatial analysis and adaptive route restructuring.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and lengths\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n\n    # Identify overloaded routes and underutilized routes\n    overloaded_routes = [i for i, d in enumerate(route_demands) if d > capacity]\n    underutilized_routes = [i for i, d in enumerate(route_demands) if d < capacity * 0.3]\n\n    # If there are overloaded routes, try to split them\n    for route_idx in overloaded_routes:\n        route = selected_solution[route_idx]\n        customers = route[1:-1]\n\n        # Find the best split point based on demand balance\n        best_split = None\n        min_demand_diff = float('inf')\n\n        for i in range(1, len(customers)):\n            demand1 = sum(demand[customers[:i]])\n            demand2 = sum(demand[customers[i:]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                demand_diff = abs(demand1 - demand2)\n                if demand_diff < min_demand_diff:\n                    min_demand_diff = demand_diff\n                    best_split = i\n\n        if best_split is not None:\n            # Create two new routes\n            new_route1 = np.concatenate([[0], customers[:best_split], [0]])\n            new_route2 = np.concatenate([[0], customers[best_split:], [0]])\n\n            # Replace the original route with the two new routes\n            new_solution = [route for i, route in enumerate(selected_solution) if i != route_idx]\n            new_solution.extend([new_route1, new_route2])\n\n            # Check if any underutilized routes can be merged\n            for under_route_idx in underutilized_routes:\n                under_route = new_solution[under_route_idx]\n                under_demand = sum(demand[under_route[1:-1]])\n\n                for new_route in [new_route1, new_route2]:\n                    new_demand = sum(demand[new_route[1:-1]])\n                    if under_demand + new_demand <= capacity:\n                        # Merge routes\n                        merged_route = np.concatenate([under_route[:-1], new_route[1:]])\n                        new_solution[under_route_idx] = merged_route\n                        new_solution.remove(new_route)\n                        break\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n            # If the new solution is better, return it\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    # If no improvement from splitting, try merging underutilized routes\n    if len(underutilized_routes) >= 2:\n        for i in range(len(underutilized_routes)-1):\n            for j in range(i+1, len(underutilized_routes)):\n                route1_idx = underutilized_routes[i]\n                route2_idx = underutilized_routes[j]\n\n                if route1_idx >= len(selected_solution) or route2_idx >= len(selected_solution):\n                    continue\n\n                route1 = selected_solution[route1_idx]\n                route2 = selected_solution[route2_idx]\n\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if combined_demand <= capacity:\n                    # Find the best insertion point to merge\n                    best_insertion = None\n                    min_distance_increase = float('inf')\n\n                    for pos in range(1, len(route1)):\n                        prev_node = route1[pos-1]\n                        next_node = route1[pos]\n                        first_node = route2[1]\n                        last_node = route2[-2]\n\n                        distance_increase = (distance_matrix[prev_node][first_node] +\n                                           distance_matrix[last_node][next_node] -\n                                           distance_matrix[prev_node][next_node])\n\n                        if distance_increase < min_distance_increase:\n                            min_distance_increase = distance_increase\n                            best_insertion = pos\n\n                    if best_insertion is not None:\n                        # Merge routes\n                        new_route = np.concatenate([route1[:best_insertion], route2[1:-1], route1[best_insertion:]])\n                        new_solution = [route for idx, route in enumerate(selected_solution)\n                                      if idx not in [route1_idx, route2_idx]]\n                        new_solution.append(new_route)\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n                        # If the new solution is better, return it\n                        new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n                        if max(new_route_lengths) < max(route_lengths):\n                            return new_solution\n\n    return selected_solution.copy()\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, \"Spatial-Demand Hybrid Clustering with Adaptive Route Splitting,\" first selects the solution with the highest total distance from the archive to identify the most inefficient route, then applies a novel spatial-demand hybrid clustering approach that dynamically partitions customers into clusters based on both geographic proximity and demand compatibility, while adaptively splitting and merging routes to balance spatial efficiency and demand constraints, resulting in a feasible neighbor solution that significantly reduces total distance while improving route balance and minimizing makespan through a hybrid operator that combines spatial optimization with demand-aware route adjustments.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    unassigned_customers.sort(key=lambda x: (coords[x][0], coords[x][1], demand[x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n    current_center = np.array([0.0, 0.0])\n    customer_count = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n            customer_count += 1\n            current_center = ((customer_count - 1) * current_center + coords[customer]) / customer_count\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n            customer_count = 1\n            current_center = coords[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            split_point = len(route) // 2\n            first_part = np.concatenate([route[:split_point], [0]])\n            second_part = np.concatenate([[0], route[split_point:-1], [0]])\n            selected_solution[i] = first_part\n            selected_solution.append(second_part)\n\n    new_solution = selected_solution + new_routes\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The novel \"Adaptive Demand-Spatial Hybrid Consolidation and Route Expansion\" algorithm first identifies solutions with imbalanced demand distribution and spatial clustering tendencies, then dynamically expands high-demand regions by strategically inserting new customers into existing routes while simultaneously consolidating underutilized routes through spatial proximity-based merging, creating a neighbor solution that improves both total distance and makespan by balancing demand load and spatial efficiency through a hybrid operator that combines demand-aware route adjustments with spatial optimization, while ensuring feasibility through adaptive capacity checks and dynamic route restructuring.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and centroids\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_centroids = []\n    for route in selected_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            centroid = np.mean(coords[customers], axis=0)\n        else:\n            centroid = coords[0]  # depot if no customers\n        route_centroids.append(centroid)\n\n    # Identify high-demand and low-demand routes\n    high_demand_routes = [i for i, d in enumerate(route_demands) if d > capacity * 0.7]\n    low_demand_routes = [i for i, d in enumerate(route_demands) if d < capacity * 0.3]\n\n    # Expand high-demand routes by adding nearby customers\n    for route_idx in high_demand_routes:\n        route = selected_solution[route_idx]\n        current_demand = route_demands[route_idx]\n        route_centroid = route_centroids[route_idx]\n\n        # Find customers not in this route\n        assigned_customers = set(route[1:-1])\n        all_customers = set(range(1, len(coords)))\n        available_customers = list(all_customers - assigned_customers)\n\n        # Sort by distance to route centroid and demand\n        available_customers.sort(key=lambda x: (distance_matrix[x][0], demand[x]))\n\n        for customer in available_customers:\n            if current_demand + demand[customer] <= capacity:\n                # Find best insertion point\n                best_insertion = None\n                min_increase = float('inf')\n\n                for i in range(1, len(route)):\n                    prev_node = route[i-1]\n                    next_node = route[i]\n                    current_distance = distance_matrix[prev_node][next_node]\n                    new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n\n                    if new_distance - current_distance < min_increase:\n                        min_increase = new_distance - current_distance\n                        best_insertion = i\n\n                if best_insertion is not None:\n                    # Insert customer\n                    new_route = np.concatenate([route[:best_insertion], [customer], route[best_insertion:]])\n                    selected_solution[route_idx] = new_route\n                    current_demand += demand[customer]\n                    assigned_customers.add(customer)\n\n    # Consolidate low-demand routes\n    if len(low_demand_routes) > 1:\n        # Sort low-demand routes by centroid proximity\n        low_demand_routes.sort(key=lambda x: np.linalg.norm(route_centroids[x] - coords[0]))\n\n        for i in range(len(low_demand_routes)-1):\n            for j in range(i+1, len(low_demand_routes)):\n                route1_idx = low_demand_routes[i]\n                route2_idx = low_demand_routes[j]\n\n                if route1_idx >= len(selected_solution) or route2_idx >= len(selected_solution):\n                    continue\n\n                route1 = selected_solution[route1_idx]\n                route2 = selected_solution[route2_idx]\n\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if combined_demand <= capacity:\n                    # Find best merge point (closest nodes between routes)\n                    best_merge = None\n                    min_distance = float('inf')\n\n                    for i1 in range(1, len(route1)-1):\n                        for i2 in range(1, len(route2)-1):\n                            node1 = route1[i1]\n                            node2 = route2[i2]\n                            dist = distance_matrix[node1][node2]\n\n                            if dist < min_distance:\n                                min_distance = dist\n                                best_merge = (i1, i2)\n\n                    if best_merge is not None:\n                        i1, i2 = best_merge\n                        # Merge routes\n                        new_route = np.concatenate([route1[:i1], route2[1:i2+1], route1[i1:]])\n                        selected_solution[route1_idx] = new_route\n                        selected_solution[route2_idx] = np.array([0])  # mark for removal\n\n        # Remove empty routes\n        selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n",
          "score": [
               -0.7398930944464417,
               1.2162155210971832
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route demands and centroids\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n    route_centroids = []\n    for route in selected_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            centroid = np.mean(coords[customers], axis=0)\n        else:\n            centroid = coords[0]  # depot if no customers\n        route_centroids.append(centroid)\n\n    # Identify high-demand and low-demand routes\n    high_demand_routes = [i for i, d in enumerate(route_demands) if d > capacity * 0.7]\n    low_demand_routes = [i for i, d in enumerate(route_demands) if d < capacity * 0.3]\n\n    # Expand high-demand routes by adding nearby customers\n    for route_idx in high_demand_routes:\n        route = selected_solution[route_idx]\n        current_demand = route_demands[route_idx]\n        route_centroid = route_centroids[route_idx]\n\n        # Find customers not in this route\n        assigned_customers = set(route[1:-1])\n        all_customers = set(range(1, len(coords)))\n        available_customers = list(all_customers - assigned_customers)\n\n        # Sort by distance to route centroid and demand\n        available_customers.sort(key=lambda x: (distance_matrix[x][0], demand[x]))\n\n        for customer in available_customers:\n            if current_demand + demand[customer] <= capacity:\n                # Find best insertion point\n                best_insertion = None\n                min_increase = float('inf')\n\n                for i in range(1, len(route)):\n                    prev_node = route[i-1]\n                    next_node = route[i]\n                    current_distance = distance_matrix[prev_node][next_node]\n                    new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n\n                    if new_distance - current_distance < min_increase:\n                        min_increase = new_distance - current_distance\n                        best_insertion = i\n\n                if best_insertion is not None:\n                    # Insert customer\n                    new_route = np.concatenate([route[:best_insertion], [customer], route[best_insertion:]])\n                    selected_solution[route_idx] = new_route\n                    current_demand += demand[customer]\n                    assigned_customers.add(customer)\n\n    # Consolidate low-demand routes\n    if len(low_demand_routes) > 1:\n        # Sort low-demand routes by centroid proximity\n        low_demand_routes.sort(key=lambda x: np.linalg.norm(route_centroids[x] - coords[0]))\n\n        for i in range(len(low_demand_routes)-1):\n            for j in range(i+1, len(low_demand_routes)):\n                route1_idx = low_demand_routes[i]\n                route2_idx = low_demand_routes[j]\n\n                if route1_idx >= len(selected_solution) or route2_idx >= len(selected_solution):\n                    continue\n\n                route1 = selected_solution[route1_idx]\n                route2 = selected_solution[route2_idx]\n\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if combined_demand <= capacity:\n                    # Find best merge point (closest nodes between routes)\n                    best_merge = None\n                    min_distance = float('inf')\n\n                    for i1 in range(1, len(route1)-1):\n                        for i2 in range(1, len(route2)-1):\n                            node1 = route1[i1]\n                            node2 = route2[i2]\n                            dist = distance_matrix[node1][node2]\n\n                            if dist < min_distance:\n                                min_distance = dist\n                                best_merge = (i1, i2)\n\n                    if best_merge is not None:\n                        i1, i2 = best_merge\n                        # Merge routes\n                        new_route = np.concatenate([route1[:i1], route2[1:i2+1], route1[i1:]])\n                        selected_solution[route1_idx] = new_route\n                        selected_solution[route2_idx] = np.array([0])  # mark for removal\n\n        # Remove empty routes\n        selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy, called \"Demand-Aware Spatial Partitioning and Multi-Objective Route Realignment,\" first selects a solution from the archive by prioritizing those with the highest makespan and second-highest total distance, indicating significant potential for improvement in both objectives. It then partitions the solution space into demand-aware spatial regions by clustering customers based on both spatial proximity and demand similarity, dynamically adjusting the cluster formation to balance the trade-off between spatial compactness and demand feasibility. The algorithm then strategically realigns these clusters by either merging them with existing routes, splitting them into new routes, or redistributing them to reduce the makespan while maintaining or improving the total distance. The operator employs a hybrid evaluation framework that considers both spatial and demand metrics to assess the quality of each realignment move, ensuring that all generated neighbor solutions are feasible and potentially dominate the current Pareto front in the bi-objective space. The method dynamically adapts its clustering and realignment strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective optimization to generate high-quality neighbor solutions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Find demand-aware spatial clusters in the longest route\n    clusters = []\n    cluster_demands = []\n    temp_cluster = []\n    temp_demand = 0\n\n    for customer in longest_customers:\n        if temp_demand + demand[customer] <= capacity * 0.7:  # Allow some slack for insertion\n            temp_cluster.append(customer)\n            temp_demand += demand[customer]\n        else:\n            if temp_cluster:\n                clusters.append(temp_cluster)\n                cluster_demands.append(temp_demand)\n                temp_cluster = [customer]\n                temp_demand = demand[customer]\n    if temp_cluster:\n        clusters.append(temp_cluster)\n        cluster_demands.append(temp_demand)\n\n    # Try to reassign clusters to other routes or create new routes\n    new_solution = selected_solution.copy()\n    for i, cluster in enumerate(clusters):\n        cluster_demand = cluster_demands[i]\n        best_route = None\n        best_pos = None\n        best_score = float('inf')\n\n        # Try to insert the cluster into existing routes\n        for j, route in enumerate(new_solution):\n            if j == longest_route_idx:\n                continue\n            current_demand = route_demands[j]\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            # Find best insertion position\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                # Calculate spatial compactness score\n                spatial_score = (distance_matrix[prev_node][first_node] +\n                                distance_matrix[last_node][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                # Calculate demand balance score\n                demand_balance = abs((current_demand + cluster_demand) - capacity/2)\n\n                # Combined score\n                combined_score = spatial_score + 0.5 * demand_balance\n\n                if combined_score < best_score:\n                    best_score = combined_score\n                    best_route = j\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = new_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            new_solution[best_route] = new_route\n\n            # Update the longest route\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in cluster] + [0])\n            new_solution[longest_route_idx] = new_longest_route\n            longest_customers = new_longest_route[1:-1]\n\n            # Update route demands\n            route_demands[best_route] += cluster_demand\n            route_demands[longest_route_idx] -= cluster_demand\n            break\n\n    # If no cluster was moved, try to create a new route from a compact cluster\n    if len(longest_customers) > 1:\n        # Find most compact cluster of 2 customers\n        min_spread = float('inf')\n        best_pair = (longest_customers[0], longest_customers[1])\n\n        for i in range(len(longest_customers)):\n            for j in range(i+1, len(longest_customers)):\n                dist = distance_matrix[longest_customers[i]][longest_customers[j]]\n                if dist < min_spread:\n                    min_spread = dist\n                    best_pair = (longest_customers[i], longest_customers[j])\n\n        # Check if pair can form a new route\n        if demand[best_pair[0]] + demand[best_pair[1]] <= capacity:\n            new_route = np.array([0, best_pair[0], best_pair[1], 0])\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in best_pair] + [0])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    # If no improvement found, try to merge two shortest routes if possible\n    if len(new_solution) > 2:\n        # Find two shortest routes\n        sorted_indices = np.argsort([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        route1_idx = sorted_indices[0]\n        route2_idx = sorted_indices[1]\n\n        if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Create merged route\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution)\n                          if idx not in [route1_idx, route2_idx]]\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel \"Route Reconstruction and Demand Harmonization\" algorithm first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, indicating potential for route optimization. It then reconstructs routes by iteratively removing the longest route and redistributing its customers to other routes using a \"demand-aware\" insertion heuristic that minimizes both the increase in total distance and the deviation from an ideal load balance. The algorithm dynamically adjusts the insertion points based on demand proximity and spatial clustering to create balanced routes, while ensuring feasibility through strict capacity checks. If redistribution fails, it attempts to create new routes by grouping spatially close, low-demand customers. The method combines these steps in a probabilistic framework to explore diverse neighborhoods while maintaining solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers_to_reinsert = longest_route[1:-1]\n\n    # Remove the longest route\n    del new_solution[longest_route_idx]\n\n    # Sort customers by demand (ascending) to prioritize smaller customers\n    customers_to_reinsert = sorted(customers_to_reinsert, key=lambda x: demand[x])\n\n    # Calculate ideal load per route (excluding the longest route)\n    remaining_capacity = capacity * len(new_solution)\n    ideal_load = remaining_capacity / len(new_solution)\n\n    # Reinsert customers into existing routes\n    for customer in customers_to_reinsert:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        for i, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                insertion_cost = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                # Calculate load deviation from ideal\n                current_load = sum(demand[route[1:-1]])\n                new_load = current_load + demand[customer]\n                load_dev = abs(new_load - ideal_load)\n\n                # Combine cost and load deviation\n                total_cost = insertion_cost + 0.1 * load_dev\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            # Insert the customer\n            route = new_solution[best_route_idx]\n            new_route = np.insert(route, best_position, customer)\n            new_solution[best_route_idx] = new_route\n\n    # If some customers couldn't be reinserted, create new routes\n    remaining_customers = [c for c in customers_to_reinsert if c not in [node for route in new_solution for node in route[1:-1]]]\n    if remaining_customers:\n        # Group remaining customers by spatial proximity and low demand\n        remaining_customers = sorted(remaining_customers, key=lambda x: demand[x])\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            for i, customer in enumerate(remaining_customers):\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    break\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The novel \"Spatial-Demand Synergy Clustering and Route Fusion\" algorithm first selects a solution from the archive by prioritizing those with moderate makespan and high total distance, indicating significant potential for route optimization through spatial-demand synergy. It then partitions the solution space into spatial-demand synergy clusters by combining hierarchical clustering based on spatial proximity with demand-based grouping, creating clusters that balance both spatial compactness and demand feasibility. The algorithm strategically fuses these clusters by either merging them with existing routes, creating new routes from compact clusters, or redistributing them to optimize both objectives, while dynamically adjusting cluster formation based on current solution characteristics. The method employs a hybrid evaluation framework that considers both spatial and demand metrics to assess the quality of each fusion move, ensuring feasibility and potential dominance in the bi-objective space. The algorithm explores diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective optimization, generating high-quality neighbor solutions by leveraging spatial-demand synergy to balance route lengths and loads effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with moderate makespan and high total distance\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Find all customers in the solution\n    all_customers = [node for route in new_solution for node in route[1:-1]]\n    if not all_customers:\n        return new_solution\n\n    # Create spatial-demand synergy clusters\n    clusters = []\n    remaining_customers = set(all_customers)\n\n    while remaining_customers:\n        # Select a seed customer\n        seed = remaining_customers.pop()\n        cluster = [seed]\n        cluster_demand = demand[seed]\n\n        # Grow the cluster by spatial-demand synergy\n        while True:\n            best_candidate = None\n            best_score = float('inf')\n\n            for candidate in remaining_customers:\n                # Spatial score (inverse of distance)\n                spatial_score = 1 / (distance_matrix[seed][candidate] + 1e-6)\n\n                # Demand score (normalized demand difference)\n                demand_score = 1 - abs(demand[candidate] - (capacity - cluster_demand)) / capacity\n\n                # Combined score\n                combined_score = spatial_score + demand_score\n\n                if combined_score < best_score and cluster_demand + demand[candidate] <= capacity * 1.1:  # Allow slight overcapacity for growth\n                    best_score = combined_score\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                cluster.append(best_candidate)\n                cluster_demand += demand[best_candidate]\n                remaining_customers.remove(best_candidate)\n                seed = best_candidate\n            else:\n                break\n\n        clusters.append(cluster)\n\n    # Try to fuse clusters into new routes\n    new_routes = []\n    used_clusters = set()\n\n    for i, cluster in enumerate(clusters):\n        if i in used_clusters:\n            continue\n\n        # Find compatible clusters to merge\n        current_cluster = cluster.copy()\n        current_demand = sum(demand[node] for node in current_cluster)\n\n        for j, other_cluster in enumerate(clusters):\n            if i == j or j in used_clusters:\n                continue\n\n            other_demand = sum(demand[node] for node in other_cluster)\n            if current_demand + other_demand <= capacity:\n                # Check spatial compatibility\n                center_i = np.mean(coords[np.array(current_cluster)], axis=0)\n                center_j = np.mean(coords[np.array(other_cluster)], axis=0)\n                if np.linalg.norm(center_i - center_j) < np.mean(distance_matrix) * 1.5:  # Within 1.5x average distance\n                    current_cluster.extend(other_cluster)\n                    current_demand += other_demand\n                    used_clusters.add(j)\n\n        # Create route from the cluster\n        if current_cluster:\n            # Sort customers by polar angle relative to cluster centroid\n            centroid = np.mean(coords[np.array(current_cluster)], axis=0)\n            angles = np.arctan2(coords[np.array(current_cluster)][:,1] - centroid[1],\n                               coords[np.array(current_cluster)][:,0] - centroid[0])\n            sorted_indices = np.argsort(angles)\n            sorted_cluster = [current_cluster[idx] for idx in sorted_indices]\n\n            new_route = [0] + sorted_cluster + [0]\n            new_routes.append(np.array(new_route))\n            used_clusters.add(i)\n\n    # If we have new routes, replace the old solution\n    if new_routes:\n        new_solution = new_routes\n\n    # Try to improve by merging routes if possible\n    if len(new_solution) > 1:\n        # Sort routes by distance\n        sorted_routes = sorted(new_solution, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n        merged_routes = []\n\n        for route in sorted_routes:\n            if not merged_routes:\n                merged_routes.append(route.copy())\n                continue\n\n            # Try to merge with last route in merged_routes\n            last_route = merged_routes[-1]\n            if sum(demand[last_route[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                # Find best merge point\n                best_cost = float('inf')\n                best_merge = None\n\n                # Try merging at different points\n                for i in range(1, len(last_route)):\n                    for j in range(1, len(route)):\n                        # Calculate merge cost\n                        prev_node = last_route[i-1]\n                        first_node = route[j]\n                        last_node = route[-2]\n                        next_node = last_route[i]\n\n                        merge_cost = (distance_matrix[prev_node][first_node] +\n                                     distance_matrix[last_node][next_node] -\n                                     distance_matrix[prev_node][next_node])\n\n                        if merge_cost < best_cost:\n                            best_cost = merge_cost\n                            best_merge = (i, j)\n\n                if best_merge is not None and best_cost < 0:  # Only merge if it improves distance\n                    i, j = best_merge\n                    merged_route = np.concatenate([last_route[:i], route[j:-1], last_route[i:]])\n                    merged_routes[-1] = merged_route\n            else:\n                merged_routes.append(route.copy())\n\n        # Check if merging improved the makespan\n        merged_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in merged_routes]\n        original_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n        if max(merged_lengths) < max(original_lengths):\n            new_solution = merged_routes\n\n    return new_solution\n\n",
          "score": [
               -0.7558229231147668,
               7.36836051940918
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with moderate makespan and high total distance\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Find all customers in the solution\n    all_customers = [node for route in new_solution for node in route[1:-1]]\n    if not all_customers:\n        return new_solution\n\n    # Create spatial-demand synergy clusters\n    clusters = []\n    remaining_customers = set(all_customers)\n\n    while remaining_customers:\n        # Select a seed customer\n        seed = remaining_customers.pop()\n        cluster = [seed]\n        cluster_demand = demand[seed]\n\n        # Grow the cluster by spatial-demand synergy\n        while True:\n            best_candidate = None\n            best_score = float('inf')\n\n            for candidate in remaining_customers:\n                # Spatial score (inverse of distance)\n                spatial_score = 1 / (distance_matrix[seed][candidate] + 1e-6)\n\n                # Demand score (normalized demand difference)\n                demand_score = 1 - abs(demand[candidate] - (capacity - cluster_demand)) / capacity\n\n                # Combined score\n                combined_score = spatial_score + demand_score\n\n                if combined_score < best_score and cluster_demand + demand[candidate] <= capacity * 1.1:  # Allow slight overcapacity for growth\n                    best_score = combined_score\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                cluster.append(best_candidate)\n                cluster_demand += demand[best_candidate]\n                remaining_customers.remove(best_candidate)\n                seed = best_candidate\n            else:\n                break\n\n        clusters.append(cluster)\n\n    # Try to fuse clusters into new routes\n    new_routes = []\n    used_clusters = set()\n\n    for i, cluster in enumerate(clusters):\n        if i in used_clusters:\n            continue\n\n        # Find compatible clusters to merge\n        current_cluster = cluster.copy()\n        current_demand = sum(demand[node] for node in current_cluster)\n\n        for j, other_cluster in enumerate(clusters):\n            if i == j or j in used_clusters:\n                continue\n\n            other_demand = sum(demand[node] for node in other_cluster)\n            if current_demand + other_demand <= capacity:\n                # Check spatial compatibility\n                center_i = np.mean(coords[np.array(current_cluster)], axis=0)\n                center_j = np.mean(coords[np.array(other_cluster)], axis=0)\n                if np.linalg.norm(center_i - center_j) < np.mean(distance_matrix) * 1.5:  # Within 1.5x average distance\n                    current_cluster.extend(other_cluster)\n                    current_demand += other_demand\n                    used_clusters.add(j)\n\n        # Create route from the cluster\n        if current_cluster:\n            # Sort customers by polar angle relative to cluster centroid\n            centroid = np.mean(coords[np.array(current_cluster)], axis=0)\n            angles = np.arctan2(coords[np.array(current_cluster)][:,1] - centroid[1],\n                               coords[np.array(current_cluster)][:,0] - centroid[0])\n            sorted_indices = np.argsort(angles)\n            sorted_cluster = [current_cluster[idx] for idx in sorted_indices]\n\n            new_route = [0] + sorted_cluster + [0]\n            new_routes.append(np.array(new_route))\n            used_clusters.add(i)\n\n    # If we have new routes, replace the old solution\n    if new_routes:\n        new_solution = new_routes\n\n    # Try to improve by merging routes if possible\n    if len(new_solution) > 1:\n        # Sort routes by distance\n        sorted_routes = sorted(new_solution, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n        merged_routes = []\n\n        for route in sorted_routes:\n            if not merged_routes:\n                merged_routes.append(route.copy())\n                continue\n\n            # Try to merge with last route in merged_routes\n            last_route = merged_routes[-1]\n            if sum(demand[last_route[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                # Find best merge point\n                best_cost = float('inf')\n                best_merge = None\n\n                # Try merging at different points\n                for i in range(1, len(last_route)):\n                    for j in range(1, len(route)):\n                        # Calculate merge cost\n                        prev_node = last_route[i-1]\n                        first_node = route[j]\n                        last_node = route[-2]\n                        next_node = last_route[i]\n\n                        merge_cost = (distance_matrix[prev_node][first_node] +\n                                     distance_matrix[last_node][next_node] -\n                                     distance_matrix[prev_node][next_node])\n\n                        if merge_cost < best_cost:\n                            best_cost = merge_cost\n                            best_merge = (i, j)\n\n                if best_merge is not None and best_cost < 0:  # Only merge if it improves distance\n                    i, j = best_merge\n                    merged_route = np.concatenate([last_route[:i], route[j:-1], last_route[i:]])\n                    merged_routes[-1] = merged_route\n            else:\n                merged_routes.append(route.copy())\n\n        # Check if merging improved the makespan\n        merged_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in merged_routes]\n        original_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n        if max(merged_lengths) < max(original_lengths):\n            new_solution = merged_routes\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy, called \"Demand-Aware Spatial Partitioning and Multi-Objective Route Realignment,\" first selects a solution from the archive by prioritizing those with the highest makespan and second-highest total distance, indicating significant potential for improvement in both objectives. It then partitions the solution space into demand-aware spatial regions by clustering customers based on both spatial proximity and demand similarity, dynamically adjusting the cluster formation to balance the trade-off between spatial compactness and demand feasibility. The algorithm then strategically realigns these clusters by either merging them with existing routes, splitting them into new routes, or redistributing them to reduce the makespan while maintaining or improving the total distance. The operator employs a hybrid evaluation framework that considers both spatial and demand metrics to assess the quality of each realignment move, ensuring that all generated neighbor solutions are feasible and potentially dominate the current Pareto front in the bi-objective space. The method dynamically adapts its clustering and realignment strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of spatial analysis, demand-aware grouping, and multi-objective optimization to generate high-quality neighbor solutions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Find the longest route\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = selected_solution[longest_route_idx]\n    longest_customers = longest_route[1:-1]\n\n    # Find demand-aware spatial clusters in the longest route\n    clusters = []\n    cluster_demands = []\n    temp_cluster = []\n    temp_demand = 0\n\n    for customer in longest_customers:\n        if temp_demand + demand[customer] <= capacity * 0.7:  # Allow some slack for insertion\n            temp_cluster.append(customer)\n            temp_demand += demand[customer]\n        else:\n            if temp_cluster:\n                clusters.append(temp_cluster)\n                cluster_demands.append(temp_demand)\n                temp_cluster = [customer]\n                temp_demand = demand[customer]\n    if temp_cluster:\n        clusters.append(temp_cluster)\n        cluster_demands.append(temp_demand)\n\n    # Try to reassign clusters to other routes or create new routes\n    new_solution = selected_solution.copy()\n    for i, cluster in enumerate(clusters):\n        cluster_demand = cluster_demands[i]\n        best_route = None\n        best_pos = None\n        best_score = float('inf')\n\n        # Try to insert the cluster into existing routes\n        for j, route in enumerate(new_solution):\n            if j == longest_route_idx:\n                continue\n            current_demand = route_demands[j]\n            if current_demand + cluster_demand > capacity:\n                continue\n\n            # Find best insertion position\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                # Calculate spatial compactness score\n                spatial_score = (distance_matrix[prev_node][first_node] +\n                                distance_matrix[last_node][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                # Calculate demand balance score\n                demand_balance = abs((current_demand + cluster_demand) - capacity/2)\n\n                # Combined score\n                combined_score = spatial_score + 0.5 * demand_balance\n\n                if combined_score < best_score:\n                    best_score = combined_score\n                    best_route = j\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = new_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            new_solution[best_route] = new_route\n\n            # Update the longest route\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in cluster] + [0])\n            new_solution[longest_route_idx] = new_longest_route\n            longest_customers = new_longest_route[1:-1]\n\n            # Update route demands\n            route_demands[best_route] += cluster_demand\n            route_demands[longest_route_idx] -= cluster_demand\n            break\n\n    # If no cluster was moved, try to create a new route from a compact cluster\n    if len(longest_customers) > 1:\n        # Find most compact cluster of 2 customers\n        min_spread = float('inf')\n        best_pair = (longest_customers[0], longest_customers[1])\n\n        for i in range(len(longest_customers)):\n            for j in range(i+1, len(longest_customers)):\n                dist = distance_matrix[longest_customers[i]][longest_customers[j]]\n                if dist < min_spread:\n                    min_spread = dist\n                    best_pair = (longest_customers[i], longest_customers[j])\n\n        # Check if pair can form a new route\n        if demand[best_pair[0]] + demand[best_pair[1]] <= capacity:\n            new_route = np.array([0, best_pair[0], best_pair[1], 0])\n            new_longest_route = np.array([0] + [c for c in longest_customers if c not in best_pair] + [0])\n\n            # Create new solution\n            new_solution = selected_solution.copy()\n            new_solution[longest_route_idx] = new_longest_route\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    # If no improvement found, try to merge two shortest routes if possible\n    if len(new_solution) > 2:\n        # Find two shortest routes\n        sorted_indices = np.argsort([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        route1_idx = sorted_indices[0]\n        route2_idx = sorted_indices[1]\n\n        if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Create merged route\n            new_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution)\n                          if idx not in [route1_idx, route2_idx]]\n            new_solution.append(new_route)\n\n            # Check if makespan improved\n            new_route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            if max(new_route_lengths) < max(route_lengths):\n                return new_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel \"Route Reconstruction and Demand Harmonization\" algorithm first selects a solution from the archive by prioritizing those with high makespan and moderate total distance, indicating potential for route optimization. It then reconstructs routes by iteratively removing the longest route and redistributing its customers to other routes using a \"demand-aware\" insertion heuristic that minimizes both the increase in total distance and the deviation from an ideal load balance. The algorithm dynamically adjusts the insertion points based on demand proximity and spatial clustering to create balanced routes, while ensuring feasibility through strict capacity checks. If redistribution fails, it attempts to create new routes by grouping spatially close, low-demand customers. The method combines these steps in a probabilistic framework to explore diverse neighborhoods while maintaining solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate current route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers_to_reinsert = longest_route[1:-1]\n\n    # Remove the longest route\n    del new_solution[longest_route_idx]\n\n    # Sort customers by demand (ascending) to prioritize smaller customers\n    customers_to_reinsert = sorted(customers_to_reinsert, key=lambda x: demand[x])\n\n    # Calculate ideal load per route (excluding the longest route)\n    remaining_capacity = capacity * len(new_solution)\n    ideal_load = remaining_capacity / len(new_solution)\n\n    # Reinsert customers into existing routes\n    for customer in customers_to_reinsert:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        for i, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                insertion_cost = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                # Calculate load deviation from ideal\n                current_load = sum(demand[route[1:-1]])\n                new_load = current_load + demand[customer]\n                load_dev = abs(new_load - ideal_load)\n\n                # Combine cost and load deviation\n                total_cost = insertion_cost + 0.1 * load_dev\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            # Insert the customer\n            route = new_solution[best_route_idx]\n            new_route = np.insert(route, best_position, customer)\n            new_solution[best_route_idx] = new_route\n\n    # If some customers couldn't be reinserted, create new routes\n    remaining_customers = [c for c in customers_to_reinsert if c not in [node for route in new_solution for node in route[1:-1]]]\n    if remaining_customers:\n        # Group remaining customers by spatial proximity and low demand\n        remaining_customers = sorted(remaining_customers, key=lambda x: demand[x])\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            for i, customer in enumerate(remaining_customers):\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    break\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The novel \"Spatial-Demand Hybrid Clustering and Multi-Objective Route Fusion\" algorithm selects a solution from the archive prioritizing those with high makespan and moderate total distance, then partitions the solution space into adaptive spatial-demand clusters by combining spatial proximity with demand similarity, dynamically adjusting cluster boundaries based on current route loads and spatial distribution. It then fuses these clusters through a hybrid multi-objective operator that strategically merges, splits, or redistributes clusters to optimize both total distance and makespan, while maintaining feasibility through strict capacity checks and evaluating each move using a combined spatial-demand compactness metric. The algorithm balances exploration of diverse neighborhoods through probabilistic cluster selection and exploitation of promising spatial-demand patterns, dynamically adapting its fusion strategies based on the current solution's characteristics to generate high-quality, potentially Pareto-dominant neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers = longest_route[1:-1]\n\n    # Create spatial-demand clusters\n    clusters = []\n    current_cluster = []\n    current_load = 0\n    centroid = np.mean(coords[customers], axis=0)\n\n    for customer in customers:\n        # Calculate spatial-demand score\n        spatial_score = np.linalg.norm(coords[customer] - centroid)\n        demand_score = demand[customer] / capacity\n        combined_score = spatial_score + 0.5 * demand_score\n\n        if current_load + demand[customer] <= capacity * 1.1 and combined_score < 1.5:  # Allow some flexibility\n            current_cluster.append(customer)\n            current_load += demand[customer]\n        else:\n            if current_cluster:\n                clusters.append(current_cluster)\n                current_cluster = [customer]\n                current_load = demand[customer]\n            else:\n                current_cluster = [customer]\n                current_load = demand[customer]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Process clusters in random order\n    np.random.shuffle(clusters)\n\n    # Try to fuse clusters with other routes\n    for cluster in clusters:\n        cluster_demand = sum(demand[cluster])\n        best_route = None\n        best_pos = None\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n\n            current_load = sum(demand[route[1:-1]])\n            if current_load + cluster_demand > capacity:\n                continue\n\n            # Calculate cluster centroid\n            cluster_centroid = np.mean(coords[cluster], axis=0)\n\n            # Find best insertion position\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n\n                # Calculate spatial compactness score\n                spatial_score = (distance_matrix[prev_node, cluster[0]] +\n                                distance_matrix[cluster[-1], next_node] -\n                                distance_matrix[prev_node, next_node])\n\n                # Calculate demand balance score\n                demand_balance = abs((current_load + cluster_demand) - capacity/2)\n\n                # Combined score\n                combined_score = spatial_score + 0.3 * demand_balance\n\n                if combined_score < best_score:\n                    best_score = combined_score\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = new_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            new_solution[best_route] = new_route\n\n            # Update the longest route\n            remaining_customers = [c for c in customers if c not in cluster]\n            new_longest_route = np.array([0] + remaining_customers + [0])\n            new_solution[longest_route_idx] = new_longest_route\n            customers = remaining_customers\n\n            # Update route loads\n            route_loads[best_route] += cluster_demand\n            route_loads[longest_route_idx] -= cluster_demand\n            break\n\n    # If no cluster was moved, try to create new routes from compact clusters\n    if len(customers) > 1 and len(new_solution) < 3 * len(archive_sorted):\n        # Find most compact cluster\n        min_spread = float('inf')\n        best_cluster = None\n\n        for cluster in clusters:\n            if len(cluster) < 2:\n                continue\n            cluster_coords = coords[cluster]\n            centroid = np.mean(cluster_coords, axis=0)\n            spread = np.max(np.linalg.norm(cluster_coords - centroid, axis=1))\n            if spread < min_spread:\n                min_spread = spread\n                best_cluster = cluster\n\n        if best_cluster and sum(demand[best_cluster]) <= capacity:\n            new_route = np.array([0] + best_cluster + [0])\n            new_solution.append(new_route)\n\n            # Update the longest route\n            remaining_customers = [c for c in customers if c not in best_cluster]\n            new_longest_route = np.array([0] + remaining_customers + [0])\n            new_solution[longest_route_idx] = new_longest_route\n\n    return new_solution\n\n",
          "score": [
               -0.7540682397305432,
               0.3148687183856964
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high makespan and moderate total distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route loads and distances\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n\n    # Identify the longest route\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = np.argmax(route_distances)\n    longest_route = new_solution[longest_route_idx].copy()\n    customers = longest_route[1:-1]\n\n    # Create spatial-demand clusters\n    clusters = []\n    current_cluster = []\n    current_load = 0\n    centroid = np.mean(coords[customers], axis=0)\n\n    for customer in customers:\n        # Calculate spatial-demand score\n        spatial_score = np.linalg.norm(coords[customer] - centroid)\n        demand_score = demand[customer] / capacity\n        combined_score = spatial_score + 0.5 * demand_score\n\n        if current_load + demand[customer] <= capacity * 1.1 and combined_score < 1.5:  # Allow some flexibility\n            current_cluster.append(customer)\n            current_load += demand[customer]\n        else:\n            if current_cluster:\n                clusters.append(current_cluster)\n                current_cluster = [customer]\n                current_load = demand[customer]\n            else:\n                current_cluster = [customer]\n                current_load = demand[customer]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Process clusters in random order\n    np.random.shuffle(clusters)\n\n    # Try to fuse clusters with other routes\n    for cluster in clusters:\n        cluster_demand = sum(demand[cluster])\n        best_route = None\n        best_pos = None\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n\n            current_load = sum(demand[route[1:-1]])\n            if current_load + cluster_demand > capacity:\n                continue\n\n            # Calculate cluster centroid\n            cluster_centroid = np.mean(coords[cluster], axis=0)\n\n            # Find best insertion position\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n\n                # Calculate spatial compactness score\n                spatial_score = (distance_matrix[prev_node, cluster[0]] +\n                                distance_matrix[cluster[-1], next_node] -\n                                distance_matrix[prev_node, next_node])\n\n                # Calculate demand balance score\n                demand_balance = abs((current_load + cluster_demand) - capacity/2)\n\n                # Combined score\n                combined_score = spatial_score + 0.3 * demand_balance\n\n                if combined_score < best_score:\n                    best_score = combined_score\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            # Insert the cluster into the best route\n            route = new_solution[best_route]\n            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n            new_solution[best_route] = new_route\n\n            # Update the longest route\n            remaining_customers = [c for c in customers if c not in cluster]\n            new_longest_route = np.array([0] + remaining_customers + [0])\n            new_solution[longest_route_idx] = new_longest_route\n            customers = remaining_customers\n\n            # Update route loads\n            route_loads[best_route] += cluster_demand\n            route_loads[longest_route_idx] -= cluster_demand\n            break\n\n    # If no cluster was moved, try to create new routes from compact clusters\n    if len(customers) > 1 and len(new_solution) < 3 * len(archive_sorted):\n        # Find most compact cluster\n        min_spread = float('inf')\n        best_cluster = None\n\n        for cluster in clusters:\n            if len(cluster) < 2:\n                continue\n            cluster_coords = coords[cluster]\n            centroid = np.mean(cluster_coords, axis=0)\n            spread = np.max(np.linalg.norm(cluster_coords - centroid, axis=1))\n            if spread < min_spread:\n                min_spread = spread\n                best_cluster = cluster\n\n        if best_cluster and sum(demand[best_cluster]) <= capacity:\n            new_route = np.array([0] + best_cluster + [0])\n            new_solution.append(new_route)\n\n            # Update the longest route\n            remaining_customers = [c for c in customers if c not in best_cluster]\n            new_longest_route = np.array([0] + remaining_customers + [0])\n            new_solution[longest_route_idx] = new_longest_route\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, \"Spatial-Demand Hybrid Clustering with Adaptive Route Splitting,\" first selects the solution with the highest total distance from the archive to identify the most inefficient route, then applies a novel spatial-demand hybrid clustering approach that dynamically partitions customers into clusters based on both geographic proximity and demand compatibility, while adaptively splitting and merging routes to balance spatial efficiency and demand constraints, resulting in a feasible neighbor solution that significantly reduces total distance while improving route balance and minimizing makespan through a hybrid operator that combines spatial optimization with demand-aware route adjustments.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    assigned_customers = set()\n    for route in selected_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        return selected_solution\n\n    unassigned_customers.sort(key=lambda x: (coords[x][0], coords[x][1], demand[x]))\n\n    new_routes = []\n    current_route = [0]\n    current_load = 0\n    current_center = np.array([0.0, 0.0])\n    customer_count = 0\n\n    for customer in unassigned_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n            customer_count += 1\n            current_center = ((customer_count - 1) * current_center + coords[customer]) / customer_count\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n            customer_count = 1\n            current_center = coords[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_routes.append(np.array(current_route))\n\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            split_point = len(route) // 2\n            first_part = np.concatenate([route[:split_point], [0]])\n            second_part = np.concatenate([[0], route[split_point:-1], [0]])\n            selected_solution[i] = first_part\n            selected_solution.append(second_part)\n\n    new_solution = selected_solution + new_routes\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy, called \"Dynamic Demand-Adaptive Route Clustering and Relocation,\" first selects a solution from the archive by prioritizing those with the highest makespan and highest total distance, indicating significant potential for improvement in both objectives. It then clusters customers based on both spatial proximity and demand similarity, creating demand-adaptive clusters that can be efficiently relocated or merged. The operator dynamically identifies the most promising clusters by analyzing demand profiles and spatial compactness, then evaluates multiple relocation strategies that prioritize reducing the makespan while maintaining or improving the total distance. If no beneficial relocation is found, it attempts to merge clusters from different routes when their combined demand is within capacity limits, creating more balanced and efficient route configurations. The operator dynamically adjusts its clustering and relocation strategies based on the current solution's characteristics, exploring diverse neighborhoods through a combination of demand-adaptive clustering and spatial analysis to generate high-quality neighbor solutions that improve both objectives while maintaining feasibility through careful capacity checks and spatial considerations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Create demand-adaptive clusters\n    all_customers = np.concatenate([route[1:-1] for route in selected_solution])\n    cluster_centers = []\n    cluster_members = []\n\n    for customer in all_customers:\n        # Find the nearest cluster center with similar demand\n        best_cluster = None\n        best_distance = float('inf')\n\n        for i, center in enumerate(cluster_centers):\n            dist = distance_matrix[customer][center]\n            demand_diff = abs(demand[customer] - demand[center])\n\n            if demand_diff <= capacity * 0.2 and dist < best_distance:\n                best_distance = dist\n                best_cluster = i\n\n        if best_cluster is not None:\n            cluster_members[best_cluster].append(customer)\n        else:\n            cluster_centers.append(customer)\n            cluster_members.append([customer])\n\n    # Try to relocate clusters to balance makespan\n    for i, cluster in enumerate(cluster_members):\n        cluster_demand = sum(demand[cluster])\n\n        # Find best route to insert this cluster\n        best_route = None\n        best_position = None\n        best_improvement = 0\n\n        for route_idx in range(len(selected_solution)):\n            route = selected_solution[route_idx]\n            if sum(demand[route[1:-1]]) + cluster_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for pos in range(1, len(route)):\n                # Calculate potential improvement\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                first_node = cluster[0]\n                last_node = cluster[-1]\n\n                distance_increase = (distance_matrix[prev_node][first_node] +\n                                   distance_matrix[last_node][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                # Calculate new makespan\n                current_length = route_lengths[route_idx]\n                new_length = current_length + distance_increase\n                new_makespan = max(max(route_lengths), new_length)\n\n                improvement = (max(route_lengths) - new_makespan) * 0.7 + (sum(route_lengths) - (sum(route_lengths) + distance_increase)) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = route_idx\n                    best_position = pos\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the relocation\n            new_route = np.concatenate([selected_solution[best_route][:best_position],\n                                      np.array(cluster),\n                                      selected_solution[best_route][best_position:]])\n\n            new_solution = selected_solution.copy()\n            new_solution[best_route] = new_route\n\n            # Remove relocated customers from their original routes\n            for customer in cluster:\n                for route_idx in range(len(new_solution)):\n                    if customer in new_solution[route_idx][1:-1]:\n                        mask = new_solution[route_idx] != customer\n                        new_solution[route_idx] = new_solution[route_idx][mask]\n                        if len(new_solution[route_idx]) == 2:  # Only depot left\n                            new_solution.pop(route_idx)\n                        break\n\n            return new_solution\n\n    # If relocation didn't work, try merging clusters from different routes\n    for i in range(len(cluster_members)):\n        for j in range(i+1, len(cluster_members)):\n            combined_demand = sum(demand[cluster_members[i]]) + sum(demand[cluster_members[j]])\n\n            if combined_demand <= capacity:\n                # Find best pair of routes to merge these clusters\n                best_pair = None\n                best_improvement = 0\n\n                for route1_idx in range(len(selected_solution)):\n                    for route2_idx in range(route1_idx+1, len(selected_solution)):\n                        if (sum(demand[selected_solution[route1_idx][1:-1]]) +\n                            sum(demand[selected_solution[route2_idx][1:-1]])) + combined_demand <= capacity:\n\n                            # Calculate potential improvement\n                            original_length = sum(distance_matrix[selected_solution[route1_idx][:-1], selected_solution[route1_idx][1:]]) + \\\n                                             sum(distance_matrix[selected_solution[route2_idx][:-1], selected_solution[route2_idx][1:]])\n\n                            # Create merged route\n                            merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                          cluster_members[i],\n                                                          selected_solution[route2_idx][1:]])\n\n                            new_length = sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n                            improvement = original_length - new_length\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_pair = (route1_idx, route2_idx)\n\n                if best_pair is not None and best_improvement > 0:\n                    route1_idx, route2_idx = best_pair\n                    merged_route = np.concatenate([selected_solution[route1_idx][:-1],\n                                                  cluster_members[i],\n                                                  selected_solution[route2_idx][1:]])\n\n                    new_solution = [route for idx, route in enumerate(selected_solution)\n                                  if idx not in [route1_idx, route2_idx]]\n                    new_solution.append(merged_route)\n\n                    # Remove merged clusters from their original positions\n                    for customer in cluster_members[i] + cluster_members[j]:\n                        for route_idx in range(len(new_solution)):\n                            if customer in new_solution[route_idx][1:-1]:\n                                mask = new_solution[route_idx] != customer\n                                new_solution[route_idx] = new_solution[route_idx][mask]\n                                if len(new_solution[route_idx]) == 2:  # Only depot left\n                                    new_solution.pop(route_idx)\n                                break\n\n                    return new_solution\n\n    return selected_solution.copy()\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": "{The new algorithm, \"Adaptive Multi-Objective Route Consolidation with Spatial-Demand Balance\", first selects the solution with the highest makespan from the archive to identify the most imbalanced route, then applies a novel adaptive consolidation strategy that dynamically groups routes based on spatial proximity and demand similarity while evaluating multiple consolidation options to merge routes when their combined demand is within capacity limits, creating more balanced configurations that simultaneously reduce both total distance and makespan through a hybrid operator that combines spatial clustering with demand-aware route adjustments, ensuring feasibility through careful capacity checks and spatial considerations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Create spatial-demand clusters\n    all_customers = np.concatenate([route[1:-1] for route in selected_solution])\n    cluster_centers = []\n    cluster_members = []\n\n    for customer in all_customers:\n        best_cluster = None\n        best_score = float('inf')\n\n        for i, center in enumerate(cluster_centers):\n            spatial_dist = distance_matrix[customer][center]\n            demand_diff = abs(demand[customer] - demand[center])\n            score = spatial_dist * 0.6 + demand_diff * 0.4\n\n            if score < best_score:\n                best_score = score\n                best_cluster = i\n\n        if best_cluster is not None and best_score < capacity * 0.3:\n            cluster_members[best_cluster].append(customer)\n        else:\n            cluster_centers.append(customer)\n            cluster_members.append([customer])\n\n    # Try to consolidate routes based on clusters\n    for i in range(len(selected_solution)):\n        for j in range(i+1, len(selected_solution)):\n            combined_demand = route_demands[i] + route_demands[j]\n\n            if combined_demand <= capacity:\n                # Calculate potential improvement\n                original_length = route_lengths[i] + route_lengths[j]\n                original_makespan = max(route_lengths)\n\n                # Create consolidated route\n                route1 = selected_solution[i]\n                route2 = selected_solution[j]\n\n                # Find best insertion point\n                best_insertion = None\n                best_score = float('inf')\n\n                for pos in range(1, len(route1)):\n                    # Calculate spatial and demand balance score\n                    prev_node = route1[pos-1]\n                    next_node = route1[pos]\n\n                    spatial_score = (distance_matrix[prev_node][route2[1]] +\n                                   distance_matrix[route2[-2]][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                    demand_score = abs(combined_demand - capacity/2)\n\n                    total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_insertion = pos\n\n                if best_insertion is not None:\n                    consolidated_route = np.concatenate([\n                        route1[:best_insertion],\n                        route2[1:-1],\n                        route1[best_insertion:]\n                    ])\n\n                    new_length = sum(distance_matrix[consolidated_route[:-1], consolidated_route[1:]])\n                    new_makespan = max([l for k, l in enumerate(route_lengths) if k not in [i, j]], default=0) if len(route_lengths) > 2 else 0\n\n                    if new_makespan == 0 or new_makespan < original_makespan:\n                        new_solution = [route for k, route in enumerate(selected_solution) if k not in [i, j]]\n                        new_solution.append(consolidated_route)\n                        return new_solution\n\n    # If consolidation didn't work, try to redistribute clusters\n    for cluster in cluster_members:\n        cluster_demand = sum(demand[cluster])\n        best_route = None\n        best_improvement = 0\n\n        for route_idx in range(len(selected_solution)):\n            if route_demands[route_idx] + cluster_demand <= capacity:\n                # Calculate potential improvement\n                current_length = route_lengths[route_idx]\n                new_length = current_length + sum(distance_matrix[cluster][cluster])  # Approximation\n\n                improvement = (current_length - new_length) * 0.7 + (max(route_lengths) - new_length) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = route_idx\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the redistribution\n            new_route = np.concatenate([\n                selected_solution[best_route][:-1],\n                np.array(cluster),\n                [0]\n            ])\n\n            new_solution = selected_solution.copy()\n            new_solution[best_route] = new_route\n\n            # Remove redistributed customers from original positions\n            for customer in cluster:\n                for route_idx in range(len(new_solution)):\n                    if customer in new_solution[route_idx][1:-1]:\n                        mask = new_solution[route_idx] != customer\n                        new_solution[route_idx] = new_solution[route_idx][mask]\n                        if len(new_solution[route_idx]) == 2:\n                            new_solution.pop(route_idx)\n                        break\n\n            return new_solution\n\n    return selected_solution.copy()\n\n",
          "score": [
               -0.6443184343432284,
               0.48602041602134705
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in selected_solution]\n\n    # Create spatial-demand clusters\n    all_customers = np.concatenate([route[1:-1] for route in selected_solution])\n    cluster_centers = []\n    cluster_members = []\n\n    for customer in all_customers:\n        best_cluster = None\n        best_score = float('inf')\n\n        for i, center in enumerate(cluster_centers):\n            spatial_dist = distance_matrix[customer][center]\n            demand_diff = abs(demand[customer] - demand[center])\n            score = spatial_dist * 0.6 + demand_diff * 0.4\n\n            if score < best_score:\n                best_score = score\n                best_cluster = i\n\n        if best_cluster is not None and best_score < capacity * 0.3:\n            cluster_members[best_cluster].append(customer)\n        else:\n            cluster_centers.append(customer)\n            cluster_members.append([customer])\n\n    # Try to consolidate routes based on clusters\n    for i in range(len(selected_solution)):\n        for j in range(i+1, len(selected_solution)):\n            combined_demand = route_demands[i] + route_demands[j]\n\n            if combined_demand <= capacity:\n                # Calculate potential improvement\n                original_length = route_lengths[i] + route_lengths[j]\n                original_makespan = max(route_lengths)\n\n                # Create consolidated route\n                route1 = selected_solution[i]\n                route2 = selected_solution[j]\n\n                # Find best insertion point\n                best_insertion = None\n                best_score = float('inf')\n\n                for pos in range(1, len(route1)):\n                    # Calculate spatial and demand balance score\n                    prev_node = route1[pos-1]\n                    next_node = route1[pos]\n\n                    spatial_score = (distance_matrix[prev_node][route2[1]] +\n                                   distance_matrix[route2[-2]][next_node] -\n                                   distance_matrix[prev_node][next_node])\n\n                    demand_score = abs(combined_demand - capacity/2)\n\n                    total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_insertion = pos\n\n                if best_insertion is not None:\n                    consolidated_route = np.concatenate([\n                        route1[:best_insertion],\n                        route2[1:-1],\n                        route1[best_insertion:]\n                    ])\n\n                    new_length = sum(distance_matrix[consolidated_route[:-1], consolidated_route[1:]])\n                    new_makespan = max([l for k, l in enumerate(route_lengths) if k not in [i, j]], default=0) if len(route_lengths) > 2 else 0\n\n                    if new_makespan == 0 or new_makespan < original_makespan:\n                        new_solution = [route for k, route in enumerate(selected_solution) if k not in [i, j]]\n                        new_solution.append(consolidated_route)\n                        return new_solution\n\n    # If consolidation didn't work, try to redistribute clusters\n    for cluster in cluster_members:\n        cluster_demand = sum(demand[cluster])\n        best_route = None\n        best_improvement = 0\n\n        for route_idx in range(len(selected_solution)):\n            if route_demands[route_idx] + cluster_demand <= capacity:\n                # Calculate potential improvement\n                current_length = route_lengths[route_idx]\n                new_length = current_length + sum(distance_matrix[cluster][cluster])  # Approximation\n\n                improvement = (current_length - new_length) * 0.7 + (max(route_lengths) - new_length) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = route_idx\n\n        if best_route is not None and best_improvement > 0:\n            # Perform the redistribution\n            new_route = np.concatenate([\n                selected_solution[best_route][:-1],\n                np.array(cluster),\n                [0]\n            ])\n\n            new_solution = selected_solution.copy()\n            new_solution[best_route] = new_route\n\n            # Remove redistributed customers from original positions\n            for customer in cluster:\n                for route_idx in range(len(new_solution)):\n                    if customer in new_solution[route_idx][1:-1]:\n                        mask = new_solution[route_idx] != customer\n                        new_solution[route_idx] = new_solution[route_idx][mask]\n                        if len(new_solution[route_idx]) == 2:\n                            new_solution.pop(route_idx)\n                        break\n\n            return new_solution\n\n    return selected_solution.copy()\n\n"
     }
]