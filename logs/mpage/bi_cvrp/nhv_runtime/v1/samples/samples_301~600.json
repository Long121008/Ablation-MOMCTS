[
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with low total distance and high makespan, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the shortest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == shortest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[shortest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([shortest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[shortest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == shortest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.607315237021449,
               3.5382089018821716
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == shortest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[shortest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([shortest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[shortest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == shortest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8108756678043085,
               0.1263180375099182
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with low makespan and high total distance, then applies a novel adaptive route clustering operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the shortest route and merges it with the demand-compatible adjacent route while respecting capacity constraints, then systematically clusters customers based on their spatial proximity and demand similarity, creating new routes through a hierarchical partitioning strategy that minimizes both makespan and total distance. The algorithm dynamically adjusts the clustering parameters based on the current solution's characteristics, balancing the objectives by prioritizing either makespan reduction or distance minimization at each step, while ensuring feasibility through continuous capacity validation and spatial feasibility checks.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 2:\n        return new_solution\n\n    best_merge_idx = -1\n    best_compatibility = -1\n    for i in range(len(new_solution)):\n        if i == shortest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        total_demand = np.sum(demand[shortest_route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n        if total_demand > capacity:\n            continue\n        compatibility = 0\n        for c1 in shortest_route[1:-1]:\n            for c2 in other_route[1:-1]:\n                compatibility += 1 / (1 + distance_matrix[c1][c2])\n        if compatibility > best_compatibility:\n            best_compatibility = compatibility\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([shortest_route[:-1], best_route[1:]])\n\n    new_solution[shortest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    from sklearn.cluster import KMeans\n    from sklearn.preprocessing import StandardScaler\n\n    features = np.column_stack([coords[customers], demand[customers]])\n    scaler = StandardScaler()\n    features_scaled = scaler.fit_transform(features)\n\n    k = min(3, len(customers) // 2)\n    kmeans = KMeans(n_clusters=k, random_state=42)\n    clusters = kmeans.fit_predict(features_scaled)\n\n    cluster_routes = []\n    for cluster_id in range(k):\n        cluster_customers = customers[clusters == cluster_id]\n        if len(cluster_customers) == 0:\n            continue\n        current_demand = 0\n        temp_route = [0]\n        for cust in cluster_customers:\n            if current_demand + demand[cust] <= capacity:\n                temp_route.append(cust)\n                current_demand += demand[cust]\n            else:\n                temp_route.append(0)\n                cluster_routes.append(np.array(temp_route))\n                temp_route = [0, cust]\n                current_demand = demand[cust]\n        temp_route.append(0)\n        cluster_routes.append(np.array(temp_route))\n\n    new_solution.extend(cluster_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.6533928437797094,
               3.2490704357624054
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 2:\n        return new_solution\n\n    best_merge_idx = -1\n    best_compatibility = -1\n    for i in range(len(new_solution)):\n        if i == shortest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        total_demand = np.sum(demand[shortest_route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n        if total_demand > capacity:\n            continue\n        compatibility = 0\n        for c1 in shortest_route[1:-1]:\n            for c2 in other_route[1:-1]:\n                compatibility += 1 / (1 + distance_matrix[c1][c2])\n        if compatibility > best_compatibility:\n            best_compatibility = compatibility\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([shortest_route[:-1], best_route[1:]])\n\n    new_solution[shortest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    from sklearn.cluster import KMeans\n    from sklearn.preprocessing import StandardScaler\n\n    features = np.column_stack([coords[customers], demand[customers]])\n    scaler = StandardScaler()\n    features_scaled = scaler.fit_transform(features)\n\n    k = min(3, len(customers) // 2)\n    kmeans = KMeans(n_clusters=k, random_state=42)\n    clusters = kmeans.fit_predict(features_scaled)\n\n    cluster_routes = []\n    for cluster_id in range(k):\n        cluster_customers = customers[clusters == cluster_id]\n        if len(cluster_customers) == 0:\n            continue\n        current_demand = 0\n        temp_route = [0]\n        for cust in cluster_customers:\n            if current_demand + demand[cust] <= capacity:\n                temp_route.append(cust)\n                current_demand += demand[cust]\n            else:\n                temp_route.append(0)\n                cluster_routes.append(np.array(temp_route))\n                temp_route = [0, cust]\n                current_demand = demand[cust]\n        temp_route.append(0)\n        cluster_routes.append(np.array(temp_route))\n\n    new_solution.extend(cluster_routes)\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n",
          "score": [
               -0.817899315291876,
               0.11089563369750977
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with low makespan and high total distance, then applies a novel hybrid local search operator that combines angular route merging with load-balanced route splitting. It first identifies the shortest route and merges it with the angularly closest adjacent route while respecting capacity constraints, then systematically splits low-demand customers from the merged route into new routes using a load-driven partitioning strategy that maximizes makespan reduction, while simultaneously reinserting high-demand customers from the split routes into other routes using a spatial diversity heuristic to increase total distance in a controlled manner, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    shortest_route_coords = coords[shortest_route[1:-1]]\n    angles = np.arctan2(shortest_route_coords[:, 1] - depot_coords[1], shortest_route_coords[:, 0] - depot_coords[0])\n\n    min_angle_diff = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == shortest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        other_route_coords = coords[other_route[1:-1]]\n        other_angles = np.arctan2(other_route_coords[:, 1] - depot_coords[1], other_route_coords[:, 0] - depot_coords[0])\n        angle_diff = np.min(np.abs(angles[:, None] - other_angles[None, :]))\n        if angle_diff < min_angle_diff:\n            min_angle_diff = angle_diff\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([shortest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[shortest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = -float('inf')\n\n            for i in range(len(new_solution)):\n                if i == shortest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_makespan = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_makespan > best_score:\n                        best_score = current_makespan\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.650045904478578,
               3.4494218230247498
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    shortest_route_coords = coords[shortest_route[1:-1]]\n    angles = np.arctan2(shortest_route_coords[:, 1] - depot_coords[1], shortest_route_coords[:, 0] - depot_coords[0])\n\n    min_angle_diff = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == shortest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        other_route_coords = coords[other_route[1:-1]]\n        other_angles = np.arctan2(other_route_coords[:, 1] - depot_coords[1], other_route_coords[:, 0] - depot_coords[0])\n        angle_diff = np.min(np.abs(angles[:, None] - other_angles[None, :]))\n        if angle_diff < min_angle_diff:\n            min_angle_diff = angle_diff\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([shortest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[shortest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = -float('inf')\n\n            for i in range(len(new_solution)):\n                if i == shortest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_makespan = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_makespan > best_score:\n                        best_score = current_makespan\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The proposed algorithm selects a solution from the archive by prioritizing those with low makespan and high total distance, then applies a novel hybrid local search operator that combines angular-aware route reshaping with demand-balanced route clustering. It first identifies the shortest route and reshapes it by reordering customers based on their angular positions relative to the depot, then clusters high-demand customers into new routes using a k-means++-inspired approach that maximizes angular separation while respecting capacity constraints, while simultaneously redistributing low-demand customers from the reshaped route into existing routes using a greedy insertion strategy that minimizes angular deviation from the depot's perspective, dynamically balancing the trade-off between the two objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = shortest_route[1:-1]\n\n    angles = []\n    for c in customers:\n        customer_coords = coords[c]\n        angle = np.arctan2(customer_coords[1] - depot_coords[1], customer_coords[0] - depot_coords[0])\n        angles.append((c, angle))\n\n    angles_sorted = sorted(angles, key=lambda x: x[1])\n    reshaped_route = [0] + [c for c, _ in angles_sorted] + [0]\n\n    new_solution[shortest_route_idx] = np.array(reshaped_route)\n\n    high_demand_customers = sorted(customers, key=lambda c: -demand[c])\n    clusters = []\n\n    for c in high_demand_customers:\n        placed = False\n        for cluster in clusters:\n            if sum(demand[cluster]) + demand[c] <= capacity:\n                cluster.append(c)\n                placed = True\n                break\n        if not placed:\n            clusters.append([c])\n\n    new_routes = []\n    for cluster in clusters:\n        new_route = [0] + cluster + [0]\n        new_routes.append(np.array(new_route))\n\n    remaining_customers = [c for c in customers if c not in [cust for cluster in clusters for cust in cluster]]\n\n    for c in remaining_customers:\n        best_route_idx = -1\n        best_pos = -1\n        best_angle_diff = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == shortest_route_idx:\n                continue\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], [c], route[pos:]])\n                if sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                angle_diff = 0\n                for j in range(len(temp_route) - 2):\n                    angle1 = np.arctan2(coords[temp_route[j]][1] - depot_coords[1], coords[temp_route[j]][0] - depot_coords[0])\n                    angle2 = np.arctan2(coords[temp_route[j+1]][1] - depot_coords[1], coords[temp_route[j+1]][0] - depot_coords[0])\n                    angle_diff += abs(angle2 - angle1)\n\n                if angle_diff < best_angle_diff:\n                    best_angle_diff = angle_diff\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [c],\n                new_solution[best_route_idx][best_pos:]\n            ])\n\n    new_solution.extend(new_routes)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with balanced trade-offs between total distance and makespan, then applies a novel hybrid local search operator that combines spatial-angular route reshaping with demand-aware route harmonization. It first identifies the route with the highest load-to-distance ratio, reshapes it by reordering customers based on a combination of spatial proximity to the depot and angular alignment with high-demand customers, then harmonizes the route by redistributing customers to other routes using a demand-aware insertion strategy that maximizes spatial clustering of high-demand customers while minimizing angular deviations from the depot's perspective, dynamically balancing the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Identify route with highest load-to-distance ratio\n    def load_to_distance_ratio(route):\n        if len(route) <= 2:\n            return 0\n        total_demand = np.sum(demand[route[1:-1]])\n        route_distance = 0\n        for i in range(len(route) - 1):\n            route_distance += distance_matrix[route[i]][route[i+1]]\n        return total_demand / route_distance if route_distance > 0 else 0\n\n    target_route_idx = max(range(len(new_solution)), key=lambda i: load_to_distance_ratio(new_solution[i]))\n    target_route = new_solution[target_route_idx]\n\n    if len(target_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = target_route[1:-1]\n\n    # Calculate spatial-angular metrics\n    spatial_angles = []\n    for c in customers:\n        customer_coords = coords[c]\n        angle = np.arctan2(customer_coords[1] - depot_coords[1], customer_coords[0] - depot_coords[0])\n        distance = np.linalg.norm(customer_coords - depot_coords)\n        spatial_angles.append((c, angle, distance, demand[c]))\n\n    # Sort by angular position, then by distance, then by demand\n    spatial_angles_sorted = sorted(spatial_angles, key=lambda x: (x[1], x[2], -x[3]))\n    reshaped_route = [0] + [c for c, _, _, _ in spatial_angles_sorted] + [0]\n\n    # Temporarily replace the target route with reshaped version\n    temp_route = np.array(reshaped_route)\n\n    # Harmonize by redistributing customers\n    customers_to_redistribute = temp_route[1:-1]\n    new_routes = []\n\n    for cust in customers_to_redistribute:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('-inf')\n\n        for i in range(len(new_solution)):\n            if i == target_route_idx:\n                continue\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                # Calculate insertion feasibility\n                temp_insert = np.concatenate([route[:pos], [cust], route[pos:]])\n                if np.sum(demand[temp_insert[1:-1]]) > capacity:\n                    continue\n\n                # Calculate spatial-angular score\n                prev_node = temp_insert[pos-1]\n                next_node = temp_insert[pos+1] if pos+1 < len(temp_insert) else temp_insert[pos-1]\n\n                # Angular alignment score\n                angle_prev = np.arctan2(coords[prev_node][1] - depot_coords[1], coords[prev_node][0] - depot_coords[0])\n                angle_cust = np.arctan2(coords[cust][1] - depot_coords[1], coords[cust][0] - depot_coords[0])\n                angle_next = np.arctan2(coords[next_node][1] - depot_coords[1], coords[next_node][0] - depot_coords[0])\n\n                angle_diff = abs(angle_cust - angle_prev) + abs(angle_next - angle_cust)\n\n                # Distance score\n                dist_score = distance_matrix[prev_node][cust] + distance_matrix[cust][next_node] - distance_matrix[prev_node][next_node]\n\n                # Demand score (prefer inserting high-demand customers into new routes)\n                demand_score = demand[cust] if i != target_route_idx else -demand[cust]\n\n                # Combined score\n                score = -angle_diff - 0.5 * dist_score + 0.3 * demand_score\n\n                if score > best_score:\n                    best_score = score\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [cust],\n                new_solution[best_route_idx][best_pos:]\n            ])\n        else:\n            # If no good insertion found, create new route for high-demand customers\n            if demand[cust] > capacity * 0.3:\n                new_routes.append(np.array([0, cust, 0]))\n\n    # Add any new routes created\n    if new_routes:\n        new_solution.extend(new_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.7235711007882066,
               6.599566757678986
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Identify route with highest load-to-distance ratio\n    def load_to_distance_ratio(route):\n        if len(route) <= 2:\n            return 0\n        total_demand = np.sum(demand[route[1:-1]])\n        route_distance = 0\n        for i in range(len(route) - 1):\n            route_distance += distance_matrix[route[i]][route[i+1]]\n        return total_demand / route_distance if route_distance > 0 else 0\n\n    target_route_idx = max(range(len(new_solution)), key=lambda i: load_to_distance_ratio(new_solution[i]))\n    target_route = new_solution[target_route_idx]\n\n    if len(target_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = target_route[1:-1]\n\n    # Calculate spatial-angular metrics\n    spatial_angles = []\n    for c in customers:\n        customer_coords = coords[c]\n        angle = np.arctan2(customer_coords[1] - depot_coords[1], customer_coords[0] - depot_coords[0])\n        distance = np.linalg.norm(customer_coords - depot_coords)\n        spatial_angles.append((c, angle, distance, demand[c]))\n\n    # Sort by angular position, then by distance, then by demand\n    spatial_angles_sorted = sorted(spatial_angles, key=lambda x: (x[1], x[2], -x[3]))\n    reshaped_route = [0] + [c for c, _, _, _ in spatial_angles_sorted] + [0]\n\n    # Temporarily replace the target route with reshaped version\n    temp_route = np.array(reshaped_route)\n\n    # Harmonize by redistributing customers\n    customers_to_redistribute = temp_route[1:-1]\n    new_routes = []\n\n    for cust in customers_to_redistribute:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('-inf')\n\n        for i in range(len(new_solution)):\n            if i == target_route_idx:\n                continue\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                # Calculate insertion feasibility\n                temp_insert = np.concatenate([route[:pos], [cust], route[pos:]])\n                if np.sum(demand[temp_insert[1:-1]]) > capacity:\n                    continue\n\n                # Calculate spatial-angular score\n                prev_node = temp_insert[pos-1]\n                next_node = temp_insert[pos+1] if pos+1 < len(temp_insert) else temp_insert[pos-1]\n\n                # Angular alignment score\n                angle_prev = np.arctan2(coords[prev_node][1] - depot_coords[1], coords[prev_node][0] - depot_coords[0])\n                angle_cust = np.arctan2(coords[cust][1] - depot_coords[1], coords[cust][0] - depot_coords[0])\n                angle_next = np.arctan2(coords[next_node][1] - depot_coords[1], coords[next_node][0] - depot_coords[0])\n\n                angle_diff = abs(angle_cust - angle_prev) + abs(angle_next - angle_cust)\n\n                # Distance score\n                dist_score = distance_matrix[prev_node][cust] + distance_matrix[cust][next_node] - distance_matrix[prev_node][next_node]\n\n                # Demand score (prefer inserting high-demand customers into new routes)\n                demand_score = demand[cust] if i != target_route_idx else -demand[cust]\n\n                # Combined score\n                score = -angle_diff - 0.5 * dist_score + 0.3 * demand_score\n\n                if score > best_score:\n                    best_score = score\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [cust],\n                new_solution[best_route_idx][best_pos:]\n            ])\n        else:\n            # If no good insertion found, create new route for high-demand customers\n            if demand[cust] > capacity * 0.3:\n                new_routes.append(np.array([0, cust, 0]))\n\n    # Add any new routes created\n    if new_routes:\n        new_solution.extend(new_routes)\n\n    return new_solution\n\n"
     }
]