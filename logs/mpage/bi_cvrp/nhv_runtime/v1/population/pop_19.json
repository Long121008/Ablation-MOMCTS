[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    segments = []\n    current_segment = [longest_route[0]]\n\n    for i in range(1, len(longest_route)-1):\n        current_segment.append(longest_route[i])\n        if i < len(longest_route)-2:\n            prev_node = longest_route[i-1]\n            current_node = longest_route[i]\n            next_node = longest_route[i+1]\n\n            angle = np.arctan2(coords[next_node][1] - coords[current_node][1],\n                              coords[next_node][0] - coords[current_node][0]) - \\\n                   np.arctan2(coords[current_node][1] - coords[prev_node][1],\n                             coords[current_node][0] - coords[prev_node][0])\n\n            angle = np.abs((angle + np.pi) % (2*np.pi) - np.pi)\n\n            if angle > np.pi/4 or (sum(demand[current_segment[1:]]) + demand[next_node] > capacity * 0.7):\n                segments.append(current_segment + [0])\n                current_segment = [0]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment + [0])\n\n    if len(segments) < 2:\n        return new_solution\n\n    segments = [np.array(seg) for seg in segments]\n\n    for seg in segments:\n        inserted = False\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            seg_demand = sum(demand[seg[1:-1]])\n\n            if current_demand + seg_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                cost = (distance_matrix[route[pos-1], seg[1]] +\n                        distance_matrix[seg[-2], route[pos]] -\n                        distance_matrix[route[pos-1], route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            new_route = np.concatenate([best_route[:best_pos], seg[1:-1], best_route[best_pos:]])\n            new_solution[best_route_idx] = new_route\n            inserted = True\n\n    new_solution[longest_route_idx] = np.array([0, 0])\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.9010642633626035,
               1.0312801003456116
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8060362994057542,
               0.11159700155258179
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8998160088292702,
               0.1123153567314148
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8357341651155671,
               0.11425694823265076
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.6976429975852415,
               0.11389738321304321
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel \"route-segment-rebalancing\" strategy that identifies the longest route and fragments it into multiple segments based on both demand and spatial proximity, then reallocates these segments to existing routes or creates new routes using a spatial-aware insertion heuristic that minimizes both the total distance and makespan, while dynamically adjusting insertion positions to balance the trade-off between the objectives and ensuring capacity constraints are maintained. Unlike standard local search operators, this approach uses a \"segment-wise\" rebalancing that considers both the angular distribution of customers around the depot and the demand complementarity of customers within segments, allowing for more creative route restructuring that can significantly improve both objectives simultaneously.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = longest_route[1:-1]\n    customer_coords = coords[customers]\n\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    total_demand = np.sum(demand[customers])\n    if total_demand <= capacity:\n        return new_solution\n\n    segments = []\n    current_segment = [customers[0]]\n    current_demand = demand[customers[0]]\n    current_angle = angles[0]\n\n    for i in range(1, len(customers)):\n        c = customers[i]\n        angle_diff = abs(angles[i] - current_angle)\n\n        if (current_demand + demand[c] <= capacity * 0.9 and\n            angle_diff < np.pi/2 and\n            np.linalg.norm(customer_coords[i] - customer_coords[i-1]) < 1.5 * np.mean(np.linalg.norm(vectors, axis=1))):\n            current_segment.append(c)\n            current_demand += demand[c]\n            current_angle = (current_angle * len(current_segment) + angles[i]) / (len(current_segment) + 1)\n        else:\n            segments.append(current_segment)\n            current_segment = [c]\n            current_demand = demand[c]\n            current_angle = angles[i]\n    if current_segment:\n        segments.append(current_segment)\n\n    new_solution.pop(longest_route_idx)\n\n    for segment in segments:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], segment, route[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                current_dist = 0\n                for j in range(len(temp_route) - 1):\n                    current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                current_makespan = current_dist\n                for r in new_solution:\n                    route_dist = 0\n                    for k in range(len(r) - 1):\n                        route_dist += distance_matrix[r[k]][r[k+1]]\n                    if route_dist > current_makespan:\n                        current_makespan = route_dist\n\n                score = 0.5 * current_dist + 0.5 * current_makespan\n\n                if score < best_score:\n                    best_score = score\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                segment,\n                new_solution[best_route_idx][best_pos:]\n            ])\n        else:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        for j in range(1, len(route)-1):\n            cust = route[j]\n            best_route_idx = -1\n            best_pos = -1\n            best_improvement = 0\n\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                target_route = new_solution[k]\n                for pos in range(1, len(target_route)):\n                    temp_route = np.concatenate([target_route[:pos], [cust], target_route[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    original_dist = (distance_matrix[route[j-1]][cust] +\n                                   distance_matrix[cust][route[j+1]] -\n                                   distance_matrix[route[j-1]][route[j+1]])\n\n                    new_dist = (distance_matrix[target_route[pos-1]][cust] +\n                               distance_matrix[cust][target_route[pos]] -\n                               distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                    improvement = original_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = k\n                        best_pos = pos\n\n            if best_route_idx != -1 and best_improvement > 0:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                new_solution[i] = np.delete(new_solution[i], j)\n                if len(new_solution[i]) <= 2:\n                    new_solution.pop(i)\n                    break\n                j -= 1\n\n    return new_solution\n\n",
          "score": [
               -0.8906670607785585,
               0.1202617883682251
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.7420006809394131,
               0.11484518647193909
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a novel route segmentation and insertion strategy that combines spatial partitioning with demand-aware route splitting. First, it partitions the solution space into angular sectors centered at the depot, then identifies the most promising sector for improvement by analyzing both spatial distribution and demand patterns. Next, it splits the longest route in the selected sector into multiple smaller segments based on both angular changes and demand thresholds, ensuring each segment can be feasibly inserted into other routes. Finally, it attempts to insert each segment into the most suitable existing route by evaluating both spatial proximity and demand compatibility, while dynamically adjusting insertion criteria to balance the makespan and total distance objectives, and incorporating a probabilistic acceptance of partial improvements to maintain diversity in the search process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    depot_coords = coords[0]\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    all_customers = list(all_customers)\n\n    if not all_customers:\n        return new_solution\n\n    customer_coords = coords[all_customers]\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    sector_size = np.pi / 4\n    sectors = [[] for _ in range(8)]\n\n    for i, angle in enumerate(angles):\n        sector_idx = int((angle + np.pi) // sector_size) % 8\n        sectors[sector_idx].append(all_customers[i])\n\n    sector_scores = []\n    for sector in sectors:\n        if not sector:\n            sector_scores.append(0)\n            continue\n\n        sector_demand = sum(demand[sector])\n        sector_distance = sum(distance_matrix[0, c] for c in sector) + sum(distance_matrix[c, 0] for c in sector)\n        sector_scores.append(sector_demand * sector_distance)\n\n    best_sector = max(range(8), key=lambda i: sector_scores[i])\n\n    sector_customers = sectors[best_sector]\n    if not sector_customers:\n        return new_solution\n\n    longest_route_in_sector = None\n    max_length = 0\n\n    for route in new_solution:\n        route_customers = set(route[1:-1])\n        common = set(sector_customers) & route_customers\n        if len(common) > max_length:\n            max_length = len(common)\n            longest_route_in_sector = route\n\n    if longest_route_in_sector is None:\n        return new_solution\n\n    route_customers = longest_route_in_sector[1:-1]\n    segments = []\n    current_segment = [0]\n\n    for i in range(1, len(route_customers)-1):\n        current_segment.append(route_customers[i])\n        prev_node = route_customers[i-1]\n        current_node = route_customers[i]\n        next_node = route_customers[i+1]\n\n        angle_prev = np.arctan2(coords[current_node][1] - coords[prev_node][1],\n                               coords[current_node][0] - coords[prev_node][0])\n        angle_next = np.arctan2(coords[next_node][1] - coords[current_node][1],\n                               coords[next_node][0] - coords[current_node][0])\n        angle_diff = abs((angle_next - angle_prev + np.pi) % (2*np.pi) - np.pi)\n\n        current_demand = sum(demand[current_segment[1:]])\n\n        if angle_diff > np.pi/6 or (current_demand + demand[next_node] > capacity * 0.8):\n            segments.append(current_segment + [0])\n            current_segment = [0]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment + [0])\n\n    if len(segments) < 2:\n        return new_solution\n\n    segments = [np.array(seg) for seg in segments]\n\n    for seg in segments:\n        inserted = False\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if np.array_equal(route, longest_route_in_sector):\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            seg_demand = sum(demand[seg[1:-1]])\n\n            if current_demand + seg_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                cost = (distance_matrix[route[pos-1], seg[1]] +\n                        distance_matrix[seg[-2], route[pos]] -\n                        distance_matrix[route[pos-1], route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            new_route = np.concatenate([best_route[:best_pos], seg[1:-1], best_route[best_pos:]])\n            new_solution[best_route_idx] = new_route\n            inserted = True\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8869791115963259,
               1.2214601635932922
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, then applies a novel \"route-segmentation-and-rebalancing\" strategy that systematically identifies and extracts high-demand segments from long routes, reinserts them into new routes optimized for both distance and makespan objectives, while dynamically balancing the trade-off between the two objectives by considering spatial proximity, angular alignment, and demand complementarity during the reinsertion process, ensuring feasibility through continuous capacity checks and dynamic route adjustment.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    all_customers = np.array([c for route in new_solution for c in route[1:-1]])\n    customer_coords = coords[all_customers]\n\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    demand_threshold = capacity * 0.7\n    high_demand_customers = all_customers[demand[all_customers] > demand_threshold]\n\n    if len(high_demand_customers) < 1:\n        return new_solution\n\n    high_demand_coords = coords[high_demand_customers]\n    high_demand_angles = np.arctan2(high_demand_coords[:, 1] - depot_coords[1], high_demand_coords[:, 0] - depot_coords[0])\n\n    segments = []\n    for i in range(1, len(longest_route) - 1):\n        for j in range(i + 1, len(longest_route)):\n            segment = longest_route[i:j+1]\n            segment_demand = np.sum(demand[segment])\n            if segment_demand <= capacity and segment_demand > 0:\n                segment_coords = coords[segment]\n                segment_angles = np.arctan2(segment_coords[:, 1] - depot_coords[1], segment_coords[:, 0] - depot_coords[0])\n                avg_angle = np.mean(segment_angles)\n                segments.append((segment, segment_demand, avg_angle))\n\n    if not segments:\n        return new_solution\n\n    best_segment, best_segment_demand, best_segment_angle = max(segments, key=lambda x: x[1])\n\n    new_route = np.concatenate([[0], best_segment, [0]])\n    new_solution.append(new_route)\n\n    for c in best_segment:\n        for i, route in enumerate(new_solution[:-1]):\n            if c in route:\n                new_solution[i] = np.delete(route, np.where(route == c)[0][0])\n                break\n\n    for i in reversed(range(len(new_solution))):\n        if len(new_solution[i]) <= 2:\n            new_solution.pop(i)\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 2:\n            for j in range(1, len(route) - 1):\n                cust = route[j]\n                if cust in high_demand_customers:\n                    angle_diff = min(abs(angles[cust-1] - best_segment_angle), 2*np.pi - abs(angles[cust-1] - best_segment_angle))\n                    if angle_diff < np.pi/3:\n                        for k in range(len(new_solution)):\n                            if k != i:\n                                other_route = new_solution[k]\n                                if np.sum(demand[other_route[1:-1]]) + demand[cust] <= capacity:\n                                    best_pos = 1\n                                    min_dist = float('inf')\n                                    for pos in range(1, len(other_route)):\n                                        dist = distance_matrix[other_route[pos-1]][cust] + distance_matrix[cust][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_pos = pos\n                                    new_solution[k] = np.concatenate([\n                                        other_route[:best_pos],\n                                        [cust],\n                                        other_route[best_pos:]\n                                    ])\n                                    new_solution[i] = np.delete(route, j)\n                                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8648606764594223,
               0.1386987864971161
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, then applies a novel \"spatial-cluster-and-demand-balancing\" strategy that systematically identifies spatial clusters of high-demand customers in long routes, extracts these clusters into new routes optimized for both distance and makespan objectives, while dynamically balancing the trade-off between the two objectives by considering spatial density, demand complementarity, and angular alignment during the extraction process, ensuring feasibility through continuous capacity checks and dynamic route adjustment, and finally reinserts low-demand customers from the extracted clusters into existing routes using a spatial proximity heuristic to minimize total distance while maintaining makespan reduction.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = longest_route[1:-1]\n    customer_coords = coords[customers]\n\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    demand_threshold = capacity * 0.6\n    high_demand_customers = customers[demand[customers] > demand_threshold]\n\n    if len(high_demand_customers) < 2:\n        return new_solution\n\n    high_demand_coords = coords[high_demand_customers]\n    high_demand_angles = np.arctan2(high_demand_coords[:, 1] - depot_coords[1], high_demand_coords[:, 0] - depot_coords[0])\n\n    angle_clusters = {}\n    for i, angle in enumerate(high_demand_angles):\n        cluster_key = round(angle / (np.pi/4)) % 8\n        if cluster_key not in angle_clusters:\n            angle_clusters[cluster_key] = []\n        angle_clusters[cluster_key].append(high_demand_customers[i])\n\n    best_cluster = None\n    best_cluster_demand = 0\n    for cluster in angle_clusters.values():\n        cluster_demand = np.sum(demand[cluster])\n        if cluster_demand > best_cluster_demand and cluster_demand <= capacity:\n            best_cluster = cluster\n            best_cluster_demand = cluster_demand\n\n    if not best_cluster:\n        return new_solution\n\n    new_route = np.concatenate([[0], best_cluster, [0]])\n    new_solution.append(new_route)\n\n    for c in best_cluster:\n        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == c)[0][0])\n\n    if len(new_solution[longest_route_idx]) <= 2:\n        new_solution.pop(longest_route_idx)\n\n    remaining_customers = [c for c in customers if c not in best_cluster and demand[c] < demand_threshold]\n\n    for cust in remaining_customers:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route_candidate = new_solution[i]\n            for pos in range(1, len(route_candidate)):\n                temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                dist_reduction = distance_matrix[route_candidate[pos-1]][cust] + distance_matrix[cust][route_candidate[pos]] - distance_matrix[route_candidate[pos-1]][route_candidate[pos]]\n                if dist_reduction < best_score:\n                    best_score = dist_reduction\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [cust],\n                new_solution[best_route_idx][best_pos:]\n            ])\n\n    return new_solution\n\n",
          "score": [
               -0.8840929326921872,
               0.8764921128749847
          ]
     }
]