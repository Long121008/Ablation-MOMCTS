[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    segments = []\n    current_segment = [longest_route[0]]\n\n    for i in range(1, len(longest_route)-1):\n        current_segment.append(longest_route[i])\n        if i < len(longest_route)-2:\n            prev_node = longest_route[i-1]\n            current_node = longest_route[i]\n            next_node = longest_route[i+1]\n\n            angle = np.arctan2(coords[next_node][1] - coords[current_node][1],\n                              coords[next_node][0] - coords[current_node][0]) - \\\n                   np.arctan2(coords[current_node][1] - coords[prev_node][1],\n                             coords[current_node][0] - coords[prev_node][0])\n\n            angle = np.abs((angle + np.pi) % (2*np.pi) - np.pi)\n\n            if angle > np.pi/4 or (sum(demand[current_segment[1:]]) + demand[next_node] > capacity * 0.7):\n                segments.append(current_segment + [0])\n                current_segment = [0]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment + [0])\n\n    if len(segments) < 2:\n        return new_solution\n\n    segments = [np.array(seg) for seg in segments]\n\n    for seg in segments:\n        inserted = False\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            seg_demand = sum(demand[seg[1:-1]])\n\n            if current_demand + seg_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                cost = (distance_matrix[route[pos-1], seg[1]] +\n                        distance_matrix[seg[-2], route[pos]] -\n                        distance_matrix[route[pos-1], route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            new_route = np.concatenate([best_route[:best_pos], seg[1:-1], best_route[best_pos:]])\n            new_solution[best_route_idx] = new_route\n            inserted = True\n\n    new_solution[longest_route_idx] = np.array([0, 0])\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.9010642633626035,
               1.0312801003456116
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8998160088292702,
               0.1123153567314148
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8476038970283947,
               0.11185917258262634
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    new_solution[longest_route_idx] = split_routes[0]\n    new_solution.extend(split_routes[1:])\n\n    for route in new_solution:\n        if len(route) <= 2:\n            continue\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == new_solution.index(route):\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                route = np.concatenate([route[:route.tolist().index(cust)], route[route.tolist().index(cust)+1:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8220866282320791,
               0.11111319065093994
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with low makespan and high total distance, then applies a novel hybrid local search operator that combines angular-aware route reshaping with demand-balanced route clustering. It first identifies the shortest route and reshapes it by reordering customers based on their angular positions relative to the depot, then clusters high-demand customers into new routes using a k-means++-inspired approach that maximizes angular separation while respecting capacity constraints, while simultaneously redistributing low-demand customers from the reshaped route into existing routes using a greedy insertion strategy that minimizes angular deviation from the depot's perspective, dynamically balancing the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = shortest_route[1:-1]\n\n    angles = []\n    for c in customers:\n        customer_coords = coords[c]\n        angle = np.arctan2(customer_coords[1] - depot_coords[1], customer_coords[0] - depot_coords[0])\n        angles.append((c, angle))\n\n    angles_sorted = sorted(angles, key=lambda x: x[1])\n    reshaped_route = [0] + [c for c, _ in angles_sorted] + [0]\n\n    new_solution[shortest_route_idx] = np.array(reshaped_route)\n\n    high_demand_customers = sorted(customers, key=lambda c: -demand[c])\n    clusters = []\n\n    for c in high_demand_customers:\n        placed = False\n        for cluster in clusters:\n            if sum(demand[cluster]) + demand[c] <= capacity:\n                cluster.append(c)\n                placed = True\n                break\n        if not placed:\n            clusters.append([c])\n\n    new_routes = []\n    for cluster in clusters:\n        new_route = [0] + cluster + [0]\n        new_routes.append(np.array(new_route))\n\n    remaining_customers = [c for c in customers if c not in [cust for cluster in clusters for cust in cluster]]\n\n    for c in remaining_customers:\n        best_route_idx = -1\n        best_pos = -1\n        best_angle_diff = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == shortest_route_idx:\n                continue\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], [c], route[pos:]])\n                if sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                angle_diff = 0\n                for j in range(len(temp_route) - 2):\n                    angle1 = np.arctan2(coords[temp_route[j]][1] - depot_coords[1], coords[temp_route[j]][0] - depot_coords[0])\n                    angle2 = np.arctan2(coords[temp_route[j+1]][1] - depot_coords[1], coords[temp_route[j+1]][0] - depot_coords[0])\n                    angle_diff += abs(angle2 - angle1)\n\n                if angle_diff < best_angle_diff:\n                    best_angle_diff = angle_diff\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [c],\n                new_solution[best_route_idx][best_pos:]\n            ])\n\n    new_solution.extend(new_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.7981042574204065,
               0.08120453357696533
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.6947844808488912,
               0.10941681265830994
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel \"route-segment-rebalancing\" strategy that identifies the longest route and fragments it into multiple segments based on both demand and spatial proximity, then reallocates these segments to existing routes or creates new routes using a spatial-aware insertion heuristic that minimizes both the total distance and makespan, while dynamically adjusting insertion positions to balance the trade-off between the objectives and ensuring capacity constraints are maintained. Unlike standard local search operators, this approach uses a \"segment-wise\" rebalancing that considers both the angular distribution of customers around the depot and the demand complementarity of customers within segments, allowing for more creative route restructuring that can significantly improve both objectives simultaneously.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    customers = longest_route[1:-1]\n    customer_coords = coords[customers]\n\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    total_demand = np.sum(demand[customers])\n    if total_demand <= capacity:\n        return new_solution\n\n    segments = []\n    current_segment = [customers[0]]\n    current_demand = demand[customers[0]]\n    current_angle = angles[0]\n\n    for i in range(1, len(customers)):\n        c = customers[i]\n        angle_diff = abs(angles[i] - current_angle)\n\n        if (current_demand + demand[c] <= capacity * 0.9 and\n            angle_diff < np.pi/2 and\n            np.linalg.norm(customer_coords[i] - customer_coords[i-1]) < 1.5 * np.mean(np.linalg.norm(vectors, axis=1))):\n            current_segment.append(c)\n            current_demand += demand[c]\n            current_angle = (current_angle * len(current_segment) + angles[i]) / (len(current_segment) + 1)\n        else:\n            segments.append(current_segment)\n            current_segment = [c]\n            current_demand = demand[c]\n            current_angle = angles[i]\n    if current_segment:\n        segments.append(current_segment)\n\n    new_solution.pop(longest_route_idx)\n\n    for segment in segments:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], segment, route[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                current_dist = 0\n                for j in range(len(temp_route) - 1):\n                    current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                current_makespan = current_dist\n                for r in new_solution:\n                    route_dist = 0\n                    for k in range(len(r) - 1):\n                        route_dist += distance_matrix[r[k]][r[k+1]]\n                    if route_dist > current_makespan:\n                        current_makespan = route_dist\n\n                score = 0.5 * current_dist + 0.5 * current_makespan\n\n                if score < best_score:\n                    best_score = score\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                segment,\n                new_solution[best_route_idx][best_pos:]\n            ])\n        else:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        for j in range(1, len(route)-1):\n            cust = route[j]\n            best_route_idx = -1\n            best_pos = -1\n            best_improvement = 0\n\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                target_route = new_solution[k]\n                for pos in range(1, len(target_route)):\n                    temp_route = np.concatenate([target_route[:pos], [cust], target_route[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    original_dist = (distance_matrix[route[j-1]][cust] +\n                                   distance_matrix[cust][route[j+1]] -\n                                   distance_matrix[route[j-1]][route[j+1]])\n\n                    new_dist = (distance_matrix[target_route[pos-1]][cust] +\n                               distance_matrix[cust][target_route[pos]] -\n                               distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                    improvement = original_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = k\n                        best_pos = pos\n\n            if best_route_idx != -1 and best_improvement > 0:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n                new_solution[i] = np.delete(new_solution[i], j)\n                if len(new_solution[i]) <= 2:\n                    new_solution.pop(i)\n                    break\n                j -= 1\n\n    return new_solution\n\n",
          "score": [
               -0.8906670607785585,
               0.1202617883682251
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.7535926237961227,
               0.11114320158958435
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8376842888997864,
               0.11928611993789673
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8357341651155671,
               0.11425694823265076
          ]
     }
]