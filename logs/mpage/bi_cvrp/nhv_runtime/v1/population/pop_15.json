[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    segments = []\n    current_segment = [longest_route[0]]\n\n    for i in range(1, len(longest_route)-1):\n        current_segment.append(longest_route[i])\n        if i < len(longest_route)-2:\n            prev_node = longest_route[i-1]\n            current_node = longest_route[i]\n            next_node = longest_route[i+1]\n\n            angle = np.arctan2(coords[next_node][1] - coords[current_node][1],\n                              coords[next_node][0] - coords[current_node][0]) - \\\n                   np.arctan2(coords[current_node][1] - coords[prev_node][1],\n                             coords[current_node][0] - coords[prev_node][0])\n\n            angle = np.abs((angle + np.pi) % (2*np.pi) - np.pi)\n\n            if angle > np.pi/4 or (sum(demand[current_segment[1:]]) + demand[next_node] > capacity * 0.7):\n                segments.append(current_segment + [0])\n                current_segment = [0]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment + [0])\n\n    if len(segments) < 2:\n        return new_solution\n\n    segments = [np.array(seg) for seg in segments]\n\n    for seg in segments:\n        inserted = False\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            seg_demand = sum(demand[seg[1:-1]])\n\n            if current_demand + seg_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                cost = (distance_matrix[route[pos-1], seg[1]] +\n                        distance_matrix[seg[-2], route[pos]] -\n                        distance_matrix[route[pos-1], route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            new_route = np.concatenate([best_route[:best_pos], seg[1:-1], best_route[best_pos:]])\n            new_solution[best_route_idx] = new_route\n            inserted = True\n\n    new_solution[longest_route_idx] = np.array([0, 0])\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.9010642633626035,
               1.0312801003456116
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8060362994057542,
               0.11159700155258179
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8998160088292702,
               0.1123153567314148
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, then applies a novel \"route-segmentation-and-rebalancing\" strategy that systematically identifies and extracts high-demand segments from long routes, reinserts them into new routes optimized for both distance and makespan objectives, while dynamically balancing the trade-off between the two objectives by considering spatial proximity, angular alignment, and demand complementarity during the reinsertion process, ensuring feasibility through continuous capacity checks and dynamic route adjustment.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    depot_coords = coords[0]\n    all_customers = np.array([c for route in new_solution for c in route[1:-1]])\n    customer_coords = coords[all_customers]\n\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    demand_threshold = capacity * 0.7\n    high_demand_customers = all_customers[demand[all_customers] > demand_threshold]\n\n    if len(high_demand_customers) < 1:\n        return new_solution\n\n    high_demand_coords = coords[high_demand_customers]\n    high_demand_angles = np.arctan2(high_demand_coords[:, 1] - depot_coords[1], high_demand_coords[:, 0] - depot_coords[0])\n\n    segments = []\n    for i in range(1, len(longest_route) - 1):\n        for j in range(i + 1, len(longest_route)):\n            segment = longest_route[i:j+1]\n            segment_demand = np.sum(demand[segment])\n            if segment_demand <= capacity and segment_demand > 0:\n                segment_coords = coords[segment]\n                segment_angles = np.arctan2(segment_coords[:, 1] - depot_coords[1], segment_coords[:, 0] - depot_coords[0])\n                avg_angle = np.mean(segment_angles)\n                segments.append((segment, segment_demand, avg_angle))\n\n    if not segments:\n        return new_solution\n\n    best_segment, best_segment_demand, best_segment_angle = max(segments, key=lambda x: x[1])\n\n    new_route = np.concatenate([[0], best_segment, [0]])\n    new_solution.append(new_route)\n\n    for c in best_segment:\n        for i, route in enumerate(new_solution[:-1]):\n            if c in route:\n                new_solution[i] = np.delete(route, np.where(route == c)[0][0])\n                break\n\n    for i in reversed(range(len(new_solution))):\n        if len(new_solution[i]) <= 2:\n            new_solution.pop(i)\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 2:\n            for j in range(1, len(route) - 1):\n                cust = route[j]\n                if cust in high_demand_customers:\n                    angle_diff = min(abs(angles[cust-1] - best_segment_angle), 2*np.pi - abs(angles[cust-1] - best_segment_angle))\n                    if angle_diff < np.pi/3:\n                        for k in range(len(new_solution)):\n                            if k != i:\n                                other_route = new_solution[k]\n                                if np.sum(demand[other_route[1:-1]]) + demand[cust] <= capacity:\n                                    best_pos = 1\n                                    min_dist = float('inf')\n                                    for pos in range(1, len(other_route)):\n                                        dist = distance_matrix[other_route[pos-1]][cust] + distance_matrix[cust][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_pos = pos\n                                    new_solution[k] = np.concatenate([\n                                        other_route[:best_pos],\n                                        [cust],\n                                        other_route[best_pos:]\n                                    ])\n                                    new_solution[i] = np.delete(route, j)\n                                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8648606764594223,
               0.1386987864971161
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel hybrid local search operator that combines spatial-aware route merging with demand-balanced route splitting. It first identifies the longest route and merges it with the spatially closest adjacent route while respecting capacity constraints, then systematically splits high-demand customers from the merged route into new routes using a demand-driven partitioning strategy that minimizes makespan, while simultaneously reinserting low-demand customers from the split routes into other routes using a spatial proximity heuristic to reduce total distance, dynamically adjusting insertion positions to balance the trade-off between the two objectives while ensuring feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers = merged_route[1:-1]\n    sorted_customers = sorted(customers, key=lambda c: -demand[c])\n    current_demand = 0\n    split_points = []\n\n    for i, c in enumerate(sorted_customers):\n        current_demand += demand[c]\n        if current_demand > capacity and i > 0:\n            split_points.append(i)\n            current_demand = demand[c]\n\n    if not split_points:\n        return new_solution\n\n    split_routes = []\n    prev_idx = 0\n    for point in split_points:\n        new_route = np.concatenate([[0], sorted_customers[prev_idx:point], [0]])\n        split_routes.append(new_route)\n        prev_idx = point\n    split_routes.append(np.concatenate([[0], sorted_customers[prev_idx:], [0]]))\n\n    for route in split_routes:\n        customers_to_insert = route[1:-1]\n        for cust in customers_to_insert:\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route_candidate = new_solution[i]\n                for pos in range(1, len(route_candidate)):\n                    temp_route = np.concatenate([route_candidate[:pos], [cust], route_candidate[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) > capacity:\n                        continue\n\n                    current_dist = 0\n                    for j in range(len(temp_route) - 1):\n                        current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                    if current_dist < best_score:\n                        best_score = current_dist\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.concatenate([\n                    new_solution[best_route_idx][:best_pos],\n                    [cust],\n                    new_solution[best_route_idx][best_pos:]\n                ])\n\n    new_solution.extend(split_routes)\n\n    return new_solution\n\n",
          "score": [
               -0.8357341651155671,
               0.11425694823265076
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with high makespan and low total distance, then applies a novel route fragmentation and spatial-aware reallocation strategy. It first identifies the longest route and fragments it into multiple smaller segments by strategically partitioning customers based on both demand and spatial proximity, then reallocates these segments to existing routes or creates new routes using a spatial-aware insertion heuristic that minimizes both the total distance and makespan, dynamically adjusting insertion positions to balance the trade-off between the objectives while ensuring capacity constraints are maintained, and avoids standard local search operators like pure 2-opt or simple route merging.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    total_demand = np.sum(demand[customers])\n\n    if total_demand <= capacity:\n        return new_solution\n\n    # Fragment the longest route into segments based on demand and spatial proximity\n    segments = []\n    current_segment = [customers[0]]\n    current_demand = demand[customers[0]]\n\n    for c in customers[1:]:\n        if current_demand + demand[c] <= capacity * 0.8:  # Allow some flexibility\n            current_segment.append(c)\n            current_demand += demand[c]\n        else:\n            segments.append(current_segment)\n            current_segment = [c]\n            current_demand = demand[c]\n    if current_segment:\n        segments.append(current_segment)\n\n    # Remove the original long route\n    new_solution.pop(longest_route_idx)\n\n    # Reallocate segments to existing routes or create new routes\n    for segment in segments:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        # Try to insert into existing routes\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], segment, route[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                current_dist = 0\n                for j in range(len(temp_route) - 1):\n                    current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                # Balance between total distance and makespan\n                current_makespan = current_dist\n                for r in new_solution:\n                    if i != len(new_solution):\n                        route_dist = 0\n                        for k in range(len(r) - 1):\n                            route_dist += distance_matrix[r[k]][r[k+1]]\n                        if route_dist > current_makespan:\n                            current_makespan = route_dist\n\n                # Combine objectives with weights\n                score = 0.6 * current_dist + 0.4 * current_makespan\n\n                if score < best_score:\n                    best_score = score\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                segment,\n                new_solution[best_route_idx][best_pos:]\n            ])\n        else:\n            # Create a new route if no suitable insertion found\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
          "score": [
               -0.7794680355219018,
               0.117555171251297
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: Route balancing + Intra-route 3-opt + Inter-route swap\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route balancing - redistribute customers to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(demand[route[1:-1]]) for route in new_solution])\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from longest to shortest route if it fits\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into shortest route (greedy insertion)\n                best_pos = 1\n                best_cost = float('inf')\n                for j in range(1, len(shortest_route)):\n                    cost = (distance_matrix[shortest_route[j-1], customer] +\n                            distance_matrix[customer, shortest_route[j]] -\n                            distance_matrix[shortest_route[j-1], shortest_route[j]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = j\n\n                # Update routes\n                new_shortest = np.insert(shortest_route, best_pos, customer)\n                new_longest = np.delete(longest_route, i)\n                new_solution[shortest_route_idx] = new_shortest\n                new_solution[longest_route_idx] = new_longest\n                break\n\n    # Step 2: Intra-route 3-opt for each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select 3 random non-depot nodes\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n\n            # Generate all possible 3-opt moves\n            moves = [\n                (a, b, c), (a, c, b),\n                (b, a, c), (b, c, a),\n                (c, a, b), (c, b, a)\n            ]\n\n            best_move = None\n            best_cost = sum(distance_matrix[route[j-1], route[j]] for j in range(1, len(route)))\n\n            for move in moves:\n                new_route = route.copy()\n                new_route[move[0]:move[2]+1] = route[move[0]:move[2]+1][::-1]\n\n                # Check feasibility\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_move = move\n\n            if best_move is not None:\n                new_solution[i] = np.array([route[0]] + list(route[best_move[0]:best_move[2]+1][::-1]) + list(route[best_move[2]+1:]))\n\n    # Step 3: Inter-route swap for customers with similar demands\n    if len(new_solution) > 1:\n        # Find two routes with similar total demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if abs(demands[i] - demands[j]) < capacity * 0.2:  # Threshold for similar demand\n                    # Try to swap customers between these routes\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n\n                    for c1 in range(1, len(route1)-1):\n                        for c2 in range(1, len(route2)-1):\n                            # Check if swap is feasible\n                            if (sum(demand[route1[1:-1]]) - demand[route1[c1]] + demand[route2[c2]] <= capacity and\n                                sum(demand[route2[1:-1]]) - demand[route2[c2]] + demand[route1[c1]] <= capacity):\n                                # Perform swap\n                                new_route1 = route1.copy()\n                                new_route2 = route2.copy()\n                                new_route1[c1] = route2[c2]\n                                new_route2[c2] = route1[c1]\n\n                                # Check if swap reduces total distance\n                                old_cost = (distance_matrix[route1[c1-1], route1[c1]] + distance_matrix[route1[c1], route1[c1+1]] +\n                                           distance_matrix[route2[c2-1], route2[c2]] + distance_matrix[route2[c2], route2[c2+1]])\n\n                                new_cost = (distance_matrix[new_route1[c1-1], new_route1[c1]] + distance_matrix[new_route1[c1], new_route1[c1+1]] +\n                                           distance_matrix[new_route2[c2-1], new_route2[c2]] + distance_matrix[new_route2[c2], new_route2[c2+1]])\n\n                                if new_cost < old_cost:\n                                    new_solution[i] = new_route1\n                                    new_solution[j] = new_route2\n                                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8597602962387709,
               7.648170918226242
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, then applies a novel route decomposition and reconstruction strategy that combines spatial clustering with demand-aware route merging. First, it decomposes the longest route into spatial clusters based on angular and distance thresholds, then reconstructs new routes by merging clusters in a demand-aware manner that balances the makespan while minimizing total distance, ensuring feasibility by checking capacity constraints at each step. The algorithm dynamically adjusts the decomposition and merging criteria based on the current solution's characteristics to balance exploration of the search space with exploitation of promising regions, while also incorporating a probabilistic acceptance of low-quality merges to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    # Decompose the longest route into spatial clusters\n    customers = longest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    # Calculate angles and distances from depot\n    depot_coords = coords[0]\n    customer_coords = coords[customers]\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n    distances = np.linalg.norm(vectors, axis=1)\n\n    # Cluster customers based on angle and distance\n    clusters = []\n    current_cluster = [customers[0]]\n    for i in range(1, len(customers)):\n        prev_angle = angles[i-1]\n        curr_angle = angles[i]\n        angle_diff = abs((curr_angle - prev_angle + np.pi) % (2*np.pi) - np.pi)\n\n        prev_dist = distances[i-1]\n        curr_dist = distances[i]\n        dist_ratio = curr_dist / prev_dist if prev_dist > 0 else 1\n\n        if angle_diff > np.pi/6 or dist_ratio > 1.5:\n            clusters.append(current_cluster)\n            current_cluster = [customers[i]]\n        else:\n            current_cluster.append(customers[i])\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) < 2:\n        return new_solution\n\n    # Try to merge clusters into new routes\n    merged_routes = []\n    remaining_clusters = clusters.copy()\n\n    while remaining_clusters:\n        current_cluster = remaining_clusters.pop(0)\n        current_demand = sum(demand[current_cluster])\n        current_route = [0] + current_cluster + [0]\n\n        # Try to merge with other clusters\n        for _ in range(len(remaining_clusters)):\n            best_merge = None\n            best_cost = float('inf')\n\n            for i, other_cluster in enumerate(remaining_clusters):\n                other_demand = sum(demand[other_cluster])\n                if current_demand + other_demand > capacity:\n                    continue\n\n                # Calculate merge cost\n                last_customer = current_cluster[-1]\n                first_other = other_cluster[0]\n                cost = distance_matrix[last_customer, first_other]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_merge = i\n\n            if best_merge is not None:\n                merged_cluster = remaining_clusters.pop(best_merge)\n                current_cluster.extend(merged_cluster)\n                current_demand += sum(demand[merged_cluster])\n                current_route = current_route[:-1] + merged_cluster + [0]\n\n        merged_routes.append(np.array(current_route))\n\n    # Replace the original route with the merged routes\n    new_solution[longest_route_idx] = np.array([0, 0])\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution.extend(merged_routes)\n\n    # Probabilistically accept low-quality merges to escape local optima\n    if len(new_solution) > len(base_solution) and np.random.random() < 0.3:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.8580913087664004,
               1.0747464299201965
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, then applies a novel \"route-balancing-and-segment-swapping\" strategy that systematically identifies and swaps high-demand segments between routes to optimize both distance and makespan objectives, while dynamically balancing the trade-off between the two objectives by considering spatial proximity, angular alignment, and demand complementarity during the swapping process, ensuring feasibility through continuous capacity checks and dynamic route adjustment, and further improving the solution by redistributing customers based on their angular positions relative to the depot to create more balanced and efficient routes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    depot_coords = coords[0]\n    all_customers = np.array([c for route in new_solution for c in route[1:-1]])\n    customer_coords = coords[all_customers]\n\n    vectors = customer_coords - depot_coords\n    angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n\n    demand_threshold = capacity * 0.7\n    high_demand_customers = all_customers[demand[all_customers] > demand_threshold]\n\n    if len(high_demand_customers) < 1:\n        return new_solution\n\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    route_angles = [np.mean(np.arctan2(coords[route[1:-1]][:, 1] - depot_coords[1], coords[route[1:-1]][:, 0] - depot_coords[0])) for route in new_solution]\n\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            angle_diff = min(abs(route_angles[i] - route_angles[j]), 2*np.pi - abs(route_angles[i] - route_angles[j]))\n\n            if angle_diff > np.pi/2:\n                continue\n\n            segment1 = route1[1:-1]\n            segment2 = route2[1:-1]\n\n            for k in range(len(segment1)):\n                for l in range(len(segment2)):\n                    cust1 = segment1[k]\n                    cust2 = segment2[l]\n\n                    if cust1 in high_demand_customers or cust2 in high_demand_customers:\n                        new_demand1 = route_demands[i] - demand[cust1] + demand[cust2]\n                        new_demand2 = route_demands[j] - demand[cust2] + demand[cust1]\n\n                        if new_demand1 <= capacity and new_demand2 <= capacity:\n                            temp_route1 = np.concatenate([[0], np.delete(segment1, k), [cust2], [0]])\n                            temp_route2 = np.concatenate([[0], np.delete(segment2, l), [cust1], [0]])\n\n                            dist1 = distance_matrix[0][temp_route1[1]] + distance_matrix[temp_route1[-2]][0]\n                            dist2 = distance_matrix[0][temp_route2[1]] + distance_matrix[temp_route2[-2]][0]\n\n                            for m in range(1, len(temp_route1)-1):\n                                dist1 += distance_matrix[temp_route1[m-1]][temp_route1[m]]\n\n                            for n in range(1, len(temp_route2)-1):\n                                dist2 += distance_matrix[temp_route2[n-1]][temp_route2[n]]\n\n                            if dist1 < distance_matrix[0][route1[1]] + distance_matrix[route1[-2]][0] + sum(distance_matrix[route1[m]][route1[m+1]] for m in range(1, len(route1)-1)) and \\\n                               dist2 < distance_matrix[0][route2[1]] + distance_matrix[route2[-2]][0] + sum(distance_matrix[route2[n]][route2[n+1]] for n in range(1, len(route2)-1)):\n\n                                new_solution[i] = temp_route1\n                                new_solution[j] = temp_route2\n                                route_demands[i] = new_demand1\n                                route_demands[j] = new_demand2\n\n                                route_angles[i] = np.mean(np.arctan2(coords[temp_route1[1:-1]][:, 1] - depot_coords[1], coords[temp_route1[1:-1]][:, 0] - depot_coords[0]))\n                                route_angles[j] = np.mean(np.arctan2(coords[temp_route2[1:-1]][:, 1] - depot_coords[1], coords[temp_route2[1:-1]][:, 0] - depot_coords[0]))\n\n    return new_solution\n\n",
          "score": [
               -0.8209826571618211,
               0.13304424285888672
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest makespan and lowest total distance, then applies a novel \"demand-balancing\" strategy that combines route merging and spatial-aware reinsertion to create a new solution. It first identifies the most imbalanced route (based on demand deviation from the average) and merges it with another route that has complementary demand patterns, then strategically reinserts customers from the merged route back into the solution using a spatial-aware heuristic that prioritizes angular alignment and distance minimization, while dynamically adjusting insertion points to balance the trade-off between total distance and makespan objectives. The algorithm ensures feasibility through strict capacity checks and uses a multi-criteria evaluation to select the best insertion positions, creating a diverse neighborhood that effectively explores the solution space while maintaining solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Calculate demand for each route\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    avg_demand = np.mean(route_demands)\n\n    # Find the most imbalanced route (farthest from average demand)\n    imbalanced_idx = max(range(len(new_solution)), key=lambda i: abs(route_demands[i] - avg_demand))\n    imbalanced_route = new_solution[imbalanced_idx]\n\n    # Find the route with complementary demand to balance\n    target_idx = min(range(len(new_solution)), key=lambda i: abs(route_demands[i] + route_demands[imbalanced_idx] - capacity))\n    target_route = new_solution[target_idx]\n\n    if imbalanced_idx == target_idx:\n        return new_solution\n\n    # Merge the two routes\n    merged_customers = np.concatenate([imbalanced_route[1:-1], target_route[1:-1]])\n    if np.sum(demand[merged_customers]) > capacity:\n        return new_solution\n\n    new_solution.pop(max(imbalanced_idx, target_idx))\n    new_solution.pop(min(imbalanced_idx, target_idx))\n\n    # Create a new route from merged customers\n    new_route = np.concatenate([[0], merged_customers, [0]])\n    new_solution.append(new_route)\n\n    # Reinsert customers back into solution with spatial-aware heuristic\n    while len(new_solution[-1]) > 3:\n        last_route = new_solution[-1]\n        customers = last_route[1:-1]\n        depot_coords = coords[0]\n\n        # Find customer with most angular deviation from depot\n        customer_coords = coords[customers]\n        vectors = customer_coords - depot_coords\n        angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n        avg_angle = np.mean(angles)\n        angle_deviations = [min(abs(a - avg_angle), 2*np.pi - abs(a - avg_angle)) for a in angles]\n        worst_customer_idx = np.argmax(angle_deviations)\n        worst_customer = customers[worst_customer_idx]\n\n        best_insertion = None\n        best_score = float('inf')\n\n        # Try to insert into other routes\n        for i in range(len(new_solution) - 1):\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], [worst_customer], route[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                # Calculate insertion score (combination of distance and angular alignment)\n                prev_node = temp_route[pos-1]\n                next_node = temp_route[pos]\n                dist_change = (distance_matrix[prev_node][worst_customer] +\n                             distance_matrix[worst_customer][next_node] -\n                             distance_matrix[prev_node][next_node])\n\n                # Calculate angular alignment improvement\n                prev_angle = np.arctan2(coords[prev_node][1] - depot_coords[1],\n                                      coords[prev_node][0] - depot_coords[0])\n                next_angle = np.arctan2(coords[next_node][1] - depot_coords[1],\n                                      coords[next_node][0] - depot_coords[0])\n                customer_angle = np.arctan2(coords[worst_customer][1] - depot_coords[1],\n                                          coords[worst_customer][0] - depot_coords[0])\n\n                angle_diff_before = min(abs(next_angle - prev_angle), 2*np.pi - abs(next_angle - prev_angle))\n                angle_diff_after = (min(abs(customer_angle - prev_angle), 2*np.pi - abs(customer_angle - prev_angle)) +\n                                   min(abs(next_angle - customer_angle), 2*np.pi - abs(next_angle - customer_angle)))\n\n                angular_score = angle_diff_after - angle_diff_before\n\n                # Combine scores with weights\n                score = 0.7 * dist_change + 0.3 * angular_score\n\n                if score < best_score:\n                    best_score = score\n                    best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_solution[i] = np.concatenate([new_solution[i][:pos], [worst_customer], new_solution[i][pos:]])\n            new_solution[-1] = np.delete(new_solution[-1], worst_customer_idx + 1)\n        else:\n            break\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.8543399469418027,
               0.15176796913146973
          ]
     }
]