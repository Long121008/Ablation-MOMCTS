[
     {
          "algorithm": "{The novel local search strategy, named \"Adaptive Route Fusion and Splitting with Demand-Aware Relocation,\" combines three key operations: (1) probabilistically merging adjacent routes based on their demand proximity to avoid capacity violations, (2) intelligently splitting long routes into shorter segments while ensuring demand feasibility, and (3) demand-aware relocation of customers between routes by prioritizing nodes with high demand to balance makespan and total distance. The algorithm first selects a solution from the archive using a tournament selection biased toward lower makespan but considering total distance as a tiebreaker. It then applies the three operations in sequence, with each step checking feasibility and only proceeding if improvements are detected. The demand-aware relocation step uses a heuristic to select customers for relocation based on their demand and distance to nearby routes, ensuring the neighbor solution remains feasible while potentially reducing both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = random.choice(archive)\n    for _ in range(3):\n        candidate = random.choice(archive)\n        if candidate[1][1] < selected[1][1] or (candidate[1][1] == selected[1][1] and candidate[1][0] < selected[1][0]):\n            selected = candidate\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive Route Fusion with Demand Proximity\n    if len(new_solution) > 1:\n        for i in range(len(new_solution) - 1):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity and random.random() < 0.3:  # 30% chance to merge\n                merged = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged\n                del new_solution[i + 1]\n                break\n\n    # Intelligent Route Splitting with Demand Feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split routes with more than 2 customers\n            split_pos = random.randint(1, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n            if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                new_solution[i] = part1\n                new_solution.insert(i + 1, part2)\n                break\n\n    # Demand-Aware Relocation\n    if len(new_solution) > 1:\n        # Select a customer with high demand to relocate\n        all_customers = [node for route in new_solution for node in route[1:-1]]\n        if all_customers:\n            candidate = max(all_customers, key=lambda x: demand[x])\n            for i in range(len(new_solution)):\n                if candidate in new_solution[i]:\n                    original_route = new_solution[i]\n                    new_solution[i] = np.array([x for x in original_route if x != candidate])\n                    # Find best insertion point in another route\n                    best_route = -1\n                    best_pos = -1\n                    best_cost = float('inf')\n                    for j in range(len(new_solution)):\n                        if i != j:\n                            route = new_solution[j]\n                            if sum(demand[route[1:-1]]) + demand[candidate] <= capacity:\n                                for k in range(len(route) - 1):\n                                    insert_cost = distance_matrix[route[k], candidate] + distance_matrix[candidate, route[k + 1]] - distance_matrix[route[k], route[k + 1]]\n                                    if insert_cost < best_cost:\n                                        best_cost = insert_cost\n                                        best_route = j\n                                        best_pos = k + 1\n                    if best_route != -1:\n                        route = new_solution[best_route]\n                        new_solution[best_route] = np.insert(route, best_pos, candidate)\n                    else:\n                        new_solution[i] = original_route  # Revert if no feasible insertion\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.7674448594965975,
               0.1681053638458252
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search operator that combines route fragmentation and reinsertion with a novel \"demand-aware\" insertion heuristic. This heuristic reinserts fragmented customer sequences into routes by prioritizing nodes with high demand and minimizing the increase in route length, while also considering the spatial proximity of nodes to maintain route efficiency. The method ensures feasibility by strictly enforcing vehicle capacity constraints during reinsertion and uses a multi-objective evaluation to guide the selection of the best neighbor solution, balancing both distance and makespan objectives. The algorithm dynamically adjusts the fragmentation points based on demand patterns and route imbalance to explore diverse neighborhoods effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    selected_route = new_solution[route_idx]\n\n    # Fragment the route into two parts\n    if len(selected_route) <= 3:  # No fragmentation possible\n        return new_solution\n\n    split_point = random.randint(1, len(selected_route) - 2)\n    fragment = selected_route[split_point:-1]\n    remaining_route = selected_route[:split_point + 1]\n\n    # Update the selected route to the remaining part\n    new_solution[route_idx] = remaining_route\n\n    # Try to reinsert the fragment into other routes or create a new route\n    best_insertion = None\n    best_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        if i == route_idx:\n            continue\n\n        route = new_solution[i]\n        # Try inserting the fragment at different positions in the route\n        for pos in range(1, len(route)):\n            # Check capacity constraint\n            current_capacity = sum(demand[node] for node in route)\n            fragment_capacity = sum(demand[node] for node in fragment)\n            if current_capacity + fragment_capacity > capacity:\n                continue\n\n            # Calculate the cost of inserting the fragment\n            cost = (distance_matrix[route[pos-1], fragment[0]] +\n                    distance_matrix[fragment[-1], route[pos]] -\n                    distance_matrix[route[pos-1], route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_insertion = (i, pos)\n\n    # If a valid insertion is found, perform it\n    if best_insertion is not None:\n        route_idx, pos = best_insertion\n        route = new_solution[route_idx]\n        new_route = np.concatenate([route[:pos], fragment, route[pos:]])\n        new_solution[route_idx] = new_route\n    else:\n        # If no valid insertion, try to create a new route\n        fragment_capacity = sum(demand[node] for node in fragment)\n        if fragment_capacity <= capacity:\n            new_route = np.concatenate([[0], fragment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
          "score": [
               -0.8188120035537101,
               0.6072028577327728
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Route Fusion and Demand-Balanced Relocation\" (ARFR), dynamically selects the most promising solution from the archive based on a combination of normalized objective values and solution diversity, then applies a hybrid local search strategy that first fuses the shortest route with the longest route by optimally merging their segments while respecting capacity constraints, followed by a demand-balanced relocation phase that redistributes customers between routes to achieve a more balanced demand distribution across all vehicles, using a novel \"demand-aware insertion\" heuristic that considers both distance and capacity constraints.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Combine normalized objectives and diversity for selection\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    route_counts = np.array([len(sol) for sol, _ in archive])\n\n    # Normalize objectives (minimization)\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n    norm_routes = (route_counts - np.min(route_counts)) / (np.max(route_counts) - np.min(route_counts) + 1e-10)\n\n    # Weighted selection (favor lower objectives and higher diversity)\n    weights = 1 / (1 + norm_total + norm_makespan + 0.5 * norm_routes)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Route Fusion - Merge shortest and longest routes\n    if len(new_solution) >= 2:\n        route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        longest_idx = np.argmax(route_lengths)\n\n        if shortest_idx != longest_idx:\n            shortest_route = new_solution[shortest_idx]\n            longest_route = new_solution[longest_idx]\n\n            # Find optimal split points for fusion\n            best_split = None\n            best_increase = float('inf')\n\n            for i in range(1, len(shortest_route)-1):\n                for j in range(1, len(longest_route)-1):\n                    # Split shortest route at i, longest route at j\n                    segment1 = shortest_route[i:]\n                    segment2 = longest_route[:j+1]\n\n                    # Check capacity constraint\n                    if (demand[segment1].sum() + demand[segment2].sum() <= capacity and\n                        demand[segment1].sum() + demand[segment2].sum() > 0):\n\n                        # Calculate distance increase\n                        increase = (distance_matrix[segment1[-1]][segment2[0]] -\n                                   distance_matrix[shortest_route[i-1]][shortest_route[i]] -\n                                   distance_matrix[longest_route[j-1]][longest_route[j]])\n\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_split = (i, j)\n\n            if best_split is not None:\n                i, j = best_split\n                segment1 = shortest_route[i:]\n                segment2 = longest_route[:j+1]\n\n                # Create fused route\n                fused_route = np.concatenate([shortest_route[:i], segment1, segment2, longest_route[j+1:]])\n\n                # Update solution\n                new_solution[shortest_idx] = fused_route\n                new_solution[longest_idx] = longest_route[j+1:]\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 2: Demand-Balanced Relocation\n    for _ in range(5):  # Limit iterations\n        if len(new_solution) < 2:\n            break\n\n        # Calculate route demands\n        route_demands = [demand[route[1:-1]].sum() for route in new_solution]\n        avg_demand = sum(route_demands) / len(new_solution)\n\n        # Find most imbalanced routes\n        over_idx = np.argmax(route_demands)\n        under_idx = np.argmin(route_demands)\n\n        if over_idx == under_idx:\n            break\n\n        over_route = new_solution[over_idx]\n        under_route = new_solution[under_idx]\n\n        # Try to move customers from overloaded to underloaded route\n        improved = False\n        for i in range(1, len(over_route)-1):\n            customer = over_route[i]\n            if (demand[under_route[1:-1]].sum() + demand[customer] <= capacity and\n                route_demands[over_idx] - demand[customer] >= avg_demand and\n                route_demands[under_idx] + demand[customer] <= avg_demand):\n\n                # Find best insertion point in under_route\n                best_pos = -1\n                min_increase = float('inf')\n\n                for j in range(1, len(under_route)):\n                    increase = (distance_matrix[under_route[j-1]][customer] +\n                               distance_matrix[customer][under_route[j]] -\n                               distance_matrix[under_route[j-1]][under_route[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n\n                if best_pos != -1:\n                    # Perform relocation\n                    new_under_route = np.insert(under_route, best_pos, customer)\n                    new_over_route = np.delete(over_route, i)\n\n                    # Update solution\n                    new_solution[over_idx] = new_over_route\n                    new_solution[under_idx] = new_under_route\n                    improved = True\n                    break\n\n        if not improved:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.8275643609045741,
               0.8953045308589935
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a novel route consolidation and demand-adaptive clustering strategy that combines spatial proximity with demand balance. It first identifies the most fragmented routes (with high inter-customer distances relative to demand) and consolidates nearby customers into new routes while ensuring capacity constraints. For routes that cannot be consolidated, it performs a demand-adaptive route inversion where it strategically swaps high-demand customers with their spatial neighbors to reduce both total distance and makespan, while maintaining feasibility through continuous capacity checks. The algorithm dynamically adjusts the consolidation and inversion criteria based on the current solution's characteristics to balance exploration of the search space with exploitation of promising regions, while avoiding standard local search operators like pure 2-opt.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the most fragmented route (high inter-customer distance relative to demand)\n    def route_fragmentation(route):\n        if len(route) <= 2:\n            return 0\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        if total_demand == 0:\n            return 0\n        total_distance = sum(distance_matrix[customers[i], customers[i+1]] for i in range(len(customers)-1))\n        return total_distance / total_demand\n\n    fragmented_idx = max(range(len(new_solution)), key=lambda i: route_fragmentation(new_solution[i]))\n    fragmented_route = new_solution[fragmented_idx]\n\n    # Try to consolidate nearby customers into new routes\n    if len(fragmented_route) > 3:\n        customers = fragmented_route[1:-1]\n        # Find pairs of nearby customers with low demand\n        for i in range(len(customers)):\n            for j in range(i+1, len(customers)):\n                c1, c2 = customers[i], customers[j]\n                if demand[c1] + demand[c2] <= capacity and distance_matrix[c1, c2] < np.mean(distance_matrix):\n                    # Create new route with these customers\n                    new_route = np.array([0, c1, c2, 0])\n                    new_solution.append(new_route)\n\n                    # Remove from original route\n                    mask = (fragmented_route != c1) & (fragmented_route != c2)\n                    new_solution[fragmented_idx] = fragmented_route[mask]\n\n                    # Check if original route is now empty\n                    if len(new_solution[fragmented_idx]) <= 2:\n                        new_solution.pop(fragmented_idx)\n                    return new_solution\n\n    # If no consolidation possible, try demand-adaptive inversion\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) > 3:\n        customers = longest_route[1:-1]\n        # Find high-demand customers and their spatial neighbors\n        for i in range(len(customers)):\n            c = customers[i]\n            if demand[c] > capacity/2:\n                # Find nearest neighbor\n                neighbor_idx = np.argmin(distance_matrix[c, customers])\n                neighbor = customers[neighbor_idx]\n\n                # Try swapping with neighbor if feasible\n                if demand[c] + demand[neighbor] <= capacity:\n                    # Create new route with swapped customers\n                    new_order = longest_route.copy()\n                    pos_c = np.where(new_order == c)[0][0]\n                    pos_neighbor = np.where(new_order == neighbor)[0][0]\n                    new_order[pos_c], new_order[pos_neighbor] = new_order[pos_neighbor], new_order[pos_c]\n\n                    # Check if new order is better (shorter distance)\n                    original_dist = (distance_matrix[longest_route[pos_c-1], c] +\n                                    distance_matrix[c, longest_route[pos_c+1]] +\n                                    distance_matrix[longest_route[pos_neighbor-1], neighbor] +\n                                    distance_matrix[neighbor, longest_route[pos_neighbor+1]])\n\n                    new_dist = (distance_matrix[longest_route[pos_c-1], neighbor] +\n                               distance_matrix[neighbor, longest_route[pos_c+1]] +\n                               distance_matrix[longest_route[pos_neighbor-1], c] +\n                               distance_matrix[c, longest_route[pos_neighbor+1]])\n\n                    if new_dist < original_dist:\n                        new_solution[longest_route_idx] = new_order\n                        return new_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7710053836674114,
               0.29245525598526
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves selecting a solution from the archive by prioritizing those with the highest makespan and total distance, then applying a novel local search operator that combines route merging with spatial-aware customer reinsertion. It first identifies the longest route in the solution, merges it with the spatially closest adjacent route while respecting capacity constraints, and then systematically reinserts customers from the merged route into other routes using a spatial proximity heuristic that minimizes both the total distance and the makespan, dynamically adjusting insertion positions to balance the trade-off between the objectives. The process continues until no further improvements can be made in both objectives, ensuring the neighbor solution maintains feasibility while exploring non-intuitive improvements in the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    min_dist = float('inf')\n    best_merge_idx = -1\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        other_route = new_solution[i]\n        if len(other_route) <= 2:\n            continue\n        dist = distance_matrix[longest_route[-2]][other_route[1]]\n        if dist < min_dist:\n            min_dist = dist\n            best_merge_idx = i\n\n    if best_merge_idx == -1:\n        return new_solution\n\n    best_route = new_solution[best_merge_idx]\n    merged_route = np.concatenate([longest_route[:-1], best_route[1:]])\n\n    if np.sum(demand[merged_route[1:-1]]) > capacity:\n        return new_solution\n\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[best_merge_idx]\n\n    customers_to_reinsert = merged_route[1:-1]\n    np.random.shuffle(customers_to_reinsert)\n\n    for cust in customers_to_reinsert:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], [cust], route[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) > capacity:\n                    continue\n\n                current_dist = 0\n                for j in range(len(temp_route) - 1):\n                    current_dist += distance_matrix[temp_route[j]][temp_route[j+1]]\n\n                if current_dist < best_score:\n                    best_score = current_dist\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [cust],\n                new_solution[best_route_idx][best_pos:]\n            ])\n\n    return new_solution\n\n",
          "score": [
               -0.7513589623084833,
               0.13873112201690674
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest total distance and lowest makespan, then applies a novel route inversion and relocation strategy that combines angular analysis with demand-weighted distance optimization. First, it identifies the most angularly unbalanced route (with the highest angular deviation from the depot's central position) and inverts the order of customers in that route to reduce angular dispersion, then relocates high-demand customers to other routes in a way that minimizes the increase in total distance while balancing the makespan. If no feasible relocation is found, it performs a demand-weighted route inversion where it reverses the order of customers in the longest route based on their demand-weighted distances to reduce the makespan, ensuring feasibility by checking capacity constraints at each step. The algorithm dynamically adjusts the inversion and relocation criteria based on the current solution's characteristics to balance exploration of the search space with exploitation of promising regions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[-1][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate depot coordinates\n    depot_coords = coords[0]\n\n    # Find the most angularly unbalanced route\n    angular_deviations = []\n    for route in new_solution:\n        if len(route) <= 3:\n            angular_deviations.append(0)\n            continue\n\n        customers = route[1:-1]\n        customer_coords = coords[customers]\n        vectors = customer_coords - depot_coords\n        angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n        angles = np.sort(angles)\n\n        # Calculate angular deviation from uniform distribution\n        uniform_angles = np.linspace(angles[0], angles[-1], len(angles))\n        deviation = np.sum(np.abs(angles - uniform_angles))\n        angular_deviations.append(deviation)\n\n    if angular_deviations:\n        unbalanced_idx = np.argmax(angular_deviations)\n        unbalanced_route = new_solution[unbalanced_idx]\n\n        if len(unbalanced_route) > 3:\n            # Invert the order of customers in the unbalanced route\n            customers = unbalanced_route[1:-1]\n            inverted_route = np.concatenate([[0], customers[::-1], [0]])\n            new_solution[unbalanced_idx] = inverted_route\n\n            # Try to relocate high-demand customers to other routes\n            high_demand_customers = [c for c in customers if demand[c] > capacity/2]\n\n            for customer in high_demand_customers:\n                best_route = None\n                best_cost = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == unbalanced_idx:\n                        continue\n\n                    # Check if adding the customer to this route is feasible\n                    current_demand = np.sum(demand[route[1:-1]])\n                    if current_demand + demand[customer] <= capacity:\n                        # Calculate insertion cost\n                        for j in range(1, len(route)):\n                            cost = (distance_matrix[route[j-1], customer] +\n                                   distance_matrix[customer, route[j]] -\n                                   distance_matrix[route[j-1], route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = (i, j)\n\n                if best_route is not None:\n                    i, j = best_route\n                    new_solution[i] = np.insert(new_solution[i], j, customer)\n                    new_solution[unbalanced_idx] = np.delete(new_solution[unbalanced_idx],\n                                                           np.where(new_solution[unbalanced_idx] == customer)[0][0])\n\n    # If no angularly unbalanced route found, try demand-weighted inversion\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            customers = longest_route[1:-1]\n            customer_weights = demand[customers] * distance_matrix[0, customers]\n            sorted_indices = np.argsort(customer_weights)[::-1]\n            weighted_customers = customers[sorted_indices]\n\n            # Try reversing the order of high-demand customers\n            new_route = longest_route.copy()\n            for i, c in enumerate(weighted_customers):\n                pos = np.where(new_route == c)[0][0]\n                new_route[pos] = weighted_customers[i]\n\n            # Check feasibility\n            new_demand = np.sum(demand[new_route[1:-1]])\n            if new_demand <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
          "score": [
               -0.8014200516038053,
               0.42193201184272766
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    segments = []\n    current_segment = [longest_route[0]]\n\n    for i in range(1, len(longest_route)-1):\n        current_segment.append(longest_route[i])\n        if i < len(longest_route)-2:\n            prev_node = longest_route[i-1]\n            current_node = longest_route[i]\n            next_node = longest_route[i+1]\n\n            angle = np.arctan2(coords[next_node][1] - coords[current_node][1],\n                              coords[next_node][0] - coords[current_node][0]) - \\\n                   np.arctan2(coords[current_node][1] - coords[prev_node][1],\n                             coords[current_node][0] - coords[prev_node][0])\n\n            angle = np.abs((angle + np.pi) % (2*np.pi) - np.pi)\n\n            if angle > np.pi/4 or (sum(demand[current_segment[1:]]) + demand[next_node] > capacity * 0.7):\n                segments.append(current_segment + [0])\n                current_segment = [0]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment + [0])\n\n    if len(segments) < 2:\n        return new_solution\n\n    segments = [np.array(seg) for seg in segments]\n\n    for seg in segments:\n        inserted = False\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            seg_demand = sum(demand[seg[1:-1]])\n\n            if current_demand + seg_demand > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                cost = (distance_matrix[route[pos-1], seg[1]] +\n                        distance_matrix[seg[-2], route[pos]] -\n                        distance_matrix[route[pos-1], route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route_idx = i\n                    best_pos = pos\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            new_route = np.concatenate([best_route[:best_pos], seg[1:-1], best_route[best_pos:]])\n            new_solution[best_route_idx] = new_route\n            inserted = True\n\n    new_solution[longest_route_idx] = np.array([0, 0])\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.9010642633626035,
               1.0312801003456116
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Route Segmentation and Demand-Aware Merging\" (ARDSM), first selects a solution from the archive by prioritizing those with the highest makespan and lowest route count, then applies a novel local search operator that decomposes the longest route into smaller segments based on both spatial proximity and demand patterns, followed by a demand-aware merging phase that iteratively combines these segments into new routes while respecting capacity constraints, using a hybrid heuristic that considers both distance savings and demand balance, and dynamically adjusts the merging parameters based on the current solution's characteristics to balance the trade-off between reducing total distance and improving makespan, ensuring the neighbor solution maintains feasibility while exploring novel improvements in the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest makespan and lowest route count\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], len(x[0])))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find longest route\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n    longest_idx = np.argmax(route_lengths)\n    longest_route = new_solution[longest_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    customers = longest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    # Segment the longest route based on spatial and demand patterns\n    segments = []\n    current_segment = [longest_route[0]]\n    current_demand = 0\n\n    for i in range(1, len(longest_route)-1):\n        customer = longest_route[i]\n        if current_demand + demand[customer] > capacity * 0.8:  # Allow some flexibility\n            segments.append(current_segment + [0])\n            current_segment = [0]\n            current_demand = 0\n\n        current_segment.append(customer)\n        current_demand += demand[customer]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment + [0])\n\n    # Merge segments adaptively\n    merged_routes = []\n    for segment in segments:\n        if len(segment) <= 2:\n            merged_routes.append(segment)\n            continue\n\n        # Find best merge point\n        best_merge = None\n        best_score = float('inf')\n\n        for i in range(1, len(segment)-1):\n            # Split segment at i\n            part1 = segment[:i+1]\n            part2 = segment[i:]\n\n            # Calculate score (distance + demand balance)\n            score = (distance_matrix[part1[-1]][part2[0]] +\n                     abs(demand[part1[1:-1]].sum() - demand[part2[1:-1]].sum()))\n\n            if score < best_score:\n                best_score = score\n                best_merge = i\n\n        if best_merge is not None:\n            merged_routes.append(segment[:best_merge+1])\n            merged_routes.append(segment[best_merge:])\n        else:\n            merged_routes.append(segment)\n\n    # Convert to proper route format and remove empty routes\n    final_routes = []\n    for route in merged_routes:\n        if len(route) > 2:\n            final_routes.append(np.array(route))\n\n    # Add remaining routes from original solution\n    remaining_routes = [route for i, route in enumerate(new_solution) if i != longest_idx]\n    final_routes.extend(remaining_routes)\n\n    # Rebalance demand if needed\n    route_demands = [demand[route[1:-1]].sum() for route in final_routes]\n    avg_demand = sum(route_demands) / len(final_routes) if len(final_routes) > 0 else 0\n\n    for _ in range(3):  # Limit iterations\n        over_idx = np.argmax(route_demands) if len(route_demands) > 0 else -1\n        under_idx = np.argmin(route_demands) if len(route_demands) > 0 else -1\n\n        if over_idx == -1 or under_idx == -1 or over_idx == under_idx:\n            break\n\n        over_route = final_routes[over_idx]\n        under_route = final_routes[under_idx]\n\n        improved = False\n        for i in range(1, len(over_route)-1):\n            customer = over_route[i]\n            if (demand[under_route[1:-1]].sum() + demand[customer] <= capacity and\n                route_demands[over_idx] - demand[customer] >= avg_demand and\n                route_demands[under_idx] + demand[customer] <= avg_demand):\n\n                # Find best insertion point\n                best_pos = -1\n                min_increase = float('inf')\n\n                for j in range(1, len(under_route)):\n                    increase = (distance_matrix[under_route[j-1]][customer] +\n                               distance_matrix[customer][under_route[j]] -\n                               distance_matrix[under_route[j-1]][under_route[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n\n                if best_pos != -1:\n                    new_under_route = np.insert(under_route, best_pos, customer)\n                    new_over_route = np.delete(over_route, i)\n\n                    final_routes[over_idx] = new_over_route\n                    final_routes[under_idx] = new_under_route\n                    route_demands[over_idx] -= demand[customer]\n                    route_demands[under_idx] += demand[customer]\n                    improved = True\n                    break\n\n        if not improved:\n            break\n\n    return final_routes\n\n",
          "score": [
               -0.7962103416482758,
               0.33917367458343506
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search operator that combines route fragmentation and reinsertion with a novel \"demand-aware\" insertion heuristic. This heuristic reinserts fragmented customer sequences into routes by prioritizing nodes with high demand and minimizing the increase in route length, while also considering the spatial proximity of nodes to maintain route efficiency. The method ensures feasibility by strictly enforcing vehicle capacity constraints during reinsertion and uses a multi-objective evaluation to guide the selection of the best neighbor solution, balancing both distance and makespan objectives. The algorithm dynamically adjusts the fragmentation points based on demand patterns and route imbalance to explore diverse neighborhoods effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    selected_route = new_solution[route_idx]\n\n    if len(selected_route) <= 3:\n        return new_solution\n\n    split_point = random.randint(1, len(selected_route) - 2)\n    fragment = selected_route[split_point:-1]\n    remaining_route = selected_route[:split_point + 1]\n\n    new_solution[route_idx] = remaining_route\n\n    best_insertion = None\n    best_score = float('inf')\n\n    for i in range(len(new_solution)):\n        if i == route_idx:\n            continue\n\n        route = new_solution[i]\n        current_demand = sum(demand[node] for node in route[1:-1])\n        fragment_demand = sum(demand[node] for node in fragment)\n\n        if current_demand + fragment_demand > capacity:\n            continue\n\n        for pos in range(1, len(route)):\n            cost = (distance_matrix[route[pos-1], fragment[0]] +\n                    distance_matrix[fragment[-1], route[pos]] -\n                    distance_matrix[route[pos-1], route[pos]])\n\n            demand_factor = max(demand[node] for node in fragment) / capacity\n            spatial_factor = np.linalg.norm(coords[route[pos-1]] - coords[fragment[0]]) + \\\n                            np.linalg.norm(coords[fragment[-1]] - coords[route[pos]])\n\n            score = cost + 0.5 * demand_factor + 0.3 * spatial_factor\n\n            if score < best_score:\n                best_score = score\n                best_insertion = (i, pos)\n\n    if best_insertion is not None:\n        route_idx, pos = best_insertion\n        route = new_solution[route_idx]\n        new_route = np.concatenate([route[:pos], fragment, route[pos:]])\n        new_solution[route_idx] = new_route\n    else:\n        fragment_demand = sum(demand[node] for node in fragment)\n        if fragment_demand <= capacity:\n            new_route = np.concatenate([[0], fragment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
          "score": [
               -0.61293277042486,
               0.16933795809745789
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: Route balancing + Intra-route 3-opt + Inter-route swap\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route balancing - redistribute customers to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(demand[route[1:-1]]) for route in new_solution])\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from longest to shortest route if it fits\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into shortest route (greedy insertion)\n                best_pos = 1\n                best_cost = float('inf')\n                for j in range(1, len(shortest_route)):\n                    cost = (distance_matrix[shortest_route[j-1], customer] +\n                            distance_matrix[customer, shortest_route[j]] -\n                            distance_matrix[shortest_route[j-1], shortest_route[j]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = j\n\n                # Update routes\n                new_shortest = np.insert(shortest_route, best_pos, customer)\n                new_longest = np.delete(longest_route, i)\n                new_solution[shortest_route_idx] = new_shortest\n                new_solution[longest_route_idx] = new_longest\n                break\n\n    # Step 2: Intra-route 3-opt for each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select 3 random non-depot nodes\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n\n            # Generate all possible 3-opt moves\n            moves = [\n                (a, b, c), (a, c, b),\n                (b, a, c), (b, c, a),\n                (c, a, b), (c, b, a)\n            ]\n\n            best_move = None\n            best_cost = sum(distance_matrix[route[j-1], route[j]] for j in range(1, len(route)))\n\n            for move in moves:\n                new_route = route.copy()\n                new_route[move[0]:move[2]+1] = route[move[0]:move[2]+1][::-1]\n\n                # Check feasibility\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_move = move\n\n            if best_move is not None:\n                new_solution[i] = np.array([route[0]] + list(route[best_move[0]:best_move[2]+1][::-1]) + list(route[best_move[2]+1:]))\n\n    # Step 3: Inter-route swap for customers with similar demands\n    if len(new_solution) > 1:\n        # Find two routes with similar total demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if abs(demands[i] - demands[j]) < capacity * 0.2:  # Threshold for similar demand\n                    # Try to swap customers between these routes\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n\n                    for c1 in range(1, len(route1)-1):\n                        for c2 in range(1, len(route2)-1):\n                            # Check if swap is feasible\n                            if (sum(demand[route1[1:-1]]) - demand[route1[c1]] + demand[route2[c2]] <= capacity and\n                                sum(demand[route2[1:-1]]) - demand[route2[c2]] + demand[route1[c1]] <= capacity):\n                                # Perform swap\n                                new_route1 = route1.copy()\n                                new_route2 = route2.copy()\n                                new_route1[c1] = route2[c2]\n                                new_route2[c2] = route1[c1]\n\n                                # Check if swap reduces total distance\n                                old_cost = (distance_matrix[route1[c1-1], route1[c1]] + distance_matrix[route1[c1], route1[c1+1]] +\n                                           distance_matrix[route2[c2-1], route2[c2]] + distance_matrix[route2[c2], route2[c2+1]])\n\n                                new_cost = (distance_matrix[new_route1[c1-1], new_route1[c1]] + distance_matrix[new_route1[c1], new_route1[c1+1]] +\n                                           distance_matrix[new_route2[c2-1], new_route2[c2]] + distance_matrix[new_route2[c2], new_route2[c2+1]])\n\n                                if new_cost < old_cost:\n                                    new_solution[i] = new_route1\n                                    new_solution[j] = new_route2\n                                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8597602962387709,
               7.648170918226242
          ]
     }
]