[
     {
          "algorithm": "{The novel local search strategy, named \"Adaptive Route Fusion and Splitting with Demand-Aware Relocation,\" combines three key operations: (1) probabilistically merging adjacent routes based on their demand proximity to avoid capacity violations, (2) intelligently splitting long routes into shorter segments while ensuring demand feasibility, and (3) demand-aware relocation of customers between routes by prioritizing nodes with high demand to balance makespan and total distance. The algorithm first selects a solution from the archive using a tournament selection biased toward lower makespan but considering total distance as a tiebreaker. It then applies the three operations in sequence, with each step checking feasibility and only proceeding if improvements are detected. The demand-aware relocation step uses a heuristic to select customers for relocation based on their demand and distance to nearby routes, ensuring the neighbor solution remains feasible while potentially reducing both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = random.choice(archive)\n    for _ in range(3):\n        candidate = random.choice(archive)\n        if candidate[1][1] < selected[1][1] or (candidate[1][1] == selected[1][1] and candidate[1][0] < selected[1][0]):\n            selected = candidate\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive Route Fusion with Demand Proximity\n    if len(new_solution) > 1:\n        for i in range(len(new_solution) - 1):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity and random.random() < 0.3:  # 30% chance to merge\n                merged = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged\n                del new_solution[i + 1]\n                break\n\n    # Intelligent Route Splitting with Demand Feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split routes with more than 2 customers\n            split_pos = random.randint(1, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n            if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                new_solution[i] = part1\n                new_solution.insert(i + 1, part2)\n                break\n\n    # Demand-Aware Relocation\n    if len(new_solution) > 1:\n        # Select a customer with high demand to relocate\n        all_customers = [node for route in new_solution for node in route[1:-1]]\n        if all_customers:\n            candidate = max(all_customers, key=lambda x: demand[x])\n            for i in range(len(new_solution)):\n                if candidate in new_solution[i]:\n                    original_route = new_solution[i]\n                    new_solution[i] = np.array([x for x in original_route if x != candidate])\n                    # Find best insertion point in another route\n                    best_route = -1\n                    best_pos = -1\n                    best_cost = float('inf')\n                    for j in range(len(new_solution)):\n                        if i != j:\n                            route = new_solution[j]\n                            if sum(demand[route[1:-1]]) + demand[candidate] <= capacity:\n                                for k in range(len(route) - 1):\n                                    insert_cost = distance_matrix[route[k], candidate] + distance_matrix[candidate, route[k + 1]] - distance_matrix[route[k], route[k + 1]]\n                                    if insert_cost < best_cost:\n                                        best_cost = insert_cost\n                                        best_route = j\n                                        best_pos = k + 1\n                    if best_route != -1:\n                        route = new_solution[best_route]\n                        new_solution[best_route] = np.insert(route, best_pos, candidate)\n                    else:\n                        new_solution[i] = original_route  # Revert if no feasible insertion\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.7674448594965975,
               0.1681053638458252
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search operator that combines route fragmentation and reinsertion with a novel \"demand-aware\" insertion heuristic. This heuristic reinserts fragmented customer sequences into routes by prioritizing nodes with high demand and minimizing the increase in route length, while also considering the spatial proximity of nodes to maintain route efficiency. The method ensures feasibility by strictly enforcing vehicle capacity constraints during reinsertion and uses a multi-objective evaluation to guide the selection of the best neighbor solution, balancing both distance and makespan objectives. The algorithm dynamically adjusts the fragmentation points based on demand patterns and route imbalance to explore diverse neighborhoods effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    selected_route = new_solution[route_idx]\n\n    # Fragment the route into two parts\n    if len(selected_route) <= 3:  # No fragmentation possible\n        return new_solution\n\n    split_point = random.randint(1, len(selected_route) - 2)\n    fragment = selected_route[split_point:-1]\n    remaining_route = selected_route[:split_point + 1]\n\n    # Update the selected route to the remaining part\n    new_solution[route_idx] = remaining_route\n\n    # Try to reinsert the fragment into other routes or create a new route\n    best_insertion = None\n    best_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        if i == route_idx:\n            continue\n\n        route = new_solution[i]\n        # Try inserting the fragment at different positions in the route\n        for pos in range(1, len(route)):\n            # Check capacity constraint\n            current_capacity = sum(demand[node] for node in route)\n            fragment_capacity = sum(demand[node] for node in fragment)\n            if current_capacity + fragment_capacity > capacity:\n                continue\n\n            # Calculate the cost of inserting the fragment\n            cost = (distance_matrix[route[pos-1], fragment[0]] +\n                    distance_matrix[fragment[-1], route[pos]] -\n                    distance_matrix[route[pos-1], route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_insertion = (i, pos)\n\n    # If a valid insertion is found, perform it\n    if best_insertion is not None:\n        route_idx, pos = best_insertion\n        route = new_solution[route_idx]\n        new_route = np.concatenate([route[:pos], fragment, route[pos:]])\n        new_solution[route_idx] = new_route\n    else:\n        # If no valid insertion, try to create a new route\n        fragment_capacity = sum(demand[node] for node in fragment)\n        if fragment_capacity <= capacity:\n            new_route = np.concatenate([[0], fragment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
          "score": [
               -0.8188120035537101,
               0.6072028577327728
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: Route balancing + Intra-route 3-opt + Inter-route swap\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route balancing - redistribute customers to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(demand[route[1:-1]]) for route in new_solution])\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from longest to shortest route if it fits\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into shortest route (greedy insertion)\n                best_pos = 1\n                best_cost = float('inf')\n                for j in range(1, len(shortest_route)):\n                    cost = (distance_matrix[shortest_route[j-1], customer] +\n                            distance_matrix[customer, shortest_route[j]] -\n                            distance_matrix[shortest_route[j-1], shortest_route[j]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = j\n\n                # Update routes\n                new_shortest = np.insert(shortest_route, best_pos, customer)\n                new_longest = np.delete(longest_route, i)\n                new_solution[shortest_route_idx] = new_shortest\n                new_solution[longest_route_idx] = new_longest\n                break\n\n    # Step 2: Intra-route 3-opt for each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select 3 random non-depot nodes\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n\n            # Generate all possible 3-opt moves\n            moves = [\n                (a, b, c), (a, c, b),\n                (b, a, c), (b, c, a),\n                (c, a, b), (c, b, a)\n            ]\n\n            best_move = None\n            best_cost = sum(distance_matrix[route[j-1], route[j]] for j in range(1, len(route)))\n\n            for move in moves:\n                new_route = route.copy()\n                new_route[move[0]:move[2]+1] = route[move[0]:move[2]+1][::-1]\n\n                # Check feasibility\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_move = move\n\n            if best_move is not None:\n                new_solution[i] = np.array([route[0]] + list(route[best_move[0]:best_move[2]+1][::-1]) + list(route[best_move[2]+1:]))\n\n    # Step 3: Inter-route swap for customers with similar demands\n    if len(new_solution) > 1:\n        # Find two routes with similar total demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if abs(demands[i] - demands[j]) < capacity * 0.2:  # Threshold for similar demand\n                    # Try to swap customers between these routes\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n\n                    for c1 in range(1, len(route1)-1):\n                        for c2 in range(1, len(route2)-1):\n                            # Check if swap is feasible\n                            if (sum(demand[route1[1:-1]]) - demand[route1[c1]] + demand[route2[c2]] <= capacity and\n                                sum(demand[route2[1:-1]]) - demand[route2[c2]] + demand[route1[c1]] <= capacity):\n                                # Perform swap\n                                new_route1 = route1.copy()\n                                new_route2 = route2.copy()\n                                new_route1[c1] = route2[c2]\n                                new_route2[c2] = route1[c1]\n\n                                # Check if swap reduces total distance\n                                old_cost = (distance_matrix[route1[c1-1], route1[c1]] + distance_matrix[route1[c1], route1[c1+1]] +\n                                           distance_matrix[route2[c2-1], route2[c2]] + distance_matrix[route2[c2], route2[c2+1]])\n\n                                new_cost = (distance_matrix[new_route1[c1-1], new_route1[c1]] + distance_matrix[new_route1[c1], new_route1[c1+1]] +\n                                           distance_matrix[new_route2[c2-1], new_route2[c2]] + distance_matrix[new_route2[c2], new_route2[c2+1]])\n\n                                if new_cost < old_cost:\n                                    new_solution[i] = new_route1\n                                    new_solution[j] = new_route2\n                                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8597602962387709,
               7.648170918226242
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive by prioritizing those with the highest total distance and makespan, then applies a novel local search operator that combines route decomposition with adaptive customer clustering. It first identifies the shortest route in the solution, decomposes it into smaller segments based on spatial proximity and demand patterns, then reclusters these segments into new routes by iteratively merging adjacent segments while respecting capacity constraints. The algorithm dynamically adjusts the clustering parameters based on the current solution's characteristics to balance the trade-off between reducing total distance and balancing the makespan, using a greedy heuristic that prioritizes segments with high spatial coherence and demand compatibility. The process continues until no further improvements can be made in both objectives, ensuring the neighbor solution maintains feasibility while exploring less obvious improvements in the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:\n        return new_solution\n\n    customers = shortest_route[1:-1]\n    if len(customers) == 0:\n        return new_solution\n\n    centroids = []\n    clusters = []\n\n    for i in range(len(customers)):\n        for j in range(i+1, len(customers)):\n            centroid = (coords[customers[i]] + coords[customers[j]]) / 2\n            cluster = [customers[i], customers[j]]\n            centroids.append(centroid)\n            clusters.append(cluster)\n\n    for _ in range(len(customers) - 2):\n        if len(centroids) < 2:\n            break\n\n        min_dist = float('inf')\n        best_pair = None\n\n        for i in range(len(centroids)):\n            for j in range(i+1, len(centroids)):\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is None:\n            break\n\n        i, j = best_pair\n        new_cluster = clusters[i] + clusters[j]\n        new_centroid = np.mean(coords[new_cluster], axis=0)\n\n        del centroids[j]\n        del clusters[j]\n        del centroids[i]\n        del clusters[i]\n\n        centroids.append(new_centroid)\n        clusters.append(new_cluster)\n\n    new_routes = []\n    for cluster in clusters:\n        route = [0] + cluster + [0]\n        if np.sum(demand[cluster]) <= capacity:\n            new_routes.append(np.array(route))\n\n    remaining_customers = [c for c in customers if c not in [cust for cluster in clusters for cust in cluster]]\n    for cust in remaining_customers:\n        inserted = False\n        for i, route in enumerate(new_routes):\n            for pos in range(1, len(route)):\n                temp_route = np.concatenate([route[:pos], [cust], route[pos:]])\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_routes[i] = temp_route\n                    inserted = True\n                    break\n            if inserted:\n                break\n        if not inserted:\n            new_routes.append(np.array([0, cust, 0]))\n\n    new_solution = new_routes + [route for i, route in enumerate(new_solution) if i != shortest_route_idx]\n\n    return new_solution\n\n",
          "score": [
               -0.8286582073104642,
               1.1680307388305664
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Route Fusion and Demand-Balanced Relocation\" (ARFR), dynamically selects the most promising solution from the archive based on a combination of normalized objective values and solution diversity, then applies a hybrid local search strategy that first fuses the shortest route with the longest route by optimally merging their segments while respecting capacity constraints, followed by a demand-balanced relocation phase that redistributes customers between routes to achieve a more balanced demand distribution across all vehicles, using a novel \"demand-aware insertion\" heuristic that considers both distance and capacity constraints.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Combine normalized objectives and diversity for selection\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    route_counts = np.array([len(sol) for sol, _ in archive])\n\n    # Normalize objectives (minimization)\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n    norm_routes = (route_counts - np.min(route_counts)) / (np.max(route_counts) - np.min(route_counts) + 1e-10)\n\n    # Weighted selection (favor lower objectives and higher diversity)\n    weights = 1 / (1 + norm_total + norm_makespan + 0.5 * norm_routes)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Route Fusion - Merge shortest and longest routes\n    if len(new_solution) >= 2:\n        route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        longest_idx = np.argmax(route_lengths)\n\n        if shortest_idx != longest_idx:\n            shortest_route = new_solution[shortest_idx]\n            longest_route = new_solution[longest_idx]\n\n            # Find optimal split points for fusion\n            best_split = None\n            best_increase = float('inf')\n\n            for i in range(1, len(shortest_route)-1):\n                for j in range(1, len(longest_route)-1):\n                    # Split shortest route at i, longest route at j\n                    segment1 = shortest_route[i:]\n                    segment2 = longest_route[:j+1]\n\n                    # Check capacity constraint\n                    if (demand[segment1].sum() + demand[segment2].sum() <= capacity and\n                        demand[segment1].sum() + demand[segment2].sum() > 0):\n\n                        # Calculate distance increase\n                        increase = (distance_matrix[segment1[-1]][segment2[0]] -\n                                   distance_matrix[shortest_route[i-1]][shortest_route[i]] -\n                                   distance_matrix[longest_route[j-1]][longest_route[j]])\n\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_split = (i, j)\n\n            if best_split is not None:\n                i, j = best_split\n                segment1 = shortest_route[i:]\n                segment2 = longest_route[:j+1]\n\n                # Create fused route\n                fused_route = np.concatenate([shortest_route[:i], segment1, segment2, longest_route[j+1:]])\n\n                # Update solution\n                new_solution[shortest_idx] = fused_route\n                new_solution[longest_idx] = longest_route[j+1:]\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 2: Demand-Balanced Relocation\n    for _ in range(5):  # Limit iterations\n        if len(new_solution) < 2:\n            break\n\n        # Calculate route demands\n        route_demands = [demand[route[1:-1]].sum() for route in new_solution]\n        avg_demand = sum(route_demands) / len(new_solution)\n\n        # Find most imbalanced routes\n        over_idx = np.argmax(route_demands)\n        under_idx = np.argmin(route_demands)\n\n        if over_idx == under_idx:\n            break\n\n        over_route = new_solution[over_idx]\n        under_route = new_solution[under_idx]\n\n        # Try to move customers from overloaded to underloaded route\n        improved = False\n        for i in range(1, len(over_route)-1):\n            customer = over_route[i]\n            if (demand[under_route[1:-1]].sum() + demand[customer] <= capacity and\n                route_demands[over_idx] - demand[customer] >= avg_demand and\n                route_demands[under_idx] + demand[customer] <= avg_demand):\n\n                # Find best insertion point in under_route\n                best_pos = -1\n                min_increase = float('inf')\n\n                for j in range(1, len(under_route)):\n                    increase = (distance_matrix[under_route[j-1]][customer] +\n                               distance_matrix[customer][under_route[j]] -\n                               distance_matrix[under_route[j-1]][under_route[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n\n                if best_pos != -1:\n                    # Perform relocation\n                    new_under_route = np.insert(under_route, best_pos, customer)\n                    new_over_route = np.delete(over_route, i)\n\n                    # Update solution\n                    new_solution[over_idx] = new_over_route\n                    new_solution[under_idx] = new_under_route\n                    improved = True\n                    break\n\n        if not improved:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.8275643609045741,
               0.8953045308589935
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Route Segmentation and Hybrid Insertion\" (RSHI), operates by first identifying the most promising solution in the archive through a weighted random selection based on normalized objective values, favoring solutions with lower total distance and makespan. It then applies a hybrid local search strategy that combines three novel operators: (1) \"Route Segmentation,\" which splits a randomly selected route into two segments at a customer node where the demand sum of the prefix is below capacity, (2) \"Intelligent Insertion,\" which attempts to insert the second segment into another route by finding the best feasible insertion point that minimizes the increase in total distance while respecting vehicle capacity, and (3) \"Cross-Route Relocation,\" which relocates a randomly selected customer from one route to another, ensuring capacity constraints are satisfied. The algorithm iteratively applies these operators, with each operator having a probability of being selected, and terminates after a fixed number of iterations or when no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Normalize objectives and select with weighted random choice\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives (minimization)\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n\n    # Weighted selection (favor lower values)\n    weights = 1 / (1 + norm_total + norm_makespan)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    max_iterations = 10\n    for _ in range(max_iterations):\n        operator = random.choice(['segmentation', 'insertion', 'relocation'])\n\n        if operator == 'segmentation':\n            # Route Segmentation: Split a route into two segments\n            if len(new_solution) < 2:\n                continue\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) <= 3:  # Skip if route has only depot and one customer\n                continue\n\n            # Find a split point where demand sum of prefix <= capacity\n            split_points = []\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand <= capacity:\n                    split_points.append(i)\n\n            if not split_points:\n                continue\n\n            split_pos = random.choice(split_points)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Update solution\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n\n        elif operator == 'insertion':\n            # Intelligent Insertion: Insert a segment into another route\n            if len(new_solution) < 2:\n                continue\n\n            # Select two different routes\n            route_idx1 = random.randint(0, len(new_solution) - 1)\n            route_idx2 = random.choice([i for i in range(len(new_solution)) if i != route_idx1])\n            route1 = new_solution[route_idx1]\n            route2 = new_solution[route_idx2]\n\n            # Select a segment from route1 (excluding depot)\n            if len(route1) <= 3:\n                continue\n\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n\n            # Check if segment demand <= capacity\n            segment_demand = sum(demand[node] for node in segment)\n            if segment_demand > capacity:\n                continue\n\n            # Find best insertion point in route2\n            best_pos = -1\n            min_increase = float('inf')\n\n            for i in range(1, len(route2)):\n                # Insert before i\n                temp_route = np.insert(route2, i, segment)\n                # Calculate increase in distance\n                increase = (distance_matrix[temp_route[i-1]][segment[0]] +\n                           distance_matrix[segment[-1]][temp_route[i + len(segment)]] -\n                           distance_matrix[temp_route[i-1]][temp_route[i + len(segment)]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = i\n\n            if best_pos != -1:\n                # Insert the segment\n                new_route2 = np.insert(route2, best_pos, segment)\n                # Remove the segment from route1\n                new_route1 = np.delete(route1, range(segment_start, segment_end + 1))\n\n                # Update solution\n                new_solution[route_idx1] = new_route1\n                new_solution[route_idx2] = new_route2\n\n        elif operator == 'relocation':\n            # Cross-Route Relocation: Move a customer from one route to another\n            if len(new_solution) < 2:\n                continue\n\n            # Select two different routes\n            route_idx1 = random.randint(0, len(new_solution) - 1)\n            route_idx2 = random.choice([i for i in range(len(new_solution)) if i != route_idx1])\n            route1 = new_solution[route_idx1]\n            route2 = new_solution[route_idx2]\n\n            # Select a customer from route1 (excluding depot)\n            if len(route1) <= 3:\n                continue\n\n            customer_pos = random.randint(1, len(route1) - 2)\n            customer = route1[customer_pos]\n\n            # Check if moving customer to route2 is feasible\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + demand[customer] > capacity:\n                continue\n\n            # Find best insertion point in route2\n            best_pos = -1\n            min_increase = float('inf')\n\n            for i in range(1, len(route2)):\n                # Insert before i\n                increase = (distance_matrix[route2[i-1]][customer] +\n                            distance_matrix[customer][route2[i]] -\n                            distance_matrix[route2[i-1]][route2[i]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = i\n\n            if best_pos != -1:\n                # Insert the customer into route2\n                new_route2 = np.insert(route2, best_pos, customer)\n                # Remove the customer from route1\n                new_route1 = np.delete(route1, customer_pos)\n\n                # Update solution\n                new_solution[route_idx1] = new_route1\n                new_solution[route_idx2] = new_route2\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.739327959825741,
               0.4767031967639923
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves first selecting a promising solution from the archive by prioritizing those with lower makespan and total distance, then applying a hybrid local search operator that combines route swapping and customer reallocation. Specifically, it randomly selects two routes from the solution, swaps a segment from one route with another from the second route while ensuring capacity constraints are met, and then attempts to reallocate customers between routes to further optimize both objectives. The new solution is validated for feasibility before being returned, ensuring that all customers are served without exceeding vehicle capacities.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_solution = archive[0][0].copy()\n\n    # Make a deep copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select two distinct routes\n    if len(new_solution) < 2:\n        return new_solution  # No possible swap if only one route exists\n\n    # Randomly select two distinct routes\n    route_indices = random.sample(range(len(new_solution)), 2)\n    route1_idx, route2_idx = route_indices[0], route_indices[1]\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Ensure routes have enough customers to swap (at least 2 customers in each)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution  # Skip if routes are too small\n\n    # Randomly select a segment from each route (excluding depot)\n    # Segment from route1: [i, j] where i is after depot and j is before depot\n    i1 = random.randint(1, len(route1) - 2)\n    j1 = random.randint(i1, len(route1) - 2)\n    segment1 = route1[i1:j1+1]\n\n    # Segment from route2: [k, l] where k is after depot and l is before depot\n    i2 = random.randint(1, len(route2) - 2)\n    j2 = random.randint(i2, len(route2) - 2)\n    segment2 = route2[i2:j2+1]\n\n    # Check if swapping segments violates capacity constraints\n    # Calculate total demand of segments\n    demand1 = sum(demand[node] for node in segment1)\n    demand2 = sum(demand[node] for node in segment2)\n\n    # Check if swapping segments would violate capacity in either route\n    # For route1: remove segment1's demand and add segment2's demand\n    current_demand_route1 = sum(demand[node] for node in route1)\n    new_demand_route1 = current_demand_route1 - demand1 + demand2\n    if new_demand_route1 > capacity:\n        return new_solution  # Skip if capacity is violated\n\n    # For route2: remove segment2's demand and add segment1's demand\n    current_demand_route2 = sum(demand[node] for node in route2)\n    new_demand_route2 = current_demand_route2 - demand2 + demand1\n    if new_demand_route2 > capacity:\n        return new_solution  # Skip if capacity is violated\n\n    # Perform the swap\n    # Remove segment1 from route1 and insert segment2\n    new_route1 = np.concatenate([route1[:i1], segment2, route1[j1+1:]])\n    # Remove segment2 from route2 and insert segment1\n    new_route2 = np.concatenate([route2[:i2], segment1, route2[j2+1:]])\n\n    # Update the solution\n    new_solution[route1_idx] = new_route1\n    new_solution[route2_idx] = new_route2\n\n    # Attempt to reallocate customers between routes to further optimize\n    # Randomly select a customer from one route and try to move it to another\n    if len(new_solution) >= 2:\n        # Select a random route (excluding depot)\n        source_route_idx = random.choice(range(len(new_solution)))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 2:  # Ensure route has customers to move\n            # Select a random customer (excluding depot)\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_idx]\n            customer_demand = demand[customer]\n\n            # Try to insert this customer into another route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == source_route_idx:\n                    continue  # Skip the same route\n                target_route = new_solution[target_route_idx]\n                # Calculate new demand if customer is added to target route\n                current_demand = sum(demand[node] for node in target_route)\n                if current_demand + customer_demand <= capacity:\n                    # Insert customer into target route (random position)\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_target_route = np.insert(target_route, insert_pos, customer)\n                    # Remove customer from source route\n                    new_source_route = np.delete(source_route, customer_idx)\n                    # Update routes\n                    new_solution[target_route_idx] = new_target_route\n                    new_solution[source_route_idx] = new_source_route\n                    break  # Only move one customer at a time\n\n    return new_solution\n\n",
          "score": [
               -0.3921372588993272,
               0.24164479970932007
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a solution from the archive based on a novel multi-objective selection criterion that combines the total distance and makespan using a weighted sum approach, where weights are dynamically adjusted based on the current solution's Pareto dominance. It then applies a unique local search operator called \"route merging and splitting\" that identifies pairs of routes with complementary customer demands and spatial proximity, merges them into a single route if feasible, and then splits the merged route into two new routes using a demand-balanced k-means clustering approach to minimize the increase in total distance while improving the makespan. The algorithm ensures feasibility by strictly enforcing vehicle capacity constraints at every step and includes a backtracking mechanism to revert to the previous solution if the new solution is infeasible or worse in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def weighted_score(obj):\n        # Dynamic weights based on Pareto dominance\n        total_distance_weight = 0.6 if obj[0] < np.mean([x[1][0] for x in archive]) else 0.4\n        makespan_weight = 1 - total_distance_weight\n        return total_distance_weight * obj[0] + makespan_weight * obj[1]\n\n    archive_sorted = sorted(archive, key=lambda x: weighted_score(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging and splitting operator\n    if len(new_solution) > 1:\n        # Select two routes for potential merging\n        route_indices = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        if np.sum(demand[merged_customers]) <= capacity:\n            # Merge the routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for i, route in enumerate(new_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n\n            # Split the merged route using demand-balanced k-means\n            customers = merged_route[1:-1]\n            if len(customers) > 1:\n                # Use demand as weight in k-means\n                weights = demand[customers]\n                kmeans = KMeans(n_clusters=2, random_state=0).fit(coords[customers], sample_weight=weights)\n                labels = kmeans.labels_\n\n                # Create two new routes\n                route1_customers = customers[labels == 0]\n                route2_customers = customers[labels == 1]\n\n                # Ensure both routes are feasible\n                if (np.sum(demand[route1_customers]) <= capacity and\n                    np.sum(demand[route2_customers]) <= capacity):\n                    new_solution.remove(merged_route)\n                    new_solution.append(np.concatenate([[0], route1_customers, [0]]))\n                    new_solution.append(np.concatenate([[0], route2_customers, [0]]))\n                else:\n                    # Revert if splitting is infeasible\n                    new_solution = [route.copy() for route in base_solution]\n\n    # Check if the new solution is better in at least one objective\n    old_total_distance = archive_sorted[0][1][0]\n    old_makespan = archive_sorted[0][1][1]\n    new_total_distance = sum(distance_matrix[route[:-1], route[1:]].sum() for route in new_solution)\n    new_makespan = max(distance_matrix[route[:-1], route[1:]].sum() for route in new_solution)\n\n    if not (new_total_distance < old_total_distance or new_makespan < old_makespan):\n        new_solution = [route.copy() for route in base_solution]\n\n    return new_solution\n\n",
          "score": [
               -0.7386802680398381,
               0.2915624976158142
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a neighbor solution involves a hybrid local search strategy that combines route-splitting, customer reallocation, and route-merging operations. First, the algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower total distance or shorter makespan, or those with a balanced trade-off between the two objectives. Then, it identifies critical routes (either the longest or those with high demand) and performs a route-splitting operation by removing a subset of customers from the route, creating a new route with those customers. Next, it reallocates the remaining customers to other routes using a greedy insertion strategy that minimizes the increase in total distance while respecting capacity constraints. Finally, the algorithm attempts to merge adjacent routes if their combined load does not exceed capacity and if merging reduces the total distance or makespan. The neighbor solution is validated for feasibility before being returned.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, (dist, span) in archive:\n        # Prefer solutions with lower distance or makespan, or balanced trade-off\n        weight = 1.0 / (dist + span + 0.1 * abs(dist - span))\n        weights.append(weight)\n    weights = np.array(weights)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy of the selected solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify critical routes (longest or high-demand routes)\n    route_lengths = []\n    route_demands = []\n    for route in new_solution:\n        route_demands.append(np.sum(demand[route[1:-1]]))  # exclude depot\n        route_lengths.append(np.sum(distance_matrix[route[:-1], route[1:]]))\n\n    # Select a route to split (longest or high-demand)\n    if random.random() < 0.5:\n        selected_route_idx = np.argmax(route_lengths)\n    else:\n        selected_route_idx = np.argmax(route_demands)\n\n    selected_route = new_solution[selected_route_idx]\n    if len(selected_route) <= 3:  # route has only depot and one customer\n        return new_solution\n\n    # Split the route into two parts\n    split_pos = random.randint(1, len(selected_route) - 2)\n    first_part = selected_route[:split_pos + 1]\n    second_part = selected_route[split_pos:]\n\n    # Check capacity constraints for the split\n    first_part_demand = np.sum(demand[first_part[1:-1]])\n    second_part_demand = np.sum(demand[second_part[1:-1]])\n    if first_part_demand > capacity or second_part_demand > capacity:\n        return new_solution\n\n    # Replace the original route with the two split parts\n    new_solution[selected_route_idx] = first_part\n    new_solution.append(second_part)\n\n    # Reallocate customers from the second part to other routes greedily\n    customers_to_reallocate = second_part[1:-1]\n    new_solution.pop()  # remove the second part temporarily\n\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_insert_cost = float('inf')\n        best_insert_pos = -1\n\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue  # skip if capacity exceeded\n\n            for pos in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[pos - 1]\n                next_node = route[pos]\n                insert_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_pos = pos\n                    best_route_idx = i\n\n        if best_route_idx != -1:\n            # Insert the customer into the best position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n\n    # Attempt to merge routes if possible\n    merged = True\n    while merged:\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                combined_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n\n                if combined_demand <= capacity:\n                    # Merge routes i and j\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    merged = True\n                    break\n            if merged:\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.773521983418332,
               0.9211643934249878
          ]
     },
     {
          "algorithm": "{The novel local search strategy, named \"Cluster-Based Route Reconstruction with Adaptive Demand Balancing,\" operates by first partitioning the solution's routes into demand clusters using a k-means algorithm based on route demands, then reconstructing routes by iteratively merging clusters while ensuring capacity constraints, and finally balancing the demand distribution across routes through an adaptive relocation mechanism that prioritizes high-demand nodes and considers both distance and demand proximity. The algorithm selects the base solution from the archive using a probabilistic approach that favors solutions with lower makespan but considers total distance as a secondary criterion, and applies the cluster-based reconstruction and adaptive balancing operations in sequence, with each step verifying feasibility and only proceeding if improvements are detected.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Probabilistic selection favoring lower makespan but considering total distance\n    weights = []\n    for _, (total_dist, makespan) in archive:\n        weights.append(1 / (makespan + 0.1 * total_dist))\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Cluster-Based Route Reconstruction\n    if len(new_solution) > 1:\n        # Calculate route demands\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Cluster routes based on demand using k-means\n        from sklearn.cluster import KMeans\n        n_clusters = min(3, len(route_demands))\n        if n_clusters > 1:\n            kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n            clusters = kmeans.fit_predict(np.array(route_demands).reshape(-1, 1))\n\n            # Reconstruct routes by merging clusters\n            new_routes = []\n            for cluster in range(n_clusters):\n                cluster_routes = [i for i, c in enumerate(clusters) if c == cluster]\n                if not cluster_routes:\n                    continue\n\n                # Merge routes in the cluster\n                merged_route = new_solution[cluster_routes[0]].copy()\n                for i in cluster_routes[1:]:\n                    route = new_solution[i]\n                    if sum(demand[merged_route[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                        merged_route = np.concatenate([merged_route[:-1], route[1:]])\n                new_routes.append(merged_route)\n\n            new_solution = new_routes\n\n    # Step 3: Adaptive Demand Balancing\n    if len(new_solution) > 1:\n        # Calculate route demands and makespans\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find the most imbalanced route (highest demand)\n        max_demand_idx = np.argmax(route_demands)\n        max_demand_route = new_solution[max_demand_idx]\n\n        # Find the route with the lowest demand\n        min_demand_idx = np.argmin(route_demands)\n        min_demand_route = new_solution[min_demand_idx]\n\n        # Try to relocate customers from high-demand to low-demand route\n        for customer in max_demand_route[1:-1]:\n            if (sum(demand[min_demand_route[1:-1]]) + demand[customer] <= capacity and\n                random.random() < 0.5):  # 50% chance to relocate\n\n                # Find best insertion point in min_demand_route\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(min_demand_route)):\n                    insert_cost = (distance_matrix[min_demand_route[i-1], customer] +\n                                 distance_matrix[customer, min_demand_route[i]] -\n                                 distance_matrix[min_demand_route[i-1], min_demand_route[i]])\n                    if insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = i\n\n                if best_pos != -1:\n                    # Insert customer into min_demand_route\n                    min_demand_route = np.insert(min_demand_route, best_pos, customer)\n                    # Remove customer from max_demand_route\n                    max_demand_route = np.array([x for x in max_demand_route if x != customer])\n\n                    # Update solution\n                    new_solution[max_demand_idx] = max_demand_route\n                    new_solution[min_demand_idx] = min_demand_route\n\n                    # Break after first successful relocation to limit changes\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
          "score": [
               -0.7903291995257336,
               3.09366774559021
          ]
     }
]