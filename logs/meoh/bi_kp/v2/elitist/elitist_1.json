[
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    # Here, we choose a solution randomly but prioritize those with lower crowding distance (if available)\n    # For simplicity, we select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: Combine item swaps and adaptive neighborhood exploration\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select items to swap (included with excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        # If no items to swap, perform a random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n        return new_solution\n\n    # Step 2: Perform a swap between an included and excluded item\n    swap_in = random.choice(included_items)\n    swap_out = random.choice(excluded_items)\n\n    # Check feasibility of the swap\n    delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[swap_in] = 0\n        new_solution[swap_out] = 1\n\n    # Step 3: Adaptive neighborhood exploration (flip a random bit if the swap didn't improve)\n    # This is a simple heuristic; more sophisticated strategies can be added\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.890917726717365,
            -17.954234354809287
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its dominance and diversity, then applies a hybrid local search operator that combines item swapping, flipping, and probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: item swapping, flipping, and probabilistic selection\n    for _ in range(min(10, len(weight_lst))):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap or flip\n        idx1, idx2 = np.random.choice(len(weight_lst), size=2, replace=False)\n\n        # Try swapping items\n        if new_solution[idx1] != new_solution[idx2]:\n            if new_solution[idx1] == 1:\n                if current_weight - weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            else:\n                if current_weight - weight_lst[idx2] + weight_lst[idx1] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight = current_weight - weight_lst[idx2] + weight_lst[idx1]\n\n        # Try flipping an item with probability based on value improvement\n        flip_idx = np.random.randint(len(weight_lst))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -17.601109846696,
            -17.424310830938957
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    # Here, we choose a solution randomly but prioritize those with lower crowding distance (if available)\n    # For simplicity, we select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: Combine item swaps and adaptive neighborhood exploration\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select items to swap (included with excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        # If no items to swap, perform a random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n        return new_solution\n\n    # Step 2: Perform a swap between an included and excluded item\n    swap_in = random.choice(included_items)\n    swap_out = random.choice(excluded_items)\n\n    # Check feasibility of the swap\n    delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[swap_in] = 0\n        new_solution[swap_out] = 1\n\n    # Step 3: Adaptive neighborhood exploration (flip a random bit if the swap didn't improve)\n    # This is a simple heuristic; more sophisticated strategies can be added\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.890917726717365,
            -17.954234354809287
        ]
    }
]