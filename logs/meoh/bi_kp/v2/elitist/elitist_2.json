[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search strategy that combines probabilistic item removal, value-weighted insertion, and adaptive crowding-aware exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with lower crowding distance if available)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Probabilistic item removal (remove items with low marginal contribution)\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate marginal contribution for each included item\n        marginal_value1 = value1_lst[included_items]\n        marginal_value2 = value2_lst[included_items]\n        marginal_contribution = marginal_value1 + marginal_value2\n\n        # Remove items with low marginal contribution with higher probability\n        removal_probs = 1 / (1 + marginal_contribution)\n        removal_probs = removal_probs / np.sum(removal_probs)\n\n        remove_idx = np.random.choice(included_items, p=removal_probs)\n        if current_weight - weight_lst[remove_idx] <= capacity:\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    # Step 2: Value-weighted insertion (insert items with high value-to-weight ratio)\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate value-to-weight ratio for each excluded item\n        value_ratio = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n\n        # Insert items with high value-to-weight ratio with higher probability\n        insertion_probs = value_ratio / np.sum(value_ratio)\n\n        insert_idx = np.random.choice(excluded_items, p=insertion_probs)\n        if current_weight + weight_lst[insert_idx] <= capacity:\n            new_solution[insert_idx] = 1\n            current_weight += weight_lst[insert_idx]\n\n    # Step 3: Adaptive crowding-aware exploration (flip a random bit if solution is not on the Pareto front)\n    if len(archive) > 1:\n        # Check if the current solution is dominated by any other solution in the archive\n        current_val1 = np.sum(value1_lst * new_solution)\n        current_val2 = np.sum(value2_lst * new_solution)\n        is_dominated = False\n\n        for sol, (val1, val2) in archive:\n            if (val1 >= current_val1 and val2 > current_val2) or (val1 > current_val1 and val2 >= current_val2):\n                is_dominated = True\n                break\n\n        if is_dominated:\n            flip_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.954045774496187,
            -18.217066390710585
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    # Here, we choose a solution randomly but prioritize those with lower crowding distance (if available)\n    # For simplicity, we select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: Combine item swaps and adaptive neighborhood exploration\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select items to swap (included with excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        # If no items to swap, perform a random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n        return new_solution\n\n    # Step 2: Perform a swap between an included and excluded item\n    swap_in = random.choice(included_items)\n    swap_out = random.choice(excluded_items)\n\n    # Check feasibility of the swap\n    delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[swap_in] = 0\n        new_solution[swap_out] = 1\n\n    # Step 3: Adaptive neighborhood exploration (flip a random bit if the swap didn't improve)\n    # This is a simple heuristic; more sophisticated strategies can be added\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.890917726717365,
            -17.954234354809287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search strategy that combines probabilistic item selection, adaptive flipping with value-weighted probabilities, and guided neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with higher combined values)\n    selected_idx = np.random.choice(len(archive), p=np.array([v1 + v2 for _, (v1, v2) in archive]) / sum(v1 + v2 for _, (v1, v2) in archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic item selection for flipping\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Value-weighted probabilities for flipping\n        flip_candidates = np.concatenate([included_items, excluded_items])\n        flip_probs = np.zeros(len(flip_candidates))\n        for i, idx in enumerate(flip_candidates):\n            if new_solution[idx] == 1:\n                flip_probs[i] = (value1_lst[idx] + value2_lst[idx]) * 0.5  # Prefer removing high-value items\n            else:\n                flip_probs[i] = (value1_lst[idx] + value2_lst[idx]) * 1.5  # Prefer adding high-value items\n        flip_probs = flip_probs / np.sum(flip_probs)\n\n        # Perform probabilistic flips\n        for _ in range(min(3, len(flip_candidates))):\n            flip_idx = np.random.choice(flip_candidates, p=flip_probs)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n\n    # Guided neighborhood exploration: flip items based on marginal improvement\n    if np.array_equal(new_solution, base_solution):\n        marginal_values = np.zeros(len(weight_lst))\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                marginal_values[i] = (value1_lst[i] + value2_lst[i]) * 0.5\n            else:\n                marginal_values[i] = (value1_lst[i] + value2_lst[i]) * 1.5\n        marginal_values = marginal_values / np.sum(marginal_values)\n\n        for _ in range(min(5, len(weight_lst))):\n            flip_idx = np.random.choice(len(weight_lst), p=marginal_values)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -18.799767353852562,
            -18.05952401332903
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values and diversity, then applies a hybrid local search combining item reinsertion, probabilistic swapping, and value-based flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: item reinsertion, probabilistic swapping, and value-based flipping\n    for _ in range(min(10, len(weight_lst))):  # Limit iterations to avoid excessive computation\n        # Probabilistic swapping based on value improvement\n        idx1, idx2 = np.random.choice(len(weight_lst), size=2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] == 1 else (weight_lst[idx1] - weight_lst[idx2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight += delta_weight\n\n        # Value-based flipping with probability\n        flip_idx = np.random.randint(len(weight_lst))\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -18.195084283624052,
            -18.007500778483095
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its dominance and diversity, then applies a hybrid local search operator that combines item swapping, flipping, and probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: item swapping, flipping, and probabilistic selection\n    for _ in range(min(10, len(weight_lst))):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap or flip\n        idx1, idx2 = np.random.choice(len(weight_lst), size=2, replace=False)\n\n        # Try swapping items\n        if new_solution[idx1] != new_solution[idx2]:\n            if new_solution[idx1] == 1:\n                if current_weight - weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            else:\n                if current_weight - weight_lst[idx2] + weight_lst[idx1] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight = current_weight - weight_lst[idx2] + weight_lst[idx1]\n\n        # Try flipping an item with probability based on value improvement\n        flip_idx = np.random.randint(len(weight_lst))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -17.601109846696,
            -17.424310830938957
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps, random flips, and objective-weighted perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize higher values)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select top 30% of solutions and choose one randomly\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Step 1: Perform item swaps based on objective weights\n    for _ in range(3):\n        if np.random.rand() < 0.5:  # 50% chance to perform swap\n            # Identify items to swap (one in, one out)\n            in_items = np.where(new_solution == 0)[0]\n            out_items = np.where(new_solution == 1)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                # Weighted selection based on objectives\n                in_weights = (value1_lst[in_items] + value2_lst[in_items]) / (weight_lst[in_items] + 1e-6)\n                out_weights = (value1_lst[out_items] + value2_lst[out_items]) / (weight_lst[out_items] + 1e-6)\n\n                in_idx = np.random.choice(in_items, p=in_weights / np.sum(in_weights))\n                out_idx = np.random.choice(out_items, p=out_weights / np.sum(out_weights))\n\n                # Check feasibility\n                new_weight = current_weight - weight_lst[out_idx] + weight_lst[in_idx]\n                if new_weight <= capacity:\n                    new_solution[out_idx] = 0\n                    new_solution[in_idx] = 1\n                    current_weight = new_weight\n\n    # Step 2: Random flips with objective-based probability\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.2:  # 20% chance to flip each item\n            if new_solution[i] == 1:\n                # Try to remove item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Objective-weighted perturbations\n    for _ in range(2):\n        # Select items based on their contribution to objectives\n        obj_weights = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        probs = obj_weights / np.sum(obj_weights)\n        selected_items = np.random.choice(len(new_solution), size=3, p=probs, replace=False)\n\n        for i in selected_items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1 and current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -17.213447319169134,
            -16.467559274724255
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement by evaluating the trade-off between the two objectives, then applies a novel local search strategy that combines multi-objective-aware item selection, probabilistic flipping with value-to-weight ratios, and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (evaluate trade-off between objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-10)\n    v2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = v1_ratio + v2_ratio  # Simple combination for selection priority\n\n    # Multi-objective-aware item selection\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Probabilistically select items to flip based on value-to-weight ratios\n    for _ in range(min(5, len(weight_lst))):\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            # Select item to remove (from included items) with lower combined ratio\n            remove_idx = included_items[np.argmin(combined_ratio[included_items])]\n            # Select item to add (from excluded items) with higher combined ratio\n            add_idx = excluded_items[np.argmax(combined_ratio[excluded_items])]\n\n            # Check feasibility of the swap\n            delta_weight = weight_lst[add_idx] - weight_lst[remove_idx]\n            if current_weight + delta_weight <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight += delta_weight\n                included_items = np.where(new_solution == 1)[0]\n                excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 2: Adaptive probabilistic flipping based on value-to-weight ratios\n    for idx in range(len(weight_lst)):\n        if new_solution[idx] == 1:\n            # Remove item with low ratio or high weight\n            if random.random() < (1 / (1 + combined_ratio[idx])) or random.random() < 0.3:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n        else:\n            # Add item with high ratio or low weight\n            if random.random() < combined_ratio[idx] or random.random() < 0.1:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.78040917879963,
            -16.84367980385197
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive, identifies critical items based on their marginal contribution to both objectives, and applies a hybrid local search strategy that combines greedy improvements and controlled randomness to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (here, random selection with bias toward higher values)\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 3: Identify critical items (highest marginal contribution)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    critical_items = np.argsort(-(marginal_value1 + marginal_value2))[:max(5, len(base_solution) // 5)]\n\n    # Step 4: Hybrid local search: flip critical items with probability, then greedy improvement\n    new_solution = base_solution.copy()\n    for i in critical_items:\n        if random.random() < 0.3:  # 30% chance to flip critical item\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    # Step 5: Greedy improvement on remaining items\n    remaining_items = [i for i in range(len(base_solution)) if i not in critical_items]\n    for i in remaining_items:\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding improves both objectives\n            if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        elif base_solution[i] == 1:\n            # Check if removing improves both objectives\n            if (value1_lst[i] < 0 or value2_lst[i] < 0):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -15.420013874190126,
            -15.457343148684844
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for multi-objective improvement, then applies a novel local search strategy combining value-driven item selection, weight-balanced swaps, and probabilistic flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with higher combined value)\n    selected_idx = np.argmax([(obj[0] + obj[1]) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and value metrics\n    current_weight = np.sum(weight_lst * new_solution)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Novel local search strategy: Value-driven selection with weight balancing\n    for _ in range(min(5, len(weight_lst))):  # Limited iterations for efficiency\n        # Step 1: Select an item to remove based on value contribution\n        if len(included_items) > 0:\n            remove_idx = included_items[np.argmax(value1_lst[included_items] + value2_lst[included_items])]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            included_items = np.where(new_solution == 1)[0]\n\n        # Step 2: Select an item to add based on value-to-weight ratio\n        if len(excluded_items) > 0:\n            # Calculate value-to-weight ratios for excluded items\n            ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n            # Select top 20% of items by ratio\n            top_items = excluded_items[np.argsort(ratios)[-max(1, len(ratios)//5):]]\n            # Randomly choose one from top items\n            add_idx = np.random.choice(top_items)\n            if current_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n                current_weight += weight_lst[add_idx]\n                excluded_items = np.where(new_solution == 0)[0]\n\n    # Final probabilistic flipping to escape local optima\n    if np.random.random() < 0.3:  # 30% chance to perform a random flip\n        flip_candidates = np.where((weight_lst <= (capacity - current_weight)) | (new_solution == 1))[0]\n        if len(flip_candidates) > 0:\n            flip_idx = np.random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -16.218169039611155,
            -15.423418291590089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search strategy that alternates between targeted item swaps and probabilistic bit flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential by combining dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Alternate between targeted swaps and probabilistic flips\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Targeted swap: Select items with highest value/weight ratio\n        swap_in = max(included_items, key=lambda x: value1_lst[x] / weight_lst[x])\n        swap_out = max(excluded_items, key=lambda x: value2_lst[x] / weight_lst[x])\n\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # Probabilistic flip: Randomly flip bits with probability based on value/weight ratio\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to consider flipping\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -15.57482373382112,
            -15.149218285887324
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search strategy that combines probabilistic item removal, value-weighted insertion, and adaptive crowding-aware exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with lower crowding distance if available)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Probabilistic item removal (remove items with low marginal contribution)\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate marginal contribution for each included item\n        marginal_value1 = value1_lst[included_items]\n        marginal_value2 = value2_lst[included_items]\n        marginal_contribution = marginal_value1 + marginal_value2\n\n        # Remove items with low marginal contribution with higher probability\n        removal_probs = 1 / (1 + marginal_contribution)\n        removal_probs = removal_probs / np.sum(removal_probs)\n\n        remove_idx = np.random.choice(included_items, p=removal_probs)\n        if current_weight - weight_lst[remove_idx] <= capacity:\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    # Step 2: Value-weighted insertion (insert items with high value-to-weight ratio)\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate value-to-weight ratio for each excluded item\n        value_ratio = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n\n        # Insert items with high value-to-weight ratio with higher probability\n        insertion_probs = value_ratio / np.sum(value_ratio)\n\n        insert_idx = np.random.choice(excluded_items, p=insertion_probs)\n        if current_weight + weight_lst[insert_idx] <= capacity:\n            new_solution[insert_idx] = 1\n            current_weight += weight_lst[insert_idx]\n\n    # Step 3: Adaptive crowding-aware exploration (flip a random bit if solution is not on the Pareto front)\n    if len(archive) > 1:\n        # Check if the current solution is dominated by any other solution in the archive\n        current_val1 = np.sum(value1_lst * new_solution)\n        current_val2 = np.sum(value2_lst * new_solution)\n        is_dominated = False\n\n        for sol, (val1, val2) in archive:\n            if (val1 >= current_val1 and val2 > current_val2) or (val1 > current_val1 and val2 >= current_val2):\n                is_dominated = True\n                break\n\n        if is_dominated:\n            flip_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.954045774496187,
            -18.217066390710585
        ]
    }
]