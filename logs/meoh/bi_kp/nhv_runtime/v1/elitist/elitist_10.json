[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel four-phase local search strategy that first performs targeted objective-aligned swaps, followed by adaptive weight optimization flips, a diversification step with controlled randomness, and concludes with a neighborhood exploration phase that combines multiple small changes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-aligned swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective alignment scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        alignment_scores = (in_v1 * in_v2) / (in_v1 + in_v2 + 1e-6)\n        best_alignment_idx = np.argmax(alignment_scores)\n        i = in_sol[best_alignment_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        alignment_gains = (out_v1 * out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(alignment_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(7, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step with controlled randomness\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove items with low combined value/weight ratio\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        combined_ratio = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(combined_ratio) > 0:\n            worst_ratio_idx = np.argmin(combined_ratio)\n            i = in_sol[worst_ratio_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    # Phase 4: Neighborhood exploration with combined changes\n    if random.random() < 0.5:  # 50% chance for neighborhood exploration\n        # Perform multiple small changes in one step\n        changes = min(3, len(in_sol) // 2)\n        for _ in range(changes):\n            if len(in_sol) > 0 and len(out_sol) > 0:\n                i = random.choice(in_sol)\n                j = random.choice(out_sol)\n                if weight_lst[j] <= capacity - current_weight + weight_lst[i]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    in_sol = np.where(new_solution == 1)[0]\n                    out_sol = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9019550730384995,
            3.2377165853977203
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-aware score that balances both objectives, then applies a two-phase local search combining objective-driven swaps and capacity-constrained flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on dominance-aware score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            scores.append(-float('inf'))\n            continue\n        score = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply two-phase local search\n    n_items = len(new_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj1_ratios = value1_lst / weight_lst\n        obj2_ratios = value2_lst / weight_lst\n        best_in = in_sol[np.argmin(obj1_ratios[in_sol] + obj2_ratios[in_sol])]\n        best_out = out_sol[np.argmax(obj1_ratios[out_sol] + obj2_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7843467352057273,
            2.3594504296779633
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and diversity-aware weight efficiency, then applies a multi-phase local search combining value-weighted swaps, objective-balanced flips, and adaptive capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score and diversity-aware weight efficiency\n    scores = []\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        normalized_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        diversity_score = 1 - (normalized_obj1 * normalized_obj2)\n        weight_efficiency = (normalized_obj1 + normalized_obj2) / (total_weight + 1e-6)\n        score = diversity_score * weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-weighted swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_weights = (value1_lst * 0.6 + value2_lst * 0.4) / weight_lst\n        best_in = in_sol[np.argmin(value_weights[in_sol])]\n        best_out = out_sol[np.argmax(value_weights[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Objective-balanced flips\n    flip_candidates = np.argsort((value1_lst * 0.7 + value2_lst * 0.3) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive capacity-aware perturbations\n    perturb_size = min(3, n_items // 5)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8785546613753277,
            2.74297371506691
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-biased selection with capacity-aware perturbations, using a dynamic trade-off between value improvements in both objectives while intelligently balancing neighborhood exploration and exploitation through a multi-phase approach that includes adaptive item flips, weight-aware swaps, and diversity-promoting perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution based on objective trade-off\n    obj1_vals = np.array([obj[0] for _, obj in archive])\n    obj2_vals = np.array([obj[1] for _, obj in archive])\n    obj1_range = np.max(obj1_vals) - np.min(obj1_vals)\n    obj2_range = np.max(obj2_vals) - np.min(obj2_vals)\n\n    # Select solution with highest combined normalized objective value\n    if obj1_range > 0 and obj2_range > 0:\n        normalized_obj1 = (obj1_vals - np.min(obj1_vals)) / obj1_range\n        normalized_obj2 = (obj2_vals - np.min(obj2_vals)) / obj2_range\n        combined_scores = normalized_obj1 + normalized_obj2\n        selected_idx = np.argmax(combined_scores)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Multi-phase neighborhood generation\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased flips\n    for _ in range(min(3, n_items // 5)):\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) == 0:\n            break\n\n        # Select flip based on objective with lower relative improvement\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_candidates]\n        else:\n            flip_values = value2_lst[flip_candidates]\n\n        if len(flip_candidates) > 0:\n            flip_idx = np.random.choice(flip_candidates)\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n\n    # Phase 2: Weight-aware additions\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        add_candidates = np.where(new_solution == 0)[0]\n        if len(add_candidates) > 0:\n            # Select items with highest combined value-to-weight ratio\n            value_ratio = (value1_lst + value2_lst) / weight_lst\n            sorted_candidates = add_candidates[np.argsort(value_ratio[add_candidates])[::-1]]\n\n            for i in sorted_candidates:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    remaining_capacity -= weight_lst[i]\n                    break\n\n    # Phase 3: Diversity-promoting perturbations\n    if np.random.random() < 0.4:\n        perturb_indices = np.random.choice(n_items, size=min(2, n_items // 3), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.48514697013150987,
            1.746300458908081
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel four-phase local search strategy that first performs targeted objective-aligned swaps, followed by adaptive weight optimization flips, a diversification step with controlled randomness, and concludes with a neighborhood exploration phase that combines multiple small changes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-aligned swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective alignment scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        alignment_scores = (in_v1 * in_v2) / (in_v1 + in_v2 + 1e-6)\n        best_alignment_idx = np.argmax(alignment_scores)\n        i = in_sol[best_alignment_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        alignment_gains = (out_v1 * out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(alignment_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(7, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step with controlled randomness\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove items with low combined value/weight ratio\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        combined_ratio = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(combined_ratio) > 0:\n            worst_ratio_idx = np.argmin(combined_ratio)\n            i = in_sol[worst_ratio_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    # Phase 4: Neighborhood exploration with combined changes\n    if random.random() < 0.5:  # 50% chance for neighborhood exploration\n        # Perform multiple small changes in one step\n        changes = min(3, len(in_sol) // 2)\n        for _ in range(changes):\n            if len(in_sol) > 0 and len(out_sol) > 0:\n                i = random.choice(in_sol)\n                j = random.choice(out_sol)\n                if weight_lst[j] <= capacity - current_weight + weight_lst[i]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    in_sol = np.where(new_solution == 1)[0]\n                    out_sol = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9019550730384995,
            3.2377165853977203
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    }
]