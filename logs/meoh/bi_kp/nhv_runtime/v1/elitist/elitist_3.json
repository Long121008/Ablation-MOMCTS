[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware scoring mechanism that prioritizes solutions with high potential for improvement, then applies a hybrid local search operator that combines targeted item replacements and adaptive flips to generate a feasible neighbor solution while maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Score each solution based on its potential for improvement and diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, slack capacity, and diversity\n        diversity_score = np.sum(sol != archive[0][0]) / len(sol)\n        score = (obj[0] + obj[1]) * (1 - (total_weight / capacity)) * (1 + diversity_score)\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item replacements\n    for _ in range(min(3, n_items)):\n        # Select an item to potentially replace\n        i = np.random.randint(n_items)\n        # Find the best replacement candidate (not in current solution)\n        not_in_sol = np.where(new_solution == 0)[0]\n        if len(not_in_sol) > 0:\n            # Evaluate potential replacements based on both objectives\n            potential_values = (value1_lst[not_in_sol] + value2_lst[not_in_sol]) / weight_lst[not_in_sol]\n            j = not_in_sol[np.argmax(potential_values)]\n            # Check feasibility\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips with objective balancing\n    flip_size = min(3, n_items // 4)\n    for _ in range(flip_size):\n        # Select items based on both objectives\n        combined_values = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(combined_values)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try to remove item if feasible\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n            else:\n                # Try to add item if feasible\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8969140326690765,
            3.8953407406806946
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8573971367297398,
            3.205743044614792
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and weight balance, then applies a tiered local search that includes objective-specific flips, weight-aware swaps, and capacity-constrained perturbations, ensuring feasible solutions while exploring the trade-off space more thoroughly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on objective dominance and weight balance\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 - np.sum(weight_lst * sol) / capacity) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Tiered local search\n    n_items = len(base_solution)\n\n    # Tier 1: Objective-specific flips\n    flip_mask = (new_solution == 1)\n    if np.any(flip_mask):\n        obj1_total, obj2_total = archive[selected_idx][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_mask]\n        else:\n            flip_values = value2_lst[flip_mask]\n        flip_indices = np.where(flip_mask)[0]\n        top_flips = flip_indices[np.argsort(flip_values)[-min(2, len(flip_indices)):]]\n        for i in top_flips:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Tier 2: Weight-aware swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                weight_ratio = weight_lst[not_in_sol] / weight_lst[i]\n                similar_items = not_in_sol[np.argsort(np.abs(weight_ratio - 1))[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Tier 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6230837336892188,
            3.07790070772171
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive neighborhood exploration with objective-weighted flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations, and incorporates a novel scoring mechanism that prioritizes solutions with high potential for Pareto improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for Pareto improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate Pareto improvement potential\n            potential = (np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))) / (remaining_capacity + 1e-6)\n            candidates.append((potential, sol))\n\n    if not candidates:\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest Pareto potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-weighted flip (balance between value1 and value2)\n    if remaining_capacity > 0:\n        weight_factor = 0.5 + 0.3 * (remaining_capacity / capacity)  # More aggressive when capacity is tight\n        candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n        if candidates_to_add:\n            best_candidate = max(candidates_to_add, key=lambda i: (weight_factor * value1_lst[i] + (1-weight_factor) * value2_lst[i]))\n            new_solution[best_candidate] = 1\n            remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (remove low-value items)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (0.4 * value1_lst[i] + 0.6 * value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Dynamic random flip (higher chance when stuck)\n    flip_prob = 0.2 + 0.3 * (1 - min(1, len(candidates)/len(archive)))\n    if random.random() < flip_prob:\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8820468793589005,
            6.273228734731674
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-biased selection with capacity-aware perturbations, using a dynamic trade-off between value improvements in both objectives while intelligently balancing neighborhood exploration and exploitation through a multi-phase approach that includes adaptive item flips, weight-aware swaps, and diversity-promoting perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution based on objective trade-off\n    obj1_vals = np.array([obj[0] for _, obj in archive])\n    obj2_vals = np.array([obj[1] for _, obj in archive])\n    obj1_range = np.max(obj1_vals) - np.min(obj1_vals)\n    obj2_range = np.max(obj2_vals) - np.min(obj2_vals)\n\n    # Select solution with highest combined normalized objective value\n    if obj1_range > 0 and obj2_range > 0:\n        normalized_obj1 = (obj1_vals - np.min(obj1_vals)) / obj1_range\n        normalized_obj2 = (obj2_vals - np.min(obj2_vals)) / obj2_range\n        combined_scores = normalized_obj1 + normalized_obj2\n        selected_idx = np.argmax(combined_scores)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Multi-phase neighborhood generation\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased flips\n    for _ in range(min(3, n_items // 5)):\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) == 0:\n            break\n\n        # Select flip based on objective with lower relative improvement\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_candidates]\n        else:\n            flip_values = value2_lst[flip_candidates]\n\n        if len(flip_candidates) > 0:\n            flip_idx = np.random.choice(flip_candidates)\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n\n    # Phase 2: Weight-aware additions\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        add_candidates = np.where(new_solution == 0)[0]\n        if len(add_candidates) > 0:\n            # Select items with highest combined value-to-weight ratio\n            value_ratio = (value1_lst + value2_lst) / weight_lst\n            sorted_candidates = add_candidates[np.argsort(value_ratio[add_candidates])[::-1]]\n\n            for i in sorted_candidates:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    remaining_capacity -= weight_lst[i]\n                    break\n\n    # Phase 3: Diversity-promoting perturbations\n    if np.random.random() < 0.4:\n        perturb_indices = np.random.choice(n_items, size=min(2, n_items // 3), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.48514697013150987,
            1.746300458908081
        ]
    },
    {
        "algorithm": "{The heuristic function first selects a solution from the archive using a novel \"objective-balanced selection\" strategy that prioritizes solutions with balanced improvements in both objectives, then applies a \"value-aware cluster swap\" operator that intelligently swaps groups of items based on their combined value contributions while maintaining feasibility, followed by a \"diversity-aware perturbation\" that flips items in a way that preserves solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Objective-balanced selection\n    def balance_score(obj):\n        return abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n\n    scores = [balance_score(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Value-aware cluster swap\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Identify clusters of items in solution\n        in_values = value1_lst[in_sol] + value2_lst[in_sol]\n        in_weights = weight_lst[in_sol]\n\n        # Identify clusters of items outside solution\n        out_values = value1_lst[out_sol] + value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Find best cluster to remove (smallest value/weight ratio)\n        in_ratios = in_values / in_weights\n        out_ratios = out_values / out_weights\n\n        remove_cluster = in_sol[np.argsort(in_ratios)[:min(2, len(in_sol))]]\n        add_cluster = out_sol[np.argsort(out_ratios)[-min(2, len(out_sol)):]]\n\n        # Check feasibility for cluster swap\n        total_remove = np.sum(in_weights[np.isin(in_sol, remove_cluster)])\n        total_add = np.sum(out_weights[np.isin(out_sol, add_cluster)])\n\n        if current_weight - total_remove + total_add <= capacity:\n            new_solution[remove_cluster] = 0\n            new_solution[add_cluster] = 1\n            current_weight = current_weight - total_remove + total_add\n\n    # Step 3: Diversity-aware perturbation\n    n_items = len(new_solution)\n    perturbation_size = min(2, n_items // 5)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8173414677123199,
            3.582722008228302
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.767415464854095,
            3.5284809172153473
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently combines adaptive neighborhood exploration with objective-driven flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate potential for improvement (simplified for demonstration)\n            potential = (np.sum(value1_lst) - obj[0]) + (np.sum(value2_lst) - obj[1])\n            candidates.append((potential, sol))\n\n    if not candidates:\n        # Fallback to random selection if no candidates\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-driven flip (prioritize value1 if remaining capacity allows)\n    if remaining_capacity > 0:\n        if random.random() < 0.7:  # 70% chance to flip based on value1\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value1_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n        else:\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value2_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (flip one item to reduce weight if over capacity)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance for random flip\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8321156813734218,
            4.989608705043793
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a dynamic trade-off score that combines objective values and capacity utilization, then applies a novel adaptive neighborhood exploration strategy that combines targeted item replacements with capacity-aware perturbations to generate high-quality feasible neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with dynamic trade-off scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Dynamic score combines normalized objectives and capacity utilization\n        normalized_obj1 = obj[0] / (np.sum(value1_lst) + 1e-8)\n        normalized_obj2 = obj[1] / (np.sum(value2_lst) + 1e-8)\n        utilization = total_weight / capacity\n        score = (normalized_obj1 + normalized_obj2) * (1 - utilization**2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply adaptive neighborhood exploration\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item replacements\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(out_solution) > 0:\n        # Sort items by their marginal value/weight ratio for each objective\n        in_ratio1 = value1_lst[in_solution] / weight_lst[in_solution]\n        in_ratio2 = value2_lst[in_solution] / weight_lst[in_solution]\n        out_ratio1 = value1_lst[out_solution] / weight_lst[out_solution]\n        out_ratio2 = value2_lst[out_solution] / weight_lst[out_solution]\n\n        # Select top candidates from both objectives\n        top_in1 = in_solution[np.argsort(in_ratio1)[-min(2, len(in_solution)):]]\n        top_in2 = in_solution[np.argsort(in_ratio2)[-min(2, len(in_solution)):]]\n        top_out1 = out_solution[np.argsort(out_ratio1)[-min(2, len(out_solution)):]]\n        top_out2 = out_solution[np.argsort(out_ratio2)[-min(2, len(out_solution)):]]\n\n        # Combine and shuffle candidates\n        candidates = np.concatenate([top_in1, top_in2, top_out1, top_out2])\n        np.random.shuffle(candidates)\n\n        for idx in candidates:\n            if new_solution[idx] == 1:\n                # Try to replace with best feasible item from out_solution\n                feasible_out = [i for i in out_solution if current_weight - weight_lst[idx] + weight_lst[i] <= capacity]\n                if feasible_out:\n                    best_out = max(feasible_out, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                    new_solution[idx] = 0\n                    new_solution[best_out] = 1\n                    current_weight = current_weight - weight_lst[idx] + weight_lst[best_out]\n            else:\n                # Try to add if feasible\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 2: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Calculate potential weight after removal\n            potential_weight = current_weight - weight_lst[idx]\n            if potential_weight <= capacity:\n                # Calculate objective impact\n                obj1_impact = value1_lst[idx] / (np.sum(value1_lst) + 1e-8)\n                obj2_impact = value2_lst[idx] / (np.sum(value2_lst) + 1e-8)\n                # Remove if impact is below threshold or with probability\n                if np.random.random() < (obj1_impact + obj2_impact) / 2:\n                    new_solution[idx] = 0\n                    current_weight = potential_weight\n        else:\n            # Calculate potential weight after addition\n            potential_weight = current_weight + weight_lst[idx]\n            if potential_weight <= capacity:\n                # Add with probability based on value density\n                value_density = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n                if np.random.random() < min(1, value_density * 0.5):\n                    new_solution[idx] = 1\n                    current_weight = potential_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8755005490682393,
            8.22445747256279
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware scoring mechanism that prioritizes solutions with high potential for improvement, then applies a hybrid local search operator that combines targeted item replacements and adaptive flips to generate a feasible neighbor solution while maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Score each solution based on its potential for improvement and diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, slack capacity, and diversity\n        diversity_score = np.sum(sol != archive[0][0]) / len(sol)\n        score = (obj[0] + obj[1]) * (1 - (total_weight / capacity)) * (1 + diversity_score)\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item replacements\n    for _ in range(min(3, n_items)):\n        # Select an item to potentially replace\n        i = np.random.randint(n_items)\n        # Find the best replacement candidate (not in current solution)\n        not_in_sol = np.where(new_solution == 0)[0]\n        if len(not_in_sol) > 0:\n            # Evaluate potential replacements based on both objectives\n            potential_values = (value1_lst[not_in_sol] + value2_lst[not_in_sol]) / weight_lst[not_in_sol]\n            j = not_in_sol[np.argmax(potential_values)]\n            # Check feasibility\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips with objective balancing\n    flip_size = min(3, n_items // 4)\n    for _ in range(flip_size):\n        # Select items based on both objectives\n        combined_values = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(combined_values)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try to remove item if feasible\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n            else:\n                # Try to add item if feasible\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8969140326690765,
            3.8953407406806946
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8573971367297398,
            3.205743044614792
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and weight balance, then applies a tiered local search that includes objective-specific flips, weight-aware swaps, and capacity-constrained perturbations, ensuring feasible solutions while exploring the trade-off space more thoroughly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on objective dominance and weight balance\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 - np.sum(weight_lst * sol) / capacity) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Tiered local search\n    n_items = len(base_solution)\n\n    # Tier 1: Objective-specific flips\n    flip_mask = (new_solution == 1)\n    if np.any(flip_mask):\n        obj1_total, obj2_total = archive[selected_idx][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_mask]\n        else:\n            flip_values = value2_lst[flip_mask]\n        flip_indices = np.where(flip_mask)[0]\n        top_flips = flip_indices[np.argsort(flip_values)[-min(2, len(flip_indices)):]]\n        for i in top_flips:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Tier 2: Weight-aware swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                weight_ratio = weight_lst[not_in_sol] / weight_lst[i]\n                similar_items = not_in_sol[np.argsort(np.abs(weight_ratio - 1))[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Tier 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6230837336892188,
            3.07790070772171
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    }
]