[
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently combines adaptive neighborhood exploration with objective-driven flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate potential for improvement (simplified for demonstration)\n            potential = (np.sum(value1_lst) - obj[0]) + (np.sum(value2_lst) - obj[1])\n            candidates.append((potential, sol))\n\n    if not candidates:\n        # Fallback to random selection if no candidates\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-driven flip (prioritize value1 if remaining capacity allows)\n    if remaining_capacity > 0:\n        if random.random() < 0.7:  # 70% chance to flip based on value1\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value1_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n        else:\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value2_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (flip one item to reduce weight if over capacity)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance for random flip\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8321156813734218,
            4.989608705043793
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a multi-criteria scoring mechanism that prioritizes solutions with high potential for local improvement, then applies a novel hybrid local search operator that combines item swaps and adaptive perturbation to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on its potential for improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values and slack capacity\n        score = (obj[0] + obj[1]) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(3, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                j = np.random.choice(not_in_sol)\n                # Check feasibility\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive perturbation\n    perturbation_size = min(2, n_items // 5)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5246759749789403,
            4.732895731925964
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a multi-criteria scoring mechanism that prioritizes solutions with high potential for local improvement, then applies a novel hybrid local search operator that combines item swaps and adaptive perturbation to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on its potential for improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values and slack capacity\n        score = (obj[0] + obj[1]) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(3, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                j = np.random.choice(not_in_sol)\n                # Check feasibility\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive perturbation\n    perturbation_size = min(2, n_items // 5)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5246759749789403,
            4.732895731925964
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently combines adaptive neighborhood exploration with objective-driven flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate potential for improvement (simplified for demonstration)\n            potential = (np.sum(value1_lst) - obj[0]) + (np.sum(value2_lst) - obj[1])\n            candidates.append((potential, sol))\n\n    if not candidates:\n        # Fallback to random selection if no candidates\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-driven flip (prioritize value1 if remaining capacity allows)\n    if remaining_capacity > 0:\n        if random.random() < 0.7:  # 70% chance to flip based on value1\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value1_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n        else:\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value2_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (flip one item to reduce weight if over capacity)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance for random flip\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8321156813734218,
            4.989608705043793
        ]
    }
]