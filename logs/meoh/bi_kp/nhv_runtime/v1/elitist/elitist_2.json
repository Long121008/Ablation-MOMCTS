[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.767415464854095,
            3.5284809172153473
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a dynamic trade-off score that combines objective values and capacity utilization, then applies a novel adaptive neighborhood exploration strategy that combines targeted item replacements with capacity-aware perturbations to generate high-quality feasible neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with dynamic trade-off scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Dynamic score combines normalized objectives and capacity utilization\n        normalized_obj1 = obj[0] / (np.sum(value1_lst) + 1e-8)\n        normalized_obj2 = obj[1] / (np.sum(value2_lst) + 1e-8)\n        utilization = total_weight / capacity\n        score = (normalized_obj1 + normalized_obj2) * (1 - utilization**2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply adaptive neighborhood exploration\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item replacements\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(out_solution) > 0:\n        # Sort items by their marginal value/weight ratio for each objective\n        in_ratio1 = value1_lst[in_solution] / weight_lst[in_solution]\n        in_ratio2 = value2_lst[in_solution] / weight_lst[in_solution]\n        out_ratio1 = value1_lst[out_solution] / weight_lst[out_solution]\n        out_ratio2 = value2_lst[out_solution] / weight_lst[out_solution]\n\n        # Select top candidates from both objectives\n        top_in1 = in_solution[np.argsort(in_ratio1)[-min(2, len(in_solution)):]]\n        top_in2 = in_solution[np.argsort(in_ratio2)[-min(2, len(in_solution)):]]\n        top_out1 = out_solution[np.argsort(out_ratio1)[-min(2, len(out_solution)):]]\n        top_out2 = out_solution[np.argsort(out_ratio2)[-min(2, len(out_solution)):]]\n\n        # Combine and shuffle candidates\n        candidates = np.concatenate([top_in1, top_in2, top_out1, top_out2])\n        np.random.shuffle(candidates)\n\n        for idx in candidates:\n            if new_solution[idx] == 1:\n                # Try to replace with best feasible item from out_solution\n                feasible_out = [i for i in out_solution if current_weight - weight_lst[idx] + weight_lst[i] <= capacity]\n                if feasible_out:\n                    best_out = max(feasible_out, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                    new_solution[idx] = 0\n                    new_solution[best_out] = 1\n                    current_weight = current_weight - weight_lst[idx] + weight_lst[best_out]\n            else:\n                # Try to add if feasible\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 2: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Calculate potential weight after removal\n            potential_weight = current_weight - weight_lst[idx]\n            if potential_weight <= capacity:\n                # Calculate objective impact\n                obj1_impact = value1_lst[idx] / (np.sum(value1_lst) + 1e-8)\n                obj2_impact = value2_lst[idx] / (np.sum(value2_lst) + 1e-8)\n                # Remove if impact is below threshold or with probability\n                if np.random.random() < (obj1_impact + obj2_impact) / 2:\n                    new_solution[idx] = 0\n                    current_weight = potential_weight\n        else:\n            # Calculate potential weight after addition\n            potential_weight = current_weight + weight_lst[idx]\n            if potential_weight <= capacity:\n                # Add with probability based on value density\n                value_density = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n                if np.random.random() < min(1, value_density * 0.5):\n                    new_solution[idx] = 1\n                    current_weight = potential_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8755005490682393,
            8.22445747256279
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently combines adaptive neighborhood exploration with objective-driven flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate potential for improvement (simplified for demonstration)\n            potential = (np.sum(value1_lst) - obj[0]) + (np.sum(value2_lst) - obj[1])\n            candidates.append((potential, sol))\n\n    if not candidates:\n        # Fallback to random selection if no candidates\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-driven flip (prioritize value1 if remaining capacity allows)\n    if remaining_capacity > 0:\n        if random.random() < 0.7:  # 70% chance to flip based on value1\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value1_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n        else:\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value2_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (flip one item to reduce weight if over capacity)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance for random flip\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8321156813734218,
            4.989608705043793
        ]
    },
    {
        "algorithm": "{The heuristic function first selects the solution with the highest combined value-to-weight ratio, then applies a novel \"value-driven diversification\" strategy that strategically replaces low-value items with high-value items while maintaining feasibility, followed by a \"balanced perturbation\" that randomly flips items to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with highest combined value-to-weight ratio\n    ratios = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight == 0:\n            ratio = 0\n        else:\n            ratio = (obj[0] + obj[1]) / total_weight\n        ratios.append(ratio)\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Value-driven diversification\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Sort items in solution by value (ascending) and out by value (descending)\n    if len(in_sol) > 0:\n        in_values = value1_lst[in_sol] + value2_lst[in_sol]\n        low_value_items = in_sol[np.argsort(in_values)[:min(3, len(in_sol))]]\n\n    if len(out_sol) > 0:\n        out_values = value1_lst[out_sol] + value2_lst[out_sol]\n        high_value_items = out_sol[np.argsort(out_values)[-min(3, len(out_sol)):]]\n\n    for i in low_value_items if len(in_sol) > 0 else []:\n        for j in high_value_items if len(out_sol) > 0 else []:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n\n    # Step 3: Balanced perturbation\n    n_items = len(new_solution)\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2956517385439134,
            3.5085119903087616
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a multi-criteria scoring mechanism that prioritizes solutions with high potential for local improvement, then applies a novel hybrid local search operator that combines item swaps and adaptive perturbation to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on its potential for improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values and slack capacity\n        score = (obj[0] + obj[1]) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(3, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                j = np.random.choice(not_in_sol)\n                # Check feasibility\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive perturbation\n    perturbation_size = min(2, n_items // 5)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5246759749789403,
            4.732895731925964
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware scoring mechanism that prioritizes solutions with high potential for improvement, then applies a novel hybrid local search operator that combines multi-objective item flips and adaptive capacity balancing to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Score solutions based on their objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Normalize objectives and add diversity component\n        norm_obj1 = obj[0] / (np.max(value1_lst) + 1e-6)\n        norm_obj2 = obj[1] / (np.max(value2_lst) + 1e-6)\n        diversity = 1 - (total_weight / capacity)\n        score = (norm_obj1 + norm_obj2) * diversity\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Multi-objective item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        for _ in range(min(2, len(flip_candidates))):\n            i = np.random.choice(flip_candidates)\n            # Calculate potential improvement for both objectives\n            delta1 = -value1_lst[i]\n            delta2 = -value2_lst[i]\n            # Find best item to replace (considering both objectives)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Evaluate all possible replacements\n                improvements = []\n                for j in not_in_sol:\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        # Weighted improvement score\n                        imp = (value1_lst[j] * delta1 + value2_lst[j] * delta2) / (weight_lst[j] + 1e-6)\n                        improvements.append((imp, j))\n                if improvements:\n                    best_imp, best_j = max(improvements, key=lambda x: x[0])\n                    new_solution[i], new_solution[best_j] = new_solution[best_j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[best_j]\n\n    # Phase 2: Adaptive capacity balancing\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Try to add items that improve both objectives\n        candidate_adds = []\n        for j in np.where(new_solution == 0)[0]:\n            if weight_lst[j] <= remaining_capacity:\n                # Score based on both objectives and weight efficiency\n                score = (value1_lst[j] + value2_lst[j]) / weight_lst[j]\n                candidate_adds.append((score, j))\n        if candidate_adds:\n            best_score, best_j = max(candidate_adds, key=lambda x: x[0])\n            new_solution[best_j] = 1\n            current_weight += weight_lst[best_j]\n\n    return new_solution\n\n",
        "score": [
            -0.7775543846037577,
            9.138050734996796
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines random perturbations with targeted swaps based on value-to-weight ratios and objective correlations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement\n    def potential_score(sol_obj):\n        sol, (v1, v2) = sol_obj\n        # Score based on dominance area and coverage\n        total_v1 = np.sum(value1_lst[sol == 1])\n        total_v2 = np.sum(value2_lst[sol == 1])\n        total_weight = np.sum(weight_lst[sol == 1])\n        # Normalize potential (higher is better)\n        potential = (total_v1 + total_v2) / (total_weight + 1e-6)\n        return potential\n\n    # Select top 30% solutions with highest potential\n    sorted_archive = sorted(archive, key=potential_score, reverse=True)\n    top_k = max(1, len(sorted_archive) // 3)\n    candidates = sorted_archive[:top_k]\n    base_solution, (base_v1, base_v2) = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_v1 = np.sum(value1_lst[new_solution == 1])\n    current_v2 = np.sum(value2_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    v1_ratios = value1_lst / (weight_lst + 1e-6)\n    v2_ratios = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid strategy: combine random perturbations with targeted swaps\n    for _ in range(5):  # Number of local search steps\n        # Randomly select an item to flip\n        idx = random.randint(0, len(new_solution) - 1)\n\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n        # Additional targeted swap based on objective correlations\n        if random.random() < 0.3:  # 30% chance for targeted swap\n            # Find items with high value-to-weight ratio in the opposite objective\n            if random.random() < 0.5:\n                # Prioritize value1\n                candidate_items = np.where((new_solution == 0) & (v1_ratios > np.mean(v1_ratios)))[0]\n            else:\n                # Prioritize value2\n                candidate_items = np.where((new_solution == 0) & (v2_ratios > np.mean(v2_ratios)))[0]\n\n            if len(candidate_items) > 0:\n                swap_idx = random.choice(candidate_items)\n                new_weight = current_weight + weight_lst[swap_idx]\n                if new_weight <= capacity:\n                    new_solution[swap_idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.31506462919771955,
            5.178975522518158
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Strategy: Randomly flip items to explore the neighborhood while ensuring feasibility\n    # Flip a subset of items and check feasibility\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(base_solution), size=np.random.randint(1, min(5, len(base_solution))), replace=False)\n        flipped_solution = new_solution.copy()\n        flipped_solution[flip_indices] = 1 - flipped_solution[flip_indices]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst * flipped_solution)\n        if new_weight <= capacity:\n            new_solution = flipped_solution\n            break  # Use the first feasible neighbor found\n\n    # Step 3: Apply a greedy refinement to further improve the solution\n    # Iteratively add items with the highest marginal gain in either objective\n    for _ in range(5):  # Limit the number of iterations\n        # Calculate marginal gains for adding each item\n        marginal_gain1 = value1_lst * (1 - new_solution) - np.sum(value1_lst * new_solution) * (weight_lst * (1 - new_solution)) / capacity\n        marginal_gain2 = value2_lst * (1 - new_solution) - np.sum(value2_lst * new_solution) * (weight_lst * (1 - new_solution)) / capacity\n\n        # Combine gains using a weighted sum (e.g., 0.5 for each objective)\n        combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n\n        # Select the item with the highest combined gain\n        best_item = np.argmax(combined_gain)\n        if combined_gain[best_item] > 0 and (new_weight + weight_lst[best_item]) <= capacity:\n            new_solution[best_item] = 1\n            new_weight += weight_lst[best_item]\n\n    return new_solution\n\n",
        "score": [
            -0.36762076785001907,
            6.87561172246933
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel multi-stage local search that combines value-driven swaps, weight-aware perturbations, and diversity-preserving flips to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    best_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Stage 1: Value-driven swaps (prioritize items with highest value per weight ratio)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find best item to swap with (not in solution and feasible)\n            not_in_sol = np.where(new_solution == 0)[0]\n            feasible_swaps = [j for j in not_in_sol if weight_lst[j] <= capacity - current_weight + weight_lst[i]]\n            if feasible_swaps:\n                j = max(feasible_swaps, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Stage 2: Weight-aware perturbations (add/remove items based on weight balance)\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Add items with highest value per weight ratio first\n        candidates_to_add = np.where(new_solution == 0)[0]\n        feasible_adds = [i for i in candidates_to_add if weight_lst[i] <= remaining_capacity]\n        if feasible_adds:\n            best_add = max(feasible_adds, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n            new_solution[best_add] = 1\n            current_weight += weight_lst[best_add]\n    else:\n        # Remove items with lowest value per weight ratio if over capacity\n        candidates_to_remove = np.where(new_solution == 1)[0]\n        worst_remove = min(candidates_to_remove, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n        new_solution[worst_remove] = 0\n        current_weight -= weight_lst[worst_remove]\n\n    # Stage 3: Diversity-preserving flip (randomly flip one item to maintain diversity)\n    if random.random() < 0.5:\n        flip_candidates = [i for i in range(len(weight_lst)) if (new_solution[i] == 0 and weight_lst[i] <= capacity - current_weight) or\n                          (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity)]\n        if flip_candidates:\n            flip_idx = random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30611882949063796,
            5.3826504945755005
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently combines adaptive neighborhood exploration with objective-driven flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate potential for improvement (simplified for demonstration)\n            potential = (np.sum(value1_lst) - obj[0]) + (np.sum(value2_lst) - obj[1])\n            candidates.append((potential, sol))\n\n    if not candidates:\n        # Fallback to random selection if no candidates\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-driven flip (prioritize value1 if remaining capacity allows)\n    if remaining_capacity > 0:\n        if random.random() < 0.7:  # 70% chance to flip based on value1\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value1_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n        else:\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value2_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (flip one item to reduce weight if over capacity)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance for random flip\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8321156813734218,
            4.989608705043793
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a dynamic trade-off score that combines objective values and capacity utilization, then applies a novel adaptive neighborhood exploration strategy that combines targeted item replacements with capacity-aware perturbations to generate high-quality feasible neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with dynamic trade-off scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Dynamic score combines normalized objectives and capacity utilization\n        normalized_obj1 = obj[0] / (np.sum(value1_lst) + 1e-8)\n        normalized_obj2 = obj[1] / (np.sum(value2_lst) + 1e-8)\n        utilization = total_weight / capacity\n        score = (normalized_obj1 + normalized_obj2) * (1 - utilization**2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply adaptive neighborhood exploration\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item replacements\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(out_solution) > 0:\n        # Sort items by their marginal value/weight ratio for each objective\n        in_ratio1 = value1_lst[in_solution] / weight_lst[in_solution]\n        in_ratio2 = value2_lst[in_solution] / weight_lst[in_solution]\n        out_ratio1 = value1_lst[out_solution] / weight_lst[out_solution]\n        out_ratio2 = value2_lst[out_solution] / weight_lst[out_solution]\n\n        # Select top candidates from both objectives\n        top_in1 = in_solution[np.argsort(in_ratio1)[-min(2, len(in_solution)):]]\n        top_in2 = in_solution[np.argsort(in_ratio2)[-min(2, len(in_solution)):]]\n        top_out1 = out_solution[np.argsort(out_ratio1)[-min(2, len(out_solution)):]]\n        top_out2 = out_solution[np.argsort(out_ratio2)[-min(2, len(out_solution)):]]\n\n        # Combine and shuffle candidates\n        candidates = np.concatenate([top_in1, top_in2, top_out1, top_out2])\n        np.random.shuffle(candidates)\n\n        for idx in candidates:\n            if new_solution[idx] == 1:\n                # Try to replace with best feasible item from out_solution\n                feasible_out = [i for i in out_solution if current_weight - weight_lst[idx] + weight_lst[i] <= capacity]\n                if feasible_out:\n                    best_out = max(feasible_out, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                    new_solution[idx] = 0\n                    new_solution[best_out] = 1\n                    current_weight = current_weight - weight_lst[idx] + weight_lst[best_out]\n            else:\n                # Try to add if feasible\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 2: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Calculate potential weight after removal\n            potential_weight = current_weight - weight_lst[idx]\n            if potential_weight <= capacity:\n                # Calculate objective impact\n                obj1_impact = value1_lst[idx] / (np.sum(value1_lst) + 1e-8)\n                obj2_impact = value2_lst[idx] / (np.sum(value2_lst) + 1e-8)\n                # Remove if impact is below threshold or with probability\n                if np.random.random() < (obj1_impact + obj2_impact) / 2:\n                    new_solution[idx] = 0\n                    current_weight = potential_weight\n        else:\n            # Calculate potential weight after addition\n            potential_weight = current_weight + weight_lst[idx]\n            if potential_weight <= capacity:\n                # Add with probability based on value density\n                value_density = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n                if np.random.random() < min(1, value_density * 0.5):\n                    new_solution[idx] = 1\n                    current_weight = potential_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8755005490682393,
            8.22445747256279
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.767415464854095,
            3.5284809172153473
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently combines adaptive neighborhood exploration with objective-driven flips, guided by a dynamic trade-off between value improvements in both objectives, while ensuring feasibility through constrained random flips and weight-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            # Calculate potential for improvement (simplified for demonstration)\n            potential = (np.sum(value1_lst) - obj[0]) + (np.sum(value2_lst) - obj[1])\n            candidates.append((potential, sol))\n\n    if not candidates:\n        # Fallback to random selection if no candidates\n        return archive[random.randint(0, len(archive)-1)][0].copy()\n\n    # Select the candidate with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Step 1: Objective-driven flip (prioritize value1 if remaining capacity allows)\n    if remaining_capacity > 0:\n        if random.random() < 0.7:  # 70% chance to flip based on value1\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value1_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n        else:\n            candidates_to_add = [i for i in range(len(weight_lst)) if not new_solution[i] and weight_lst[i] <= remaining_capacity]\n            if candidates_to_add:\n                best_candidate = max(candidates_to_add, key=lambda i: value2_lst[i])\n                new_solution[best_candidate] = 1\n                remaining_capacity -= weight_lst[best_candidate]\n\n    # Step 2: Weight-aware perturbation (flip one item to reduce weight if over capacity)\n    if remaining_capacity < 0:\n        candidates_to_remove = [i for i in range(len(weight_lst)) if new_solution[i]]\n        if candidates_to_remove:\n            worst_candidate = min(candidates_to_remove, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_candidate] = 0\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance for random flip\n        candidates_to_flip = [i for i in range(len(weight_lst)) if weight_lst[i] <= remaining_capacity]\n        if candidates_to_flip:\n            flip_idx = random.choice(candidates_to_flip)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8321156813734218,
            4.989608705043793
        ]
    }
]