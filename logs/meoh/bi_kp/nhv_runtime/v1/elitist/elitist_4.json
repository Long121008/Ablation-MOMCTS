[
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and item diversity, then applies a multi-stage local search combining value-driven swaps, capacity-aware perturbations, and objective-balanced flips to generate high-quality feasible neighbors while ensuring both objectives are improved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high objective diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        obj_diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * obj_diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-stage local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Stage 1: Value-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate value-to-weight ratios for out-of-solution items\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidates = np.argsort(value_ratios)[-min(2, len(value_ratios)):]\n\n        for candidate in best_candidates:\n            j = out_sol[candidate]\n            # Find the worst item in current solution to swap with\n            if len(in_sol) > 0:\n                in_values = value1_lst[in_sol] + value2_lst[in_sol]\n                worst_item = in_sol[np.argmin(in_values)]\n                if current_weight - weight_lst[worst_item] + weight_lst[j] <= capacity:\n                    new_solution[worst_item], new_solution[j] = new_solution[j], new_solution[worst_item]\n                    current_weight = current_weight - weight_lst[worst_item] + weight_lst[j]\n                    in_sol = np.where(new_solution == 1)[0]\n                    out_sol = np.where(new_solution == 0)[0]\n\n    # Stage 2: Capacity-aware perturbations\n    perturbation_count = min(3, n_items // 5)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_count, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Stage 3: Objective-balanced flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n\n        if obj1_total < obj2_total:\n            # Prefer items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        flip_order = np.argsort(flip_values)[::-1]\n        for i in flip_order[:min(2, len(flip_order))]:\n            idx = flip_candidates[i]\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.53028187073352,
            2.9376628398895264
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8573971367297398,
            3.205743044614792
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and weight balance, then applies a tiered local search that includes objective-specific flips, weight-aware swaps, and capacity-constrained perturbations, ensuring feasible solutions while exploring the trade-off space more thoroughly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on objective dominance and weight balance\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 - np.sum(weight_lst * sol) / capacity) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Tiered local search\n    n_items = len(base_solution)\n\n    # Tier 1: Objective-specific flips\n    flip_mask = (new_solution == 1)\n    if np.any(flip_mask):\n        obj1_total, obj2_total = archive[selected_idx][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_mask]\n        else:\n            flip_values = value2_lst[flip_mask]\n        flip_indices = np.where(flip_mask)[0]\n        top_flips = flip_indices[np.argsort(flip_values)[-min(2, len(flip_indices)):]]\n        for i in top_flips:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Tier 2: Weight-aware swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                weight_ratio = weight_lst[not_in_sol] / weight_lst[i]\n                similar_items = not_in_sol[np.argsort(np.abs(weight_ratio - 1))[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Tier 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6230837336892188,
            3.07790070772171
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm employs a dynamic multi-objective neighborhood exploration strategy that combines adaptive knapsack packing with objective-balanced perturbations, using a weighted random selection mechanism to prioritize items based on their contribution to both objectives while maintaining feasibility through capacity-aware item swaps and removal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted combination of objectives and capacity utilization\n    weights = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Weight combines both objectives and capacity utilization\n        weight = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity))\n        weights.append(weight)\n\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate item effectiveness for both objectives\n    effectiveness1 = value1_lst / weight_lst\n    effectiveness2 = value2_lst / weight_lst\n    combined_effectiveness = effectiveness1 * 0.7 + effectiveness2 * 0.3  # Weighted combination\n\n    # Phase 1: Add high-effectiveness items not in solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        candidates = not_in_solution[np.argsort(combined_effectiveness[not_in_solution])[::-1]]\n        for i in candidates:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                if current_weight >= capacity * 0.9:  # Stop if close to capacity\n                    break\n\n    # Phase 2: Remove low-effectiveness items in solution\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) > 0:\n        candidates = in_solution[np.argsort(combined_effectiveness[in_solution])]\n        for i in candidates:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                if current_weight <= capacity * 0.1:  # Stop if too light\n                    break\n\n    # Phase 3: Objective-balanced perturbation\n    if random.random() < 0.4:  # 40% chance for perturbation\n        perturb_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for i in perturb_indices:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9081045940426637,
            3.481134980916977
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-biased selection with capacity-aware perturbations, using a dynamic trade-off between value improvements in both objectives while intelligently balancing neighborhood exploration and exploitation through a multi-phase approach that includes adaptive item flips, weight-aware swaps, and diversity-promoting perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution based on objective trade-off\n    obj1_vals = np.array([obj[0] for _, obj in archive])\n    obj2_vals = np.array([obj[1] for _, obj in archive])\n    obj1_range = np.max(obj1_vals) - np.min(obj1_vals)\n    obj2_range = np.max(obj2_vals) - np.min(obj2_vals)\n\n    # Select solution with highest combined normalized objective value\n    if obj1_range > 0 and obj2_range > 0:\n        normalized_obj1 = (obj1_vals - np.min(obj1_vals)) / obj1_range\n        normalized_obj2 = (obj2_vals - np.min(obj2_vals)) / obj2_range\n        combined_scores = normalized_obj1 + normalized_obj2\n        selected_idx = np.argmax(combined_scores)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Multi-phase neighborhood generation\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased flips\n    for _ in range(min(3, n_items // 5)):\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) == 0:\n            break\n\n        # Select flip based on objective with lower relative improvement\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_candidates]\n        else:\n            flip_values = value2_lst[flip_candidates]\n\n        if len(flip_candidates) > 0:\n            flip_idx = np.random.choice(flip_candidates)\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n\n    # Phase 2: Weight-aware additions\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        add_candidates = np.where(new_solution == 0)[0]\n        if len(add_candidates) > 0:\n            # Select items with highest combined value-to-weight ratio\n            value_ratio = (value1_lst + value2_lst) / weight_lst\n            sorted_candidates = add_candidates[np.argsort(value_ratio[add_candidates])[::-1]]\n\n            for i in sorted_candidates:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    remaining_capacity -= weight_lst[i]\n                    break\n\n    # Phase 3: Diversity-promoting perturbations\n    if np.random.random() < 0.4:\n        perturb_indices = np.random.choice(n_items, size=min(2, n_items // 3), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.48514697013150987,
            1.746300458908081
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and solution density, then applies a hybrid local search combining adaptive item swaps and targeted flips that prioritize both objectives while maintaining feasibility through a capacity-aware selection process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with balanced objective weights and density consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        density = np.sum(sol) / len(sol)\n        score = (obj[0] * 0.7 + obj[1] * 0.3) * (1 - (total_weight / capacity)) * (1 + 0.3 * density)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Adaptive item swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        sorted_in = in_sol[np.argsort(value_ratio[in_sol])]\n        sorted_out = out_sol[np.argsort(value_ratio[out_sol])[::-1]]\n        for i in sorted_in[:min(2, len(sorted_in))]:\n            for j in sorted_out[:min(2, len(sorted_out))]:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    break\n\n    # Phase 2: Targeted flips based on value density\n    flip_candidates = np.argsort((value1_lst * 0.6 + value2_lst * 0.4) / weight_lst)[::-1]\n    flip_count = min(2, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9052095643280694,
            3.6606931686401367
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-aware scoring mechanism that prioritizes solutions in less crowded regions of the objective space, then applies a hybrid local search operator that combines targeted item swaps and adaptive objective-specific flips to generate a feasible neighbor solution while maintaining exploration diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m] == 0:\n                continue\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item swaps\n    for _ in range(min(4, n_items)):\n        # Select two items to swap\n        i, j = np.random.choice(n_items, 2, replace=False)\n        # Check feasibility\n        if new_solution[i] != new_solution[j] and abs(weight_lst[i] - weight_lst[j]) <= capacity - current_weight + weight_lst[i]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Objective-specific flips\n    for obj_idx in range(2):\n        flip_size = min(2, n_items // 5)\n        for _ in range(flip_size):\n            if obj_idx == 0:\n                values = value1_lst\n            else:\n                values = value2_lst\n            sorted_indices = np.argsort(values)[::-1]\n            for idx in sorted_indices:\n                if new_solution[idx] == 1:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                        break\n                else:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8179699275052885,
            3.6089115142822266
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware scoring mechanism that prioritizes solutions with high potential for improvement, then applies a hybrid local search operator that combines targeted item replacements and adaptive flips to generate a feasible neighbor solution while maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Score each solution based on its potential for improvement and diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, slack capacity, and diversity\n        diversity_score = np.sum(sol != archive[0][0]) / len(sol)\n        score = (obj[0] + obj[1]) * (1 - (total_weight / capacity)) * (1 + diversity_score)\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted item replacements\n    for _ in range(min(3, n_items)):\n        # Select an item to potentially replace\n        i = np.random.randint(n_items)\n        # Find the best replacement candidate (not in current solution)\n        not_in_sol = np.where(new_solution == 0)[0]\n        if len(not_in_sol) > 0:\n            # Evaluate potential replacements based on both objectives\n            potential_values = (value1_lst[not_in_sol] + value2_lst[not_in_sol]) / weight_lst[not_in_sol]\n            j = not_in_sol[np.argmax(potential_values)]\n            # Check feasibility\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips with objective balancing\n    flip_size = min(3, n_items // 4)\n    for _ in range(flip_size):\n        # Select items based on both objectives\n        combined_values = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(combined_values)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try to remove item if feasible\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n            else:\n                # Try to add item if feasible\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8969140326690765,
            3.8953407406806946
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8573971367297398,
            3.205743044614792
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and weight balance, then applies a tiered local search that includes objective-specific flips, weight-aware swaps, and capacity-constrained perturbations, ensuring feasible solutions while exploring the trade-off space more thoroughly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on objective dominance and weight balance\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 - np.sum(weight_lst * sol) / capacity) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Tiered local search\n    n_items = len(base_solution)\n\n    # Tier 1: Objective-specific flips\n    flip_mask = (new_solution == 1)\n    if np.any(flip_mask):\n        obj1_total, obj2_total = archive[selected_idx][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_mask]\n        else:\n            flip_values = value2_lst[flip_mask]\n        flip_indices = np.where(flip_mask)[0]\n        top_flips = flip_indices[np.argsort(flip_values)[-min(2, len(flip_indices)):]]\n        for i in top_flips:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Tier 2: Weight-aware swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                weight_ratio = weight_lst[not_in_sol] / weight_lst[i]\n                similar_items = not_in_sol[np.argsort(np.abs(weight_ratio - 1))[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Tier 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6230837336892188,
            3.07790070772171
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and item diversity, then applies a multi-stage local search combining value-driven swaps, capacity-aware perturbations, and objective-balanced flips to generate high-quality feasible neighbors while ensuring both objectives are improved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high objective diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        obj_diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * obj_diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-stage local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Stage 1: Value-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate value-to-weight ratios for out-of-solution items\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidates = np.argsort(value_ratios)[-min(2, len(value_ratios)):]\n\n        for candidate in best_candidates:\n            j = out_sol[candidate]\n            # Find the worst item in current solution to swap with\n            if len(in_sol) > 0:\n                in_values = value1_lst[in_sol] + value2_lst[in_sol]\n                worst_item = in_sol[np.argmin(in_values)]\n                if current_weight - weight_lst[worst_item] + weight_lst[j] <= capacity:\n                    new_solution[worst_item], new_solution[j] = new_solution[j], new_solution[worst_item]\n                    current_weight = current_weight - weight_lst[worst_item] + weight_lst[j]\n                    in_sol = np.where(new_solution == 1)[0]\n                    out_sol = np.where(new_solution == 0)[0]\n\n    # Stage 2: Capacity-aware perturbations\n    perturbation_count = min(3, n_items // 5)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_count, replace=False)\n\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Stage 3: Objective-balanced flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n\n        if obj1_total < obj2_total:\n            # Prefer items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        flip_order = np.argsort(flip_values)[::-1]\n        for i in flip_order[:min(2, len(flip_order))]:\n            idx = flip_candidates[i]\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.53028187073352,
            2.9376628398895264
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score that combines objective values and item diversity, then applies a hybrid local search combining targeted swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with diversity consideration\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - (total_weight / capacity)) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Targeted swaps based on value ratios\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst[out_sol] + value2_lst[out_sol]) / weight_lst[out_sol]\n        best_candidate = np.argmax(value_ratios)\n        i = np.random.choice(in_sol)\n        j = out_sol[best_candidate]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive flips based on value density\n    flip_candidates = np.argsort((value1_lst + value2_lst) / weight_lst)[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8573971367297398,
            3.205743044614792
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and weight balance, then applies a tiered local search that includes objective-specific flips, weight-aware swaps, and capacity-constrained perturbations, ensuring feasible solutions while exploring the trade-off space more thoroughly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on objective dominance and weight balance\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 - np.sum(weight_lst * sol) / capacity) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Tiered local search\n    n_items = len(base_solution)\n\n    # Tier 1: Objective-specific flips\n    flip_mask = (new_solution == 1)\n    if np.any(flip_mask):\n        obj1_total, obj2_total = archive[selected_idx][1]\n        if obj1_total < obj2_total:\n            flip_values = value1_lst[flip_mask]\n        else:\n            flip_values = value2_lst[flip_mask]\n        flip_indices = np.where(flip_mask)[0]\n        top_flips = flip_indices[np.argsort(flip_values)[-min(2, len(flip_indices)):]]\n        for i in top_flips:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Tier 2: Weight-aware swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                weight_ratio = weight_lst[not_in_sol] / weight_lst[i]\n                similar_items = not_in_sol[np.argsort(np.abs(weight_ratio - 1))[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Tier 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6230837336892188,
            3.07790070772171
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    }
]