[
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined efficiency score that considers both objectives and weight balance, then applies a multi-phase local search combining objective-driven swaps, weight-aware perturbations, and capacity-constrained flips to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined efficiency score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity) ** 1.5)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_in = in_sol[np.argmin(obj_ratio[in_sol])]\n        best_out = out_sol[np.argmax(obj_ratio[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware perturbations\n    perturb_size = min(2, n_items // 5)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst * value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9163148859143637,
            2.689841091632843
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel dominance-aware selection criterion that prioritizes solutions with high potential for improvement in either objective, then applies a three-phase local search that includes objective-balanced swaps, adaptive neighborhood exploration with capacity constraints, and a final diversification phase to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Dominance-aware solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    selection_scores = []\n\n    for i in range(len(archive)):\n        score = (max_obj[0] - objectives[i, 0]) + (max_obj[1] - objectives[i, 1])\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-balanced swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective with balance\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = (in_values + value1_lst[in_sol] + value2_lst[in_sol]) / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = (out_values + value1_lst[out_sol] + value2_lst[out_sol]) / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive neighborhood exploration with capacity constraints\n    neighborhood_size = min(5, n_items // 4)\n    neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n    for idx in neighborhood:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if weight_lst[idx] <= capacity - current_weight:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Final diversification\n    if random.random() < 0.3:\n        flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n        for idx in flip_candidates[:min(3, len(flip_candidates))]:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9773438041916379,
            4.017314702272415
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-aware score that balances both objectives, then applies a two-phase local search combining objective-driven swaps and capacity-constrained flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on dominance-aware score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            scores.append(-float('inf'))\n            continue\n        score = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply two-phase local search\n    n_items = len(new_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj1_ratios = value1_lst / weight_lst\n        obj2_ratios = value2_lst / weight_lst\n        best_in = in_sol[np.argmin(obj1_ratios[in_sol] + obj2_ratios[in_sol])]\n        best_out = out_sol[np.argmax(obj1_ratios[out_sol] + obj2_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7843467352057273,
            2.3594504296779633
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined efficiency score that considers both objectives and weight balance, then applies a multi-phase local search combining objective-driven swaps, weight-aware perturbations, and capacity-constrained flips to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined efficiency score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity) ** 1.5)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_in = in_sol[np.argmin(obj_ratio[in_sol])]\n        best_out = out_sol[np.argmax(obj_ratio[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware perturbations\n    perturb_size = min(2, n_items // 5)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst * value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9163148859143637,
            2.689841091632843
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel dominance-aware selection criterion that prioritizes solutions with high potential for improvement in either objective, then applies a three-phase local search that includes objective-balanced swaps, adaptive neighborhood exploration with capacity constraints, and a final diversification phase to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Dominance-aware solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    selection_scores = []\n\n    for i in range(len(archive)):\n        score = (max_obj[0] - objectives[i, 0]) + (max_obj[1] - objectives[i, 1])\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-balanced swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective with balance\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = (in_values + value1_lst[in_sol] + value2_lst[in_sol]) / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = (out_values + value1_lst[out_sol] + value2_lst[out_sol]) / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive neighborhood exploration with capacity constraints\n    neighborhood_size = min(5, n_items // 4)\n    neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n    for idx in neighborhood:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if weight_lst[idx] <= capacity - current_weight:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Final diversification\n    if random.random() < 0.3:\n        flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n        for idx in flip_candidates[:min(3, len(flip_candidates))]:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9773438041916379,
            4.017314702272415
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined efficiency score that considers both objectives and weight balance, then applies a multi-phase local search combining objective-driven swaps, weight-aware perturbations, and capacity-constrained flips to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined efficiency score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity) ** 1.5)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_in = in_sol[np.argmin(obj_ratio[in_sol])]\n        best_out = out_sol[np.argmax(obj_ratio[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware perturbations\n    perturb_size = min(2, n_items // 5)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst * value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9163148859143637,
            2.689841091632843
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined efficiency score that considers both objectives and weight balance, then applies a multi-phase local search combining objective-driven swaps, weight-aware perturbations, and capacity-constrained flips to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined efficiency score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity) ** 1.5)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_in = in_sol[np.argmin(obj_ratio[in_sol])]\n        best_out = out_sol[np.argmax(obj_ratio[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware perturbations\n    perturb_size = min(2, n_items // 5)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst * value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9163148859143637,
            2.689841091632843
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined efficiency score that considers both objectives and weight balance, then applies a multi-phase local search combining objective-driven swaps, weight-aware perturbations, and capacity-constrained flips to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined efficiency score\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity) ** 1.5)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-driven swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        obj_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_in = in_sol[np.argmin(obj_ratio[in_sol])]\n        best_out = out_sol[np.argmax(obj_ratio[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware perturbations\n    perturb_size = min(2, n_items // 5)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained flips\n    flip_candidates = np.argsort((value1_lst * value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9163148859143637,
            2.689841091632843
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel hypervolume-based selection criterion that balances objective dominance and solution quality, then applies a four-phase local search that includes objective-specific item swaps, weight-balanced flips, a diversification phase with adaptive neighborhood exploration, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolumes = []\n\n    for i in range(len(archive)):\n        contrib = (max_obj[0] - objectives[i, 0]) * (max_obj[1] - objectives[i, 1])\n        hypervolumes.append(contrib)\n\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(4, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Adaptive neighborhood diversification\n    if random.random() < 0.4:\n        neighborhood_size = min(5, n_items // 3)\n        neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n        for idx in neighborhood:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 4: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Add items with highest combined value-to-weight ratio\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(potential_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8787549804228839,
            2.149842292070389
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a novel three-phase local search strategy that first performs targeted flips to balance objectives, followed by a weight-optimized flip phase, and concludes with a diversification step that explores new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing flips\n    if len(in_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Flip the item with worst balance if beneficial\n        if current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Phase 2: Weight-optimized flip phase\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(3, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.3:  # 30% chance for diversification\n        # Remove least impactful items\n        if len(in_sol) > 0:\n            in_v1 = value1_lst[in_sol]\n            in_v2 = value2_lst[in_sol]\n            impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add most impactful items\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9205814541779771,
            3.319033980369568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6169773960223719,
            1.785381406545639
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    }
]