[
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel objective-weighted selection criterion that prioritizes solutions with high potential for improvement in either objective, then applies a two-phase local search that includes objective-balanced item swaps and a capacity-optimized refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Objective-weighted solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    obj_weights = np.array([0.6, 0.4])  # Prioritize value1 more than value2\n    weighted_scores = []\n\n    for i in range(len(archive)):\n        score = (max_obj[0] - objectives[i, 0]) * obj_weights[0] + (max_obj[1] - objectives[i, 1]) * obj_weights[1]\n        weighted_scores.append(score)\n\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Two-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-balanced item swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        in_weights = weight_lst[in_sol]\n\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        # Calculate potential improvements\n        v1_improvement = (out_v1[:, None] - in_v1) / (out_weights[:, None] - in_weights + 1e-6)\n        v2_improvement = (out_v2[:, None] - in_v2) / (out_weights[:, None] - in_weights + 1e-6)\n\n        combined_improvement = v1_improvement * obj_weights[0] + v2_improvement * obj_weights[1]\n\n        # Find best swaps\n        best_swaps = np.unravel_index(np.argmax(combined_improvement), combined_improvement.shape)\n        out_idx, in_idx = best_swaps\n\n        if (current_weight - in_weights[in_idx] + out_weights[out_idx]) <= capacity:\n            new_solution[in_sol[in_idx]] = 0\n            new_solution[out_sol[out_idx]] = 1\n            current_weight = current_weight - in_weights[in_idx] + out_weights[out_idx]\n\n    # Phase 2: Capacity-optimized refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        combined_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(combined_scores[valid_candidates])]\n            idx = out_sol[best_candidate]\n            new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9258875246560838,
            2.137506365776062
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel dominance-based selection criterion that prioritizes solutions with high potential for improvement in both objectives, then applies a three-phase local search that includes objective-specific item additions, a weight-balanced diversification phase, and a final capacity-aware refinement step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Dominance-based solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    dominance_scores = []\n\n    for i in range(len(archive)):\n        score = (max_obj[0] - objectives[i, 0]) + (max_obj[1] - objectives[i, 1])\n        dominance_scores.append(score)\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item additions\n    if len(out_sol) > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                out_values = out_v1\n            else:\n                out_values = out_v2\n\n            potential_scores = out_values / (out_weights + 1e-6)\n            valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n            if len(valid_candidates) > 0:\n                best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n                idx = out_sol[best_candidate]\n\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 2: Weight-balanced diversification\n    if random.random() < 0.3:\n        flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n        for idx in flip_candidates[:min(3, len(flip_candidates))]:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        combined_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(combined_scores[valid_candidates])[-min(2, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8781704123455665,
            1.5034649670124054
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that combines both value dimensions with a weight penalty, then applies a multi-phase local search combining value-balanced swaps, weight-aware flips, and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on normalized objective score with weight penalty\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        normalized_obj = (obj[0] / (np.max(value1_lst) + 1e-6), obj[1] / (np.max(value2_lst) + 1e-6))\n        score = (normalized_obj[0] + normalized_obj[1]) / 2 * (1 - (total_weight / capacity) ** 2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-balanced swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_balance = (value1_lst + value2_lst) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n        best_in = in_sol[np.argmin(value_balance[in_sol])]\n        best_out = out_sol[np.argmax(value_balance[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-aware flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained perturbations\n    perturb_size = min(3, n_items // 3)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -1.018481273029035,
            4.408885180950165
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel objective-balanced selection criterion that prioritizes solutions with high potential for improvement in either objective, then applies a four-phase local search that includes objective-specific item additions, a weight-aware diversification phase, a capacity-constrained refinement step, and a final objective-balanced swap phase to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Objective-balanced solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    selection_scores = []\n\n    for i in range(len(archive)):\n        score = (max_obj[0] - objectives[i, 0]) * 0.6 + (max_obj[1] - objectives[i, 1]) * 0.4\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-specific item additions\n    if len(out_sol) > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                out_values = out_v1\n            else:\n                out_values = out_v2\n\n            potential_scores = out_values / (out_weights + 1e-6)\n            valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n            if len(valid_candidates) > 0:\n                best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n                idx = out_sol[best_candidate]\n\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 2: Weight-aware diversification\n    if random.random() < 0.4:\n        flip_candidates = np.argsort(weight_lst)[::-1]\n        for idx in flip_candidates[:min(4, len(flip_candidates))]:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-constrained refinement\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        combined_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidates = valid_candidates[np.argsort(combined_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in best_candidates:\n                idx = out_sol[j]\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity -= weight_lst[idx]\n\n    # Phase 4: Objective-balanced swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        in_weights = weight_lst[in_sol]\n        out_weights = weight_lst[out_sol]\n\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                remove_scores = in_values / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                add_scores = out_values / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9636236794059108,
            2.1604917645454407
        ]
    },
    {
        "algorithm": "{This algorithm first selects a solution from the archive based on a novel objective-ratio selection criterion that prioritizes solutions with high potential for improvement in either objective, then applies a four-phase local search that includes objective-balanced item flips, capacity-aware neighborhood exploration, value-weighted diversification, and a final equilibrium adjustment phase to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Objective-ratio solution selection\n    objectives = np.array([obj for _, obj in archive])\n    obj_ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(obj_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Four-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-balanced item flips\n    if len(in_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        in_weights = weight_lst[in_sol]\n\n        flip_scores = (in_v1 + in_v2) / (in_weights + 1e-6)\n        flip_order = np.argsort(flip_scores)[::-1]\n\n        for idx in flip_order[:min(3, len(flip_order))]:\n            if current_weight - in_weights[idx] <= capacity:\n                new_solution[in_sol[idx]] = 0\n                current_weight -= in_weights[idx]\n\n    # Phase 2: Capacity-aware neighborhood exploration\n    neighborhood_size = min(5, n_items // 3)\n    neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n    for idx in neighborhood:\n        if new_solution[idx] == 0 and weight_lst[idx] <= capacity - current_weight:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Phase 3: Value-weighted diversification\n    if random.random() < 0.4:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        combined_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(combined_scores[valid_candidates])]\n            idx = out_sol[best_candidate]\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Phase 4: Final equilibrium adjustment\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0 and len(out_sol) > 0:\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n\n        equilibrium_scores = (out_v1 * out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= remaining_capacity)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(equilibrium_scores[valid_candidates])]\n            idx = out_sol[best_candidate]\n            new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9249555663789886,
            1.62503120303154
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective values, weight efficiency, and item diversity, then applies a novel three-phase local search strategy that first performs targeted swaps to balance objectives, followed by adaptive flips to optimize weight utilization, and concludes with a diversification step to explore new solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on hybrid scoring\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        score = weight_efficiency * (1 + 0.3 * diversity) * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Targeted objective-balancing swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Calculate objective balance scores for in-items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        balance_scores = np.abs(in_v1 - in_v2) / (in_v1 + in_v2 + 1e-6)\n        worst_balance_idx = np.argmax(balance_scores)\n        i = in_sol[worst_balance_idx]\n\n        # Find best out-item to swap with\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_gains = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight + weight_lst[i])[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_gains[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive weight optimization flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    flip_count = min(5, len(flip_candidates))\n    for idx in flip_candidates[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Diversification step\n    if random.random() < 0.2:  # 20% chance for diversification\n        # Remove low-impact items and add high-impact items\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        impact_scores = (in_v1 + in_v2) / (weight_lst[in_sol] + 1e-6)\n        if len(impact_scores) > 0:\n            worst_impact_idx = np.argmin(impact_scores)\n            i = in_sol[worst_impact_idx]\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n        # Add new items with high potential\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n        out_weights = weight_lst[out_sol]\n        potential_scores = (out_v1 + out_v2) / (out_weights + 1e-6)\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n\n        if len(valid_candidates) > 0:\n            best_candidate = valid_candidates[np.argmax(potential_scores[valid_candidates])]\n            j = out_sol[best_candidate]\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.974397308122354,
            3.3541338741779327
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines dominance scores with item diversity metrics, then applies a two-phase local search that includes a multi-objective greedy insertion phase followed by a capacity-optimized diversification step to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    diversity_scores = np.sum(archive[0][0] != archive[1][0]) if len(archive) > 1 else 0\n    hybrid_scores = (max_obj[0] - objectives[:, 0]) + (max_obj[1] - objectives[:, 1]) + diversity_scores\n\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Multi-objective greedy insertion\n    out_sol = np.where(new_solution == 0)[0]\n    if len(out_sol) > 0:\n        out_weights = weight_lst[out_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Calculate normalized scores for both objectives\n        v1_scores = out_v1 / (out_weights + 1e-6)\n        v2_scores = out_v2 / (out_weights + 1e-6)\n\n        # Combine scores with different weights\n        combined_scores = 0.6 * v1_scores + 0.4 * v2_scores\n\n        # Select top candidates\n        valid_candidates = np.where(out_weights <= capacity - current_weight)[0]\n        if len(valid_candidates) > 0:\n            top_candidates = valid_candidates[np.argsort(combined_scores[valid_candidates])[-min(3, len(valid_candidates)):]]\n            for j in top_candidates:\n                idx = out_sol[j]\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Phase 2: Capacity-optimized diversification\n    in_sol = np.where(new_solution == 1)[0]\n    if len(in_sol) > 0 and random.random() < 0.4:\n        # Calculate removal potential\n        removal_scores = (value1_lst[in_sol] + value2_lst[in_sol]) / (weight_lst[in_sol] + 1e-6)\n        worst_items = np.argsort(removal_scores)[:min(2, len(in_sol))]\n\n        for j in worst_items:\n            idx = in_sol[j]\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8237563116223877,
            1.4160197973251343
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a novel dominance-aware selection criterion that prioritizes solutions with high potential for improvement in either objective, then applies a three-phase local search that includes objective-balanced swaps, adaptive neighborhood exploration with capacity constraints, and a final diversification phase to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Dominance-aware solution selection\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    selection_scores = []\n\n    for i in range(len(archive)):\n        score = (max_obj[0] - objectives[i, 0]) + (max_obj[1] - objectives[i, 1])\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Three-phase local search\n    n_items = len(new_solution)\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n\n    # Phase 1: Objective-balanced swaps\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        in_v1 = value1_lst[in_sol]\n        in_v2 = value2_lst[in_sol]\n        out_v1 = value1_lst[out_sol]\n        out_v2 = value2_lst[out_sol]\n\n        # Find best swap for each objective with balance\n        for obj_idx in [0, 1]:\n            if obj_idx == 0:\n                in_values = in_v1\n                out_values = out_v1\n            else:\n                in_values = in_v2\n                out_values = out_v2\n\n            if np.sum(in_values) > 0 and np.sum(out_values) > 0:\n                in_weights = weight_lst[in_sol]\n                out_weights = weight_lst[out_sol]\n\n                # Find best item to remove\n                remove_scores = (in_values + value1_lst[in_sol] + value2_lst[in_sol]) / (in_weights + 1e-6)\n                remove_idx = np.argmin(remove_scores)\n\n                # Find best item to add\n                add_scores = (out_values + value1_lst[out_sol] + value2_lst[out_sol]) / (out_weights + 1e-6)\n                valid_add = np.where(out_weights <= capacity - current_weight + in_weights[remove_idx])[0]\n\n                if len(valid_add) > 0:\n                    best_add = valid_add[np.argmax(add_scores[valid_add])]\n\n                    i = in_sol[remove_idx]\n                    j = out_sol[best_add]\n\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i] = 0\n                        new_solution[j] = 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 2: Adaptive neighborhood exploration with capacity constraints\n    neighborhood_size = min(5, n_items // 4)\n    neighborhood = np.random.choice(n_items, size=neighborhood_size, replace=False)\n\n    for idx in neighborhood:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if weight_lst[idx] <= capacity - current_weight:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Final diversification\n    if random.random() < 0.3:\n        flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n        for idx in flip_candidates[:min(3, len(flip_candidates))]:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if weight_lst[idx] <= capacity - current_weight:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9773438041916379,
            4.017314702272415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score and weight efficiency, then applies a multi-phase local search combining value-ratio swaps, weight-balanced flips, and capacity-aware perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on combined objective score and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        weight_efficiency = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        score = weight_efficiency * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Value-ratio swaps\n    in_sol = np.where(new_solution == 1)[0]\n    out_sol = np.where(new_solution == 0)[0]\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        best_in = in_sol[np.argmin(value_ratios[in_sol])]\n        best_out = out_sol[np.argmax(value_ratios[out_sol])]\n        if current_weight - weight_lst[best_in] + weight_lst[best_out] <= capacity:\n            new_solution[best_in], new_solution[best_out] = new_solution[best_out], new_solution[best_in]\n            current_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n    # Phase 2: Weight-balanced flips\n    flip_candidates = np.argsort((value1_lst + value2_lst) / (weight_lst + 1e-6))[::-1]\n    for idx in flip_candidates[:min(3, len(flip_candidates))]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 3: Capacity-aware perturbations\n    perturb_size = min(2, n_items // 4)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7448664800050583,
            1.8074132800102234
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-phase local search operator that combines adaptive item flips, objective-biased swaps, and capacity-aware perturbations to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Score each solution based on objective diversity and potential improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score is a combination of objective values, diversity, and slack capacity\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = (obj[0] + obj[1]) * diversity * (1 - (total_weight / capacity))\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply multi-phase local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Phase 1: Objective-biased item flips\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        # Select items to flip based on the objective with lower value\n        obj1_total = archive[selected_idx][1][0]\n        obj2_total = archive[selected_idx][1][1]\n        if obj1_total < obj2_total:\n            # Prefer flipping items that improve objective 1\n            flip_values = value1_lst[flip_candidates]\n        else:\n            # Prefer flipping items that improve objective 2\n            flip_values = value2_lst[flip_candidates]\n\n        # Sort candidates by value (descending) and select top 2\n        top_candidates = flip_candidates[np.argsort(flip_values)[-min(2, len(flip_candidates)):]]\n        for i in top_candidates:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 2: Adaptive item swaps\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        for _ in range(min(2, len(swap_candidates))):\n            i = np.random.choice(swap_candidates)\n            # Find an item to swap with (not in current solution) with similar weight\n            not_in_sol = np.where(new_solution == 0)[0]\n            if len(not_in_sol) > 0:\n                # Find items with similar weight to the one being removed\n                weight_diff = abs(weight_lst[not_in_sol] - weight_lst[i])\n                similar_items = not_in_sol[np.argsort(weight_diff)[:min(3, len(not_in_sol))]]\n                if len(similar_items) > 0:\n                    j = np.random.choice(similar_items)\n                    # Check feasibility\n                    if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Phase 3: Capacity-aware perturbations\n    perturbation_size = min(3, n_items // 4)\n    perturbed_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n    for idx in perturbed_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity and (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5041953241156018,
            1.7110706865787506
        ]
    }
]