[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search that combines random item swaps and targeted flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random swaps and targeted flips\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to flip\n    if len(items) > 0:\n        flip_indices = random.sample(list(items), min(3, len(items)))\n        for idx in flip_indices:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Randomly add items if capacity allows\n    random.shuffle(non_items)\n    for idx in non_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Ensure feasibility (fallback if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            for idx in items_in_solution:\n                if excess_weight <= 0:\n                    break\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.35682452083347693,
            3.1650768518447876
        ]
    },
    {
        "algorithm": "{A hybrid local search algorithm that combines adaptive mutation with a biased random walk to explore the solution space intelligently, prioritizing regions with high potential for multi-objective improvement while ensuring feasibility through weight-constrained perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive mutation with biased random walk\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Adaptive mutation - flip items with high marginal gain\n    for _ in range(3):\n        # Calculate marginal gains\n        marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n        marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        # Select items to flip with probability proportional to gain\n        flip_probs = combined_gain * (1 - new_solution)  # Prefer adding items\n        flip_probs[new_solution == 1] = combined_gain[new_solution == 1] * 0.5  # Lower chance to remove\n\n        if np.sum(flip_probs) > 0:\n            flip_probs = flip_probs / np.sum(flip_probs)\n            candidate_idx = np.random.choice(len(weight_lst), p=flip_probs)\n\n            if new_solution[candidate_idx] == 0 and remaining_capacity >= weight_lst[candidate_idx]:\n                new_solution[candidate_idx] = 1\n                remaining_capacity -= weight_lst[candidate_idx]\n            elif new_solution[candidate_idx] == 1:\n                new_solution[candidate_idx] = 0\n                remaining_capacity += weight_lst[candidate_idx]\n\n    # Step 2: Biased random walk - explore nearby solutions\n    for _ in range(2):\n        # Select a random neighbor by flipping one bit\n        candidate_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[candidate_idx] == 0 and remaining_capacity >= weight_lst[candidate_idx]:\n            new_solution[candidate_idx] = 1\n            remaining_capacity -= weight_lst[candidate_idx]\n        elif new_solution[candidate_idx] == 1:\n            new_solution[candidate_idx] = 0\n            remaining_capacity += weight_lst[candidate_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3370581643142962,
            4.867403298616409
        ]
    }
]