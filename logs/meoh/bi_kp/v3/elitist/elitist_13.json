[
    {
        "algorithm": "{This novel hybrid local search operator employs a dynamic neighborhood exploration strategy with a weighted marginal contribution score function that prioritizes items with high normalized value-to-weight ratios while considering both objectives, followed by a probabilistic item swap mechanism using a different parameterization to ensure feasibility and balance exploration of promising regions with exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / (weight_lst[in_items] + 1e-6)\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / (weight_lst[out_items] + 1e-6)\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            if (contribution1 < 0.3 and contribution2 < 0.3 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.745229305930565,
            -18.816404235592884
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.5 + value2_lst[out_items] * 0.5) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.2 and contribution2 < 0.2 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.12922508419043,
            -18.596960290677085
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel adaptive local search operator dynamically adjusts neighborhood size and selection probability based on solution quality, combining item flips with a value-weighted swap mechanism to explore diverse regions while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    total_values = np.array([v1 + v2 for _, (v1, v2) in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Adaptive neighborhood size based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_flip = min(5, len(base_solution))\n    flip_size = max(1, int(max_flip * (1 - quality / np.max(total_values))))\n\n    # Dynamic item flips with value-weighted probability\n    flip_probs = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_probs = flip_probs / np.sum(flip_probs)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, p=flip_probs, replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Value-weighted swaps based on objective importance\n    obj1_weight = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n    obj2_weight = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Combined value-to-weight ratio considering both objectives\n            in_scores = (obj1_weight * value1_lst[in_items] + obj2_weight * value2_lst[in_items]) / weight_lst[in_items]\n            out_scores = (obj1_weight * value1_lst[out_items] + obj2_weight * value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.144736987535413,
            -18.503805165956177
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{An adaptive value-balanced neighborhood search that dynamically adjusts exploration intensity based on solution quality gradients and employs a hybrid of deterministic value-driven swaps and stochastic weight-constrained perturbations to navigate the Pareto frontier efficiently.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.4 + x[1][1] * 0.6))\n    selected_idx = min(1, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value density gradients\n    value_density1 = value1_lst / weight_lst\n    value_density2 = value2_lst / weight_lst\n    combined_density = value_density1 * 0.6 + value_density2 * 0.4\n\n    # Phase 1: Gradient-aware deterministic swaps\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with highest density to add\n            best_in = in_items[np.argmax(combined_density[in_items])]\n\n            # Select items with lowest density to remove\n            worst_out = out_items[np.argmin(combined_density[out_items])]\n\n            # Check feasibility\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Adaptive stochastic perturbations\n    num_perturb = min(2, len(new_solution))\n    perturb_indices = np.random.choice(len(new_solution), size=num_perturb, replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.364421286570913,
            -18.019721393317905
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] * 0.3 + x[1][1] * 0.7))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.5 + value2_lst[out_items] * 0.5) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.208939027341902,
            -17.83962916821944
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / (weight_lst[out_items] + 1e-6)\n            in_scores = (value1_lst[in_items] * 0.3 + value2_lst[in_items] * 0.7) / (weight_lst[in_items] + 1e-6)\n\n            worst_out = out_items[np.argmin(out_scores)]\n            best_in = in_items[np.argmax(in_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for idx in range(num_items):\n        if random.random() < 0.10:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -17.945161072157624,
            -19.19924042162659
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel adaptive local search operator dynamically adjusts neighborhood size and selection probability based on solution quality, combining item flips with a value-weighted swap mechanism to explore diverse regions while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    total_values = np.array([v1 + v2 for _, (v1, v2) in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Adaptive neighborhood size based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_flip = min(5, len(base_solution))\n    flip_size = max(1, int(max_flip * (1 - quality / np.max(total_values))))\n\n    # Dynamic item flips with value-weighted probability\n    flip_probs = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_probs = flip_probs / np.sum(flip_probs)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, p=flip_probs, replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Value-weighted swaps based on objective importance\n    obj1_weight = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n    obj2_weight = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Combined value-to-weight ratio considering both objectives\n            in_scores = (obj1_weight * value1_lst[in_items] + obj2_weight * value2_lst[in_items]) / weight_lst[in_items]\n            out_scores = (obj1_weight * value1_lst[out_items] + obj2_weight * value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.144736987535413,
            -18.503805165956177
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{An adaptive value-balanced neighborhood search that dynamically adjusts exploration intensity based on solution quality gradients and employs a hybrid of deterministic value-driven swaps and stochastic weight-constrained perturbations to navigate the Pareto frontier efficiently.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.4 + x[1][1] * 0.6))\n    selected_idx = min(1, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value density gradients\n    value_density1 = value1_lst / weight_lst\n    value_density2 = value2_lst / weight_lst\n    combined_density = value_density1 * 0.6 + value_density2 * 0.4\n\n    # Phase 1: Gradient-aware deterministic swaps\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with highest density to add\n            best_in = in_items[np.argmax(combined_density[in_items])]\n\n            # Select items with lowest density to remove\n            worst_out = out_items[np.argmin(combined_density[out_items])]\n\n            # Check feasibility\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Adaptive stochastic perturbations\n    num_perturb = min(2, len(new_solution))\n    perturb_indices = np.random.choice(len(new_solution), size=num_perturb, replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.364421286570913,
            -18.019721393317905
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.5 + value2_lst[out_items] * 0.5) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.2 and contribution2 < 0.2 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.12922508419043,
            -18.596960290677085
        ]
    },
    {
        "algorithm": "{This novel hybrid local search operator employs a dynamic neighborhood exploration strategy with a weighted marginal contribution score function that prioritizes items with high normalized value-to-weight ratios while considering both objectives, followed by a probabilistic item swap mechanism using a different parameterization to ensure feasibility and balance exploration of promising regions with exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / (weight_lst[in_items] + 1e-6)\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / (weight_lst[out_items] + 1e-6)\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            if (contribution1 < 0.3 and contribution2 < 0.3 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.745229305930565,
            -18.816404235592884
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel adaptive local search operator dynamically adjusts neighborhood size and selection probability based on solution quality, combining item flips with a value-weighted swap mechanism to explore diverse regions while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    total_values = np.array([v1 + v2 for _, (v1, v2) in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Adaptive neighborhood size based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_flip = min(5, len(base_solution))\n    flip_size = max(1, int(max_flip * (1 - quality / np.max(total_values))))\n\n    # Dynamic item flips with value-weighted probability\n    flip_probs = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_probs = flip_probs / np.sum(flip_probs)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, p=flip_probs, replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Value-weighted swaps based on objective importance\n    obj1_weight = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n    obj2_weight = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Combined value-to-weight ratio considering both objectives\n            in_scores = (obj1_weight * value1_lst[in_items] + obj2_weight * value2_lst[in_items]) / weight_lst[in_items]\n            out_scores = (obj1_weight * value1_lst[out_items] + obj2_weight * value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.144736987535413,
            -18.503805165956177
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.5 + value2_lst[out_items] * 0.5) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.2 and contribution2 < 0.2 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.12922508419043,
            -18.596960290677085
        ]
    },
    {
        "algorithm": "{An adaptive value-balanced neighborhood search that dynamically adjusts exploration intensity based on solution quality gradients and employs a hybrid of deterministic value-driven swaps and stochastic weight-constrained perturbations to navigate the Pareto frontier efficiently.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.4 + x[1][1] * 0.6))\n    selected_idx = min(1, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value density gradients\n    value_density1 = value1_lst / weight_lst\n    value_density2 = value2_lst / weight_lst\n    combined_density = value_density1 * 0.6 + value_density2 * 0.4\n\n    # Phase 1: Gradient-aware deterministic swaps\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with highest density to add\n            best_in = in_items[np.argmax(combined_density[in_items])]\n\n            # Select items with lowest density to remove\n            worst_out = out_items[np.argmin(combined_density[out_items])]\n\n            # Check feasibility\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Adaptive stochastic perturbations\n    num_perturb = min(2, len(new_solution))\n    perturb_indices = np.random.choice(len(new_solution), size=num_perturb, replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.364421286570913,
            -18.019721393317905
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{A novel adaptive local search operator dynamically adjusts neighborhood size and selection probability based on solution quality, combining item flips with a value-weighted swap mechanism to explore diverse regions while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    total_values = np.array([v1 + v2 for _, (v1, v2) in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Adaptive neighborhood size based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_flip = min(5, len(base_solution))\n    flip_size = max(1, int(max_flip * (1 - quality / np.max(total_values))))\n\n    # Dynamic item flips with value-weighted probability\n    flip_probs = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_probs = flip_probs / np.sum(flip_probs)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, p=flip_probs, replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Value-weighted swaps based on objective importance\n    obj1_weight = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n    obj2_weight = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Combined value-to-weight ratio considering both objectives\n            in_scores = (obj1_weight * value1_lst[in_items] + obj2_weight * value2_lst[in_items]) / weight_lst[in_items]\n            out_scores = (obj1_weight * value1_lst[out_items] + obj2_weight * value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.144736987535413,
            -18.503805165956177
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    }
]