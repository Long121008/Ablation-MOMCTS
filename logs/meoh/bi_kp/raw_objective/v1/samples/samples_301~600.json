[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic trade-off between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.4 - density * 0.3)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(2, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.6:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value1 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value2 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.5:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 70))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, prioritizing value2 over value1, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a modified parameterization of the score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.4 + obj[1]/max_value2 * 0.6) * (1 + diversity * 0.8)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(base_solution)\n    for _ in range(4):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.6:\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.4:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 60))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 60))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic trade-off between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(2, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.7:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value1 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value2 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 65))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 35))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.315938625735058,
            -18.23812686141313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(2, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.7:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value1 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value2 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 65))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 35))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution density, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.7:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 80))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 30))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.6 - density * 0.5)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.6:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.5:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 70))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.90042499145857,
            -18.690895331204487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.6 - density * 0.5)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.6:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.5:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 70))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution density, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.7:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 80))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 30))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic combination of objective dominance and solution sparsity, then applies a hybrid local search combining objective-specific flips, adaptive density adjustments, and probabilistic perturbations, while ensuring feasibility through capacity-aware operations and dominance-preserving modifications, using a novel scoring mechanism that balances objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        dominance = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3)\n        sparsity = 1 - np.sum(sol) / len(sol)\n        score = dominance * (1 + sparsity * 0.6)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-specific operations\n    n_items = len(base_solution)\n    for _ in range(2):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-specific multi-flip with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_flips = min(2, len(included), len(excluded))\n            for _ in range(num_flips):\n                if random.random() < 0.6:\n                    candidates = np.where(value1_lst > np.percentile(value1_lst, 70))[0]\n                else:\n                    candidates = np.where(value2_lst > np.percentile(value2_lst, 70))[0]\n\n                if len(candidates) > 0:\n                    item = random.choice(candidates)\n                    new_solution[item] = 1 - new_solution[item]\n                    current_weight = np.sum(weight_lst * new_solution)\n                    if current_weight > capacity:\n                        new_solution[item] = 1 - new_solution[item]\n\n        # Adaptive density-based adjustment\n        if np.array_equal(new_solution, base_solution):\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight < capacity * 0.7:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n            else:\n                candidates = np.where(weight_lst > np.percentile(weight_lst, 60))[0]\n\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                elif new_solution[item] == 1:\n                    new_solution[item] = 0\n\n    # Final adjustment for empty solutions\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.585012703955588,
            -16.292346268423138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        dominance = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3)\n        sparsity = 1 - np.sum(sol) / len(sol)\n        score = dominance * (1 + sparsity * 0.6)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-specific operations\n    n_items = len(base_solution)\n    for _ in range(2):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-specific multi-flip with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_flips = min(2, len(included), len(excluded))\n            for _ in range(num_flips):\n                if random.random() < 0.6:\n                    candidates = np.where(value1_lst > np.percentile(value1_lst, 70))[0]\n                else:\n                    candidates = np.where(value2_lst > np.percentile(value2_lst, 70))[0]\n\n                if len(candidates) > 0:\n                    item = random.choice(candidates)\n                    new_solution[item] = 1 - new_solution[item]\n                    current_weight = np.sum(weight_lst * new_solution)\n                    if current_weight > capacity:\n                        new_solution[item] = 1 - new_solution[item]\n\n        # Adaptive density-based adjustment\n        if np.array_equal(new_solution, base_solution):\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight < capacity * 0.7:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n            else:\n                candidates = np.where(weight_lst > np.percentile(weight_lst, 60))[0]\n\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                elif new_solution[item] == 1:\n                    new_solution[item] = 0\n\n    # Final adjustment for empty solutions\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution density, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.7:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 80))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 30))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, prioritizing value2 over value1, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a modified parameterization of the score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.3 + obj[1]/max_value2 * 0.7) * (1 + diversity * 0.6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n            else:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    if np.sum(new_solution) == 0:\n        combined_values = value2_lst + value1_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective-aware clustering approach, then applies a hybrid local search combining feature-based swaps, adaptive multi-objective flips, and dynamic capacity-aware perturbations, while ensuring feasibility through hierarchical capacity checks and dominance-aware adjustments, using a unique scoring mechanism that combines objective improvements, solution diversity, and item feature correlations, and employs a sophisticated combination of greedy, random, and feature-aware operations with adaptive probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate objective-aware clustering scores\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        feature_score = np.sum((value1_lst + value2_lst) * sol) / (np.sum(value1_lst + value2_lst) + 1e-6)\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.4 + feature_score * 0.3)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with feature-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Feature-based multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(2, len(included), len(excluded))\n            for _ in range(num_swaps):\n                # Select items with high feature correlation\n                feature_corr = np.abs((value1_lst[excluded] - value1_lst[included][:, None]) +\n                                    (value2_lst[excluded] - value2_lst[included][:, None]))\n                best_pair = np.unravel_index(np.argmax(feature_corr), feature_corr.shape)\n                item_in, item_out = included[best_pair[0]], excluded[best_pair[1]]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive feature-based flip with capacity-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_weight = np.sum(weight_lst * new_solution)\n            remaining_capacity = capacity - current_weight\n\n            if remaining_capacity > 0:\n                # Select items with high value-to-weight ratio\n                value_ratio = (value1_lst + value2_lst) / weight_lst\n                candidates = np.where((value_ratio > np.percentile(value_ratio, 70)) &\n                                    (weight_lst <= remaining_capacity))[0]\n\n                if len(candidates) > 0:\n                    random_item = random.choice(candidates)\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Final adjustment for empty solution\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -13.764933129057315,
            -13.442609674744288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate objective-aware clustering scores\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        feature_score = np.sum((value1_lst + value2_lst) * sol) / (np.sum(value1_lst + value2_lst) + 1e-6)\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.4 + feature_score * 0.3)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with feature-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Feature-based multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(2, len(included), len(excluded))\n            for _ in range(num_swaps):\n                # Select items with high feature correlation\n                feature_corr = np.abs((value1_lst[excluded] - value1_lst[included][:, None]) +\n                                    (value2_lst[excluded] - value2_lst[included][:, None]))\n                best_pair = np.unravel_index(np.argmax(feature_corr), feature_corr.shape)\n                item_in, item_out = included[best_pair[0]], excluded[best_pair[1]]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive feature-based flip with capacity-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_weight = np.sum(weight_lst * new_solution)\n            remaining_capacity = capacity - current_weight\n\n            if remaining_capacity > 0:\n                # Select items with high value-to-weight ratio\n                value_ratio = (value1_lst + value2_lst) / weight_lst\n                candidates = np.where((value_ratio > np.percentile(value_ratio, 70)) &\n                                    (weight_lst <= remaining_capacity))[0]\n\n                if len(candidates) > 0:\n                    random_item = random.choice(candidates)\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Final adjustment for empty solution\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution density, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.7:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 80))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 30))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a dynamic trade-off between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution density, and employs a unique combination of greedy and random operations with adaptive probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with different parameter settings\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.4 - density * 0.3)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.6:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.5:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 70))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.075431643977346,
            -18.530117394359173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with different parameter settings\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.4 - density * 0.3)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.6:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.5:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 70))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic trade-off between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.5 + obj[1]/max_value2 * 0.5) * (1 + diversity * 0.4 - density * 0.3)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(2, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.6:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value1 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value2 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.5:\n                candidates = np.where(value1_lst + value2_lst > np.percentile(value1_lst + value2_lst, 70))[0]\n            else:\n                candidates = np.where(weight_lst < np.percentile(weight_lst, 40))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, prioritizing value2 over value1, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a modified parameterization of the score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.3 + obj[1]/max_value2 * 0.7) * (1 + diversity * 0.6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n            else:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    if np.sum(new_solution) == 0:\n        combined_values = value2_lst + value1_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a novel scoring mechanism that considers both objective improvements and solution diversity, and employs a unique combination of greedy and random operations with adaptive probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.4 + obj[1]/max_value2 * 0.6) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.5:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 80))[0]\n            else:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 60))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value2_lst + value1_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.302439644385828,
            -19.032147265563488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        density = np.sum(weight_lst * sol) / capacity if capacity > 0 else 0\n        score = (obj[0]/max_value1 * 0.4 + obj[1]/max_value2 * 0.6) * (1 + diversity * 0.5 - density * 0.4)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Objective-aware multi-swap with adaptive selection\n        if len(included) > 0 and len(excluded) > 0:\n            num_swaps = min(3, len(included), len(excluded))\n            for _ in range(num_swaps):\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                if random.random() < 0.5:\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                else:\n                    delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                    delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive density-based flip with value-aware selection\n        if np.array_equal(new_solution, base_solution):\n            current_density = np.sum(weight_lst * new_solution) / capacity if capacity > 0 else 0\n            if current_density < 0.6:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 80))[0]\n            else:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 60))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's density and objective balance\n    if np.sum(new_solution) == 0:\n        combined_values = value2_lst + value1_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements, solution diversity, and item criticality, then applies a novel hybrid local search combining targeted swaps, multi-objective perturbations, and dominance-aware flips, while ensuring feasibility through adaptive capacity checks and objective-aware adjustments, using a different parameterization of the score function to prioritize value2 over value1 and incorporating a novel search strategy that combines both objectives in a geometric mean to balance exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores combining objective values, diversity, and criticality\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        criticality = np.sum(sol * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        geometric_mean = np.sqrt(obj[0] * obj[1])\n        score = (0.4 * obj[0]/max_value1 + 0.6 * obj[1]/max_value2) * (1 + diversity) * (1 + 0.3 * criticality) * (1 + 0.2 * geometric_mean)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search with multi-objective operations\n    n_items = len(base_solution)\n    for _ in range(4):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Geometric mean-based swap with adaptive probability\n            if random.random() < 0.6:\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                # Calculate geometric mean-based delta\n                obj_balance = np.sqrt(archive[selected_idx][1][0] * archive[selected_idx][1][1])\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                weighted_delta = np.sqrt((obj_balance * delta_value1) * ((1 - obj_balance) * delta_value2))\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and weighted_delta > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Multi-objective perturbation with criticality awareness\n        if np.array_equal(new_solution, base_solution):\n            # Select items based on geometric mean of objectives and criticality\n            combined_values = np.sqrt((value1_lst * value2_lst) * (1 + 0.4 * (value1_lst / (weight_lst + 1e-6))))\n            candidates = np.where(combined_values > np.percentile(combined_values, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # Add most critical items based on geometric mean of objectives\n        combined_values = np.sqrt((value1_lst * value2_lst) * (1 + 0.3 * (value1_lst / (weight_lst + 1e-6))))\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic balance between objective improvements, solution diversity, and item criticality, then applies a novel hybrid local search combining targeted swaps, multi-objective perturbations, and dominance-aware flips, while ensuring feasibility through adaptive capacity checks and objective-aware adjustments, using a different parameterization of the score function to prioritize value1 over value2 and incorporating a novel search strategy that combines both objectives in a harmonic mean to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores combining objective values, diversity, and criticality\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        criticality = np.sum(sol * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        harmonic_mean = 2 * obj[0] * obj[1] / (obj[0] + obj[1] + 1e-6)\n        score = (0.6 * obj[0]/max_value1 + 0.4 * obj[1]/max_value2) * (1 + diversity) * (1 + 0.3 * criticality) * (1 + 0.2 * harmonic_mean)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search with multi-objective operations\n    n_items = len(base_solution)\n    for _ in range(4):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Harmonic mean-based swap with adaptive probability\n            if random.random() < 0.6:\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                # Calculate harmonic mean-based delta\n                obj_balance = 2 * archive[selected_idx][1][0] * archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                weighted_delta = (obj_balance * delta_value1 + (1 - obj_balance) * delta_value2)\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and weighted_delta > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Multi-objective perturbation with criticality awareness\n        if np.array_equal(new_solution, base_solution):\n            # Select items based on harmonic mean of objectives and criticality\n            combined_values = (value1_lst + value2_lst) / (1 + 0.3 * (weight_lst / (value1_lst + value2_lst + 1e-6)))\n            candidates = np.where(combined_values > np.percentile(combined_values, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # Add most critical items based on harmonic mean of objectives\n        combined_values = (value1_lst + value2_lst) / (1 + 0.2 * (weight_lst / (value1_lst + value2_lst + 1e-6)))\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.627059358571145,
            -16.16354958867869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores combining objective values, diversity, and criticality\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        criticality = np.sum(sol * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        harmonic_mean = 2 * obj[0] * obj[1] / (obj[0] + obj[1] + 1e-6)\n        score = (0.6 * obj[0]/max_value1 + 0.4 * obj[1]/max_value2) * (1 + diversity) * (1 + 0.3 * criticality) * (1 + 0.2 * harmonic_mean)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search with multi-objective operations\n    n_items = len(base_solution)\n    for _ in range(4):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Harmonic mean-based swap with adaptive probability\n            if random.random() < 0.6:\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                # Calculate harmonic mean-based delta\n                obj_balance = 2 * archive[selected_idx][1][0] * archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                weighted_delta = (obj_balance * delta_value1 + (1 - obj_balance) * delta_value2)\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                current_weight = np.sum(weight_lst * new_solution)\n\n                if current_weight + delta_weight <= capacity and weighted_delta > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Multi-objective perturbation with criticality awareness\n        if np.array_equal(new_solution, base_solution):\n            # Select items based on harmonic mean of objectives and criticality\n            combined_values = (value1_lst + value2_lst) / (1 + 0.3 * (weight_lst / (value1_lst + value2_lst + 1e-6)))\n            candidates = np.where(combined_values > np.percentile(combined_values, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # Add most critical items based on harmonic mean of objectives\n        combined_values = (value1_lst + value2_lst) / (1 + 0.2 * (weight_lst / (value1_lst + value2_lst + 1e-6)))\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    }
]