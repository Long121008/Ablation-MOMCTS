[
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive and applies a hybrid local search operator that combines item swapping and adaptive perturbation, ensuring feasibility by dynamically adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb adaptively\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Find items to swap or perturb\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Randomly select an included and excluded item\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                # Perform swap\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            new_solution[random_item] = 1 - new_solution[random_item]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                # Revert if infeasible\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.752390265186136,
            -18.305823809960927
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware metric, then applies a novel local search that combines value-balanced item selection, objective-aware swapping, and capacity-constrained perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: randomly among top 30% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, min(2, len(archive) - 1)) if len(archive) <= 3 else random.randint(0, len(archive) // 3)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Value-balanced item selection (prioritize items with high value-to-weight ratio for both objectives)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2  # Simple combination for multi-objective trade-off\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Descending order\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] <= capacity:\n            if random.random() < 0.3:  # 30% chance to remove low-value items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-aware swapping (swap items to improve both objectives)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if both objectives improve or at least one improves\n            if (swapped_value1 > new_value1 and swapped_value2 >= new_value2) or (swapped_value1 >= new_value1 and swapped_value2 > new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Capacity-constrained perturbation (add or remove items to balance capacity)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio\n        for i in sorted_indices[::-1]:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.09801667107522,
            -17.637557329905533
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel local search combining item clustering, objective-weighted flipping, and capacity-constrained perturbation to explore high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: based on diversity metric)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by similar objective contributions\n    n_items = len(weight_lst)\n    if n_items > 1:\n        # Create clusters of items with similar value ratios\n        ratios = value1_lst / (value2_lst + 1e-10)\n        clusters = {}\n        for i in range(n_items):\n            cluster_key = round(ratios[i], 1)\n            if cluster_key not in clusters:\n                clusters[cluster_key] = []\n            clusters[cluster_key].append(i)\n\n        # Step 2: Objective-weighted flipping within clusters\n        for cluster in clusters.values():\n            if len(cluster) > 1:\n                i = random.choice(cluster)\n                j = random.choice(cluster)\n                if i != j:\n                    # Flip based on objective dominance\n                    if value1_lst[i] > value1_lst[j] and value2_lst[i] > value2_lst[j]:\n                        if new_solution[i] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                    else:\n                        if new_solution[j] == 1 and np.sum(weight_lst[new_solution == 1]) - weight_lst[j] <= capacity:\n                            new_solution[j] = 0\n\n    # Step 3: Capacity-constrained perturbation\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight < capacity * 0.95:\n        # Add items with highest combined value density\n        remaining_capacity = capacity - total_weight\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate value density (sum of normalized values per weight)\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            best_item = available_items[np.argmax(value_density[available_items])]\n            if weight_lst[best_item] <= remaining_capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.109929365102712,
            -17.0573024322208
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search that combines item swapping, probabilistic flipping, and capacity-aware perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: randomly among top 30% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, min(2, len(archive) - 1)) if len(archive) <= 3 else random.randint(0, len(archive) // 3)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swapping, flipping, and perturbation\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Random swapping of items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n            if new_weight <= capacity:\n                total_weight = new_weight\n            else:\n                new_solution = base_solution.copy()\n\n    # Step 2: Probabilistic flipping of items\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip each item\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Step 3: Capacity-aware perturbation (if still feasible)\n    if total_weight < capacity * 0.9:  # Add items if underutilized\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            i = random.choice(available_items)\n            if total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -17.350624648789527,
            -17.182688380758343
        ]
    },
    {
        "algorithm": "{The new heuristic selects a solution from the archive based on a combination of objective dominance and weight diversity, then applies a multi-phase local search that includes item reallocation, value-aware swapping, and capacity-constrained flipping to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high combined objective values and weight diversity\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive_objectives[i]) * (1 - np.sum(archive_solutions[i]) / len(weight_lst)))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Phase 1: Value-aware item reallocation\n    if n_items >= 2:\n        # Find items to swap based on value ratio difference\n        items_in = np.where(base_solution == 1)[0]\n        items_out = np.where(base_solution == 0)[0]\n        if len(items_in) > 0 and len(items_out) > 0:\n            i = random.choice(items_in)\n            j = random.choice(items_out)\n            value_ratio = (value1_lst[i] + value2_lst[i]) / (value1_lst[j] + value2_lst[j])\n            if value_ratio < 1.2:  # Only swap if not too unbalanced\n                new_solution[i], new_solution[j] = 0, 1\n                new_weight = total_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    total_weight = new_weight\n                else:\n                    new_solution = base_solution.copy()\n\n    # Phase 2: Capacity-constrained flipping with value preference\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity and (value1_lst[i] + value2_lst[i]) > 0.5 * np.mean(value1_lst + value2_lst):\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Phase 3: Multi-objective perturbation\n    if total_weight < capacity * 0.8:  # Add items if underutilized\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Select items with highest combined value-to-weight ratio\n            ratios = (value1_lst + value2_lst) / weight_lst\n            sorted_items = sorted(available_items, key=lambda x: -ratios[x])\n            for i in sorted_items[:3]:  # Try top 3 items\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -16.886663682680616,
            -16.52757816406428
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines multi-objective neighborhood partitioning with adaptive objective weighting and feasibility-preserving perturbation to dynamically explore trade-offs and escape local optima while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with highest combined objective score\n        scores = [obj[0] + obj[1] for _, obj in archive]\n        base_solution = archive[np.argmax(scores)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Objective-weighted neighborhood partitioning\n    weight1 = random.uniform(0.3, 0.7)\n    weight2 = 1 - weight1\n    combined_scores = weight1 * value1_lst + weight2 * value2_lst\n\n    # Step 2: Adaptive perturbation - flip items based on combined scores\n    sorted_items = np.argsort(combined_scores)[::-1]\n    for i in range(min(5, len(sorted_items))):\n        item = sorted_items[i]\n        if random.random() < 0.4:  # 40% chance to consider flipping\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 3: Feasibility-preserving diversification\n    if random.random() < 0.3:  # 30% chance to add a random item\n        candidates = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(candidates) > 0:\n            selected = random.choice(candidates)\n            new_solution[selected] = 1\n\n    return new_solution\n\n",
        "score": [
            -15.591277015996239,
            -16.071250933148118
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, then applies a combination of adaptive item swapping based on marginal utility ratios and probabilistic flipping of items with high value-to-weight ratios to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (here, we select the one with highest sum of objectives)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    current_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Calculate marginal utility ratios for each item\n    marginal_utility1 = value1_lst / (weight_lst + 1e-10)\n    marginal_utility2 = value2_lst / (weight_lst + 1e-10)\n    combined_utility = marginal_utility1 + marginal_utility2\n\n    # Identify items to consider for flipping\n    candidate_items = np.where(combined_utility > np.mean(combined_utility))[0]\n\n    if len(candidate_items) == 0:\n        return current_solution  # No candidates, return current solution\n\n    # Randomly select a candidate item to flip\n    item_to_flip = random.choice(candidate_items)\n\n    # Create new solution by flipping the selected item\n    new_solution = current_solution.copy()\n\n    if new_solution[item_to_flip] == 1:\n        # Remove the item if it's in the solution\n        new_solution[item_to_flip] = 0\n    else:\n        # Add the item if it's not in the solution and doesn't exceed capacity\n        if current_weight + weight_lst[item_to_flip] <= capacity:\n            new_solution[item_to_flip] = 1\n\n    # Additional probabilistic flipping of other items\n    for item in candidate_items:\n        if item == item_to_flip:\n            continue\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n            elif np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -14.50002501993782,
            -15.044509135491616
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and applies a hybrid local search operator that combines random item swaps with a greedy improvement phase to explore the solution space while ensuring feasibility and potential for multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps followed by greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps to explore neighborhood\n    for _ in range(min(5, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight - new_solution[i] * weight_lst[i] + new_solution[j] * weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    # Greedy improvement phase\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item i\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -13.908174985218178,
            -13.694583664504755
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective improvement and diversity metric, then applies a novel multi-phase local search that combines probabilistic item swaps, objective-biased flips, and capacity-adaptive perturbations to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection phase: choose solution with best combined objective improvement and diversity\n    max_val1 = max(obj[0] for _, obj in archive)\n    max_val2 = max(obj[1] for _, obj in archive)\n    candidates = []\n    for sol, obj in archive:\n        improvement = (max_val1 - obj[0]) + (max_val2 - obj[1])\n        diversity = np.sum(sol != archive[0][0])\n        candidates.append((improvement + diversity, sol))\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    base_solution = candidates[0][1].copy()\n    new_solution = base_solution.copy()\n\n    # Local search phase 1: probabilistic swap with objective bias\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Swap with probability based on objective values\n            swap_prob = (value1_lst[i] + value1_lst[j] + value2_lst[i] + value2_lst[j]) / (4 * np.sum(value1_lst + value2_lst))\n            if random.random() < swap_prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_weight = current_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else current_weight + weight_lst[j] - weight_lst[i]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                else:\n                    new_solution = base_solution.copy()\n\n    # Local search phase 2: objective-biased flips\n    current_val1 = np.sum(value1_lst * new_solution)\n    current_val2 = np.sum(value2_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Flip items with high value ratio in under-represented objective\n    if current_val1 < current_val2 * 0.8:  # Value1 is underperforming\n        flip_candidates = np.where((new_solution == 0) & (value1_lst > value2_lst * 0.7))[0]\n    elif current_val2 < current_val1 * 0.8:  # Value2 is underperforming\n        flip_candidates = np.where((new_solution == 0) & (value2_lst > value1_lst * 0.7))[0]\n    else:\n        flip_candidates = np.where(new_solution == 0)[0]\n\n    if len(flip_candidates) > 0:\n        i = random.choice(flip_candidates)\n        if current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n\n    # Local search phase 3: capacity-adaptive perturbation\n    if current_weight < capacity * 0.8:  # Add items if capacity is underutilized\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            i = random.choice(available_items)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -14.199560438090835,
            -13.875742295692884
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines adaptive neighborhood exploration with objective-specific perturbations, dynamically balancing between intensification and diversification to escape local optima while ensuring feasibility, using a different scoring function that prioritizes solutions with balanced improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate balanced improvement potential (harmonic mean of differences)\n        best_val1 = max(obj[0] for _, obj in archive)\n        best_val2 = max(obj[1] for _, obj in archive)\n        candidates = []\n        for sol, obj in archive:\n            diff1 = best_val1 - obj[0]\n            diff2 = best_val2 - obj[1]\n            harmonic_mean = 2 * (diff1 * diff2) / (diff1 + diff2) if (diff1 + diff2) > 0 else 0\n            candidates.append((harmonic_mean, sol))\n        # Select solution with highest balanced potential\n        candidates.sort(reverse=True, key=lambda x: x[0])\n        base_solution = candidates[0][1].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive perturbation and objective-specific flips\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Identify critical items (high impact on both objectives)\n    impact_scores = (value1_lst + value2_lst) * new_solution\n    critical_items = np.argsort(impact_scores)[-max(2, len(impact_scores)//5):]\n\n    # Step 2: Adaptive perturbation - flip critical items with probability\n    for item in critical_items:\n        if random.random() < 0.4:  # 40% chance to flip\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 3: Objective-specific flips to balance objectives\n    current_val1 = np.sum(value1_lst * new_solution)\n    current_val2 = np.sum(value2_lst * new_solution)\n\n    # If one objective is significantly worse, try to improve it\n    if current_val1 < current_val2 * 0.6:  # Value1 is significantly worse\n        # Add items with high value1 that fit\n        possible_adds = np.where((new_solution == 0) &\n                                (weight_lst <= remaining_capacity))[0]\n        if len(possible_adds) > 0:\n            best_add = possible_adds[np.argmax(value1_lst[possible_adds])]\n            if current_weight + weight_lst[best_add] <= capacity:\n                new_solution[best_add] = 1\n    elif current_val2 < current_val1 * 0.6:  # Value2 is significantly worse\n        # Add items with high value2 that fit\n        possible_adds = np.where((new_solution == 0) &\n                                (weight_lst <= remaining_capacity))[0]\n        if len(possible_adds) > 0:\n            best_add = possible_adds[np.argmax(value2_lst[possible_adds])]\n            if current_weight + weight_lst[best_add] <= capacity:\n                new_solution[best_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -13.907358540850433,
            -13.709339529467012
        ]
    },
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive and applies a hybrid local search operator that combines item swapping and adaptive perturbation, ensuring feasibility by dynamically adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb adaptively\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Find items to swap or perturb\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Randomly select an included and excluded item\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                # Perform swap\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            new_solution[random_item] = 1 - new_solution[random_item]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                # Revert if infeasible\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.752390265186136,
            -18.305823809960927
        ]
    }
]