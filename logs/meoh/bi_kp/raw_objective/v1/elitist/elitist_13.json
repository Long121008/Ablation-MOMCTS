[
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.861667705633327,
            -18.582656107279348
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.321209241450113,
            -17.78967739151849
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a different parameterization of the score function to prioritize value2 over value1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with modified parameterization\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.3 + obj[1]/max_value2 * 0.7) * (1 + diversity * 0.8)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.3:  # Lower probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.4:  # Lower probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -17.657273300602732,
            -19.2842467065651
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.978756819803827,
            -18.462973588442047
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.308257786384512,
            -17.896404742415037
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):  # Moderate search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.6:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.5:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 50))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.471293423175954,
            -17.601485213985136
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and weight utilization, then applies a hybrid local search that uses an \"objective-aware\" item swapping strategy combined with a capacity-aware value redistribution mechanism to explore the solution space while ensuring feasibility and balancing both objectives through dynamic value prioritization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight utilization\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_solution, (v1, v2) = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate objective scores for included items\n        obj_scores = (value1_lst[included] / (v1 + 1e-10)) + (value2_lst[included] / (v2 + 1e-10))\n        obj_scores /= np.sum(obj_scores) if np.sum(obj_scores) > 0 else 1.0\n\n        # Select items to potentially swap based on objective scores\n        swap_items = np.random.choice(included, size=min(2, len(included)), p=obj_scores)\n\n        for item in swap_items:\n            # Find best replacement from excluded items\n            available_weight = capacity - (total_weight - weight_lst[item])\n            candidates = [i for i in excluded if weight_lst[i] <= available_weight]\n\n            if candidates:\n                # Calculate objective-aware scores for candidates\n                candidate_scores = (value1_lst[candidates] / (v1 + 1e-10)) + (value2_lst[candidates] / (v2 + 1e-10))\n                candidate_scores /= (weight_lst[candidates] + 1e-10)\n                best_candidate = candidates[np.argmax(candidate_scores)]\n\n                # Perform swapping\n                new_solution[item] = 0\n                new_solution[best_candidate] = 1\n                total_weight = total_weight - weight_lst[item] + weight_lst[best_candidate]\n\n    # Step 2: Capacity-aware value redistribution\n    if total_weight < capacity:\n        # Calculate normalized value scores for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_scores = (value1_lst[excluded] / (np.max(value1_lst) + 1e-10)) + (value2_lst[excluded] / (np.max(value2_lst) + 1e-10))\n            sorted_items = excluded[np.argsort(-value_scores)]\n\n            # Greedily add items until capacity is reached\n            for item in sorted_items:\n                if weight_lst[item] <= capacity - total_weight:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n                else:\n                    break\n\n    # Step 3: Dynamic value prioritization flip\n    if total_weight < capacity:\n        # Calculate dynamic value priorities\n        value_priority = (value1_lst - v1) + (value2_lst - v2)\n        flip_candidates = np.where(value_priority > np.median(value_priority))[0]\n\n        if len(flip_candidates) > 0:\n            flip_item = random.choice(flip_candidates)\n            if new_solution[flip_item] == 0 and weight_lst[flip_item] <= capacity - total_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.85038896183289,
            -18.630111589985354
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips, while ensuring feasibility by dynamically adjusting the search based on the current solution's dominance in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with alternative parameters\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        # Alternative score calculation: emphasize diversity more and use different normalization\n        score = (0.7 * obj[0]/max_value1 + 0.3 * obj[1]/max_value2) * (2 * diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with modified objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(7):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Modified objective-aware swap with probability\n            if random.random() < 0.7:  # Higher probability for swaps\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive perturbation with modified objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Different threshold for flipping based on objective balance\n            if archive[selected_idx][1][0] < 0.8 * archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 70))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 70))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items with different criteria\n        sorted_items = np.argsort(value1_lst + 0.5 * value2_lst)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.525129714610785,
            -17.56138081412963
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips, while ensuring feasibility by dynamically adjusting the search based on the current solution's dominance in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with different weights\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (0.6 * obj[0]/max_value1 + 0.4 * obj[1]/max_value2) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(7):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with weighted randomness\n            item_in = random.choices(included, weights=value1_lst[included] + value2_lst[included])[0]\n            item_out = random.choices(excluded, weights=value1_lst[excluded] + value2_lst[excluded])[0]\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker with probability\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items with weighted selection\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.22057332711458,
            -18.006238510754542
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips, while ensuring feasibility by dynamically adjusting the search based on the current solution's dominance in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with different weights\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (0.6 * obj[0]/max_value1 + 0.4 * obj[1]/max_value2) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(7):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with weighted randomness\n            item_in = random.choices(included, weights=value1_lst[included] + value2_lst[included])[0]\n            item_out = random.choices(excluded, weights=value1_lst[excluded] + value2_lst[excluded])[0]\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker with probability\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items with weighted selection\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.22057332711458,
            -18.006238510754542
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a different parameterization of the score function to prioritize value2 over value1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with modified parameterization\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.3 + obj[1]/max_value2 * 0.7) * (1 + diversity * 0.8)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.3:  # Lower probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.4:  # Lower probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -17.657273300602732,
            -19.2842467065651
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.978756819803827,
            -18.462973588442047
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.308257786384512,
            -17.896404742415037
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):  # Moderate search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.6:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.5:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 50))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.471293423175954,
            -17.601485213985136
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and weight utilization, then applies a hybrid local search that uses an \"objective-aware\" item swapping strategy combined with a capacity-aware value redistribution mechanism to explore the solution space while ensuring feasibility and balancing both objectives through dynamic value prioritization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight utilization\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_solution, (v1, v2) = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate objective scores for included items\n        obj_scores = (value1_lst[included] / (v1 + 1e-10)) + (value2_lst[included] / (v2 + 1e-10))\n        obj_scores /= np.sum(obj_scores) if np.sum(obj_scores) > 0 else 1.0\n\n        # Select items to potentially swap based on objective scores\n        swap_items = np.random.choice(included, size=min(2, len(included)), p=obj_scores)\n\n        for item in swap_items:\n            # Find best replacement from excluded items\n            available_weight = capacity - (total_weight - weight_lst[item])\n            candidates = [i for i in excluded if weight_lst[i] <= available_weight]\n\n            if candidates:\n                # Calculate objective-aware scores for candidates\n                candidate_scores = (value1_lst[candidates] / (v1 + 1e-10)) + (value2_lst[candidates] / (v2 + 1e-10))\n                candidate_scores /= (weight_lst[candidates] + 1e-10)\n                best_candidate = candidates[np.argmax(candidate_scores)]\n\n                # Perform swapping\n                new_solution[item] = 0\n                new_solution[best_candidate] = 1\n                total_weight = total_weight - weight_lst[item] + weight_lst[best_candidate]\n\n    # Step 2: Capacity-aware value redistribution\n    if total_weight < capacity:\n        # Calculate normalized value scores for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_scores = (value1_lst[excluded] / (np.max(value1_lst) + 1e-10)) + (value2_lst[excluded] / (np.max(value2_lst) + 1e-10))\n            sorted_items = excluded[np.argsort(-value_scores)]\n\n            # Greedily add items until capacity is reached\n            for item in sorted_items:\n                if weight_lst[item] <= capacity - total_weight:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n                else:\n                    break\n\n    # Step 3: Dynamic value prioritization flip\n    if total_weight < capacity:\n        # Calculate dynamic value priorities\n        value_priority = (value1_lst - v1) + (value2_lst - v2)\n        flip_candidates = np.where(value_priority > np.median(value_priority))[0]\n\n        if len(flip_candidates) > 0:\n            flip_item = random.choice(flip_candidates)\n            if new_solution[flip_item] == 0 and weight_lst[flip_item] <= capacity - total_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.85038896183289,
            -18.630111589985354
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips, while ensuring feasibility by dynamically adjusting the search based on the current solution's dominance in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with alternative parameters\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        # Alternative score calculation: emphasize diversity more and use different normalization\n        score = (0.7 * obj[0]/max_value1 + 0.3 * obj[1]/max_value2) * (2 * diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with modified objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(7):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Modified objective-aware swap with probability\n            if random.random() < 0.7:  # Higher probability for swaps\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive perturbation with modified objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Different threshold for flipping based on objective balance\n            if archive[selected_idx][1][0] < 0.8 * archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 70))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 70))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items with different criteria\n        sorted_items = np.argsort(value1_lst + 0.5 * value2_lst)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.525129714610785,
            -17.56138081412963
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.861667705633327,
            -18.582656107279348
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.13480130746991,
            -18.384004526364166
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and weight utilization, then applies a hybrid local search that uses an \"objective-aware\" item swapping strategy combined with a capacity-aware value redistribution mechanism to explore the solution space while ensuring feasibility and balancing both objectives through dynamic value prioritization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight utilization\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_solution, (v1, v2) = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate objective scores for included items\n        obj_scores = (value1_lst[included] / (v1 + 1e-10)) + (value2_lst[included] / (v2 + 1e-10))\n        obj_scores /= np.sum(obj_scores) if np.sum(obj_scores) > 0 else 1.0\n\n        # Select items to potentially swap based on objective scores\n        swap_items = np.random.choice(included, size=min(2, len(included)), p=obj_scores)\n\n        for item in swap_items:\n            # Find best replacement from excluded items\n            available_weight = capacity - (total_weight - weight_lst[item])\n            candidates = [i for i in excluded if weight_lst[i] <= available_weight]\n\n            if candidates:\n                # Calculate objective-aware scores for candidates\n                candidate_scores = (value1_lst[candidates] / (v1 + 1e-10)) + (value2_lst[candidates] / (v2 + 1e-10))\n                candidate_scores /= (weight_lst[candidates] + 1e-10)\n                best_candidate = candidates[np.argmax(candidate_scores)]\n\n                # Perform swapping\n                new_solution[item] = 0\n                new_solution[best_candidate] = 1\n                total_weight = total_weight - weight_lst[item] + weight_lst[best_candidate]\n\n    # Step 2: Capacity-aware value redistribution\n    if total_weight < capacity:\n        # Calculate normalized value scores for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_scores = (value1_lst[excluded] / (np.max(value1_lst) + 1e-10)) + (value2_lst[excluded] / (np.max(value2_lst) + 1e-10))\n            sorted_items = excluded[np.argsort(-value_scores)]\n\n            # Greedily add items until capacity is reached\n            for item in sorted_items:\n                if weight_lst[item] <= capacity - total_weight:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n                else:\n                    break\n\n    # Step 3: Dynamic value prioritization flip\n    if total_weight < capacity:\n        # Calculate dynamic value priorities\n        value_priority = (value1_lst - v1) + (value2_lst - v2)\n        flip_candidates = np.where(value_priority > np.median(value_priority))[0]\n\n        if len(flip_candidates) > 0:\n            flip_item = random.choice(flip_candidates)\n            if new_solution[flip_item] == 0 and weight_lst[flip_item] <= capacity - total_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.962186149316842,
            -18.54356368112481
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.978756819803827,
            -18.462973588442047
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.308257786384512,
            -17.896404742415037
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):  # Moderate search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.6:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.5:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 50))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.471293423175954,
            -17.601485213985136
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and weight utilization, then applies a hybrid local search that uses an \"objective-aware\" item swapping strategy combined with a capacity-aware value redistribution mechanism to explore the solution space while ensuring feasibility and balancing both objectives through dynamic value prioritization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight utilization\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_solution, (v1, v2) = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate objective scores for included items\n        obj_scores = (value1_lst[included] / (v1 + 1e-10)) + (value2_lst[included] / (v2 + 1e-10))\n        obj_scores /= np.sum(obj_scores) if np.sum(obj_scores) > 0 else 1.0\n\n        # Select items to potentially swap based on objective scores\n        swap_items = np.random.choice(included, size=min(2, len(included)), p=obj_scores)\n\n        for item in swap_items:\n            # Find best replacement from excluded items\n            available_weight = capacity - (total_weight - weight_lst[item])\n            candidates = [i for i in excluded if weight_lst[i] <= available_weight]\n\n            if candidates:\n                # Calculate objective-aware scores for candidates\n                candidate_scores = (value1_lst[candidates] / (v1 + 1e-10)) + (value2_lst[candidates] / (v2 + 1e-10))\n                candidate_scores /= (weight_lst[candidates] + 1e-10)\n                best_candidate = candidates[np.argmax(candidate_scores)]\n\n                # Perform swapping\n                new_solution[item] = 0\n                new_solution[best_candidate] = 1\n                total_weight = total_weight - weight_lst[item] + weight_lst[best_candidate]\n\n    # Step 2: Capacity-aware value redistribution\n    if total_weight < capacity:\n        # Calculate normalized value scores for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_scores = (value1_lst[excluded] / (np.max(value1_lst) + 1e-10)) + (value2_lst[excluded] / (np.max(value2_lst) + 1e-10))\n            sorted_items = excluded[np.argsort(-value_scores)]\n\n            # Greedily add items until capacity is reached\n            for item in sorted_items:\n                if weight_lst[item] <= capacity - total_weight:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n                else:\n                    break\n\n    # Step 3: Dynamic value prioritization flip\n    if total_weight < capacity:\n        # Calculate dynamic value priorities\n        value_priority = (value1_lst - v1) + (value2_lst - v2)\n        flip_candidates = np.where(value_priority > np.median(value_priority))[0]\n\n        if len(flip_candidates) > 0:\n            flip_item = random.choice(flip_candidates)\n            if new_solution[flip_item] == 0 and weight_lst[flip_item] <= capacity - total_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.85038896183289,
            -18.630111589985354
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips, while ensuring feasibility by dynamically adjusting the search based on the current solution's dominance in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with alternative parameters\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        # Alternative score calculation: emphasize diversity more and use different normalization\n        score = (0.7 * obj[0]/max_value1 + 0.3 * obj[1]/max_value2) * (2 * diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with modified objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(7):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Modified objective-aware swap with probability\n            if random.random() < 0.7:  # Higher probability for swaps\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Adaptive perturbation with modified objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Different threshold for flipping based on objective balance\n            if archive[selected_idx][1][0] < 0.8 * archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 70))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 70))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items with different criteria\n        sorted_items = np.argsort(value1_lst + 0.5 * value2_lst)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.525129714610785,
            -17.56138081412963
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.861667705633327,
            -18.582656107279348
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic scoring system that combines objective values and solution structure, then applies a hybrid local search that includes intelligent item swaps, objective-biased flips, and adaptive perturbations, while ensuring feasibility through continuous capacity checks and solution quality validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        structure_score = np.sum(sol) / len(sol)\n        objective_score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4)\n        score = objective_score * (1 + structure_score * 0.5)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Moderate search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            if random.random() < 0.7:  # Higher probability for value1\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                item_in = random.choice(included)\n                item_out = random.choice(excluded)\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 60))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 60))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.42503736160007,
            -17.84383453637814
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments, using a different parameterization of the score function to prioritize value2 over value1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with modified parameterization\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.3 + obj[1]/max_value2 * 0.7) * (1 + diversity * 0.8)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.3:  # Lower probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.4:  # Lower probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -17.657273300602732,
            -19.2842467065651
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips, while ensuring feasibility by dynamically adjusting the search based on the current solution's dominance in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions with different weights\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (0.6 * obj[0]/max_value1 + 0.4 * obj[1]/max_value2) * (1 + 0.5 * diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(7):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with weighted randomness\n            item_in = random.choices(included, weights=value1_lst[included] + value2_lst[included])[0]\n            item_out = random.choices(excluded, weights=value1_lst[excluded] + value2_lst[excluded])[0]\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker with probability\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items with weighted selection\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.22057332711458,
            -18.006238510754542
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.308257786384512,
            -17.896404742415037
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):  # Moderate search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.6:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.5:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 50))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.471293423175954,
            -17.601485213985136
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and item diversity, then applies a novel local search combining targeted value-ratio swaps, capacity-aware perturbations, and objective-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) * (1 - np.std(normalized_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Targeted value-ratio swaps\n    if len(base_solution) >= 2:\n        ratio1 = value1_lst / (weight_lst + 1e-10)\n        ratio2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratio = ratio1 + ratio2\n\n        # Find items to swap based on ratio differences\n        for _ in range(3):\n            i, j = random.sample(range(len(base_solution)), 2)\n            if base_solution[i] != base_solution[j]:\n                delta_ratio = combined_ratio[j] - combined_ratio[i]\n                if delta_ratio > 0 and (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n    # Step 2: Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low normalized value ratios\n        norm_ratio = (ratio1 + ratio2) / (np.max(ratio1 + ratio2) + 1e-10)\n        sorted_indices = np.argsort(norm_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-balanced flips\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:\n            # Flip out items that are below objective medians\n            if (value1_lst[i] < np.median(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.median(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.2:\n            # Flip in items that are above objective medians\n            if (value1_lst[i] > np.median(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.median(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.978756819803827,
            -18.462973588442047
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and weight utilization, then applies a hybrid local search that uses an \"objective-aware\" item swapping strategy combined with a capacity-aware value redistribution mechanism to explore the solution space while ensuring feasibility and balancing both objectives through dynamic value prioritization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight utilization\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_solution, (v1, v2) = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate objective scores for included items\n        obj_scores = (value1_lst[included] / (v1 + 1e-10)) + (value2_lst[included] / (v2 + 1e-10))\n        obj_scores /= np.sum(obj_scores) if np.sum(obj_scores) > 0 else 1.0\n\n        # Select items to potentially swap based on objective scores\n        swap_items = np.random.choice(included, size=min(2, len(included)), p=obj_scores)\n\n        for item in swap_items:\n            # Find best replacement from excluded items\n            available_weight = capacity - (total_weight - weight_lst[item])\n            candidates = [i for i in excluded if weight_lst[i] <= available_weight]\n\n            if candidates:\n                # Calculate objective-aware scores for candidates\n                candidate_scores = (value1_lst[candidates] / (v1 + 1e-10)) + (value2_lst[candidates] / (v2 + 1e-10))\n                candidate_scores /= (weight_lst[candidates] + 1e-10)\n                best_candidate = candidates[np.argmax(candidate_scores)]\n\n                # Perform swapping\n                new_solution[item] = 0\n                new_solution[best_candidate] = 1\n                total_weight = total_weight - weight_lst[item] + weight_lst[best_candidate]\n\n    # Step 2: Capacity-aware value redistribution\n    if total_weight < capacity:\n        # Calculate normalized value scores for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_scores = (value1_lst[excluded] / (np.max(value1_lst) + 1e-10)) + (value2_lst[excluded] / (np.max(value2_lst) + 1e-10))\n            sorted_items = excluded[np.argsort(-value_scores)]\n\n            # Greedily add items until capacity is reached\n            for item in sorted_items:\n                if weight_lst[item] <= capacity - total_weight:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n                else:\n                    break\n\n    # Step 3: Dynamic value prioritization flip\n    if total_weight < capacity:\n        # Calculate dynamic value priorities\n        value_priority = (value1_lst - v1) + (value2_lst - v2)\n        flip_candidates = np.where(value_priority > np.median(value_priority))[0]\n\n        if len(flip_candidates) > 0:\n            flip_item = random.choice(flip_candidates)\n            if new_solution[flip_item] == 0 and weight_lst[flip_item] <= capacity - total_weight:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.85038896183289,
            -18.630111589985354
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.308257786384512,
            -17.896404742415037
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.7 + obj[1]/max_value2 * 0.3) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(4):  # Moderate search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.6:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.5:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 50))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 50))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.471293423175954,
            -17.601485213985136
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and solution diversity, then applies a hybrid local search combining targeted swaps, objective-aware flips, and adaptive perturbations, while ensuring feasibility through dynamic capacity checks and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 * 0.6 + obj[1]/max_value2 * 0.4) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(3):  # Reduced search steps for efficiency\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap with probability bias\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            if random.random() < 0.7:  # Higher probability for value1\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            else:\n                delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n                delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive flip with objective bias\n        if np.array_equal(new_solution, base_solution):\n            if random.random() < 0.6:  # Higher probability for value1\n                candidates = np.where(value1_lst > np.percentile(value1_lst, 75))[0]\n            else:\n                candidates = np.where(value2_lst > np.percentile(value2_lst, 75))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    # Additional dynamic adjustment based on solution's dominance\n    if np.sum(new_solution) == 0:\n        # If solution is empty, try to add high-value items for both objectives\n        combined_values = value1_lst + value2_lst\n        sorted_items = np.argsort(combined_values)[::-1]\n        for item in sorted_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.308257786384512,
            -17.896404742415037
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.989840748927463,
            -18.43360805396152
        ]
    }
]