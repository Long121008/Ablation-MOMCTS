[
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive and applies a hybrid local search operator that combines item swapping and adaptive perturbation, ensuring feasibility by dynamically adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb adaptively\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Find items to swap or perturb\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Randomly select an included and excluded item\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                # Perform swap\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            new_solution[random_item] = 1 - new_solution[random_item]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                # Revert if infeasible\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.752390265186136,
            -18.305823809960927
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and capacity utilization, then applies a novel local search that combines value-aware swapping, capacity-balanced perturbation, and objective-aware flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high capacity utilization and good objective balance\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Value-aware swapping with objective trade-off consideration\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it improves at least one objective while maintaining feasibility\n            if ((new_value1 > current_value1 or new_value2 > current_value2) and\n                (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Capacity-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-aware flipping\n    for i in range(n_items):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            # Flip out items with low value dominance in either objective\n            if (value1_lst[i] < np.mean(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.mean(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:\n            # Flip in items with high value dominance in either objective\n            if (value1_lst[i] > np.mean(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.mean(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.037421246406957,
            -17.930404769973897
        ]
    },
    {
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines adaptive item swapping, objective-aware perturbation, and dynamic feasibility checks to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swapping and perturbation\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased number of local search steps\n        # Objective-aware item selection\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select item to remove based on both objectives\n            item_in = random.choices(included, weights=value1_lst[included] + value2_lst[included], k=1)[0]\n            item_out = random.choices(excluded, weights=value1_lst[excluded] + value2_lst[excluded], k=1)[0]\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip items based on value\n        if np.array_equal(new_solution, base_solution):\n            # Select items to flip based on value ratio\n            value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            flip_candidates = np.where(value_ratio > np.median(value_ratio))[0]\n            if len(flip_candidates) > 0:\n                random_item = random.choice(flip_candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.604071342312412,
            -18.416396543903165
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and weight balance, then applies a novel local search combining dynamic item substitution, value-aware perturbation, and capacity-adaptive flipping to generate high-quality neighbors while ensuring feasibility through iterative weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight balance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_solution = random.choice(archive_solutions).copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Dynamic item substitution based on value dominance\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select items to potentially swap\n        candidate_in = random.choice(included)\n        candidate_out = random.choice(excluded)\n\n        # Calculate value ratios\n        value_ratio_in = value1_lst[candidate_in] / (value2_lst[candidate_in] + 1e-10)\n        value_ratio_out = value1_lst[candidate_out] / (value2_lst[candidate_out] + 1e-10)\n\n        # Perform substitution if it improves both objectives\n        if value_ratio_out > value_ratio_in:\n            delta_weight = weight_lst[candidate_out] - weight_lst[candidate_in]\n            if total_weight + delta_weight <= capacity:\n                new_solution[candidate_in] = 0\n                new_solution[candidate_out] = 1\n                total_weight += delta_weight\n\n    # Step 2: Value-aware perturbation with capacity consideration\n    if total_weight < capacity * 0.9:\n        # Calculate value density for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            best_item = excluded[np.argmax(value_density[excluded])]\n\n            if weight_lst[best_item] <= capacity - total_weight:\n                new_solution[best_item] = 1\n\n    # Step 3: Capacity-adaptive flipping for fine-tuning\n    if total_weight < capacity:\n        # Flip a random bit if it doesn't exceed capacity\n        random_item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - total_weight:\n            new_solution[random_item] = 1\n        elif new_solution[random_item] == 1:\n            new_solution[random_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.08884813784865,
            -16.822851724373287
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement, then applies a hybrid local search that uses a combination of item swaps, adaptive perturbations, and a novel \"value-balanced\" flip strategy to explore the solution space while ensuring feasibility and prioritizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items, perturb adaptively, and flip based on value balance\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Value-balanced swap\n            item_in = random.choice(included)\n            candidates = [item for item in excluded if weight_lst[item] <= weight_lst[item_in]]\n            if candidates:\n                item_out = random.choice(candidates)\n                current_weight = np.sum(weight_lst * new_solution)\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Value-balanced flip\n        if np.array_equal(new_solution, base_solution):\n            candidates = [i for i in range(n_items) if (new_solution[i] == 0 and weight_lst[i] <= capacity - np.sum(weight_lst * new_solution)) or\n                         (new_solution[i] == 1 and np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity)]\n            if candidates:\n                flip_item = random.choice(candidates)\n                new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Adaptive perturbation\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            if (new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - np.sum(weight_lst * new_solution)) or \\\n               (new_solution[random_item] == 1):\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.633909492738727,
            -18.236489285478783
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining value-weighted item flipping, objective-balanced swapping, and capacity-adaptive perturbation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest crowding distance (diversity-aware selection)\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Value-weighted item flipping (prioritize items with high normalized value)\n    normalized_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    normalized_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    combined_value = normalized_value1 + normalized_value2\n    sorted_indices = np.argsort(combined_value)[::-1]\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n            if random.random() < 0.2:  # 20% chance to remove items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-balanced swapping (swap items to balance both objectives)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it improves the geometric mean of both objectives\n            if (swapped_value1 * swapped_value2) > (new_value1 * new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Capacity-adaptive perturbation (adjust items to utilize capacity more effectively)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio\n        value_ratio = (normalized_value1 + normalized_value2) / weight_lst\n        for i in np.argsort(value_ratio)[::-1]:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio\n        for i in np.argsort(value_ratio):\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -17.58424722957983,
            -18.16390783961988
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid score combining dominance depth and objective diversity, then applies a two-phase local search with adaptive item selection and objective-balanced perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution using hybrid score (dominance depth + objective diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance depth (number of solutions that dominate each solution)\n    dominance_depth = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive_objectives[i][0] >= archive_objectives[j][0] and archive_objectives[i][1] >= archive_objectives[j][1]) and \\\n                   (archive_objectives[i][0] > archive_objectives[j][0] or archive_objectives[i][1] > archive_objectives[j][1]):\n                    dominance_depth[j] += 1\n\n    # Calculate objective diversity (normalized spread in objective space)\n    obj1_vals = np.array([obj[0] for obj in archive_objectives])\n    obj2_vals = np.array([obj[1] for obj in archive_objectives])\n    obj1_range = np.ptp(obj1_vals)\n    obj2_range = np.ptp(obj2_vals)\n    diversity_scores = []\n    for i in range(len(archive)):\n        diversity = 0\n        if obj1_range > 0:\n            diversity += (obj1_vals[i] - np.min(obj1_vals)) / obj1_range\n        if obj2_range > 0:\n            diversity += (obj2_vals[i] - np.min(obj2_vals)) / obj2_range\n        diversity_scores.append(diversity)\n\n    # Combine scores (higher weight to dominance depth)\n    combined_scores = [0.7 * (1 - dominance_depth[i] / len(archive)) + 0.3 * diversity_scores[i] for i in range(len(archive))]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Phase 1: Adaptive item selection (weighted by both objectives)\n    value_ratio1 = value1_lst / (weight_lst + 1e-6)\n    value_ratio2 = value2_lst / (weight_lst + 1e-6)\n    weighted_ratio = 0.6 * value_ratio1 + 0.4 * value_ratio2  # Weighted combination\n    sorted_indices = np.argsort(weighted_ratio)[::-1]\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and random.random() < 0.2:  # 20% chance to remove\n            new_solution[i] = 0\n            total_weight -= weight_lst[i]\n\n    # Phase 2: Objective-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high weighted ratio\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low weighted ratio\n        for i in sorted_indices[::-1]:\n            if new_solution[i] == 1 and total_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Final check for feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove items until feasible\n        sorted_remove = np.argsort(weighted_ratio)\n        for i in sorted_remove:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                if np.sum(weight_lst[new_solution == 1]) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.890933046501086,
            -18.098878050907054
        ]
    },
    {
        "algorithm": "{The new heuristic selects a solution from the archive based on a Pareto-frontier proximity metric, then applies a hybrid local search combining diverse item swaps, objective-specific perturbations, and capacity-aware rebalancing to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution near the Pareto frontier (top 20% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, max(0, len(archive) - 1)) if len(archive) <= 5 else random.randint(0, len(archive) // 5)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Diverse item swaps (prioritize items with high normalized value differences)\n    value_norm1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-8)\n    value_norm2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-8)\n    value_diff = np.abs(value_norm1 - value_norm2)\n    sorted_indices = np.argsort(value_diff)[::-1]\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] <= capacity:\n            if random.random() < 0.2:  # 20% chance to remove low-difference items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-specific perturbations\n    if n_items >= 3:\n        i, j, k = random.sample(range(n_items), 3)\n        # Rotate three items to explore trade-offs\n        if (base_solution[i] + base_solution[j] + base_solution[k]) == 1:  # Exactly one is included\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Step 3: Capacity-aware rebalancing\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with highest value-to-weight ratio for the underrepresented objective\n        obj1_total = np.sum(value1_lst[new_solution == 1])\n        obj2_total = np.sum(value2_lst[new_solution == 1])\n        if obj1_total < obj2_total:\n            target_ratio = value1_lst / weight_lst\n        else:\n            target_ratio = value2_lst / weight_lst\n        sorted_indices = np.argsort(target_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with lowest value-to-weight ratio for the overrepresented objective\n        if obj1_total > obj2_total:\n            target_ratio = value1_lst / weight_lst\n        else:\n            target_ratio = value2_lst / weight_lst\n        sorted_indices = np.argsort(target_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.374858460750275,
            -18.079092825280725
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware metric, then applies a novel local search that combines value-balanced item selection, objective-aware swapping, and capacity-constrained perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: randomly among top 30% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, min(2, len(archive) - 1)) if len(archive) <= 3 else random.randint(0, len(archive) // 3)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Value-balanced item selection (prioritize items with high value-to-weight ratio for both objectives)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2  # Simple combination for multi-objective trade-off\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Descending order\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] <= capacity:\n            if random.random() < 0.3:  # 30% chance to remove low-value items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-aware swapping (swap items to improve both objectives)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if both objectives improve or at least one improves\n            if (swapped_value1 > new_value1 and swapped_value2 >= new_value2) or (swapped_value1 >= new_value1 and swapped_value2 > new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Capacity-constrained perturbation (add or remove items to balance capacity)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio\n        for i in sorted_indices[::-1]:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.09801667107522,
            -17.637557329905533
        ]
    },
    {
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive and applies a hybrid local search that combines item flipping with dynamic weight balancing to generate a neighbor solution, ensuring feasibility by adaptively adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items and balance weights dynamically\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Calculate current weight and value contributions\n        current_weight = np.sum(weight_lst * new_solution)\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n\n        # Identify items to flip\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate potential value-to-weight ratios for excluded items\n            ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n            best_excluded = excluded[np.argmax(ratios)]\n\n            # Calculate potential value-to-weight ratios for included items\n            ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            worst_included = included[np.argmin(ratios)]\n\n            # Check feasibility of adding best_excluded and removing worst_included\n            delta_weight = weight_lst[best_excluded] - weight_lst[worst_included]\n            if current_weight + delta_weight <= capacity:\n                new_solution[worst_included] = 0\n                new_solution[best_excluded] = 1\n            else:\n                # If swap is infeasible, try adding the best excluded item\n                if current_weight + weight_lst[best_excluded] <= capacity:\n                    new_solution[best_excluded] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            if current_weight + (1 - 2 * new_solution[random_item]) * weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.160815882025673,
            -17.48578207668115
        ]
    }
]