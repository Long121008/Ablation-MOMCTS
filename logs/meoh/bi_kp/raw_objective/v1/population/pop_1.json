[
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search that combines item swapping, probabilistic flipping, and capacity-aware perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: randomly among top 30% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, min(2, len(archive) - 1)) if len(archive) <= 3 else random.randint(0, len(archive) // 3)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swapping, flipping, and perturbation\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Random swapping of items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n            if new_weight <= capacity:\n                total_weight = new_weight\n            else:\n                new_solution = base_solution.copy()\n\n    # Step 2: Probabilistic flipping of items\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip each item\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Step 3: Capacity-aware perturbation (if still feasible)\n    if total_weight < capacity * 0.9:  # Add items if underutilized\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            i = random.choice(available_items)\n            if total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -17.350624648789527,
            -17.182688380758343
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines adaptive neighborhood exploration with objective-specific perturbations, dynamically balancing between intensification and diversification to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate improvement potential (difference from current to best)\n        best_val1 = max(obj[0] for _, obj in archive)\n        best_val2 = max(obj[1] for _, obj in archive)\n        candidates = []\n        for sol, obj in archive:\n            potential = (best_val1 - obj[0]) + (best_val2 - obj[1])\n            candidates.append((potential, sol))\n        # Select solution with highest potential\n        candidates.sort(reverse=True, key=lambda x: x[0])\n        base_solution = candidates[0][1].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive perturbation and objective-specific flips\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Identify critical items (high impact on both objectives)\n    impact_scores = (value1_lst + value2_lst) * new_solution\n    critical_items = np.argsort(impact_scores)[-max(2, len(impact_scores)//5):]\n\n    # Step 2: Adaptive perturbation - flip critical items with probability\n    for item in critical_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 3: Objective-specific flips to balance objectives\n    current_val1 = np.sum(value1_lst * new_solution)\n    current_val2 = np.sum(value2_lst * new_solution)\n\n    # If one objective is significantly worse, try to improve it\n    if current_val1 < current_val2 * 0.7:  # Value1 is significantly worse\n        # Add items with high value1 that fit\n        possible_adds = np.where((new_solution == 0) &\n                                (weight_lst <= remaining_capacity))[0]\n        if len(possible_adds) > 0:\n            best_add = possible_adds[np.argmax(value1_lst[possible_adds])]\n            if current_weight + weight_lst[best_add] <= capacity:\n                new_solution[best_add] = 1\n    elif current_val2 < current_val1 * 0.7:  # Value2 is significantly worse\n        # Add items with high value2 that fit\n        possible_adds = np.where((new_solution == 0) &\n                                (weight_lst <= remaining_capacity))[0]\n        if len(possible_adds) > 0:\n            best_add = possible_adds[np.argmax(value2_lst[possible_adds])]\n            if current_weight + weight_lst[best_add] <= capacity:\n                new_solution[best_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -13.867814611320007,
            -13.788981778910951
        ]
    }
]