[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and weight balance, then applies a novel hybrid local search that uses a \"value-weighted\" item reshuffling strategy combined with a capacity-aware item redistribution mechanism to explore the solution space while ensuring feasibility and balancing both objectives through adaptive value weighting.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective diversity and weight balance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions).copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Value-weighted item reshuffling\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0:\n        # Calculate value weights for included items\n        value_weights = (value1_lst + value2_lst) * new_solution\n        value_weights /= np.sum(value_weights) if np.sum(value_weights) > 0 else 1.0\n\n        # Select items to potentially reshuffle based on value weights\n        reshuffle_items = np.random.choice(included, size=min(3, len(included)), p=value_weights[included])\n\n        for item in reshuffle_items:\n            # Find best replacement from excluded items\n            available_weight = capacity - (total_weight - weight_lst[item])\n            candidates = [i for i in excluded if weight_lst[i] <= available_weight]\n\n            if candidates:\n                # Calculate value-weighted scores for candidates\n                candidate_scores = (value1_lst[candidates] + value2_lst[candidates]) / (weight_lst[candidates] + 1e-10)\n                best_candidate = candidates[np.argmax(candidate_scores)]\n\n                # Perform reshuffling\n                new_solution[item] = 0\n                new_solution[best_candidate] = 1\n                total_weight = total_weight - weight_lst[item] + weight_lst[best_candidate]\n\n    # Step 2: Capacity-aware item redistribution\n    if total_weight < capacity:\n        # Calculate value density for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            sorted_items = excluded[np.argsort(-value_density[excluded])]\n\n            # Greedily add items until capacity is reached\n            for item in sorted_items:\n                if weight_lst[item] <= capacity - total_weight:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n                else:\n                    break\n\n    # Step 3: Adaptive value balancing flip\n    if total_weight < capacity:\n        # Calculate value balance scores for all items\n        value_balance = (value1_lst - value2_lst) / (weight_lst + 1e-10)\n        flip_candidates = np.where(value_balance > np.mean(value_balance))[0]\n\n        if len(flip_candidates) > 0:\n            flip_item = random.choice(flip_candidates)\n            if new_solution[flip_item] == 0 and weight_lst[flip_item] <= capacity - total_weight:\n                new_solution[flip_item] = 1\n            elif new_solution[flip_item] == 1:\n                new_solution[flip_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -18.64818428020884,
            -18.58724172666227
        ]
    },
    {
        "algorithm": "{The new heuristic function selects a solution from the archive based on a dynamic score combining normalized objective values and item diversity, then applies a hybrid local search combining targeted swaps, adaptive perturbations, and objective-aware flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate dynamic scores for solutions\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(sol) / len(sol)\n        score = (obj[0]/max_value1 + obj[1]/max_value2) * (1 + diversity)\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware operations\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased search steps\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Objective-aware swap\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Calculate potential objective improvements\n            delta_value1 = value1_lst[item_out] - value1_lst[item_in]\n            delta_value2 = value2_lst[item_out] - value2_lst[item_in]\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity and (delta_value1 > 0 or delta_value2 > 0):\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation with objective bias\n        if np.array_equal(new_solution, base_solution):\n            # Flip based on which objective is weaker\n            if archive[selected_idx][1][0] < archive[selected_idx][1][1]:\n                candidates = np.where(value1_lst > np.median(value1_lst))[0]\n            else:\n                candidates = np.where(value2_lst > np.median(value2_lst))[0]\n\n            if len(candidates) > 0:\n                random_item = random.choice(candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.824035122131903,
            -18.489819145605054
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and weight balance, then applies a novel local search combining dynamic item substitution, value-aware perturbation, and capacity-adaptive flipping to generate high-quality neighbors while ensuring feasibility through iterative weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight balance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_solution = random.choice(archive_solutions).copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Dynamic item substitution based on value dominance\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select items to potentially swap\n        candidate_in = random.choice(included)\n        candidate_out = random.choice(excluded)\n\n        # Calculate value ratios\n        value_ratio_in = value1_lst[candidate_in] / (value2_lst[candidate_in] + 1e-10)\n        value_ratio_out = value1_lst[candidate_out] / (value2_lst[candidate_out] + 1e-10)\n\n        # Perform substitution if it improves both objectives\n        if value_ratio_out > value_ratio_in:\n            delta_weight = weight_lst[candidate_out] - weight_lst[candidate_in]\n            if total_weight + delta_weight <= capacity:\n                new_solution[candidate_in] = 0\n                new_solution[candidate_out] = 1\n                total_weight += delta_weight\n\n    # Step 2: Value-aware perturbation with capacity consideration\n    if total_weight < capacity * 0.9:\n        # Calculate value density for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            best_item = excluded[np.argmax(value_density[excluded])]\n\n            if weight_lst[best_item] <= capacity - total_weight:\n                new_solution[best_item] = 1\n\n    # Step 3: Capacity-adaptive flipping for fine-tuning\n    if total_weight < capacity:\n        # Flip a random bit if it doesn't exceed capacity\n        random_item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - total_weight:\n            new_solution[random_item] = 1\n        elif new_solution[random_item] == 1:\n            new_solution[random_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.147045858191305,
            -17.27113053967086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and weight balance, then applies a novel local search combining dynamic item substitution, value-aware perturbation, and capacity-adaptive flipping to generate high-quality neighbors while ensuring feasibility through iterative weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight balance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_solution = random.choice(archive_solutions).copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Dynamic item substitution based on value dominance\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select items to potentially swap\n        candidate_in = random.choice(included)\n        candidate_out = random.choice(excluded)\n\n        # Calculate value ratios\n        value_ratio_in = value1_lst[candidate_in] / (value2_lst[candidate_in] + 1e-10)\n        value_ratio_out = value1_lst[candidate_out] / (value2_lst[candidate_out] + 1e-10)\n\n        # Perform substitution if it improves both objectives\n        if value_ratio_out > value_ratio_in:\n            delta_weight = weight_lst[candidate_out] - weight_lst[candidate_in]\n            if total_weight + delta_weight <= capacity:\n                new_solution[candidate_in] = 0\n                new_solution[candidate_out] = 1\n                total_weight += delta_weight\n\n    # Step 2: Value-aware perturbation with capacity consideration\n    if total_weight < capacity * 0.9:\n        # Calculate value density for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            best_item = excluded[np.argmax(value_density[excluded])]\n\n            if weight_lst[best_item] <= capacity - total_weight:\n                new_solution[best_item] = 1\n\n    # Step 3: Capacity-adaptive flipping for fine-tuning\n    if total_weight < capacity:\n        # Flip a random bit if it doesn't exceed capacity\n        random_item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - total_weight:\n            new_solution[random_item] = 1\n        elif new_solution[random_item] == 1:\n            new_solution[random_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.24867683502095,
            -17.038118041006
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and capacity utilization, then applies a novel local search that combines value-aware swapping, capacity-balanced perturbation, and objective-aware flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high capacity utilization and good objective balance\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Value-aware swapping with objective trade-off consideration\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it improves at least one objective while maintaining feasibility\n            if ((new_value1 > current_value1 or new_value2 > current_value2) and\n                (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Capacity-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-aware flipping\n    for i in range(n_items):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            # Flip out items with low value dominance in either objective\n            if (value1_lst[i] < np.mean(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.mean(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:\n            # Flip in items with high value dominance in either objective\n            if (value1_lst[i] > np.mean(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.mean(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.037421246406957,
            -17.930404769973897
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic trade-off between objective dominance and solution diversity, then applies a hybrid local search that combines adaptive value-driven swaps, capacity-aware perturbations, and a novel objective-space exploration strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective score\n    scores = [v1 * 0.7 + v2 * 0.3 for _, (v1, v2) in archive]\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic trade-off between objectives\n    tradeoff = random.uniform(0.3, 0.7)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Adaptive value-driven swaps\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        for _ in range(3):\n            item_in = random.choice(included)\n            candidates = [item for item in excluded if weight_lst[item] <= weight_lst[item_in] + 0.1 * capacity]\n\n            if candidates:\n                # Evaluate candidates based on dynamic trade-off\n                candidate_scores = [(value1_lst[item] * tradeoff + value2_lst[item] * (1 - tradeoff)) for item in candidates]\n                item_out = candidates[np.argmax(candidate_scores)]\n\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n                if total_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    total_weight += delta_weight\n\n    # Capacity-aware perturbations\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add high-value items that fit\n        candidate_items = [i for i in excluded if weight_lst[i] <= remaining_capacity]\n        if candidate_items:\n            candidate_scores = [value1_lst[i] * tradeoff + value2_lst[i] * (1 - tradeoff) for i in candidate_items]\n            best_item = candidate_items[np.argmax(candidate_scores)]\n            new_solution[best_item] = 1\n    else:\n        # Remove low-value items to free up space\n        candidate_items = [i for i in included if total_weight - weight_lst[i] <= capacity]\n        if candidate_items:\n            candidate_scores = [value1_lst[i] * tradeoff + value2_lst[i] * (1 - tradeoff) for i in candidate_items]\n            worst_item = candidate_items[np.argmin(candidate_scores)]\n            new_solution[worst_item] = 0\n\n    # Objective-space exploration\n    for i in range(len(weight_lst)):\n        if random.random() < 0.15:  # 15% chance to flip\n            if base_solution[i] == 0 and weight_lst[i] <= capacity - np.sum(weight_lst[new_solution == 1]):\n                new_solution[i] = 1\n            elif base_solution[i] == 1 and np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.082649300128097,
            -17.505662211245028
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective diversity and capacity sensitivity, then applies a novel local search that combines value-weighted flipping, capacity-aware swapping, and objective-balanced perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective diversity and capacity sensitivity\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Value-weighted flipping with objective diversity consideration\n    if n_items >= 1:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            # Flip out items with low value-to-weight ratio in both objectives\n            value_weight_ratio1 = value1_lst[i] / (weight_lst[i] + 1e-10)\n            value_weight_ratio2 = value2_lst[i] / (weight_lst[i] + 1e-10)\n            if (value_weight_ratio1 < 0.7 * np.mean(value1_lst / (weight_lst + 1e-10)) and\n                value_weight_ratio2 < 0.7 * np.mean(value2_lst / (weight_lst + 1e-10))):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        else:\n            # Flip in items with high value-to-weight ratio in at least one objective\n            value_weight_ratio1 = value1_lst[i] / (weight_lst[i] + 1e-10)\n            value_weight_ratio2 = value2_lst[i] / (weight_lst[i] + 1e-10)\n            if ((value_weight_ratio1 > 1.3 * np.mean(value1_lst / (weight_lst + 1e-10)) or\n                 value_weight_ratio2 > 1.3 * np.mean(value2_lst / (weight_lst + 1e-10))) and\n                weight_lst[i] <= capacity - total_weight):\n                new_solution[i] = 1\n\n    # Step 2: Capacity-aware swapping with objective balance consideration\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values and weights\n            new_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it maintains feasibility and improves objective balance\n            if (new_weight <= capacity and\n                ((new_value1 > current_value1 and new_value2 > current_value2) or\n                 (new_value1 > current_value1 and new_value2 >= current_value2 * 0.9) or\n                 (new_value2 > current_value2 and new_value1 >= current_value1 * 0.9))):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Objective-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio in both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio in both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.82264287544064,
            -18.138029894332576
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and capacity utilization, then applies a novel local search that combines value-aware swapping, capacity-balanced perturbation, and objective-aware flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            if ((new_value1 > current_value1 or new_value2 > current_value2) and\n                (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    for i in range(n_items):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            if (value1_lst[i] < np.mean(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.mean(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:\n            if (value1_lst[i] > np.mean(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.mean(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.42145585508827,
            -18.545046924344874
        ]
    },
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive and applies a hybrid local search operator that combines item swapping and adaptive perturbation, ensuring feasibility by dynamically adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb adaptively\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Find items to swap or perturb\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Randomly select an included and excluded item\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                # Perform swap\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            new_solution[random_item] = 1 - new_solution[random_item]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                # Revert if infeasible\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.752390265186136,
            -18.305823809960927
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score combining both objectives, then applies a hybrid local search with adaptive swaps, value-balanced flips, and a novel \"objective-aware\" perturbation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            scores.append(0)\n        else:\n            scores.append(v1 * 0.6 + v2 * 0.4)  # Weighted sum of objectives\n\n    # Select the solution with the highest score\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swaps, value-balanced flips, and objective-aware perturbations\n    n_items = len(base_solution)\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Adaptive swap based on objective values\n        if len(included) > 0 and len(excluded) > 0:\n            item_in = random.choice(included)\n            candidates = [item for item in excluded if weight_lst[item] <= weight_lst[item_in]]\n            if candidates:\n                # Prioritize items that improve both objectives\n                candidate_scores = [(value1_lst[item] + value2_lst[item]) for item in candidates]\n                item_out = candidates[np.argmax(candidate_scores)]\n                current_weight = np.sum(weight_lst * new_solution)\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Objective-aware flip\n        if np.array_equal(new_solution, base_solution):\n            candidates = []\n            for i in range(n_items):\n                if new_solution[i] == 0 and weight_lst[i] <= capacity - np.sum(weight_lst * new_solution):\n                    candidates.append((i, value1_lst[i] + value2_lst[i]))\n                elif new_solution[i] == 1 and np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    candidates.append((i, -value1_lst[i] - value2_lst[i]))\n\n            if candidates:\n                candidates.sort(key=lambda x: x[1], reverse=True)\n                flip_item = candidates[0][0]\n                new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Objective-aware perturbation\n        if np.array_equal(new_solution, base_solution):\n            # Select items with high combined value\n            candidate_items = [i for i in range(n_items) if (value1_lst[i] + value2_lst[i]) > np.mean(value1_lst + value2_lst)]\n            if candidate_items:\n                random_item = random.choice(candidate_items)\n                if (new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - np.sum(weight_lst * new_solution)) or \\\n                   (new_solution[random_item] == 1):\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.81106623670786,
            -18.104203770130837
        ]
    }
]