[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An innovative multi-objective local search operator that combines adaptive objective weighting with dynamic cluster-based swaps and a novel \"value-balancing\" perturbation strategy, using a four-phase approach of weighted item clustering, probabilistic value-balancing swaps, adaptive objective-driven flips, and a feasibility-aware knapsack optimization phase to explore high-quality non-dominated regions while maintaining solution diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    # Phase 1: Adaptive objective weighting and clustering\n    alpha = np.random.uniform(0.4, 0.6)\n    cluster_size = max(3, num_items // 4)\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            in_scores = (value1_lst[cluster_in] * alpha + value2_lst[cluster_in] * (1-alpha)) / weight_lst[cluster_in]\n            out_scores = (value1_lst[cluster_out] * (1-alpha) + value2_lst[cluster_out] * alpha) / weight_lst[cluster_out]\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Value-balancing perturbation\n    for _ in range(5):\n        indices = np.random.choice(num_items, size=min(6, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                balance_factor = (value1_lst[idx] - value2_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n                if balance_factor > 0.4 and np.random.random() < 0.4:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n            else:\n                balance_factor = (value2_lst[idx] - value1_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n                if balance_factor > 0.4 and np.random.random() < 0.5 and (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    # Phase 3: Adaptive objective-driven flips\n    for _ in range(3):\n        indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                if (value1_lst[idx] + value2_lst[idx]) < (np.mean(value1_lst) + np.mean(value2_lst)) and np.random.random() < 0.3:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n            else:\n                if (value1_lst[idx] + value2_lst[idx]) > (np.mean(value1_lst) + np.mean(value2_lst)) and np.random.random() < 0.4:\n                    if (current_weight + weight_lst[idx]) <= capacity:\n                        new_solution[idx] = 1\n\n    # Phase 4: Feasibility-aware knapsack optimization\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_out_items = np.where(new_solution == 1)[0]\n        sorted_out_items = sorted_out_items[np.argsort((value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / weight_lst[sorted_out_items])]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{An advanced multi-objective local search operator that employs dynamic objective prioritization with adaptive weight scaling, cluster-based value-driven swaps, a novel \"profit-imbalance\" perturbation strategy, and an enhanced feasibility-preserving optimization phase to efficiently explore the Pareto front while maintaining solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] * 0.6 + x[1][1] * 0.4))\n    selected_idx = np.random.choice(min(4, len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    alpha = np.random.uniform(0.3, 0.7)\n    cluster_size = max(2, num_items // 5)\n    for _ in range(3):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            in_scores = (value1_lst[cluster_in] * (1-alpha) + value2_lst[cluster_in] * alpha) / (weight_lst[cluster_in] ** 0.7)\n            out_scores = (value1_lst[cluster_out] * alpha + value2_lst[cluster_out] * (1-alpha)) / (weight_lst[cluster_out] ** 0.7)\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for _ in range(6):\n        indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n        for idx in indices:\n            profit_diff = abs(value1_lst[idx] - value2_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n            if new_solution[idx] == 1 and profit_diff > 0.3 and np.random.random() < 0.5:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            elif new_solution[idx] == 0 and profit_diff > 0.3 and np.random.random() < 0.6:\n                if (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n        for idx in indices:\n            value_ratio = (value1_lst[idx] / np.max(value1_lst)) - (value2_lst[idx] / np.max(value2_lst))\n            if new_solution[idx] == 1 and value_ratio < -0.2 and np.random.random() < 0.4:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            elif new_solution[idx] == 0 and value_ratio > 0.2 and np.random.random() < 0.5:\n                if (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_out_items = np.where(new_solution == 1)[0]\n        sorted_out_items = sorted_out_items[np.argsort((value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / (weight_lst[sorted_out_items] ** 0.8))]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.626166031782404,
            -18.030714465045797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] * 0.6 + x[1][1] * 0.4))\n    selected_idx = np.random.choice(min(4, len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    alpha = np.random.uniform(0.3, 0.7)\n    cluster_size = max(2, num_items // 5)\n    for _ in range(3):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            in_scores = (value1_lst[cluster_in] * (1-alpha) + value2_lst[cluster_in] * alpha) / (weight_lst[cluster_in] ** 0.7)\n            out_scores = (value1_lst[cluster_out] * alpha + value2_lst[cluster_out] * (1-alpha)) / (weight_lst[cluster_out] ** 0.7)\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for _ in range(6):\n        indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n        for idx in indices:\n            profit_diff = abs(value1_lst[idx] - value2_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n            if new_solution[idx] == 1 and profit_diff > 0.3 and np.random.random() < 0.5:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            elif new_solution[idx] == 0 and profit_diff > 0.3 and np.random.random() < 0.6:\n                if (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n        for idx in indices:\n            value_ratio = (value1_lst[idx] / np.max(value1_lst)) - (value2_lst[idx] / np.max(value2_lst))\n            if new_solution[idx] == 1 and value_ratio < -0.2 and np.random.random() < 0.4:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            elif new_solution[idx] == 0 and value_ratio > 0.2 and np.random.random() < 0.5:\n                if (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_out_items = np.where(new_solution == 1)[0]\n        sorted_out_items = sorted_out_items[np.argsort((value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / (weight_lst[sorted_out_items] ** 0.8))]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using an adaptive score function parameterization that prioritizes balanced objective contributions, while ensuring feasibility through constrained item selection and dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_scores = (value1_lst[in_items] * 0.3 + value2_lst[in_items] * 0.7) / (weight_lst[in_items] + 1e-6)\n            out_scores = (value1_lst[out_items] * 0.7 + value2_lst[out_items] * 0.3) / (weight_lst[out_items] + 1e-6)\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            if (contribution1 < 0.05 or contribution2 < 0.05) and (current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.168087108417954,
            -18.0662732044596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_scores = (value1_lst[in_items] * 0.3 + value2_lst[in_items] * 0.7) / (weight_lst[in_items] + 1e-6)\n            out_scores = (value1_lst[out_items] * 0.7 + value2_lst[out_items] * 0.3) / (weight_lst[out_items] + 1e-6)\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            if (contribution1 < 0.05 or contribution2 < 0.05) and (current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An innovative multi-objective local search operator that combines adaptive objective weighting with dynamic cluster-based swaps and a novel \"value-balancing\" perturbation strategy, using a four-phase approach of weighted item clustering, probabilistic value-balancing swaps, adaptive objective-driven flips, and a feasibility-aware knapsack optimization phase to explore high-quality non-dominated regions while maintaining solution diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    # Phase 1: Adaptive objective weighting and clustering\n    alpha = np.random.uniform(0.4, 0.6)\n    cluster_size = max(3, num_items // 4)\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            in_scores = (value1_lst[cluster_in] * alpha + value2_lst[cluster_in] * (1-alpha)) / weight_lst[cluster_in]\n            out_scores = (value1_lst[cluster_out] * (1-alpha) + value2_lst[cluster_out] * alpha) / weight_lst[cluster_out]\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Value-balancing perturbation\n    for _ in range(5):\n        indices = np.random.choice(num_items, size=min(6, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                balance_factor = (value1_lst[idx] - value2_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n                if balance_factor > 0.4 and np.random.random() < 0.4:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n            else:\n                balance_factor = (value2_lst[idx] - value1_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n                if balance_factor > 0.4 and np.random.random() < 0.5 and (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    # Phase 3: Adaptive objective-driven flips\n    for _ in range(3):\n        indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                if (value1_lst[idx] + value2_lst[idx]) < (np.mean(value1_lst) + np.mean(value2_lst)) and np.random.random() < 0.3:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n            else:\n                if (value1_lst[idx] + value2_lst[idx]) > (np.mean(value1_lst) + np.mean(value2_lst)) and np.random.random() < 0.4:\n                    if (current_weight + weight_lst[idx]) <= capacity:\n                        new_solution[idx] = 1\n\n    # Phase 4: Feasibility-aware knapsack optimization\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_out_items = np.where(new_solution == 1)[0]\n        sorted_out_items = sorted_out_items[np.argsort((value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / weight_lst[sorted_out_items])]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines adaptive objective-driven clustering with dynamic value-aware perturbations and feasibility-preserving swaps, using a three-stage strategy of cluster-based value optimization, probabilistic objective-balanced flips, and capacity-constrained item swaps to explore diverse non-dominated regions while maintaining solution quality across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    # Stage 1: Adaptive objective-driven clustering and value optimization\n    cluster_size = max(3, num_items // 5)\n    for _ in range(3):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            # Dynamic objective weighting based on current solution\n            alpha = 0.5 + 0.3 * (current_weight / capacity)\n            in_scores = (value1_lst[cluster_in] * alpha + value2_lst[cluster_in] * (1-alpha)) / weight_lst[cluster_in]\n            out_scores = (value1_lst[cluster_out] * (1-alpha) + value2_lst[cluster_out] * alpha) / weight_lst[cluster_out]\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Stage 2: Probabilistic objective-balanced flips\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                # More likely to remove low-value items\n                prob = 0.3 * (1 - (value1_lst[idx] + value2_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst)))\n                if np.random.random() < prob:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n            else:\n                # More likely to add high-value items\n                prob = 0.6 * (value1_lst[idx] + value2_lst[idx]) / (np.max(value1_lst) + np.max(value2_lst))\n                if np.random.random() < prob and (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Stage 3: Feasibility-preserving capacity-constrained swaps\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest value-to-weight ratio first\n        sorted_out_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / weight_lst[sorted_out_items]\n        sorted_out_items = sorted_out_items[np.argsort(ratios)]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{A novel hybrid local search operator that combines adaptive objective-driven clustering with dynamic value-aware perturbations and feasibility-preserving swaps, using a three-stage strategy of cluster-based value optimization, probabilistic objective-balanced flips, and capacity-constrained item swaps to explore diverse non-dominated regions while maintaining solution quality across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    # Stage 1: Adaptive objective-driven clustering with dynamic value optimization\n    cluster_size = max(3, num_items // 6)\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            # Dynamic objective weighting based on current solution's balance\n            alpha = 0.5 + 0.4 * (np.sum(value1_lst * new_solution) / (np.sum(value1_lst * new_solution) + np.sum(value2_lst * new_solution) + 1e-6))\n            in_scores = (value1_lst[cluster_in] * alpha + value2_lst[cluster_in] * (1-alpha)) / weight_lst[cluster_in]\n            out_scores = (value1_lst[cluster_out] * (1-alpha) + value2_lst[cluster_out] * alpha) / weight_lst[cluster_out]\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Stage 2: Probabilistic objective-balanced flips with value-aware perturbations\n    for _ in range(5):\n        indices = np.random.choice(num_items, size=min(7, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                # More likely to remove items with low value imbalance\n                imbalance = abs(value1_lst[idx] - value2_lst[idx]) / (value1_lst[idx] + value2_lst[idx] + 1e-6)\n                prob = 0.2 * (1 - imbalance)\n                if np.random.random() < prob and (current_weight - weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                # More likely to add items with high value balance\n                imbalance = abs(value1_lst[idx] - value2_lst[idx]) / (value1_lst[idx] + value2_lst[idx] + 1e-6)\n                prob = 0.5 * (1 - imbalance)\n                if np.random.random() < prob and (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Stage 3: Feasibility-preserving capacity-constrained swaps with value optimization\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest combined value-to-weight ratio first\n        sorted_out_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / weight_lst[sorted_out_items]\n        sorted_out_items = sorted_out_items[np.argsort(ratios)]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.181193096428824,
            -18.506948910958233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    num_items = len(new_solution)\n\n    # Stage 1: Adaptive objective-driven clustering with dynamic value optimization\n    cluster_size = max(3, num_items // 6)\n    for _ in range(4):\n        indices = np.random.choice(num_items, size=cluster_size, replace=False)\n        cluster_in = indices[new_solution[indices] == 0]\n        cluster_out = indices[new_solution[indices] == 1]\n\n        if len(cluster_in) > 0 and len(cluster_out) > 0:\n            # Dynamic objective weighting based on current solution's balance\n            alpha = 0.5 + 0.4 * (np.sum(value1_lst * new_solution) / (np.sum(value1_lst * new_solution) + np.sum(value2_lst * new_solution) + 1e-6))\n            in_scores = (value1_lst[cluster_in] * alpha + value2_lst[cluster_in] * (1-alpha)) / weight_lst[cluster_in]\n            out_scores = (value1_lst[cluster_out] * (1-alpha) + value2_lst[cluster_out] * alpha) / weight_lst[cluster_out]\n\n            best_in = cluster_in[np.argmax(in_scores)]\n            worst_out = cluster_out[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Stage 2: Probabilistic objective-balanced flips with value-aware perturbations\n    for _ in range(5):\n        indices = np.random.choice(num_items, size=min(7, num_items), replace=False)\n        for idx in indices:\n            if new_solution[idx] == 1:\n                # More likely to remove items with low value imbalance\n                imbalance = abs(value1_lst[idx] - value2_lst[idx]) / (value1_lst[idx] + value2_lst[idx] + 1e-6)\n                prob = 0.2 * (1 - imbalance)\n                if np.random.random() < prob and (current_weight - weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                # More likely to add items with high value balance\n                imbalance = abs(value1_lst[idx] - value2_lst[idx]) / (value1_lst[idx] + value2_lst[idx] + 1e-6)\n                prob = 0.5 * (1 - imbalance)\n                if np.random.random() < prob and (current_weight + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Stage 3: Feasibility-preserving capacity-constrained swaps with value optimization\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest combined value-to-weight ratio first\n        sorted_out_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[sorted_out_items] + value2_lst[sorted_out_items]) / weight_lst[sorted_out_items]\n        sorted_out_items = sorted_out_items[np.argsort(ratios)]\n\n        for idx in sorted_out_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    }
]