[
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.064540309795028,
            -18.61274387020973
        ]
    },
    {
        "algorithm": "{A novel adaptive local search operator dynamically adjusts neighborhood size and selection probability based on solution quality, combining item flips with a value-weighted swap mechanism to explore diverse regions while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([v1 + v2 for _, (v1, v2) in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Adaptive neighborhood size based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_flip = min(5, len(base_solution))\n    flip_size = max(1, int(max_flip * (1 - quality / np.max(total_values))))\n\n    # Dynamic item flips with value-weighted probability\n    flip_probs = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_probs = flip_probs / np.sum(flip_probs)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, p=flip_probs, replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Value-weighted swaps based on objective importance\n    obj1_weight = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n    obj2_weight = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Combined value-to-weight ratio considering both objectives\n            in_scores = (obj1_weight * value1_lst[in_items] + obj2_weight * value2_lst[in_items]) / weight_lst[in_items]\n            out_scores = (obj1_weight * value1_lst[out_items] + obj2_weight * value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.144736987535413,
            -18.503805165956177
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] * 0.7 + x[1][1] * 0.3))  # Sort by weighted total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement with different scoring\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value scores with different weights\n            in_scores = (value1_lst[in_items] * 0.5 + value2_lst[in_items] * 0.5) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation with different probability\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.20505881486052,
            -19.23128181075814
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on value diversity\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item replacement - replace low-value items with high-value ones\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            # Calculate normalized value scores using a different parameter setting\n            out_scores = (value1_lst[out_items] * 0.7 + value2_lst[out_items] * 0.3) / (weight_lst[out_items] + 1e-6)\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / (weight_lst[in_items] + 1e-6)\n\n            # Select items with lowest and highest scores\n            worst_out = out_items[np.argmin(out_scores)]\n            best_in = in_items[np.argmax(in_scores)]\n\n            # Check if replacement is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Randomized item perturbation - small chance to flip items\n    for idx in range(num_items):\n        if random.random() < 0.15:  # 15% chance to perturb\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.208690975029782,
            -17.65911843088295
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on their contribution to objectives\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Calculate potential new weight and objective values if we remove this item\n            new_weight = current_weight - weight_lst[idx]\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n        else:\n            # Calculate potential new weight and objective values if we add this item\n            new_weight = current_weight + weight_lst[idx]\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Only flip if it doesn't violate capacity and improves at least one objective\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item swap - swap items based on their marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate marginal contribution scores for in-items (potential additions)\n            in_scores = (value1_lst[in_items] * 0.4 + value2_lst[in_items] * 0.6) / (weight_lst[in_items] + 1e-6)\n\n            # Calculate marginal contribution scores for out-items (potential removals)\n            out_scores = (value1_lst[out_items] * 0.6 + value2_lst[out_items] * 0.4) / (weight_lst[out_items] + 1e-6)\n\n            # Select items to swap\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Final perturbation - flip items with low contribution\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Calculate contribution of this item to both objectives\n            contribution1 = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            contribution2 = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n\n            # Flip if contribution is below a threshold and removal is feasible\n            if (contribution1 < 0.1 and contribution2 < 0.1 and\n                current_weight - weight_lst[idx] <= capacity):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00183097183058,
            -18.72652047854329
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism using a different score function parameterization to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / (weight_lst[out_items] + 1e-6)\n            in_scores = (value1_lst[in_items] * 0.3 + value2_lst[in_items] * 0.7) / (weight_lst[in_items] + 1e-6)\n\n            worst_out = out_items[np.argmin(out_scores)]\n            best_in = in_items[np.argmax(in_scores)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    for idx in range(num_items):\n        if random.random() < 0.10:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -17.945161072157624,
            -19.19924042162659
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total value\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using a novel two-phase approach\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement\n    for _ in range(3):  # Perform 3 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate normalized value scores\n            in_scores = (value1_lst[in_items] * 0.6 + value2_lst[in_items] * 0.4) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.4 + value2_lst[out_items] * 0.6) / weight_lst[out_items]\n\n            # Select top candidate to add and bottom candidate to remove\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check feasibility\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.881810520891953,
            -18.617428695634146
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-criteria item selection strategy with an adaptive neighborhood perturbation mechanism, dynamically adjusting the search focus between value maximization and weight efficiency while maintaining feasibility through a hybrid of deterministic and randomized local moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    values = np.array([x[1][0] + x[1][1] for x in archive])\n    weights = np.array([np.sum(weight_lst * x[0]) for x in archive])\n    scores = (values / weights) * (1 + 0.1 * np.random.rand(len(archive)))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-weighted item replacement\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate combined value scores\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            # Select items with highest potential\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check feasibility and perform swap\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Adaptive neighborhood perturbation\n    num_items = len(base_solution)\n    adaptivity = min(5, num_items)\n    perturb_indices = np.random.choice(num_items, size=adaptivity, replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Consider adding with probability based on relative value\n            value_ratio = (value1_lst[idx] + value2_lst[idx]) / np.mean(value1_lst + value2_lst)\n            if np.random.rand() < value_ratio and (current_weight + weight_lst[idx] <= capacity):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.72643277518261,
            -18.644855266734602
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on value dominance\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - prioritize high-value items for each objective\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios for each objective\n            in_ratios1 = value1_lst[in_items] / weight_lst[in_items]\n            out_ratios1 = value1_lst[out_items] / weight_lst[out_items]\n\n            in_ratios2 = value2_lst[in_items] / weight_lst[in_items]\n            out_ratios2 = value2_lst[out_items] / weight_lst[out_items]\n\n            # Select items with highest ratios for each objective\n            best_in1 = in_items[np.argmax(in_ratios1)]\n            worst_out1 = out_items[np.argmin(out_ratios1)]\n\n            best_in2 = in_items[np.argmax(in_ratios2)]\n            worst_out2 = out_items[np.argmin(out_ratios2)]\n\n            # Choose the more promising swap\n            swap1_value = (value1_lst[best_in1] - value1_lst[worst_out1]) + (value2_lst[best_in1] - value2_lst[worst_out1])\n            swap2_value = (value1_lst[best_in2] - value1_lst[worst_out2]) + (value2_lst[best_in2] - value2_lst[worst_out2])\n\n            if swap1_value > swap2_value:\n                best_in, worst_out = best_in1, worst_out1\n            else:\n                best_in, worst_out = best_in2, worst_out2\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -17.488041436472912,
            -19.073657588325936
        ]
    }
]