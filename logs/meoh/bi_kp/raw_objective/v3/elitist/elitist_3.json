[
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on value diversity\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item replacement - replace low-value items with high-value ones\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            # Calculate normalized value scores using a different parameter setting\n            out_scores = (value1_lst[out_items] * 0.7 + value2_lst[out_items] * 0.3) / (weight_lst[out_items] + 1e-6)\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / (weight_lst[in_items] + 1e-6)\n\n            # Select items with lowest and highest scores\n            worst_out = out_items[np.argmin(out_scores)]\n            best_in = in_items[np.argmax(in_scores)]\n\n            # Check if replacement is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Randomized item perturbation - small chance to flip items\n    for idx in range(num_items):\n        if random.random() < 0.15:  # 15% chance to perturb\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.208690975029782,
            -17.65911843088295
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a value-driven item selection strategy with a dynamic weight adjustment mechanism, where it first identifies high-value items based on both objectives and then adaptively adjusts the solution by considering both value improvements and weight constraints, ensuring feasibility while exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([v1 + v2 for (sol, (v1, v2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Value-driven item selection - prioritize items with high combined value\n    combined_value = value1_lst + value2_lst\n    sorted_items = np.argsort(combined_value)[::-1]\n\n    for idx in sorted_items:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and random.random() < 0.3:  # 30% chance to remove low-value items\n            if combined_value[idx] < np.median(combined_value):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Step 2: Dynamic weight adjustment - balance objectives by considering value-to-weight ratios\n    for _ in range(3):\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.02752219656019,
            -18.601607318309412
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total value\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using a novel two-phase approach\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-driven item replacement\n    for _ in range(3):  # Perform 3 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate normalized value scores\n            in_scores = (value1_lst[in_items] * 0.6 + value2_lst[in_items] * 0.4) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.4 + value2_lst[out_items] * 0.6) / weight_lst[out_items]\n\n            # Select top candidate to add and bottom candidate to remove\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check feasibility\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Randomized perturbation\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.881810520891953,
            -18.617428695634146
        ]
    },
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive, then applies a hybrid local search operator combining item swaps and adaptive flips to explore high-potential neighborhoods while ensuring feasibility, prioritizing solutions with the highest marginal improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        candidates.append((sol, v1, v2))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Prioritize solutions with the highest marginal improvement potential\n    candidates.sort(key=lambda x: -(x[1] + x[2]))  # Simple heuristic: prioritize high total value\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search: adaptive item swaps and flips\n    new_sol = selected_sol.copy()\n    n_items = len(new_sol)\n\n    # Step 1: Randomly select a subset of items to consider for flip\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    # Step 2: Adaptive flip - flip items that improve both objectives\n    for idx in flip_indices:\n        if new_sol[idx] == 1:\n            new_weight = np.sum(weight_lst[new_sol == 1]) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_sol[idx] = 0\n        else:\n            new_weight = np.sum(weight_lst[new_sol == 1]) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_sol[idx] = 1\n\n    # Step 3: Random swap if the solution didn't change\n    if np.array_equal(new_sol, selected_sol):\n        swap_indices = np.random.choice(n_items, size=2, replace=False)\n        i, j = swap_indices\n        if new_sol[i] != new_sol[j]:\n            temp = new_sol[i]\n            new_sol[i] = new_sol[j]\n            new_sol[j] = temp\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_sol == 1])\n    if total_weight > capacity:\n        # Remove heaviest items until feasible\n        sorted_indices = np.argsort(weight_lst[new_sol == 1])[::-1]\n        for idx in sorted_indices:\n            if total_weight > capacity:\n                new_sol[new_sol == 1][idx] = 0\n                total_weight -= weight_lst[new_sol == 1][idx]\n\n    return new_sol\n\n",
        "score": [
            -19.025344766354777,
            -18.48211120177676
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    values = np.array([x[1][0] + x[1][1] for x in archive])\n    weights = np.array([np.sum(weight_lst * x[0]) for x in archive])\n    scores = values * 0.7 + weights * 0.3  # Balance between value and weight\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Phase 1: Multi-objective item selection\n    for _ in range(2):\n        # Calculate combined value-to-weight ratio\n        ratios = (value1_lst * 0.5 + value2_lst * 0.5) / weight_lst\n\n        # Select items to add (not in solution) with high ratio\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            best_in = candidates[np.argmax(ratios[candidates])]\n            if current_weight + weight_lst[best_in] <= capacity:\n                new_solution[best_in] = 1\n                current_weight += weight_lst[best_in]\n\n    # Phase 2: Intelligent item removal\n    for _ in range(2):\n        # Select items to remove (in solution) with low ratio\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            worst_out = candidates[np.argmin(ratios[candidates])]\n            new_solution[worst_out] = 0\n            current_weight -= weight_lst[worst_out]\n\n    # Phase 3: Randomized diversification\n    num_items = len(new_solution)\n    flip_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.955924381072062,
            -18.544828744320682
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total value\n    selected_idx = min(1, len(archive) - 1)  # Select from top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Phase 1: Value-weighted item replacement\n    for _ in range(2):  # Perform 2 replacements\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate weighted value scores\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / weight_lst[in_items]\n            out_scores = (value1_lst[out_items] * 0.3 + value2_lst[out_items] * 0.7) / weight_lst[out_items]\n\n            # Select top candidate to add and bottom candidate to remove\n            best_in = in_items[np.argmax(in_scores)]\n            worst_out = out_items[np.argmin(out_scores)]\n\n            # Check feasibility\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Phase 2: Adaptive perturbation\n    num_items = len(base_solution)\n    perturb_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.99677019545487,
            -18.34648274625591
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on value diversity\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item replacement - replace low-value items with high-value ones\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            # Calculate normalized value scores\n            out_scores = (value1_lst[out_items] + value2_lst[out_items]) / (weight_lst[out_items] + 1e-6)\n            in_scores = (value1_lst[in_items] + value2_lst[in_items]) / (weight_lst[in_items] + 1e-6)\n\n            # Select items with lowest and highest scores\n            worst_out = out_items[np.argmin(out_scores)]\n            best_in = in_items[np.argmax(in_scores)]\n\n            # Check if replacement is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Randomized item perturbation - small chance to flip items\n    for idx in range(num_items):\n        if random.random() < 0.1:  # 10% chance to perturb\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.936432322404652,
            -18.479213320934416
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swapping and probabilistic flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Item swapping (swap two items if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Swap out i and in j\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap out j and in i\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flipping (flip items with high marginal gain)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item i\n                if current_weight - weight_lst[i] <= capacity:\n                    # Check if removing improves at least one objective\n                    new_val1 = current_val1 - value1_lst[i]\n                    new_val2 = current_val2 - value2_lst[i]\n                    if (new_val1 > current_val1) or (new_val2 > current_val2):\n                        new_solution[i] = 0\n            else:\n                # Consider adding item i\n                if current_weight + weight_lst[i] <= capacity:\n                    # Check if adding improves at least one objective\n                    new_val1 = current_val1 + value1_lst[i]\n                    new_val2 = current_val2 + value2_lst[i]\n                    if (new_val1 > current_val1) or (new_val2 > current_val2):\n                        new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.716256431715426,
            -18.182593853381196
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the highest total value in either objective, then applies a hybrid local search strategy that combines random item swaps with value-based greedy selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total value in either objective\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps with value-based selection\n    for _ in range(10):  # Number of iterations\n        # Randomly select an item to consider flipping\n        candidate_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[candidate_idx] == 1:\n            # If item is in the solution, consider removing it\n            new_weight = current_weight - weight_lst[candidate_idx]\n            if new_weight <= capacity:\n                new_solution[candidate_idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is not in the solution, consider adding it\n            new_weight = current_weight + weight_lst[candidate_idx]\n            if new_weight <= capacity:\n                # Greedily select the item that improves the most in either objective\n                value1_gain = value1_lst[candidate_idx]\n                value2_gain = value2_lst[candidate_idx]\n                if value1_gain > 0 or value2_gain > 0:\n                    new_solution[candidate_idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -17.14182517911808,
            -18.037749599929786
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip items based on value diversity\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(4, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item replacement - replace low-value items with high-value ones\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            # Calculate normalized value scores using a different parameter setting\n            out_scores = (value1_lst[out_items] * 0.7 + value2_lst[out_items] * 0.3) / (weight_lst[out_items] + 1e-6)\n            in_scores = (value1_lst[in_items] * 0.7 + value2_lst[in_items] * 0.3) / (weight_lst[in_items] + 1e-6)\n\n            # Select items with lowest and highest scores\n            worst_out = out_items[np.argmin(out_scores)]\n            best_in = in_items[np.argmax(in_scores)]\n\n            # Check if replacement is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    # Step 3: Randomized item perturbation - small chance to flip items\n    for idx in range(num_items):\n        if random.random() < 0.15:  # 15% chance to perturb\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.208690975029782,
            -17.65911843088295
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic neighborhood exploration strategy with a probabilistic item swap mechanism to intelligently perturb solutions while ensuring feasibility, balancing exploration of promising regions and exploitation of high-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Dynamic neighborhood exploration - flip a random subset of items\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Probabilistic item swap - swap items based on value-to-weight ratio\n    for _ in range(2):  # Perform 2 swaps\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate value-to-weight ratios\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            # Select items with highest and lowest ratios\n            best_in = in_items[np.argmax(in_ratios)]\n            worst_out = out_items[np.argmin(out_ratios)]\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_out] + weight_lst[best_in]) <= capacity:\n                new_solution[worst_out] = 0\n                new_solution[best_in] = 1\n                current_weight = current_weight - weight_lst[worst_out] + weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -19.039968039981336,
            -18.673451700486247
        ]
    }
]