[
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and capacity utilization, then applies a novel local search that combines value-aware swapping, capacity-balanced perturbation, and objective-aware flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            if ((new_value1 > current_value1 or new_value2 > current_value2) and\n                (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    for i in range(n_items):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            if (value1_lst[i] < np.mean(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.mean(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:\n            if (value1_lst[i] > np.mean(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.mean(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.42145585508827,
            -18.545046924344874
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and weight balance, then applies a novel local search combining dynamic item substitution, value-aware perturbation, and capacity-adaptive flipping to generate high-quality neighbors while ensuring feasibility through iterative weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective dominance and weight balance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_solution = random.choice(archive_solutions).copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Dynamic item substitution based on value dominance\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select items to potentially swap\n        candidate_in = random.choice(included)\n        candidate_out = random.choice(excluded)\n\n        # Calculate value ratios\n        value_ratio_in = value1_lst[candidate_in] / (value2_lst[candidate_in] + 1e-10)\n        value_ratio_out = value1_lst[candidate_out] / (value2_lst[candidate_out] + 1e-10)\n\n        # Perform substitution if it improves both objectives\n        if value_ratio_out > value_ratio_in:\n            delta_weight = weight_lst[candidate_out] - weight_lst[candidate_in]\n            if total_weight + delta_weight <= capacity:\n                new_solution[candidate_in] = 0\n                new_solution[candidate_out] = 1\n                total_weight += delta_weight\n\n    # Step 2: Value-aware perturbation with capacity consideration\n    if total_weight < capacity * 0.9:\n        # Calculate value density for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            best_item = excluded[np.argmax(value_density[excluded])]\n\n            if weight_lst[best_item] <= capacity - total_weight:\n                new_solution[best_item] = 1\n\n    # Step 3: Capacity-adaptive flipping for fine-tuning\n    if total_weight < capacity:\n        # Flip a random bit if it doesn't exceed capacity\n        random_item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - total_weight:\n            new_solution[random_item] = 1\n        elif new_solution[random_item] == 1:\n            new_solution[random_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.147045858191305,
            -17.27113053967086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and capacity utilization, then applies a novel local search that combines value-aware swapping, capacity-balanced perturbation, and objective-aware flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high capacity utilization and good objective balance\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Value-aware swapping with objective trade-off consideration\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it improves at least one objective while maintaining feasibility\n            if ((new_value1 > current_value1 or new_value2 > current_value2) and\n                (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Capacity-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-aware flipping\n    for i in range(n_items):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            # Flip out items with low value dominance in either objective\n            if (value1_lst[i] < np.mean(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.mean(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:\n            # Flip in items with high value dominance in either objective\n            if (value1_lst[i] > np.mean(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.mean(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.037421246406957,
            -17.930404769973897
        ]
    },
    {
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines adaptive item swapping, objective-aware perturbation, and dynamic feasibility checks to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swapping and perturbation\n    n_items = len(base_solution)\n    for _ in range(5):  # Increased number of local search steps\n        # Objective-aware item selection\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select item to remove based on both objectives\n            item_in = random.choices(included, weights=value1_lst[included] + value2_lst[included], k=1)[0]\n            item_out = random.choices(excluded, weights=value1_lst[excluded] + value2_lst[excluded], k=1)[0]\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip items based on value\n        if np.array_equal(new_solution, base_solution):\n            # Select items to flip based on value ratio\n            value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            flip_candidates = np.where(value_ratio > np.median(value_ratio))[0]\n            if len(flip_candidates) > 0:\n                random_item = random.choice(flip_candidates)\n                new_solution[random_item] = 1 - new_solution[random_item]\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.604071342312412,
            -18.416396543903165
        ]
    },
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive and applies a hybrid local search operator that combines item swapping and adaptive perturbation, ensuring feasibility by dynamically adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb adaptively\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Find items to swap or perturb\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Randomly select an included and excluded item\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                # Perform swap\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            new_solution[random_item] = 1 - new_solution[random_item]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                # Revert if infeasible\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.752390265186136,
            -18.305823809960927
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective diversity and capacity sensitivity, then applies a novel local search that combines value-weighted flipping, capacity-aware swapping, and objective-balanced perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective diversity and capacity sensitivity\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Value-weighted flipping with objective diversity consideration\n    if n_items >= 1:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            # Flip out items with low value-to-weight ratio in both objectives\n            value_weight_ratio1 = value1_lst[i] / (weight_lst[i] + 1e-10)\n            value_weight_ratio2 = value2_lst[i] / (weight_lst[i] + 1e-10)\n            if (value_weight_ratio1 < 0.7 * np.mean(value1_lst / (weight_lst + 1e-10)) and\n                value_weight_ratio2 < 0.7 * np.mean(value2_lst / (weight_lst + 1e-10))):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        else:\n            # Flip in items with high value-to-weight ratio in at least one objective\n            value_weight_ratio1 = value1_lst[i] / (weight_lst[i] + 1e-10)\n            value_weight_ratio2 = value2_lst[i] / (weight_lst[i] + 1e-10)\n            if ((value_weight_ratio1 > 1.3 * np.mean(value1_lst / (weight_lst + 1e-10)) or\n                 value_weight_ratio2 > 1.3 * np.mean(value2_lst / (weight_lst + 1e-10))) and\n                weight_lst[i] <= capacity - total_weight):\n                new_solution[i] = 1\n\n    # Step 2: Capacity-aware swapping with objective balance consideration\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values and weights\n            new_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it maintains feasibility and improves objective balance\n            if (new_weight <= capacity and\n                ((new_value1 > current_value1 and new_value2 > current_value2) or\n                 (new_value1 > current_value1 and new_value2 >= current_value2 * 0.9) or\n                 (new_value2 > current_value2 and new_value1 >= current_value1 * 0.9))):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Objective-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio in both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio in both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.82264287544064,
            -18.138029894332576
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a score combining both objectives, then applies a hybrid local search with adaptive swaps, value-balanced flips, and a novel \"objective-aware\" perturbation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            scores.append(0)\n        else:\n            scores.append(v1 * 0.6 + v2 * 0.4)  # Weighted sum of objectives\n\n    # Select the solution with the highest score\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swaps, value-balanced flips, and objective-aware perturbations\n    n_items = len(base_solution)\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Adaptive swap based on objective values\n        if len(included) > 0 and len(excluded) > 0:\n            item_in = random.choice(included)\n            candidates = [item for item in excluded if weight_lst[item] <= weight_lst[item_in]]\n            if candidates:\n                # Prioritize items that improve both objectives\n                candidate_scores = [(value1_lst[item] + value2_lst[item]) for item in candidates]\n                item_out = candidates[np.argmax(candidate_scores)]\n                current_weight = np.sum(weight_lst * new_solution)\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Objective-aware flip\n        if np.array_equal(new_solution, base_solution):\n            candidates = []\n            for i in range(n_items):\n                if new_solution[i] == 0 and weight_lst[i] <= capacity - np.sum(weight_lst * new_solution):\n                    candidates.append((i, value1_lst[i] + value2_lst[i]))\n                elif new_solution[i] == 1 and np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    candidates.append((i, -value1_lst[i] - value2_lst[i]))\n\n            if candidates:\n                candidates.sort(key=lambda x: x[1], reverse=True)\n                flip_item = candidates[0][0]\n                new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Objective-aware perturbation\n        if np.array_equal(new_solution, base_solution):\n            # Select items with high combined value\n            candidate_items = [i for i in range(n_items) if (value1_lst[i] + value2_lst[i]) > np.mean(value1_lst + value2_lst)]\n            if candidate_items:\n                random_item = random.choice(candidate_items)\n                if (new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - np.sum(weight_lst * new_solution)) or \\\n                   (new_solution[random_item] == 1):\n                    new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.81106623670786,
            -18.104203770130837
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement, then applies a hybrid local search that uses a combination of item swaps, adaptive perturbations, and a novel \"value-balanced\" flip strategy to explore the solution space while ensuring feasibility and prioritizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items, perturb adaptively, and flip based on value balance\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Value-balanced swap\n            item_in = random.choice(included)\n            candidates = [item for item in excluded if weight_lst[item] <= weight_lst[item_in]]\n            if candidates:\n                item_out = random.choice(candidates)\n                current_weight = np.sum(weight_lst * new_solution)\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Value-balanced flip\n        if np.array_equal(new_solution, base_solution):\n            candidates = [i for i in range(n_items) if (new_solution[i] == 0 and weight_lst[i] <= capacity - np.sum(weight_lst * new_solution)) or\n                         (new_solution[i] == 1 and np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity)]\n            if candidates:\n                flip_item = random.choice(candidates)\n                new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Adaptive perturbation\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            if (new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - np.sum(weight_lst * new_solution)) or \\\n               (new_solution[random_item] == 1):\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.633909492738727,
            -18.236489285478783
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and capacity utilization, then applies a novel local search that combines value-aware swapping, capacity-balanced perturbation, and objective-aware flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high capacity utilization and good objective balance\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Value-aware swapping with objective trade-off consideration\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else current_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else current_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it improves at least one objective while maintaining feasibility\n            if ((new_value1 > current_value1 or new_value2 > current_value2) and\n                (total_weight - weight_lst[i] + weight_lst[j] <= capacity if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i] <= capacity)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Capacity-balanced perturbation\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio for both objectives\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(combined_ratio)\n        for i in sorted_indices:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 3: Objective-aware flipping\n    for i in range(n_items):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            # Flip out items with low value dominance in either objective\n            if (value1_lst[i] < np.mean(value1_lst[base_solution == 1]) and\n                value2_lst[i] < np.mean(value2_lst[base_solution == 1])):\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:\n            # Flip in items with high value dominance in either objective\n            if (value1_lst[i] > np.mean(value1_lst[base_solution == 0]) and\n                value2_lst[i] > np.mean(value2_lst[base_solution == 0])):\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.393310113727708,
            -18.436534058092985
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining value-weighted item flipping, objective-balanced swapping, and capacity-adaptive perturbation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest crowding distance (diversity-aware selection)\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Value-weighted item flipping (prioritize items with high normalized value)\n    normalized_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    normalized_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    combined_value = normalized_value1 + normalized_value2\n    sorted_indices = np.argsort(combined_value)[::-1]\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n            if random.random() < 0.2:  # 20% chance to remove items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-balanced swapping (swap items to balance both objectives)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if it improves the geometric mean of both objectives\n            if (swapped_value1 * swapped_value2) > (new_value1 * new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Capacity-adaptive perturbation (adjust items to utilize capacity more effectively)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio\n        value_ratio = (normalized_value1 + normalized_value2) / weight_lst\n        for i in np.argsort(value_ratio)[::-1]:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio\n        for i in np.argsort(value_ratio):\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -17.58424722957983,
            -18.16390783961988
        ]
    }
]