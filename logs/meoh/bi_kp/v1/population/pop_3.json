[
    {
        "algorithm": "{The heuristic function intelligently selects a non-dominated solution from the archive and applies a hybrid local search operator that combines item swapping and adaptive perturbation, ensuring feasibility by dynamically adjusting item selections while prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb adaptively\n    n_items = len(base_solution)\n    for _ in range(3):  # Number of local search steps\n        # Find items to swap or perturb\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Randomly select an included and excluded item\n            item_in = random.choice(included)\n            item_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n            if current_weight + delta_weight <= capacity:\n                # Perform swap\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n        # Adaptive perturbation: flip a random bit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            new_solution[random_item] = 1 - new_solution[random_item]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                # Revert if infeasible\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.752390265186136,
            -18.305823809960927
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement, then applies a hybrid local search that uses a combination of item swaps, adaptive perturbations, and a novel \"value-balanced\" flip strategy to explore the solution space while ensuring feasibility and prioritizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    potential_solutions = []\n\n    for sol in archive_solutions:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = archive_solutions\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items, perturb adaptively, and flip based on value balance\n    n_items = len(base_solution)\n    for _ in range(3):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Value-balanced swap\n            item_in = random.choice(included)\n            candidates = [item for item in excluded if weight_lst[item] <= weight_lst[item_in]]\n            if candidates:\n                item_out = random.choice(candidates)\n                current_weight = np.sum(weight_lst * new_solution)\n                delta_weight = weight_lst[item_out] - weight_lst[item_in]\n\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n        # Value-balanced flip\n        if np.array_equal(new_solution, base_solution):\n            candidates = [i for i in range(n_items) if (new_solution[i] == 0 and weight_lst[i] <= capacity - np.sum(weight_lst * new_solution)) or\n                         (new_solution[i] == 1 and np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity)]\n            if candidates:\n                flip_item = random.choice(candidates)\n                new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Adaptive perturbation\n        if np.array_equal(new_solution, base_solution):\n            random_item = random.randint(0, n_items - 1)\n            if (new_solution[random_item] == 0 and weight_lst[random_item] <= capacity - np.sum(weight_lst * new_solution)) or \\\n               (new_solution[random_item] == 1):\n                new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -18.633909492738727,
            -18.236489285478783
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware metric, then applies a novel local search that combines value-balanced item selection, objective-aware swapping, and capacity-constrained perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: randomly among top 30% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, min(2, len(archive) - 1)) if len(archive) <= 3 else random.randint(0, len(archive) // 3)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Value-balanced item selection (prioritize items with high value-to-weight ratio for both objectives)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2  # Simple combination for multi-objective trade-off\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Descending order\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] <= capacity:\n            if random.random() < 0.3:  # 30% chance to remove low-value items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-aware swapping (swap items to improve both objectives)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Calculate potential new values\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if both objectives improve or at least one improves\n            if (swapped_value1 > new_value1 and swapped_value2 >= new_value2) or (swapped_value1 >= new_value1 and swapped_value2 > new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Capacity-constrained perturbation (add or remove items to balance capacity)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Add items with high value-to-weight ratio\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        # Remove items with low value-to-weight ratio\n        for i in sorted_indices[::-1]:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.09801667107522,
            -17.637557329905533
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-aware score, then applies a hybrid local search that combines weighted item selection, objective-specific swapping, and adaptive capacity adjustment to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: based on dominance score)\n    scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] >= obj[0] and other_obj[1] > obj[1]) or (other_obj[0] > obj[0] and other_obj[1] >= obj[1]):\n                dominated += 1\n        scores.append(dominated)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Weighted item selection (prioritize items with high value-to-weight ratio for both objectives)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = 0.6 * value_ratio1 + 0.4 * value_ratio2  # Weighted combination\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n\n    for i in sorted_indices:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] <= capacity:\n            if random.random() < 0.2:  # 20% chance to remove low-value items\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Objective-specific swapping (swap items to improve both objectives)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept swap if both objectives improve or at least one improves significantly\n            if (swapped_value1 > new_value1 and swapped_value2 > new_value2) or \\\n               (swapped_value1 > new_value1 + 0.1 * new_value1 and swapped_value2 >= new_value2) or \\\n               (swapped_value1 >= new_value1 and swapped_value2 > new_value2 + 0.1 * new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Adaptive capacity adjustment (add or remove items to balance capacity)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n    else:\n        for i in sorted_indices[::-1]:\n            if new_solution[i] == 1 and (total_weight - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -17.64883724793985,
            -17.76683214782728
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel local search combining item clustering, objective-weighted flipping, and capacity-constrained perturbation to explore high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: based on diversity metric)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by similar objective contributions\n    n_items = len(weight_lst)\n    if n_items > 1:\n        # Create clusters of items with similar value ratios\n        ratios = value1_lst / (value2_lst + 1e-10)\n        clusters = {}\n        for i in range(n_items):\n            cluster_key = round(ratios[i], 1)\n            if cluster_key not in clusters:\n                clusters[cluster_key] = []\n            clusters[cluster_key].append(i)\n\n        # Step 2: Objective-weighted flipping within clusters\n        for cluster in clusters.values():\n            if len(cluster) > 1:\n                i = random.choice(cluster)\n                j = random.choice(cluster)\n                if i != j:\n                    # Flip based on objective dominance\n                    if value1_lst[i] > value1_lst[j] and value2_lst[i] > value2_lst[j]:\n                        if new_solution[i] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                    else:\n                        if new_solution[j] == 1 and np.sum(weight_lst[new_solution == 1]) - weight_lst[j] <= capacity:\n                            new_solution[j] = 0\n\n    # Step 3: Capacity-constrained perturbation\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight < capacity * 0.95:\n        # Add items with highest combined value density\n        remaining_capacity = capacity - total_weight\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate value density (sum of normalized values per weight)\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            best_item = available_items[np.argmax(value_density[available_items])]\n            if weight_lst[best_item] <= remaining_capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.109929365102712,
            -17.0573024322208
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-aware metric, then applies a novel local search that combines objective-balanced item replacement, Pareto-frontier guided perturbation, and capacity-constrained swapping to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution based on dominance metric (prioritize solutions on the Pareto frontier)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts for each solution\n    dominance_counts = []\n    for i in range(len(archive_solutions)):\n        count = 0\n        for j in range(len(archive_solutions)):\n            if i != j:\n                if (archive_objectives[i][0] >= archive_objectives[j][0] and archive_objectives[i][1] >= archive_objectives[j][1]) and \\\n                   (archive_objectives[i][0] > archive_objectives[j][0] or archive_objectives[i][1] > archive_objectives[j][1]):\n                    count += 1\n        dominance_counts.append(count)\n\n    # Select the solution with highest dominance count (most dominating)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Objective-balanced item replacement\n    if n_items > 0:\n        # Calculate value ratios for each item\n        value_ratio1 = value1_lst / (weight_lst + 1e-10)\n        value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Find items to replace (lowest value ratios in the solution)\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) > 0:\n            worst_item = in_solution[np.argmin(value_ratio1[in_solution] + value_ratio2[in_solution])]\n\n            # Find best candidate to replace with (highest value ratios not in solution)\n            not_in_solution = np.where(base_solution == 0)[0]\n            if len(not_in_solution) > 0:\n                best_candidate = not_in_solution[np.argmax(value_ratio1[not_in_solution] + value_ratio2[not_in_solution])]\n\n                # Check feasibility before replacement\n                if weight_lst[best_candidate] <= weight_lst[worst_item] or (total_weight - weight_lst[worst_item] + weight_lst[best_candidate] <= capacity):\n                    new_solution[worst_item] = 0\n                    new_solution[best_candidate] = 1\n\n    # Step 2: Pareto-frontier guided perturbation\n    if random.random() < 0.3:  # 30% chance to perturb\n        # Find the most dominated solution in the archive\n        if len(archive_solutions) > 1:\n            dominated_idx = np.argmin(dominance_counts)\n            dominated_solution = archive_solutions[dominated_idx]\n\n            # Find items that differ between the selected and dominated solutions\n            diff_items = np.where(base_solution != dominated_solution)[0]\n\n            if len(diff_items) > 0:\n                # Randomly select a differing item to flip\n                flip_item = random.choice(diff_items)\n\n                # Flip the item if it improves the solution's dominance\n                if base_solution[flip_item] == 1:\n                    if total_weight - weight_lst[flip_item] <= capacity:\n                        new_solution[flip_item] = 0\n                else:\n                    if total_weight + weight_lst[flip_item] <= capacity:\n                        new_solution[flip_item] = 1\n\n    # Step 3: Capacity-constrained swapping\n    if n_items >= 2:\n        # Select two items to swap\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate potential new weight\n        new_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n\n        # Accept swap if feasible and improves one or both objectives\n        if new_weight <= capacity:\n            new_value1 = np.sum(value1_lst[new_solution == 1])\n            new_value2 = np.sum(value2_lst[new_solution == 1])\n            swapped_value1 = new_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else new_value1 + value1_lst[j] - value1_lst[i]\n            swapped_value2 = new_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else new_value2 + value2_lst[j] - value2_lst[i]\n\n            # Accept if at least one objective improves\n            if (swapped_value1 > new_value1) or (swapped_value2 > new_value2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -17.91642786420885,
            -17.217703386757073
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search that combines item swapping, probabilistic flipping, and capacity-aware perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here: randomly among top 30% by diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, min(2, len(archive) - 1)) if len(archive) <= 3 else random.randint(0, len(archive) // 3)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swapping, flipping, and perturbation\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Random swapping of items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = total_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else total_weight + weight_lst[j] - weight_lst[i]\n            if new_weight <= capacity:\n                total_weight = new_weight\n            else:\n                new_solution = base_solution.copy()\n\n    # Step 2: Probabilistic flipping of items\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip each item\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Step 3: Capacity-aware perturbation (if still feasible)\n    if total_weight < capacity * 0.9:  # Add items if underutilized\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            i = random.choice(available_items)\n            if total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -17.350624648789527,
            -17.182688380758343
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective-aware selection metric, then applies a hybrid local search combining adaptive item grouping, Pareto-optimal swapping, and capacity-balanced perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (based on objective diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Adaptive item grouping based on Pareto dominance\n    if n_items > 1:\n        # Identify non-dominated items in the current solution\n        selected_items = np.where(base_solution == 1)[0]\n        if len(selected_items) > 0:\n            # Calculate Pareto dominance relationships\n            dominated = np.zeros(len(selected_items), dtype=bool)\n            for i in range(len(selected_items)):\n                for j in range(len(selected_items)):\n                    if i != j:\n                        if (value1_lst[selected_items[i]] <= value1_lst[selected_items[j]] and\n                            value2_lst[selected_items[i]] <= value2_lst[selected_items[j]]):\n                            dominated[i] = True\n                            break\n\n            # Remove dominated items with probability 0.4\n            for i, idx in enumerate(selected_items):\n                if dominated[i] and random.random() < 0.4:\n                    if total_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        total_weight -= weight_lst[idx]\n\n    # Step 2: Pareto-optimal swapping between selected and unselected items\n    selected_items = np.where(new_solution == 1)[0]\n    unselected_items = np.where(new_solution == 0)[0]\n\n    if len(selected_items) > 0 and len(unselected_items) > 0:\n        # Select a candidate from selected items and a candidate from unselected items\n        i = random.choice(selected_items)\n        j = random.choice(unselected_items)\n\n        # Check if swapping would improve Pareto front\n        if (value1_lst[j] > value1_lst[i] and value2_lst[j] >= value2_lst[i]) or \\\n           (value1_lst[j] >= value1_lst[i] and value2_lst[j] > value2_lst[i]):\n            if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Capacity-balanced perturbation (add items with high utility)\n    remaining_capacity = capacity - total_weight\n    if remaining_capacity > 0:\n        # Calculate utility as harmonic mean of normalized values\n        utility = 2 * (value1_lst * value2_lst) / (value1_lst + value2_lst + 1e-10)\n        available_items = np.where(new_solution == 0)[0]\n\n        if len(available_items) > 0:\n            # Select top 20% of available items by utility\n            top_items = available_items[np.argsort(utility[available_items])[-max(1, len(available_items)//5):]]\n            for i in top_items:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -17.384544307447836,
            -16.446524720826652
        ]
    },
    {
        "algorithm": "{The new heuristic selects a solution from the archive based on a combination of objective dominance and weight diversity, then applies a multi-phase local search that includes item reallocation, value-aware swapping, and capacity-constrained flipping to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high combined objective values and weight diversity\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive_objectives[i]) * (1 - np.sum(archive_solutions[i]) / len(weight_lst)))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Phase 1: Value-aware item reallocation\n    if n_items >= 2:\n        # Find items to swap based on value ratio difference\n        items_in = np.where(base_solution == 1)[0]\n        items_out = np.where(base_solution == 0)[0]\n        if len(items_in) > 0 and len(items_out) > 0:\n            i = random.choice(items_in)\n            j = random.choice(items_out)\n            value_ratio = (value1_lst[i] + value2_lst[i]) / (value1_lst[j] + value2_lst[j])\n            if value_ratio < 1.2:  # Only swap if not too unbalanced\n                new_solution[i], new_solution[j] = 0, 1\n                new_weight = total_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    total_weight = new_weight\n                else:\n                    new_solution = base_solution.copy()\n\n    # Phase 2: Capacity-constrained flipping with value preference\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity and (value1_lst[i] + value2_lst[i]) > 0.5 * np.mean(value1_lst + value2_lst):\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Phase 3: Multi-objective perturbation\n    if total_weight < capacity * 0.8:  # Add items if underutilized\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Select items with highest combined value-to-weight ratio\n            ratios = (value1_lst + value2_lst) / weight_lst\n            sorted_items = sorted(available_items, key=lambda x: -ratios[x])\n            for i in sorted_items[:3]:  # Try top 3 items\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -16.886663682680616,
            -16.52757816406428
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines multi-objective neighborhood partitioning with adaptive objective weighting and feasibility-preserving perturbation to dynamically explore trade-offs and escape local optima while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with highest combined objective score\n        scores = [obj[0] + obj[1] for _, obj in archive]\n        base_solution = archive[np.argmax(scores)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Objective-weighted neighborhood partitioning\n    weight1 = random.uniform(0.3, 0.7)\n    weight2 = 1 - weight1\n    combined_scores = weight1 * value1_lst + weight2 * value2_lst\n\n    # Step 2: Adaptive perturbation - flip items based on combined scores\n    sorted_items = np.argsort(combined_scores)[::-1]\n    for i in range(min(5, len(sorted_items))):\n        item = sorted_items[i]\n        if random.random() < 0.4:  # 40% chance to consider flipping\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 3: Feasibility-preserving diversification\n    if random.random() < 0.3:  # 30% chance to add a random item\n        candidates = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(candidates) > 0:\n            selected = random.choice(candidates)\n            new_solution[selected] = 1\n\n    return new_solution\n\n",
        "score": [
            -15.591277015996239,
            -16.071250933148118
        ]
    }
]