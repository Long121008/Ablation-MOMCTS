[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6826143314800543,
            2.5631468176841734
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6842166962733786,
            2.797532057762146
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6523830934774043,
            2.0378265261650084
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that selects a solution based on objective diversity, then applies a combination of segment reversal and node reinsertion with adaptive perturbation to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply adaptive perturbation based on objective diversity\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5996510901291552,
            2.6659298658370973
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform segment reversal with objective-aware selection\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate segment in all three objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))),\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))),\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n    ]\n\n    # Reverse segment if it improves any objective\n    if any(cost > 0 for cost in segment_costs):\n        new_solution[start:start+segment_size] = segment[::-1]\n\n    # Perform objective-aware node swaps\n    for _ in range(3):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate potential improvement in all objectives\n        improvements = [\n            distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_1[new_solution[i-1], node_i] - distance_matrix_1[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_1[new_solution[j-1], node_j] - distance_matrix_1[node_j, new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_2[new_solution[i-1], node_i] - distance_matrix_2[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_2[new_solution[j-1], node_j] - distance_matrix_2[node_j, new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], node_i] + distance_matrix_3[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_3[new_solution[i-1], node_i] - distance_matrix_3[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_3[new_solution[j-1], node_j] - distance_matrix_3[node_j, new_solution[(j+1)%n]]\n        ]\n\n        # Swap if at least one objective improves\n        if any(improvement > 0 for improvement in improvements):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6254622189786001,
            3.298504078388214
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.6158149239578572,
            3.0981446623802187
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the highest diversity in objectives, then applies a novel hybrid local search combining 3-opt swaps with objective-aware edge swapping to improve solutions across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap to improve tour structure\n    if i + 1 != j and j + 1 != k:\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Objective-aware edge swapping\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate improvement potential across all objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_1[node_b, new_solution[b-1]] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_1[node_b, new_solution[b-1]] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_2[node_b, new_solution[b-1]] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_2[node_b, new_solution[b-1]] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[node_a, new_solution[a-1]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_3[node_b, new_solution[b-1]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_3[node_a, new_solution[a-1]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_3[node_b, new_solution[b-1]] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        if delta1 + delta2 + delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6242437727825421,
            2.8109444975852966
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a multi-objective-aware local search that combines 3-opt with objective-specific edge swaps, ensuring feasibility by verifying node uniqueness and repairing invalid solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest combined normalized value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Multi-objective 3-opt with objective-aware edge selection\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate objective-specific edge weights\n    obj_weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    edge_weights = np.zeros(3)\n    for i in range(3):\n        edge_weights[i] = (obj_weights[i][new_solution[a], new_solution[b]] +\n                          obj_weights[i][new_solution[b], new_solution[c]])\n\n    # Select the objective with highest edge weight for this operation\n    selected_obj = np.argmax(edge_weights)\n\n    # Perform 3-opt based on the selected objective\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n\n    # Reconstruct solution in different order\n    if selected_obj == 0:\n        new_order = np.concatenate([segment1, segment3, segment2])\n    elif selected_obj == 1:\n        new_order = np.concatenate([segment2, segment1, segment3])\n    else:\n        new_order = np.concatenate([segment3, segment2, segment1])\n\n    new_solution[a:] = new_order\n\n    # Verify feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5992219105743475,
            2.9392340898513796
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a novel local search operator: \"Objective-Driven Segment Reversal\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Evaluate the new solution's objectives\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the new solution is non-dominated or better in at least one objective, accept it\n    original_obj = archive[selected_idx][1]\n    if any(new_obj[i] < original_obj[i] for i in range(3)):\n        return new_solution\n\n    # If not, try a different segment reversal\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    return new_solution\n\n",
        "score": [
            -0.5471811056183162,
            3.296879005432129
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    }
]