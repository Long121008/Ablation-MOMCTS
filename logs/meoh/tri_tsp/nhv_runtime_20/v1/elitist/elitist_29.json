[
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7020854534148383,
            0.5440329551696778
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.717270421433435,
            0.7420053482055664
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7257307064174444,
            0.7975167036056519
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-aware segment swapping strategy that dynamically selects segment lengths based on objective trade-offs, prioritizes the least improved objective for local optimization, and employs a hybrid of 2-opt and node reinsertion with adaptive segment selection to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8415409017524699,
            3.0242960453033447
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8067558780615164,
            3.270241045951843
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.717270421433435,
            0.7420053482055664
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7257307064174444,
            0.7975167036056519
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-aware segment swapping strategy that dynamically selects segment lengths based on objective trade-offs, prioritizes the least improved objective for local optimization, and employs a hybrid of 2-opt and node reinsertion with adaptive segment selection to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8415409017524699,
            3.0242960453033447
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7020854534148383,
            0.5440329551696778
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.717270421433435,
            0.7420053482055664
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7257307064174444,
            0.7975167036056519
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.717270421433435,
            0.7420053482055664
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    }
]