[
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8272230658111269,
            4.093543696403503
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective diversity metric that considers both objective values and their distribution in the archive, then applies a hybrid local search combining a multi-objective segment insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.666955987255546,
            1.0424012422561646
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7622373871768312,
            1.5556856274604798
        ]
    },
    {
        "algorithm": "{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7490596763778978,
            1.1524938821792603
        ]
    },
    {
        "algorithm": "{A new algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using adaptive objective weights and non-linear improvement potential to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj ** 2\n    weights = np.array([0.5, 0.3, 0.2])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7242270390705882,
            1.0454744219779968
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7457153660610267,
            1.0815984010696411
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    }
]