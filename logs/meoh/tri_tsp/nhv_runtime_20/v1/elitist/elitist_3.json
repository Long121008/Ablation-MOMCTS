[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7874278529961871,
            3.993821918964386
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.731078947156645,
            2.709162104129791
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.776750955178542,
            3.3453062772750854
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6826143314800543,
            2.5631468176841734
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6523830934774043,
            2.0378265261650084
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6842166962733786,
            2.797532057762146
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that selects a solution based on objective diversity, then applies a combination of segment reversal and node reinsertion with adaptive perturbation to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply adaptive perturbation based on objective diversity\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5996510901291552,
            2.6659298658370973
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment of the tour and apply a multi-objective-aware 2-opt move\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate the total distance reduction across all three objectives\n    def calculate_delta(a, b):\n        delta = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            delta += dm[new_solution[a-1], new_solution[a]] + dm[new_solution[b-1], new_solution[b]]\n            delta -= dm[new_solution[a-1], new_solution[b-1]] + dm[new_solution[a], new_solution[b]]\n        return delta\n\n    # Apply the move if it improves at least one objective\n    if calculate_delta(a, b) < 0:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Additional diversification: randomly swap two nodes if the tour is too similar to the base solution\n    if np.array_equal(new_solution, base_solution):\n        c, d = np.random.choice(range(n), 2, replace=False)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6900290656527557,
            3.3864779353141783
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate the total distance improvement across all three objectives\n    def calculate_improvement(solution):\n        total_improvement = 0\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total_improvement += (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n        return total_improvement\n\n    current_improvement = calculate_improvement(new_solution)\n\n    # Try all possible 3-opt moves and select the one with the best improvement\n    best_improvement = current_improvement\n    best_solution = new_solution.copy()\n\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_improvement = calculate_improvement(temp_solution)\n                if temp_improvement < best_improvement:\n                    best_improvement = temp_improvement\n                    best_solution = temp_solution.copy()\n\n    new_solution = best_solution.copy()\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6848907002482537,
            3.811893939971924
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.776750955178542,
            3.3453062772750854
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.731078947156645,
            2.709162104129791
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7874278529961871,
            3.993821918964386
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    }
]