[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.600178144946075,
            1.06874680519104
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8025620663011376,
            3.213436150550842
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6922881887044491,
            2.3746248960494993
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects a solution from the archive based on its objective diversity and applies a hybrid 2-opt and edge exchange operator tailored for three-dimensional objective spaces to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objective_ranges))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange based on objective diversity\n    k = np.random.randint(0, n)\n    l = (k + np.random.randint(1, n)) % n\n\n    # Swap edges in a way that maximizes objective diversity\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7068840529013978,
            2.387748968601227
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7837616220655585,
            2.861217975616455
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7754966857918857,
            2.541741704940796
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic combination of objectives, where weights are adjusted based on the current diversity of the archive, then applies a hybrid local search combining 2-opt, segment reversal, and a novel multi-objective swap operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / diversity.sum() if diversity.sum() > 0 else np.ones(3)/3\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, segment reversal, and multi-objective swap\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # 2-opt move\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Segment reversal\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective swap\n    swap_nodes = np.random.choice(new_solution, size=2, replace=False)\n    idx1, idx2 = np.where(new_solution == swap_nodes[0])[0][0], np.where(new_solution == swap_nodes[1])[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7650913367224138,
            2.456178939342499
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6523830934774043,
            2.0378265261650084
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.600178144946075,
            1.06874680519104
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.600178144946075,
            1.06874680519104
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ]
    }
]