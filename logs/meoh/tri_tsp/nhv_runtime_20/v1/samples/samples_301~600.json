[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm uses a dominance-aware segment swapping strategy that dynamically selects segment lengths based on objective trade-offs, prioritizes the least improved objective for local optimization, and employs a hybrid of 2-opt and node reinsertion with adaptive segment selection to balance exploration and exploitation across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm employs a multi-objective adaptive path inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node relocation that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6695636714668468,
            1.2507335782051086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment reversal strategy that dynamically selects and reverses segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.709430428565256,
            1.0078564524650573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm uses a multi-objective adaptive segment inversion strategy that dynamically selects segment lengths based on the relative performance of objectives, prioritizes the least improved objective for inversion, and employs a dominance-based reinsertion to balance all three objectives while ensuring feasibility through a validation check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    dominance_scores = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    removed_node = reversed_segment[-1]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6668255524836607,
            1.1418856620788573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    dominance_scores = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    removed_node = reversed_segment[-1]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst-performing objective, then applies a hybrid local search combining segment reversal with adaptive node reinsertion, prioritizing improvement in the least dominant objective while dynamically adjusting segment length based on objective performance to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst performance in any objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_indices = np.argmax(objectives, axis=1)\n    selected_idx = np.argmax(objectives[np.arange(len(archive)), worst_obj_indices])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment length based on objective performance\n    obj_ratio = worst_obj / np.sum(worst_obj)\n    seg_length = max(2, int(np.random.normal(loc=3, scale=1) * (1 + obj_ratio[least_dominant])))\n\n    # Select and reverse a segment\n    n = len(new_solution)\n    seg_length = min(seg_length, n//2)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    # Adaptive reinsertion for the least dominant objective\n    removed_node = segment[0]\n    best_pos = -1\n    min_improvement = 0\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            improvement = distance_matrix_1[prev_node, next_node] - (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node])\n        elif least_dominant == 1:\n            improvement = distance_matrix_2[prev_node, next_node] - (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node])\n        else:\n            improvement = distance_matrix_3[prev_node, next_node] - (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node])\n\n        if improvement > min_improvement:\n            min_improvement = improvement\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4602284037867411,
            3.4302661538124086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst performance in any objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_indices = np.argmax(objectives, axis=1)\n    selected_idx = np.argmax(objectives[np.arange(len(archive)), worst_obj_indices])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment length based on objective performance\n    obj_ratio = worst_obj / np.sum(worst_obj)\n    seg_length = max(2, int(np.random.normal(loc=3, scale=1) * (1 + obj_ratio[least_dominant])))\n\n    # Select and reverse a segment\n    n = len(new_solution)\n    seg_length = min(seg_length, n//2)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    # Adaptive reinsertion for the least dominant objective\n    removed_node = segment[0]\n    best_pos = -1\n    min_improvement = 0\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            improvement = distance_matrix_1[prev_node, next_node] - (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node])\n        elif least_dominant == 1:\n            improvement = distance_matrix_2[prev_node, next_node] - (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node])\n        else:\n            improvement = distance_matrix_3[prev_node, next_node] - (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node])\n\n        if improvement > min_improvement:\n            min_improvement = improvement\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]